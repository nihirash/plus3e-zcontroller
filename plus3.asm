; **************************************************
; *** SPECTRUM +3 ROM 0 DISASSEMBLY (EDITOR ROM) ***
; **************************************************

; The Spectrum ROMs are copyright Amstrad, who have kindly given permission
; to reverse engineer and publish Spectrum ROM disassemblies.


; =====
; NOTES
; =====

; ------------------------
; Disassembly Contributors
; ------------------------
; Garry Lancaster
;
; The ROM disassembly was created with the aid of dZ80 V1.10, and incorporates work from
; "The canonical list of +3 oddities" by Ian Collier.

; -----------------
; Assembler Details
; -----------------

; This file can be assembled to produce a binary image of the ROM
; with Interlogic's Z80ASM assembler (available for Z88, QL, DOS and Linux).
; Note that the defs directive is used and this causes a block of $00 bytes to be created.

;**************************************************

; System variable definitions for 48K Spectrum

;        include "sysvar48.def"
        define  KSTATE    $5c00
        define  LAST_K    $5c08
        define  REPDEL    $5c09
        define  REPPER    $5c0a
        define  DEFADD    $5c0b
        define  K_DATA    $5c0d
        define  TVDATA    $5c0e
        define  STRMS     $5c10
        define  CHARS     $5c36
        define  RASP      $5c38
        define  PIP       $5c39
        define  ERR_NR    $5c3a
        define  FLAGS     $5c3b
        define  TV_FLAG   $5c3c
        define  ERR_SP    $5c3d
        define  LIST_SP   $5c3f
        define  MODE      $5c41
        define  NEWPPC    $5c42
        define  NSPPC     $5c44 
        define  PPC       $5c45
        define  SUBPPC    $5c47
        define  BORDCR    $5c48
        define  E_PPC     $5c49
        define  VARS      $5c4b
        define  DEST      $5c4d
        define  CHANS     $5c4f
        define  CURCHL    $5c51
        define  PROG      $5c53
        define  NXTLIN    $5c55
        define  DATADD    $5c57
        define  E_LINE    $5c59
        define  K_CUR     $5c5b
        define  CH_ADD    $5c5d
        define  X_PTR     $5c5f
        define  WORKSP    $5c61
        define  STKBOT    $5c63
        define  STKEND    $5c65
        define  BREG      $5c67
        define  MEM       $5c68
        define  FLAGS2    $5c6a
        define  DF_SZ     $5c6b
        define  S_TOP     $5c6c
        define  OLDPPC    $5c6e
        define  OSPCC     $5c70
        define  FLAGX     $5c71
        define  STRLEN    $5c72
        define  T_ADDR    $5c74
        define  SEED      $5c76
        define  FRAMES    $5c78
        define  UDG       $5c7b
        define  COORDS    $5c7d
        define  P_POSN    $5c7f
        define  PR_CC     $5c80
        define  ECHO_E    $5c82
        define  DF_CC     $5c84
        define  DF_CCL    $5c86
        define  S_POSN    $5c88
        define  SPOSNL    $5c8a
        define  SCR_CT    $5c8c
        define  ATTR_P    $5c8d
        define  MASK_P    $5c8e
        define  ATTR_T    $5c8f
        define  MASK_T    $5c90
        define  P_FLAG    $5c91
        define  MEMBOT    $5c92
        define  NMIADD    $5cb0            ; only used in +3
        define  RAMTOP    $5cb2
        define  P_RAMT    $5cb4
;--------------------------------------------------

; Additional system variables used in the +3

;        include "sysvarp3.def"
        define  SWAP      $5b00
        define  STOO      $5b10
        define  YOUNGER   $5b21
        define  REGNUOY   $5b2a
        define  ONERR     $5b3a
        define  OLDHL     $5b52
        define  OLDBC     $5b54
        define  OLDAF     $5b56
        define  TARGET    $5b58
        define  RETADDR   $5b5a
        define  BANKM     $5b5c
        define  RAMRST    $5b5d
        define  RAMERR    $5b5e
        define  BAUD      $5b5f
        define  SERFL     $5b61
        define  COL       $5b63
        define  WIDTH     $5b64
        define  TVPARS    $5b65
        define  FLAGS3    $5b66
        define  BANK678   $5b67
        define  XLOC      $5b68
        define  YLOC      $5b69
        define  OLDSP     $5b6a
        define  SYNRET    $5b6c
        define  LASTV     $5b6e
        define  RC_LINE   $5b73
        define  RC_START  $5b75
        define  RC_STEP   $5b77
        define  LODDRV    $5b79
        define  SAVDRV    $5b7a
        define  DUMPLF    $5b7b
        define  STRIP1    $5b7c
      IF v41
        define  STRIP2    $5b85
      ELSE
        define  STRIP2    $5b84
      ENDIF
        define  TSTACK    $5bff
;--------------------------------------------------

; System variables and data structures in DOS workspace (page 7)

;        include "sysvarp7.def"
; Alternate screen $c000-$daff
; Also used by +3 BASIC commands for temporary storage

        define  src_add   $c000   ; (2) address of source filespec
        define  dst_add   $c002   ; (2) address of dest filespec
        define  src_drv   $c004   ; (1) source drive
        define  dst_drv   $c005   ; (1) dest drive
        define  eof       $c006   ; (1) EOF flag
        define  free_m    $c007   ; (2) space free on M: for copying
        define  copy_ram  $c009   ; (1) flag: true if copy via RAM, not M:
        define  dst_open  $c00a   ; (1) flag: true if dst_file is open
        define  wild      $c00b   ; (1) flag: true for wildcards in filespec
        define  dst_dev   $c00c   ; (1) dest dev:$00=file,$e0=printer,$aa=screen
        define  tmp_bytes $c00d   ; (2) #bytes copied to temporary file
        define  copied    $c00f   ; (1) #files copied
        define  dst_file  $c010   ; (18) dest filespec ($ff-term)
        define  src_file  $c022   ; (18) source filespec ($ff-term)
        define  cat_spec  $c034   ; (13) filespec to search catalog from
        define  wld_next  $c041   ; (13) next filename formed from wild spec
        define  tmp_file  $c04e   ; (18) temp filespec ($ff-term)

; +3DOS permanent structures & variables

        define  pg_buffer $db00   ; ($20) buffer for copying between pages
        define  rt_alert  $db20   ; (2) ALERT routine address
        define  al_resp   $db22   ; (7) ALERT response string
        define  fcbs      $dba0   ; ($380) FCBs ($38 bytes each for $10 files)
        define  sysfcb0   $df20   ; ($38) system FCB 0
        define  sysfcb1   $df58   ; ($38) system FCB 1
        define  filerecs  $df90   ; (3) #recs in file (during open)
        define  def_user  $df93   ; (1) default user area
        define  def_drv   $df94   ; (1) default drive
        define  extchg    $df95   ; (1) extents changed in operation flag
        define  att_clr   $df96   ; (1) attributes to clear
        define  att_set   $df97   ; (1) attributes to set
        define  cat_buff  $df98   ; (2) address of catalog buffer
        define  cat_filt  $df9a   ; (1) catalog filter
        define  cat_size  $df9b   ; (1) catalog buffer size (in entries)
        define  cat_ents  $df9c   ; (1) number of completed catalog entries

        ; $df9d-$df9f unused (3 bytes)

        define  rt_dirent $dfa0   ; (2) routine to call for every dir entry
        define  direntry  $dfa2   ; ($20) directory entry buffer

        ; $dfc2-$dfcf unused (14 bytes)
        ; Not advisable to use, due to bug in datestamp checking routine

        define  rw_page   $dfd0   ; (1) page to read/write to
        define  rw_add    $dfd1   ; (2) address to read/write to

        ; $dfd3-$dfdf unused (13 bytes)

        define  bcbs      $dfe0   ; ($b0) BCBs ($0b bytes each for $10 buffers)
        define  cache7    $e090   ; ($200) Page 7 cache buffer (always exists)
        define  cachenum  $e290   ; (1) number of cache buffers
        define  cachefst  $e291   ; (1) first cache buffer number
        define  bcb_inuse $e292   ; (2) inuse BCB chain
        define  bcb_free  $e294   ; (2) free BCB chain

        ; $e296-$e29f unused (10 bytes)

        define  xdpb_ptrs $e2a0   ; ($20) pointers to XDPBs (or 0) for A: to P:
        define  xdpb_a    $e2c0   ; ($30) XDPB for drive A:
        define  chksm_a   $e2f0   ; ($10) checksum vector for drive A:
        define  alloc_a   $e300   ; ($2d) allocation bitmap for drive A:
        define  xdpb_b    $e32d   ; ($30) XDPB for drive B:
        define  chksm_b   $e35d   ; ($10) checksum vector for drive B:
        define  alloc_b   $e36d   ; ($2d) allocation bitmap for drive B:
        define  xdpb_m    $e39a   ; ($30) XDPB for drive M:
        define  alloc_m   $e3ca   ; ($20) allocation bitmap for drive M:
        define  unit0     $e3ea   ; (1) drive mapped to unit 0
        define  rt_chgdsk $e3eb   ; (2) CHANGE_DISK routine address
        define  rt_temp   $e3ed   ; (2) address of subroutine (temporary)
        define  spec_m    $e3ef   ; (8) disk spec for drive M:

        ; $e3f7-$e3ff unused (9 bytes)

        define  ddl_parms $e400   ; ($19) parameters in calls to DD_L_READ etc
        define  rt_encode $e419   ; (2) ENCODE routine address

        ; $e41a-$e41f unused (6 bytes)

        define  equipment $e420   ; (8) equipment info for FD units 0 to 3
                ; Byte 0: bits 0..1=side info (0=unknown,1/2=#sides)
                ; Byte 0: bits 2..3=track info (0=unknown,1/2=single/double)
                ; Byte 0: bit 6 set if head position known
                ; Byte 1: track under head
        define  tm_mtron  $e428   ; (1) motor on time
        define  tm_mtroff $e429   ; (1) motor off time
        define  tm_wroff  $e42a   ; (1) write off time
        define  tm_hdset  $e42b   ; (1) head settle time
        define  tm_step   $e42c   ; (1) step rate
        define  retry_cnt $e42d   ; (1) retry count

        ; $e42e-$e42f unused (2 bytes)

        define  fdc_res   $e430   ; (8) FDC results buffer

        ; $e438-$e5ff unused (456 bytes)

        define  timeout   $e600   ; (1) current disk motor timeout

        ; $e601 unused (1 byte)

; From this point, "unused" status is not 100% certain, due to limited
; knowledge of the Editor ROM

; Temporary storage used when switching ROMs etc

        define  tmp_sp    $e602   ; (2) temporary SP store
        define  tmp_ret   $e604   ; (2) temporary return address store
        define  tmp_af    $e606   ; (2) temporary AF store
        define  tmp_hl    $e608   ; (2) temporary HL store
        define  tmp_de    $e60a   ; (2) temporary DE store
        define  tmp_bc    $e60c   ; (2) temporary BC store

        ; $e60e-$e77b unused (366 bytes)

        define  tmp_stack $e7ff   ; ($84) temporary TSTACK store
                                  ; from $e77c-$e7ff

        ; $e800-$ebff unused (1024 bytes)

; Editor variables

        define  men_high  $ec0c   ; (1) highlighted menu line
        define  ed_flags  $ec0d   ; (1) - bit 1 set when processing menu
        define  process   $ec0e   ; (1) process: $07 Loader, $04 Calculator
        define  ed_ATTR_P $ec0f   ; (1) editor/saved ATTR_P
        define  ed_MASK_P $ec10   ; (1) editor/saved MASK_P
        define  ed_ATTR_T $ec11   ; (1) editor/saved ATTR_T
        define  ed_MASK_T $ec12   ; (1) editor/saved MASK_T
        define  ed_P_FLAG $ec13   ; (1) editor/saved P_FLAG
        define  ed_N_ROWS $ec15   ;

        ; $ec20-$ecff unused (224 bytes)

; Temporary buffers/storage

        define  tmp_fspec $ed01   ; (??) temporary filespec workspace
        define  tmp_buff  $ed11   ; (2048) temporary buffer for FORMAT/COPY
                                  ; *BUG* means COPY uses page 0 instead of 7

        ; $f511-$f6e9 unused (473 bytes)

        define  men_rout  $f6ea   ; (2) address of menu routines table
        define  men_text  $f6ec   ; (2) address of menu text
        define  ed_area   $f6f3   ; (1) Edit area info - Number of rows in the editing area.
        define  row_below $f6f5   ; (1) Number of rows held in the Below-Screen Line Edit Buffer.
 

        ; $f700-$f8ff unused (512 bytes)

        define  nr_above  $f9db    ; (1) Number of rows held in the Above-Screen Line Edit Buffer.

        ; $fa00-$fbff unused (512 bytes)

        define  ign_space $fc9e   ; (1) flag: if set, ignore leading space
        define  line_add  $fc9f   ; (2) 0 or add of line data
        define  ascii_add $fca1   ; (2) 0 or add of ASCII expanded token/number
        define  ascii_txt $fca3   ; (??) bit-7 terminated ASCII text

        ; IX normally set to $fd98, so this area unknown exactly

        define  edit_top  $fd99   ; (1) top screen line of editing area

        define  curs_cols $fd9e   ; (1) cursor colours
        define  curs_attr $fd9f   ; (1) saved attribute under cursor
        define  chkword   $fda0   ; (??) word to check if token

        ; $fe00-$ffff used to load bootsector by +3DOS ROM
;--------------------------------------------------

;#######################################    ZXTAP definitions    ######################################################
    IF zx_tap
        define  temp_working_mem    $8000   ; idem para contener rutinas temp y stack
        define  save_buffer         $c100   ; creo que +3DOS no usa esto (1K)
        define  temp_buffer_file    $c600   ; tmp en donde vuelco lo que lea desde disco

        define  conf_ram            $e800   ; guardo el nro de pagina del 4to seg que
                                            ; habia al llamarse la rutina LOAD de ROM3
        define  tmp_BANKM           $e801   ; guardo una copia aqui de lo que habia en 5B5C
        define  tmp_BANK678         $e802   ; idem pero para 5B67
        define  save_STACK          $e803   ; (2) guardo temporalmente SP aqui
        define  tapeloader_stat1    $e805   ; (1) multiproposito tapeloader 1
        define  tapeloader_stat2    $e806   ; (1) multiproposito tapeloader 2
        define  save_REGI           $e807   ; (1) respaldo aqui el registro I
        define  save_INTERR         $e808   ; (1) respaldo aqui el estado de las interrupciones
        define  buffer_ADDR         $e809   ; (2) direccion del buffer por la que voy
        define  buffer_COUNT        $e80B   ; (2) cuenta regresiva para vaciar el buffer
        define  terminar_CARGA      $e80D   ; (1) poner a 1 para terminar la carga y salir por error
        define  EXCEPCIONES         $e80E   ; (1) indique llamar a funciones alternativas en la funcion
                                            ; que llenga el buffer
        define  save_POS_FILE       $e80F   ; (4) guarda temporalmente la posicion del puntero del archivo #6
        define  save_rt_alert       $e813   ; (2) swapeo acÂ  la dir de la rutina alert. para desactivarla 
                                            ; mientras dure la carga desde "cinta"

        define  buffer_file_size    5*1024  ; si uso valores mayores, o no funciona o queda corrupto
    ENDIF
 ;#####################################################################################################################

    IF pokemon&&!zx_tap
        DEFINE  lenp  $c0       ; $40 if ZX Spectrum 16K
    ENDIF

      .macro  ROM1  par1
        call    l3e80
        defw    par1
      .endm
      .macro  ROM2  par1
        call    $3f00
        defw    par1
      .endm
      .macro  ROM3  par1
        rst     $28
        defw    par1
      .endm

        org     $0000

l0000   di                      ; +3 Startup address
        ld      bc,$6c03

l0004   dec     bc              ; Delay for approx 0.2s
        ld      a,b
        or      c
        jr      nz,l0004
        jp      l010f           ; go to test memory

        defm    "ED"            ; Editor ROM ID
        defs    2

; RST 10: call the RST 10 routine in ROM 3 to print a character

l0010   ROM3    o0010           ; call RST 10 in ROM 3
        ret

        defs    4

; RST 18: call the RST 18 routine in ROM 3 to collect a character

l0018   ROM3    o0018           ; call RST 18 in ROM 3
        ret

        defs    4

; RST 20: call the RST 20 routine in ROM 3 to collect next character

l0020   ROM3    o0020           ; call RST 20 in ROM 3
        ret

        defs    4

; RST 28 : Call a routine in ROM 3, then return to ROM 0
; The address following the RST 28 instruction is called, then control
; is returned to the instruction following the address

l0028   ex      (sp),hl         ; save HL, get return address
        push    af              ; save AF
        ld      a,(hl)          ; A=low byte of address to call
        inc     hl
        inc     hl              ; HL=address of instruction to return to
        ld      (RETADDR),hl    ; save

l0030   dec     hl
        ld      h,(hl)
        ld      l,a             ; HL=address to call in ROM 3
        pop     af              ; restore AF
        jp      l00ae           ; jump on

        defs    1

; The maskable interrupt routine, called every 50ms while in IM1

l0038   push    hl              ; save HL
        ld      hl,$0048
        push    hl
        ld      hl,SWAP
        push    hl
        ld      hl,$0038
        push    hl
        jp      SWAP            ; call MASK-INT and KEY-INT in ROM 3
        pop     hl              ; restore HL
        di                      ; disable interrupts again
        call    l0074
        ei                      ; re-enable interrupts
        ret

        defs    $17

; NMI routine

l0066   push    af              ; save AF & HL
        push    hl
        ld      hl,(NMIADD)
        ld      a,h
        or      l
        jr      z,l0070         ; skip if no routine (NMIADD=0)
        jp      (hl)            ; else execute
l0070   pop     hl              ; restore registers
        pop     af
        retn

; Disk motor timeout subroutine
; Called by maskable interrupt to turn off disk motor when timeout occurs

l0074   push    af              ; save AF & BC
        push    bc
        ld      bc,$7ffd
        ld      a,(BANKM)
        or      $07
        out     (c),a           ; get page 7 (+3DOS workspace)
        ld      a,($e600)       ; check motor off timeout
        or      a
        jr      z,l00a3         ; move on if already off
        ld      a,(FRAMES)
        bit     0,a
        jr      nz,l00a3        ; only decrement every other time
        ld      a,($e600)
        dec     a
        ld      ($e600),a       ; decrement motor off timeout
        jr      nz,l00a3        ; move on if still should be on
        ld      bc,$1ffd
        ld      a,(BANK678)
        and     $f7
        ld      (BANK678),a
        out     (c),a           ; turn motor off
l00a3   ld      bc,$7ffd
        ld      a,(BANKM)
        out     (c),a           ; page previous memory back in
        pop     bc              ; restore registers
        pop     af
        ret

; Continuation of RST 28: call a routine in ROM 3

l00ae   ld      (TARGET),hl     ; save ROM 3 address in TARGET
        ld      hl,YOUNGER
        ex      (sp),hl         ; stack YOUNGER address beneath TOS
        push    hl
        ld      hl,(TARGET)     ; get HL=target address in ROM 3
        ex      (sp),hl         ; restore HL & save target address on stack
        jp      SWAP            ; jump to SWAP - pages in ROM 3, returns to
                                ; target routine which returns to YOUNGER
                                ; where ROM 0 is paged back and jump made
                                ; back to RETADDR


; Here follows the five paging subroutines which are copied into
; the system variables on startup

; Enter at SWAP to change ROM 0<->3 or ROM 1<->2

l00bd   push    af              ; save AF & BC
        push    bc
        ld      bc,$7ffd
        ld      a,(BANKM)       ; get copy of last OUT to $7ffd
        xor     $10             ; change ROM 0<->1 or ROM 2<->3
        di                      ; disable interrupts
        ld      (BANKM),a
        out     (c),a           ; page new ROM

; Enter at STOO with interrupts disabled and AF/BC stacked
; to change ROM 0<->2 or ROM 1<->3

l00cd   ld      bc,$1ffd
        ld      a,(BANK678)     ; get copy of last OUT to $1ffd
        xor     $04             ; change ROM 0<->2 or ROM 1<->3
        ld      (BANK678),a
        out     (c),a           ; page new ROM
        ei                      ; re-enable interrupts
        pop     bc              ; restore registers
        pop     af
        ret

; Enter at YOUNGER with return address in RETADDR to swap
; ROM 0<->3 or ROM 1<->2 and return there

l00de   call    SWAP            ; swap ROM 0<->3 or ROM 1<->2
        push    hl              ; save HL
        ld      hl,(RETADDR)    ; get return address from system vars
        ex      (sp),hl         ; restore return address & HL
        ret

; Enter at REGNUOY with return address in RETADDR to swap
; ROM 0<->2 or ROM 1<->3 and return there

l00e7   push    hl              ; save HL
        ld      hl,$5b34
        ex      (sp),hl         ; place $5b34 as return address
        push    af              ; save AF & BC
        push    bc
        jp      STOO            ; swap ROM 0<->2 or ROM 1<->3 and return here
        push    hl              ; save HL
        ld      hl,(RETADDR)    ; get return address from system vars
        ex      (sp),hl         ; restore return address & HL
        ret

; Enter at ONERR to page in Syntax ROM (ROM 1) and jump to error handler

l00f7   di                      ; disable interrupts
      IF v41
        ld      a,$10
      ELSE
        xor     a
      ENDIF
        ld      bc,$1ffd
        out     (c),a           ; ensure ROM 0 or 1 is paged
        ld      (BANK678),a
        set     4,a
        ld      bc,$7ffd
        out     (c),a           ; ensure ROM 1 is paged
        ld      (BANKM),a
      IF v41=0
        ei                      ; enable interrupts
      ENDIF
        jp      m253a           ; jump to error handler in ROM 1

; Test memory at startup & initialise

      IF carmel=1
l010f   exx
        cp      5
        ld      bc, $7ffd
        ld      e, $fe
        ld      hl, $7fff
        jr      z, l0120
        out     (c), a          ; page next RAM page to $c000
        ld      h, l
l0120   ld      d, h
        push    bc
        ld      bc, $4000
        ld      (hl), c
        lddr
        exx
        pop     bc
        inc     a
        and     7
        jr      nz, l010f
        ld      h, $dc
      ELSE
l010f   ld      b,$08           ; 8 pages to clear
l0111   ld      a,b
        exx
        dec     a
        ld      bc,$7ffd
        out     (c),a           ; page next RAM page to $c000
        ld      hl,$c000
        ld      de,$c001
        ld      bc,$3fff
        ld      (hl),$00
        ldir                    ; clear it
        exx
        djnz    l0111           ; back for more pages
        xor     a
        ld      hl,$dcba        ; an address in top 16K of ROM
        ld      bc,$7ffd        ; memory paging address
      ENDIF

l0130   ld      de,$0108        ; E=8 bits to test, D=bit 0
        out     (c),a           ; get next page to segment 3
        ex      af,af'          ; save A'=page

l0136   ld      a,d             ; test to see if bit can be set
        ld      (hl),a
        ld      a,(hl)
        and     d
        jp      z,l0367         ; jump if memory not re-read correctly
        cpl                     ; test to see if bit can be reset
        ld      (hl),a
        ld      a,(hl)
        and     d
        jp      nz,l0367        ; jump if memory not re-read correctly
        rlc     d
        dec     e
        jr      nz,l0136        ; loop back to test other bits
        ex      af,af'
        inc     a
        cp      $08
        jr      nz,l0130        ; loop back to test other pages
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a           ; select AY register 14 (RS232/AUX)
        ld      b,e
        ld      a,$ff
        out     (c),a           ; set all RS232/AUX lines high
        jr      l0167           ; move on, with page 7 at $c000


; Apparently unused section, possibly originally intended to
; flag a memory error

        exx
        ld      a,b
        out     ($fe),a
l0165   jr      l0165


; More initialisation (with page 7 at $c000)

l0167   xor     a
        ex      af,af'          ; A' clear to show reset, not NEW
        ld      sp,$6000        ; set stack within page 5

l016c   ld      b,d
        ld      a,$07
        out     (c),a           ; select AY register $07
        ld      b,e
        ld      a,$ff
        out     (c),a           ; initialise AY chip (?)
        ld      de,SWAP
        ld      hl,l00bd
        ld      bc,$0052
        ldir                    ; copy paging subroutines to system vars
        ld      a,$cf
        ld      (RAMRST),a      ; place RST 8 instruction at RAMRST
        ld      hl,$ffff
        ld      (P_RAMT),hl     ; set P RAMT to 64K
        ld      de,$3eaf        ; prepare to copy chars A-U from ROM 3
        ld      bc,$00a8        ; to UDG area
        ex      de,hl
        ROM3    o1661           ; execute a LDDR from ROM 3 to copy them
        ex      de,hl
        inc     hl
        ld      (UDG),hl        ; store address of first UDG
        dec     hl
        ld      bc,$0040
        ld      (RASP),bc       ; set RASP and PIP
        ld      (RAMTOP),hl     ; set RAMTOP below UDGs
        ld      hl,FLAGS3
        res     7,(hl)          ; reset bit 7 of FLAGS3 (??)
        ld      hl,DUMPLF
        ld      (hl),$09        ; set DUMPLF

; The NEW command enters here

l01b0   ld      hl,$3c00
        ld      (CHARS),hl      ; set CHARS
        im      1               ; set interrupt mode 1
        ld      iy,ERR_NR       ; IY points to ERR NR
        set     4,(iy+$01)      ; set "+3 BASIC mode"
        ld      hl,FLAGS3
        res     3,(hl)          ; set "print to Centronics"
        set     2,(hl)          ; set "print expanded tokens"
        ld      hl,$000b
        ld      (BAUD),hl       ; set BAUD
      IF v41
        ld      hl,FLAGS2
        res     6,(hl)
      ENDIF
        xor     a
        ld      (SERFL),a       ; clear SERFL
        ld      (COL),a         ; clear COL
        ld      (TVPARS),a      ; clear TVPARS
        ld      hl,$ec00
        ld      ($ff24),hl      ; ???
        ld      a,$50
        ld      (WIDTH),a       ; set WIDTH
        ld      hl,$000a
        ld      (RC_START),hl   ; set RCSTART
        ld      (RC_STEP),hl    ; set RCSTEP
        ld      a,'T'
        ld      (LODDRV),a      ; set LODDRV to "T"
        ld      (SAVDRV),a      ; set SAVDRV to "T"
        ld      hl,$5cb6
        ld      (CHANS),hl      ; set CHANS immediately after system vars
        ld      de,l03b8
        ld      bc,$0015
        ex      de,hl
        ldir                    ; copy initial channel information
        ex      de,hl
        dec     hl
        ld      (DATADD),hl     ; set DATADD after CHANS
        inc     hl
        ld      (PROG),hl       ; set PROG after DATADD
        ld      (VARS),hl       ; set VARS
        ld      (hl),$80        ; store end of variables marker
        inc     hl
        ld      (E_LINE),hl     ; set ELINE after VARS
        ld      (hl),$0d        ; store end of line marker
        inc     hl
        ld      (hl),$80        ; store end of ELINE marker
        inc     hl
        ld      (WORKSP),hl     ; set WORKSP after ELINE
        ld      (STKBOT),hl     ; set STKBOT
        ld      (STKEND),hl     ; set STKEND
        ld      a,$38
        ld      (ATTR_P),a      ; set ATTR P
        ld      (ATTR_T),a      ; set ATTR T
        ld      (BORDCR),a      ; set BORDCR
        xor     a
        ld      (ed_P_FLAG),a   ; set editor's P_FLAG
        ld      a,$07
        out     ($fe),a         ; white border
        ld      hl,$0523
        ld      (REPDEL),hl     ; set REPDEL and REPPER
        dec     (iy-$3a)        ; set two bytes of KSTATE to $ff
        dec     (iy-$36)
        ld      hl,l03cd
        ld      de,STRMS
        ld      bc,$000e
        ldir                    ; copy initial stream addresses to STRMS
        res     1,(iy+$01)      ; reset bit 1 of FLAGS
        ld      (iy+$00),$ff    ; set ERR NR to no error
        ld      (iy+$31),$02    ; set DF SZ
        ex      af,af'
        cp      $52
      IF garry
        defb    0, 0, 0
      ELSE
        jp      z,l2675         ; move on if in self-test program
      ENDIF
        ld      hl,(RAMTOP)
        inc     hl
        ld      sp,hl           ; set SP to RAMTOP+1
        ei                      ; enable interrupts
        ROM3    o0D6B           ; CLS using ROM 3
        call    l02aa           ; display test image if BREAK held down
      IF garry
        ld      de,l3834
      ELSE
        ld      de,l03db
      ENDIF
        call    l029e           ; display copyright message
        ld      hl,TSTACK
        ld      (OLDSP),hl      ; set OLDSP to TSTACK area
        call    l05cc           ; switch in page 7 with stack in TSTACK
        ld      a,$38
        ld      (ed_ATTR_T),a   ; set editor's ATTR_T
        ld      (ed_ATTR_P),a   ; set editor's ATTR_P
        call    l05a7           ; switch back page 0
        ROM1    m2410           ; initialise DOS & display drive info
        call    l05cc           ; switch in page 7 with stack in TSTACK
        ld      (iy+$31),$02    ; set DFSZ
        set     5,(iy+$02)      ; set bit 5 of TVFLAG
        call    l0633           ; ???
        call    l05a7           ; switch back page 0
        jp      l064e           ; move on

; Print string subroutine
; Displays a string terminated by a byte with bit 7 set
; Entry: DE=address of string
; Exit: DE=address after string, A corrupted

l029e   ld      a,(de)          ; get next character
        and     $7f             ; mask high bit
        push    de
        rst     $10             ; print it
        pop     de
        ld      a,(de)
        inc     de              ; increment address
        add     a,a
        jr      nc,l029e        ; loop back if bit 7 wasn't set
        ret

; Check to see if BREAK is held down, entering the test image if so

l02aa   ld      a,$7f
        in      a,($fe)
l02ae   rra
        ret     c               ; exit if SPACE not held down
        ld      a,$fe
        in      a,($fe)
        rra
        ret     c               ; exit if CAPS SHIFT not held down
        ld      a,$07
        out     ($fe),a         ; white border
        ld      a,$02
        ROM3    o1601           ; open stream 2 for output
        xor     a
        ld      (TV_FLAG),a     ; clear TV FLAG
        ld      a,$16
        rst     $10
        xor     a
        rst     $10
        xor     a
        rst     $10             ; AT 0,0
        ld      e,$08           ; E=8, used many times in routine
        ld      b,e             ; B=8 messages per line
        ld      d,b             ; D=8 lines
l02ce   ld      a,b
        dec     a
        rl      a
        rl      a
        rl      a               ; A=paper colour from position along line
        add     a,d
        dec     a               ; add in ink colour from line number
        ld      (ATTR_T),a      ; set ATTR T
        ld      hl,l03b0        ; address of '1987' test message
        ld      c,e             ; C=8=length of message
l02df   ld      a,(hl)
        rst     $10             ; display next character
        inc     hl
        dec     c
        jr      nz,l02df        ; loop back for more characters
        djnz    l02ce           ; loop back for more messages
        ld      b,e             ; B=8 messages per line
        dec     d
        jr      nz,l02ce        ; loop back for more lines
        ld      hl,$4800        ; start of middle third of screen
        ld      d,h
        ld      e,l
        inc     de
        xor     a
        ld      (hl),a
        ld      bc,$0fff
        ldir                    ; clear bottom two thirds of screen
        ex      de,hl
        ld      de,$5900
        ld      bc,$0200
        ldir                    ; copy attribs of top third to rest of screen
        di                      ; disable interrupts
l0302   ld      de,$0370
        ld      l,$07
l0307   ld      bc,$0099
l030a   dec     bc
        ld      a,b
        or      c
        jr      nz,l030a        ; delay
        ld      a,l
        xor     $10
        ld      l,a
        out     ($fe),a         ; generate tone
        dec     de
        ld      a,d
        or      e
        jr      nz,l0307        ; loop back for tone
; Here we test for sets of keys pressed at the test image, and jump
; to routines to handle them if necessary
      IF garry
        jr      l0302           ; sound tone again
l031c   call    l089f
        ld      (hl), a
        ret
l0321   call    l089f
        ld      a, (hl)
        ret
l0326   inc     b
        djnz    l032e
        ld      de, 15
        jr      l0352
l032e   djnz    l034f
        ld      a, d
        or      e
        jp      nz, l38d5
        push    hl
        ld      hl, (CURCHL)
        ld      de, 13
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        dec     de
        inc     hl
        ex      de, hl
        pop     bc
        and     a
        sbc     hl, bc
        ex      de, hl
        jp      c, l38d5
        ld      (hl), c
        inc     hl
        ld      (hl), b
        ret
l034f   ld      de, 13
l0352   ld      hl, (CURCHL)
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ex      de, hl
        ld      de, 0
        ret
l035e   DEFS    9
      ELSE
        ld      de,$2000        ; DE=number of times to check for keysets
        ld      ix,l03a8        ; IX=start of keyset table
l0321   ld      l,(ix+$00)      ; HL=next keyset start address-1
        ld      h,(ix+$01)
        inc     ix
        inc     ix              ; IX points to next entry in keyset table
        ld      a,h
        or      l
        jr      nz,l0335        ; test keyset unless at end of table
        ld      ix,l03a8        ; if so, start again at the beginning
        jr      l0321

l0335   inc     hl              ; HL points to next keyboard scan address
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=next keyboard scan address
        inc     hl
        ld      a,b
        or      c
        jr      z,l034c         ; move on if scanned all for this keyset
        in      a,(c)
        and     $1f             ; mask keyboard (bits 0-4)
        cp      (hl)            ; check against required value
        jr      z,l0335         ; continue checking if OK
        dec     de              ; decrement number of checks counter
        ld      a,d
        or      e
        jr      nz,l0321        ; loop back to scan again
        jr      l0302           ; sound tone again

l034c   ld      c,(hl)          ; get address of routine to execute
        inc     hl
        ld      b,(hl)
        push    bc              ; stack address
        ret                     ; and "return" to it

; Self-test keyset table
; Program accessed with "QAZPLM" held down on test screen

l0351   defw    $fbfe
        defb    $1e             ; "Q"
        defw    $fdfe
        defb    $1e             ; "A"
        defw    $fefe
        defb    $1d             ; "Z"
        defw    $dffe
        defb    $1e             ; "P"
        defw    $bffe
        defb    $1d             ; "L"
        defw    $7ffe
        defb    $1b             ; "M"
        defw    0               ; end of keys to scan
        defw    l21df           ; routine address
      ENDIF

; Jump here if there is a memory test error:
; if the bit couldn't be set, a border is set to the bit number,
; if it couldn't be reset, an alternating bit number/bit number XOR 7
; border is set.

l0367   ld      a,8
        sub     e
        ex      af,af'          ; A'=bit number failed on
        and     a
        jr      nz,l0373        ; jump on if bit could be set
        ex      af,af'
        out     ($fe),a         ; else halt with border set to bit number
l0371   jr      l0371

l0373   ex      af,af'
        ld      c,a
        ld      b,$07
        xor     b
        ld      b,a             ; B=bit number XOR 7

l0379   ld      a,c
        out     ($fe),a         ; set bit number border
        ld      de,$0000
l037f   dec     de
        ld      a,d
        or      e
        jr      nz,l037f        ; pause for approx 0.5s
        ld      a,b
        out     ($fe),a         ; set bit number XOR 7 border
        ld      de,$2aaa
l038a   dec     de
        ld      a,d
        or      e
        jr      nz,l038a        ; pause for approx 0.1s
        jr      l0379           ; loop back

      IF garry
        defs    31
      ELSE
; Pretty EAR monitor keyset table
; Program accessed with "EUA" held down on test screen
l0391   defw    $fbfe
        defb    $1b             ; "E"
        defw    $dffe
        defb    $17             ; "U"
        defw    $fdfe
        defb    $1e             ; "A"
        defw    0               ; end of keys to scan
        defw    l22d0           ; routine address

; Reboot keyset table
; Spectrum rebooted with "BV" held down on test screen

l039e   defw    $7ffe
        defb    $0f             ; "B"
        defw    $fefe
        defb    $0f             ; "V"
        defw    0               ; end of keys to scan
        defw    $0000           ; routine address

; The table of keyset addresses-1 scanned at startup

l03a8   defw    l0351-1         ; self-test keyset table-1
        defw    l0391-1         ; pretty EAR monitor keyset table-1
        defw    l039e-1         ; reboot keyset table-1
        defw    0               ; end of table marker
; Text used for the test display
      ENDIF

l03b0   defm    $13, $0, "19", $13, $1, "87"

; Here is the initial channel information, copied to CHANS

l03b8   defw    o09F4
        defw    o10A8
        defb    'K'             ; keyboard/lower screen channel
        defw    o09F4
        defw    o15C4
        defb    'S'             ; main screen channel
        defw    o0F81
        defw    o15C4
        defb    'X'             ; workspace channel
      IF garry
        defw    $5b00
        defw    $5b00
      ELSE
        defw    o3A05
        defw    o3A00
      ENDIF
        defb    'P'             ; printer channel
        defb    $80             ; end of channel information

; Here is the initial stream addresses, copied to STRMS

l03cd   defw    $0001           ; stream -3, 'K'
        defw    $0006           ; stream -2, 'S'
        defw    $000b           ; stream -1, 'X'
        defw    $0001           ; stream 0, 'K'
        defw    $0001           ; stream 1, 'K'
        defw    $0006           ; stream 2, 'S'
        defw    $0010           ; stream 3, 'P'

; Copyright message

l03db   defm    $7f, "1982, 1986, 1987 Amstrad Plc.", $8d

; Subroutine to ???

l03fa   ld      hl,$eef5
        res     0,(hl)          ; ???
        set     1,(hl)          ; ???
l0401   ld      hl,(E_PPC)      ; get current line
        ld      a,h
        or      l
        jr      nz,l040b        ; move on unless 0
l0408   ld      ($ec06),hl      ; ???
l040b   ld      a,(nr_above)    ; ???
        push    af
        ld      hl,($fc9a)      ; ???
        call    l1418           ; get number of line before (or 0)
        ld      ($f9d7),hl      ; ???
        call    l12f0           ; ???
        call    l11a4           ; ???
        pop     af
l041f   or      a
        jr      z,l042e         ; move on if ???
        push    af
l0423   call    l11ad           ; ???
        ex      de,hl
        call    l1338
        pop     af
        dec     a
        defb    $18
        defb    -15
l042e   ld      c,$00
        call    l1182
        ld      b,c
        ld      a,(ed_N_ROWS)
        ld      c,a
        push    bc
        push    de
l043a   call    l11ad
        ld      a,($eef5)
        bit     1,a
        defb    $28
        defb    29
        push    de
        push    hl
l0446   ld      de,$0020
        add     hl,de
        bit     0,(hl)
        defb    $28
        defb    17
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      e,(hl)
        or      a
        ld      hl,(E_PPC)
        sbc     hl,de
        defb    $20
        defb    5
        ld      hl,$eef5
        set     0,(hl)
l045f   pop     hl
        pop     de
l0461   push    bc
        push    hl
        ld      bc,$0023
        ldir
        pop     hl
        pop     bc
        push    de
        push    bc
        ex      de,hl
        ld      hl,$eef5
        bit     0,(hl)
        defb    $28
        defb    42
        ld      b,$00
l0476   ld      hl,($ec06)
        ld      a,h
        or      l
        defb    $28
        defb    14
        push    hl
        call    l0f0f
        pop     hl
        defb    $30
        defb    18
        dec     hl
        inc     b
        ld      ($ec06),hl
        defb    $18
        ex      de,hl
        call    l0f0f
        call    nc,l0f31
        ld      hl,$eef5
        ld      (hl),$00
l0496   ld      a,b
        pop     bc
        push    bc
        ld      c,b
        ld      b,a
        call    l0adc
l049e   pop     bc
        pop     de
        ld      a,c
        inc     b
        cp      b
        defb    $30
        defb    -107
        ld      a,($eef5)
        bit     1,a
        defb    $28
        defb    33
        bit     0,a
        defb    $20
        defb    29
        ld      hl,(E_PPC)
        ld      a,h
        or      l
        defb    $28
        defb    8
        ld      ($fc9a),hl
        call    l12f0
        defb    $18
        defb    9
l04bf   ld      ($fc9a),hl
        call    l1420
        ld      (E_PPC),hl
l04c8   pop     de
        pop     bc
        jp      l0401

l04cd   pop     de
        pop     bc
        cp      a

l04d0   push    af
        ld      a,c
        ld      c,b
        call    l1182
        ex      de,hl

l04d7   push    af
        call    l16fe
        pop     af
        ld      de,$0023
        add     hl,de
        inc     c
        cp      c
        jr      nc,l04d7            ; (-13)
        pop     af
        ret     z
        call    l0ad2

l04e9   call    l0c43
        ld      hl,($ec06)
        dec     hl
        ld      a,h
        or      l
        ld      ($ec06),hl
        jr      nz,l04e9            ; (-14)
        jp      l0adc
        ret

l04fb   ld      b,$00
        ld      a,(ed_N_ROWS)
        ld      d,a
        jp      l1d6b

l0504   ld      b,$00
        push    hl
        ld      c,b
        call    l1182
        call    l1338
        pop     hl
        ret     nc
        call    l11ad

l0513   push    bc
        push    hl
        ld      hl,$0023
        add     hl,de
        ld      a,(ed_N_ROWS)
        ld      c,a
        cp      b
        jr      z,l052e             ; (14)
        push    bc

l0521   push    bc
        ld      bc,$0023
        ldir
        pop     bc
        ld      a,c
        inc     b
        cp      b
        jr      nz,l0521            ; (-12)
        pop     bc

l052e   pop     hl
        call    l1712
        ld      bc,$0023
        ldir
        scf
        pop     bc
        ret

l053a   ld      b,$00
        call    l12f9
        ret     nc

l0540   push    bc
        push    hl
        ld      a,(ed_N_ROWS)
        ld      c,a
        call    l1182
        call    l11ec
        jr      nc,l0574            ; (38)
        dec     de
        ld      hl,$0023
        add     hl,de
        ex      de,hl
        push    bc
        ld      a,b
        cp      c
        jr      z,l0565             ; (12)

l0559   push    bc
        ld      bc,$0023
        lddr
        pop     bc
        ld      a,b
        dec     c
        cp      c
        jr      c,l0559             ; (-12)

l0565   ex      de,hl
        inc     de
        pop     bc
        pop     hl
        call    l1726
        ld      bc,$0023
        ldir
        scf
        pop     bc
        ret

l0574   pop     hl
        pop     bc
        ret

l0577   push    de
        ld      h,$00
        ld      l,b
        add     hl,de
        ld      d,a
        ld      a,b

l057e   ld      e,(hl)
        ld      (hl),d
        ld      d,e
        inc     hl
        inc     a
        cp      $20
        jr      c,l057e             ; (-9)
        ld      a,e
        cp      $00
        pop     de
        ret

l058c   push    de
        ld      hl,$0020
        add     hl,de
        push    hl
        ld      d,a
        ld      a,$1f
        jr      l059e               ; (7)

l0597   ld      e,(hl)
        ld      (hl),d
        ld      d,e
        cp      b
        jr      z,l05a1             ; (4)
        dec     a

l059e   dec     hl
        jr      l0597               ; (-10)

l05a1   ld      a,e
        cp      $00
        pop     hl
        pop     de
        ret

; Subroutine to page in normal memory (page 0) and swap SP with OLDSP

l05a7   ex      af,af'          ; save AF
        ld      a,$00
        di
        call    l05c1           ; page in page 0
        pop     af              ; AF holds return address
        ld      (TARGET),hl     ; save HL in TARGET
        ld      hl,(OLDSP)      ; get OLDSP
        ld      (OLDSP),sp      ; save SP in OLDSP
        ld      sp,hl           ; SP now holds what was in OLDSP
        ei
        ld      hl,(TARGET)     ; restore HL
        push    af              ; push back return address
        ex      af,af'          ; restore AF
        ret

; Subroutine to page in page A

l05c1   push    bc              ; save BC
        ld      bc,$7ffd
        out     (c),a           ; change page
        ld      (BANKM),a       ; save copy of OUT
        pop     bc              ; restore BC
        ret

; Subroutine to page in DOS workspace (page 7) and swap SP with OLDSP

l05cc   ex      af,af'          ; save AF
        di
        pop     af              ; AF holds return address
        ld      (TARGET),hl     ; save HL in TARGET
        ld      hl,(OLDSP)      ; get OLDSP
        ld      (OLDSP),sp      ; save SP in OLDSP
        ld      sp,hl           ; SP now holds what was in OLDSP
        ld      hl,(TARGET)     ; restore HL
        push    af              ; push back return address
        ld      a,$07
        call    l05c1           ; page in page 7
        ei
        ex      af,af'          ; restore AF
        ret

; The editing keys table
; Most of these keys are produced by the external keypad, which was not
; made available in the UK.

l05e6   defb    $15
        defb    $0b             ; cursor up
        defw    l0b5f
        defb    $0a             ; cursor down
        defw    l0b80
        defb    $08             ; cursor left
        defw    l0ba2
        defb    $09             ; cursor right
        defw    l0bae
        defb    $ad             ; TAB (up 10)
        defw    l0b1a
        defb    $ac             ; AT (down 10)
        defw    l0af0
        defb    $af             ; CODE (left word)
        defw    l0a9f
        defb    $ae             ; VAL$ (right word)
        defw    l0aac
        defb    $a6             ; INKEY$ (top)
        defw    l0a4e
        defb    $a5             ; RND (bottom)
        defw    l0a76
        defb    $a8             ; FN (start of line)
        defw    l0b52
        defb    $a7             ; PI (end of line)
        defw    l0b45
        defb    $aa             ; SCREEN$ (delete char right)
        defw    l09e6
        defb    $0c             ; delete
        defw    l09f6
        defb    $b3             ; COS (delete word right)
        defw    l10e5
        defb    $b4             ; TAN (delete word left)
        defw    l108a
        defb    $b0             ; VAL (delete line right)
        defw    l1140
        defb    $b1             ; LEN (delete line left)
        defw    l110c
        defb    $0d             ; enter
        defw    l0a0f
        defb    $a9             ; POINT (screen)
        defw    l0748
        defb    $07             ; edit
        defw    l07b1

; The menu keys table

l0626   defb    $04
      IF curkl
        defb    $6c             ; cursor up
        defw    l07dc
        defb    $6b             ; cursor down
      ELSE
        defb    $0b             ; cursor up
        defw    l07dc
        defb    $0a             ; cursor down
      ENDIF
        defw    l07df
        defb    $07             ; edit
        defw    l07c5
        defb    $0d             ; enter
        defw    l07c5

; Subroutine to ????

l0633   call    l0989
        ld      hl,$0000
        ld      ($fc9a),hl
        ld      a,$82
        ld      (ed_flags),a
        ld      hl,$0000
        ld      (E_PPC),hl
        call    l16b6
        call    l1758
        ret

; Routine to display main menu & go to process it

l064e   ld      hl,TSTACK
        ld      (OLDSP),hl      ; set "OLDSP" to temporary stack area
        call    l05cc           ; page in DOS workspace
        ld      a,$02
        ROM3    o1601           ; open channel to stream 2
l065c   ld      hl,l07f2
        ld      (men_rout),hl   ; store main menu routine table address
        ld      hl,l07ff
        ld      (men_text),hl   ; store main menu text address
        push    hl              ; save menu address
        ld      hl,ed_flags
        set     1,(hl)          ; signal "processing menu"
        res     4,(hl)          ; ???
        dec     hl
        ld      (hl),$00        ; set men_high=0
        pop     hl              ; restore menu address
        xor     a
        call    l189a           ; display main menu
        jp      l0703           ; move to process menu


l067b   ld      ix,$fd98
        ld      hl,TSTACK
        ld      (OLDSP),hl
        call    l05cc
        ld      a,$02
        ROM3    o1601
        call    l185a
        ld      hl,$5c3b

l0693   bit     5,(hl)
        jr      z,l0693             ; (-4)
        ld      hl,ed_flags
        res     3,(hl)
        bit     6,(hl)
        jr      nz,l06b4            ; (20)
        ld      a,(process)
        cp      $04
        jr      z,l06b1             ; (10)
        cp      $00
        jp      nz,l0992
        call    l1a5a
        jr      l06b4               ; (3)

l06b1   call    l1a5f           ; display "Calculator" bar
l06b4   call    l11a4
        call    l12f0
        ld      a,(process)     ; get current process
        cp      $04
        jr      z,l0703         ; move on if its the calculator
        ld      hl,(E_PPC)      ; get number of current line
        ld      a,h
        or      l
        jr      nz,l06dd        ; move on if not zero
        ld      hl,(PROG)
        ld      bc,(VARS)
        and     a
        sbc     hl,bc           ; get length of BASIC program
        jr      nz,l06da        ; move on if not zero
        ld      hl,$0000
        ld      ($ec08),hl      ; ??? last line
l06da   ld      hl,($ec08)      ; ??? last line
l06dd   call    l05a7           ; page in normal memory
        ROM3    o196E           ; ???
        ROM3    o1695
        call    l05cc           ; page in DOS workspace
        ld      (E_PPC),de
        ld      hl,ed_flags
        bit     5,(hl)
        jr      nz,l0703            ; (15)
        ld      hl,$0000
        ld      ($ec06),hl
        call    l03fa
        call    l0abd
        call    l0a0f

; Main routine to process menus & editing functions

l0703   ld      sp,TSTACK       ; set SP in temporary stack
l0706   call    l1871           ; get a key
        push    af
        ld      a,(PIP)
        call    l0799           ; sound a 'PIP'
        pop     af
        call    l0716           ; "do" the key
        jr      l0706           ; loop back
l0716   ld      hl,ed_flags
        bit     1,(hl)          ; check editing/menu flag
        push    af
        ld      hl,l0626        ; use menu keys table
        jr      nz,l0724
        ld      hl,l05e6        ; or editing keys table
l0724   call    l2166           ; perform pressed key action
        jr      nz,l072e
        call    nc,l0794        ; sound a RASP if action failed
        pop     af              ; restore editing/menu flag status
        ret
l072e   pop     af              ; restore editing/menu flag status
        jr      z,l0736         ; move on if editing
        xor     a
        ld      (MODE),a        ; else in menu, so set MODE=0
        ret
l0736   ld      hl,ed_flags
        bit     0,(hl)
        jr      z,l0741         ; move on if ???
        call    l0794           ; sound a RASP
        ret
l0741   cp      $a3
      IF garry
        ret     nc
        nop
      ELSE
        jr      nc,l0706        ; loop back if ???
      ENDIF
        jp      l09bc

; Editing keys: SCREEN

l0748   ld      a,(process)
        cp      $04
        ret     z               ; exit if in Calculator
        call    l04fb
        ld      hl,ed_flags
        res     3,(hl)
        ld      a,(hl)
        xor     $40
        ld      (hl),a
        and     $40
        jr      z,l0763             ; (5)
        call    l0768
        jr      l0766               ; (3)
l0763   call    l077b
l0766   scf
        ret

l0768   call    l1a8e
        ld      hl,ed_flags
        set     6,(hl)
        call    l0efb
        call    l1c95
        call    l09aa
        jr      l0786               ; (11)

l077b   ld      hl,ed_flags
        res     6,(hl)
        call    l0989
        call    l1a5a
l0786   ld      hl,($fc9a)
        ld      a,h
        or      l
        call    nz,l1418
        call    l03fa
        jp      l0abd

; Subroutine to sound a PIP or RASP
; Enter at l0799 with A=PIP, or at l0794 for RASP

l0794   ld      a,(RASP)
        srl     a               ; A=RASP/2
l0799   push    ix              ; save IX
        ld      d,$00
        ld      e,a             ; DE=f*t
      IF garry
        ld      hl, $00c8
      ELSE
        ld      hl,$0c80        ; HL=timing constant
      ENDIF
l07a1   ROM3    o03B5           ; call BEEPER
        pop     ix              ; restore IX
        ret

; Another sound

l07a7   push    ix
        ld      de,$0030
        ld      hl,$0300
        jr      l07a1

; Editing keys: EDIT

l07b1   call    l0ab7           ; remove cursor
        ld      hl,ed_flags
        set     1,(hl)          ; set "processing menu"
        dec     hl
        ld      (hl),$00        ; highlight on line 0
        ld      hl,(men_text)
        xor     a
        call    l189a           ; display menu
        scf
        ret

; The menu ENTER/EDIT routine

l07c5   ld      hl,ed_flags
        res     1,(hl)          ; signal editing mode
        dec     hl
        ld      a,(hl)          ; A=currently highlighted line
        ld      hl,(men_rout)   ; HL=menu routines table
        push    hl
        push    af
        call    l1950           ; copy saved area back to screen
        pop     af
        pop     hl
        call    l2166           ; execute required routine
        jp      l0abd           ; move on

; The menu cursor up/down routines
; Enter at l07dc for up, l07df for down

l07dc   scf                     ; set carry for cursor up
        jr      l07e0
l07df   and     a               ; clear carry for cursor down
l07e0   ld      hl,men_high
        ld      a,(hl)          ; get currently highlighted line number
        push    hl
        ld      hl,(men_text)   ; point to menu
        call    c,l19b9         ; move highlight up
        call    nc,l19c8        ; or down
        pop     hl
        ld      (hl),a          ; replace highlighted line number
l07f0   scf                     ; signal "action succeeded"
        ret

; The main menu routine address table

l07f2   defb    $04
        defb    $00
        defw    l08e8           ; Loader
        defb    $01
        defw    l0937           ; +3 BASIC
        defb    $02
        defw    l0950           ; Calculator
        defb    $03
        defw    l08df           ; 48K BASIC

; The main menu

l07ff   defb    $05             ; 5 lines total
      IF garry
        defm    "128 +3e ", $ff
      ELSE
        defm    "128 +3  ", $ff
      ENDIF
      IF spanish
l0809   defm    "Cargado", 'r'+$80
l080f   defm    "+3 BASI", 'C'+$80
l0817   defm    "Calculador", 'a'+$80
        defm    "48 BASI", 'C'+$80, ' '+$80

; The editor menu routine address table

l082a   defb    $05
        defb    $00
        defw    l07f0           ; +3 BASIC
        defb    $01
        defw    l0917           ; Renumber
        defb    $02
        defw    l08c5           ; Screen
        defb    $03
        defw    l0928           ; Print
        defb    $04
        defw    l08ca           ; Exit

; The editor menu

l083a   defb    $06
        defm    "Opciones", $ff
        defm    "+3 BASI", 'C'+$80
        defm    "Renumera", 'r'+$80
        defm    "Pantall", 'a'+$80
        defm    "Imprimi", 'r'+$80
        defm    "Salid", 'a'+$80, ' '+$80

; The calculator menu routines table

l0864   defb    $02
        defb    $00
        defw    l07f0           ; Calculator
        defb    $01
        defw    l08ca           ; Exit

; The calculator menu

l086b   defb    $03
        defm    "Opciones", $ff
        defm    "Calculador", 'a'+$80
        defm    "Salid", 'a'+$80, ' '+$80

; Cassette loader message

      ELSE
l0809   defm    "Loade", 'r'+$80
l080f   defm    "+3 BASI", 'C'+$80
l0817   defm    "Calculato", 'r'+$80
        defm    "48 BASI", 'C'+$80, ' '+$80

; The editor menu routine address table

l082a   defb    $05
        defb    $00
        defw    l07f0           ; +3 BASIC
        defb    $01
        defw    l0917           ; Renumber
        defb    $02
        defw    l08c5           ; Screen
        defb    $03
        defw    l0928           ; Print
        defb    $04
        defw    l08ca           ; Exit

; The editor menu

l083a   defb    $06
        defm    "Options ", $ff
        defm    "+3 BASI", 'C'+$80
        defm    "Renumbe", 'r'+$80
        defm    "Scree", 'n'+$80
        defm    "Prin", 't'+$80
        defm    "Exi", 't'+$80, ' '+$80

; The calculator menu routines table

l0864   defb    $02
        defb    $00
        defw    l07f0           ; Calculator
        defb    $01
        defw    l08ca           ; Exit

; The calculator menu

l086b   defb    $03
        defm    "Options ", $ff
        defm    "Calculato", 'r'+$80
        defm    "Exi", 't'+$80, ' '+$80

; Cassette loader message

      ENDIF
    IF garry
      IF spanish
l0884   defs    13
      ELSE
l0884   defs    27
      ENDIF
l089f   ld      hl, (CURCHL)
        ld      de, 13
        add     hl, de
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ex      de, hl
        push    hl
        and     a
        sbc     hl, bc
        pop     hl
        ex      de, hl
        jp      nc, l38d5
        inc     de
        ld      (hl), d
        dec     hl
        ld      (hl), e
        inc     hl
        inc     hl
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        ex      de, hl
        add     hl, bc
        dec     hl
        scf
        ret
    ELSE
l0884   defm    $16, $00, $00
        defm    $10, $00, $11, $07
        defm    $13, $00
      IF spanish
        defm    "Introduzca la cinta y pulse PLAY", $0d
        defm    "Cancelar: pulse BREAK dos veces", '.'+$80
      ELSE
        defm    "Insert tape and press PLAY", $0d
        defm    "To cancel - press BREAK twic", 'e'+$80
      ENDIF
    ENDIF
; The Screen menu option

l08c5   call    l0748           ; call SCREEN editing key routine
        jr      l093f           ; ???

; The "Exit" from submenu option

l08ca   ld      hl,ed_flags
        res     6,(hl)          ; ???
        call    l0989           ; ???
        ld      b,$00
        ld      d,$17
        call    l1d6b           ; clear whole screen to editor colours
        call    l05a7           ; page in normal memory
        jp      l064e           ; display main menu & process it

; The 48K BASIC menu option

l08df   call    l05a7           ; page in normal memory
        ROM1    m1488           ; enter 48K BASIC via ROM 1
        ret

; The Loader menu option

l08e8   call    l1a64           ; display "Loader" bar
        ld      hl,TV_FLAG
        set     0,(hl)          ; signal "using lower screen"
      IF garry
        ld      de, l37eb
        nop
        nop
        ld      a, (LODDRV)
        cp      'T'
      ELSE
        ld      de,l0884
        push    hl
l08f4   ld      hl,FLAGS3
        bit     4,(hl)
        pop     hl
      ENDIF
        jr      nz,l08ff        ; move on if disk interface present
        call    l029e           ; display cassette loader message
l08ff   res     0,(hl)          ; ???
        set     6,(hl)          ; ???
        ld      a,$07
        ld      (process),a     ; signal "current process is Loader"
        ld      bc,$0000
        call    l191d           ; output "AT 0,0"
l090e   call    l05a7           ; page in normal memory
        ROM1    m12e8
        ret

l0917   call    l1a95
        call    nc,l0794
        ld      hl,$0000
        ld      (E_PPC),hl
        ld      ($ec08),hl
        jr      l0930               ; (8)

; The Print menu option

l0928   call    l05a7           ; page in normal memory
        ROM1    m1451
l0930   ld      hl,ed_flags
        bit     6,(hl)          ; ???
l0935   jr      nz,l093f

; The +3 BASIC routine - called from the main menu

l0937   ld      hl,TV_FLAG
        res     0,(hl)          ; signal "main screen"
        call    l1a5a           ; display "+3 BASIC" bar
l093f   ld      hl,ed_flags
        res     5,(hl)          ; ???
        res     4,(hl)          ; ???
        ld      a,$00           ; ???
        ld      hl,l082a        ; +3 BASIC menu addresses
        ld      de,l083a        ; +3 BASIC menu
        jr      l097c           ; go to set menu

; The Calculator routine - called from the main menu

l0950   ld      hl,ed_flags
        set     5,(hl)          ; ???
        set     4,(hl)          ; ???
        res     6,(hl)          ; ???
        call    l0989
        call    l1a5f           ; display "Calculator" bar
        ld      a,$04
        ld      (process),a
        ld      hl,$0000
        ld      (E_PPC),hl
        call    l03fa
        ld      bc,$0000
        ld      a,b
        call    l0ac3
        ld      a,$04
        ld      hl,l0864
        ld      de,l086b

; Routine to set new menu and ???

l097c   ld      (process),a     ; ???
        ld      (men_rout),hl   ; store routine address table
        ld      (men_text),de   ; store menu address
        jp      l06b4           ; ???

; Subroutine to ???

l0989   call    l0eed
        call    l1c8c
        jp      l09b3

l0992   ld      b,$00
        ld      d,$17
        call    l1d6b           ; clear screen to editor colours
        jp      l065c

l099c   defb    $06
        defb    0
        defb    0
        defb    0
        defb    $04
        defb    $10
        defb    $14

l09a3   defb    $06
        defb    0
        defb    0
        defb    0
        defb    0
        defb    $01
        defb    $01

l09aa   ld      hl,l09a3
        ld      de,$f6ee
        jp      l2152

l09b3   ld      hl,l099c
        ld      de,$f6ee
        jp      l2152

; Subroutine to ???

l09bc   ld      hl,ed_flags
        or      a
        or      a
        bit     0,(hl)
        jp      nz,l0abd
        res     7,(hl)
        set     3,(hl)
        push    hl
        push    af
        call    l0ab7
        pop     af
        push    af
        call    l0f4f
        pop     af
        ld      a,b
        call    l0c43
        pop     hl
        set     7,(hl)
        jp      nc,l0abd
        ld      a,b
        jp      c,l0ac3
        jp      l0abd


; Editing keys: DELETE RIGHT

l09e6   ld      hl,ed_flags
        set     3,(hl)
        call    l0ab7
        call    l0fe0
        scf
        ld      a,b
        jp      l0ac3

; Editing keys: DELETE

l09f6   ld      hl,ed_flags
        res     0,(hl)
        set     3,(hl)
        call    l0ab7
        call    l0c26
        ccf
        jp      c,l0abd
l0a07   call    l0fe0
        scf
        ld      a,b
        jp      l0ac3

; Editing keys: ENTER

l0a0f   call    l0ab7
        push    af
        call    l1182
        push    bc
        ld      b,$00
        call    l0f0f
        pop     bc
        jr      c,l0a29             ; (10)
        ld      hl,$0020
        add     hl,de
        ld      a,(hl)
        cpl
        and     $09
        jr      z,l0a45             ; (28)
l0a29   ld      a,(ed_flags)
        bit     3,a
        jr      z,l0a35             ; (5)
        call    l0d59
        jr      nc,l0a4a            ; (21)
l0a35   call    l0d17
        call    l0c43
        call    l0f9c
        ld      b,$00
        pop     af
        scf
        jp      l0ac3
l0a45   pop     af
        scf
        jp      l0abd
l0a4a   pop     af
        jp      l0abd

; Editing keys: TOP

l0a4e   ld      a,(process)
        cp      $04
        ret     z               ; exit if in Calculator
        call    l0ab7           ; remove cursor
        ld      hl,$0000        ; line 0
        call    l05a7           ; page in normal memory
        ROM3    o196E           ; get address of first line in HL
        ROM3    o1695           ; get line number in DE
        call    l05cc           ; page in DOS workspace
        ld      (E_PPC),de      ; set as current line
        ld      a,$0f
        call    l1ca3           ; set colours to blue ink, white paper
        call    l03fa           ; ???
        scf                     ; success
        jp      l0abd           ; place cursor & exit

; Editing keys: BOTTOM

l0a76   ld      a,(process)
        cp      $04
        ret     z               ; exit if in Calculator
        call    l0ab7           ; remove cursor
        ld      hl,9999         ; last possible line
        call    l05a7           ; page in normal memory
        ROM3    o196E           ; get last line address in DE
        ex      de,hl
        ROM3    o1695           ; get last line number in DE
        call    l05cc           ; page in DOS workspace
        ld      (E_PPC),de      ; set as current line
        ld      a,$0f
        call    l1ca3           ; set colours to blue ink, white paper
        call    l03fa           ; ???
        scf                     ; success
        jp      l0abd           ; place cursor & exit

; Editing keys: LEFT WORD

l0a9f   call    l0ab7
        call    l0cb5
        jp      nc,l0abd
        ld      a,b
        jp      l0ac3

; Editing keys: RIGHT WORD

l0aac   call    l0ab7
        call    l0cd4
        jr      nc,l0abd            ; (9)
        ld      a,b
        jr      l0ac3               ; (12)

; Subroutine to remove cursor

l0ab7   call    l0ad2           ; get cursor position
        jp      l1749           ; remove it

; Subroutine to place cursor

l0abd   call    l0ad2           ; get cursor position
        jp      l173a           ; place it

; Subroutine to set cursor to line C, column B, ??? A
; and set colours & place it

l0ac3   call    l0adc           ; set cursor details
        push    af
        push    bc
        ld      a,$0f
        call    l1ca3           ; set colours to blue INK, white PAPER
        pop     bc
        pop     af
        jp      l173a           ; place cursor

; Subroutine to get cursor line (C), column (B), and ??? (A)

l0ad2   ld      hl,$f6ee
        ld      c,(hl)          ; get line (within editing area)
        inc     hl
        ld      b,(hl)          ; get column
        inc     hl
        ld      a,(hl)          ; get ???
        inc     hl
        ret

; Subroutine to set cursor line (C), column (B), and ??? (A)

l0adc   ld      hl,$f6ee
        ld      (hl),c          ; set line
        inc     hl
        ld      (hl),b          ; set column
        inc     hl
        ld      (hl),a          ; set ???
        ret



l0ae5   push    hl
        call    l1182
        ld      h,$00
        ld      l,b
        add     hl,de
        ld      a,(hl)
        pop     hl
        ret

; Editing keys: DOWN 10 LINES

l0af0   call    l0ab7
        ld      e,a
        ld      d,$0a
l0af6   push    de
        call    l0bfb
        pop     de
        jr      nc,l0abd            ; (-64)
        ld      a,e
        call    l0adc
        ld      b,e
        call    l0bc4
        jr      nc,l0b0d            ; (6)
        dec     d
        jr      nz,l0af6            ; (-20)
        ld      a,e
        jr      c,l0ac3             ; (-74)
l0b0d   push    de
        call    l0bd6
        pop     de
        ld      b,e
        call    l0bc4
        ld      a,e
        or      a
        jr      l0ac3               ; (-87)

; Editing keys: UP 10 LINES

l0b1a   call    l0ab7
        ld      e,a
        ld      d,$0a
l0b20   push    de
        call    l0bd6
        pop     de
        jr      nc,l0abd            ; (-106)
        ld      a,e
        call    l0adc
        ld      b,e
        call    l0bcd
        jr      nc,l0b38            ; (7)
        dec     d
        jr      nz,l0b20            ; (-20)
        ld      a,e
        jp      c,l0ac3
l0b38   push    af
        call    l0bfb
        ld      b,$00
        call    l0c9f
        pop     af
        jp      l0ac3

; Editing keys: END OF LINE

l0b45   call    l0ab7
        call    l0d17
        jp      nc,l0abd
        ld      a,b
        jp      l0ac3

; Editing keys: START OF LINE

l0b52   call    l0ab7
        call    l0cfc
        jp      nc,l0abd
        ld      a,b
        jp      l0ac3

; Editing keys: CURSOR UP

l0b5f   call    l0ab7           ; remove cursor
        ld      e,a
        push    de
        call    l0bd6
        pop     de
        jp      nc,l0abd
        ld      b,e
        call    l0bcd
        ld      a,e
        jp      c,l0ac3
        push    af
        call    l0bfb
        ld      b,$00
        call    l0bc4
        pop     af
        jp      l0ac3

; Editing keys: CURSOR DOWN

l0b80   call    l0ab7           ; remove cursor
        ld      e,a
        push    de
        call    l0bfb
        pop     de
        jp      nc,l0abd
        ld      b,e
        call    l0bcd
        ld      a,e
        jp      c,l0ac3
        push    de
        call    l0bd6
        pop     de
        ld      b,e
        call    l0bc4
        ld      a,e
        or      a
        jp      l0ac3

; Editing keys: CURSOR LEFT

l0ba2   call    l0ab7           ; remove cursor
        call    l0c26
        jp      c,l0ac3
        jp      l0abd

; Editing keys: CURSOR RIGHT

l0bae   call    l0ab7           ; remove cursor
        call    l0c43
        jp      c,l0ac3
        push    af
        call    l0bd6
        ld      b,$1f
        call    l0caa
        pop     af
        jp      l0ac3



l0bc4   push    de
        call    l0c9f
        call    nc,l0caa
        pop     de
        ret

l0bcd   push    de
        call    l0caa
        call    nc,l0c9f
        pop     de
        ret

l0bd6   call    l0d47
        jr      nc,l0bfa            ; (31)
        push    bc
        call    l1182
        ld      b,$00
        call    l0f0f
        call    nc,l104e
        pop     bc
        ld      hl,$f6f1
        ld      a,(hl)
        cp      c
        jr      c,l0bf8             ; (9)
        push    bc
        call    l053a
        pop     bc
        ret     c
        ld      a,c
        or      a
        ret     z

l0bf8   dec     c
        scf

l0bfa   ret

l0bfb   push    bc
        call    l1182
        ld      b,$00
        call    l0f0f
        pop     bc
        jr      c,l0c0a             ; (3)
        jp      l104e

l0c0a   call    l0d33
        jr      nc,l0c25            ; (22)
        ld      hl,$f6f1
        inc     hl
        ld      a,c
        cp      (hl)
        jr      c,l0c23             ; (12)
        push    bc
        push    hl
        call    l0504
        pop     hl
        pop     bc
        ret     c
        inc     hl
        ld      a,(hl)
        cp      c
        ret     z

l0c23   inc     c
        scf

l0c25   ret

l0c26   ld      d,a
        dec     b
        jp      m,l0c31
        ld      e,b
        call    l0caa
        ld      a,e
        ret     c

l0c31   push    de
        call    l0bd6
        pop     de
        ld      a,e
        ret     nc
        ld      b,$1f
        call    l0caa
        ld      a,b
        ret     c
        ld      a,d
        ld      b,$00
        ret

l0c43   ld      d,a
        inc     b
        ld      a,$1f
        cp      b
        jr      c,l0c50             ; (6)
        ld      e,b
        call    l0c9f
        ld      a,e
        ret     c

l0c50   dec     b
        push    bc
        push    hl
        ld      hl,ed_flags
        bit     7,(hl)
        jr      nz,l0c8b            ; (49)
        call    l1182
        ld      hl,$0020
        add     hl,de
        ld      a,(hl)
        bit     1,a
        jr      nz,l0c8b            ; (37)
        set     1,(hl)
        res     3,(hl)
        ld      hl,$0023
        add     hl,de
        ex      de,hl
        pop     hl
        pop     bc
        push    af
        call    l0bfb
        pop     af
        call    l1182
        ld      hl,$0023
        add     hl,de
        ex      de,hl
        res     0,a
        set     3,a
        call    l0fa1
        call    l16ee
        ld      a,b
        scf
        ret

l0c8b   pop     hl
        pop     bc
        push    de
        call    l0bfb
        pop     de
        ld      a,b
        ret     nc
        ld      b,$00
        call    l0c9f
        ld      a,b
        ret     c
        ld      a,e
        ld      b,$00
        ret

l0c9f   push    de
        push    hl
        call    l1182
        call    l0f0f
        jp      l0d30

l0caa   push    de
        push    hl
        call    l1182
        call    l0f31
        jp      l0d30

l0cb5   push    de
        push    hl
l0cb7   call    l0c26
        jr      nc,l0cd2            ; (22)
        call    l0ae5
        cp      $20
        jr      z,l0cb7             ; (-12)
l0cc3   call    l0c26
        jr      nc,l0cd2            ; (10)
        call    l0ae5
        cp      $20
        jr      nz,l0cc3            ; (-12)
        call    l0c43

l0cd2   jr      l0d30               ; (92)

l0cd4   push    de
        push    hl

l0cd6   call    l0c43
        jr      nc,l0cf6            ; (27)
        call    l0ae5
        cp      $20
        jr      nz,l0cd6            ; (-12)

l0ce2   call    l0c43
        jr      nc,l0cf6            ; (15)
        call    l0f0f
        jr      nc,l0cf6            ; (10)
        call    l0ae5
        cp      $20
        jr      z,l0ce2             ; (-17)
        scf
        jr      l0d30               ; (58)

l0cf6   call    nc,l0c26
        or      a
        jr      l0d30               ; (52)

l0cfc   push    de
        push    hl

l0cfe   call    l1182
        ld      hl,$0020
        add     hl,de
        bit     0,(hl)
        jr      nz,l0d10            ; (7)
        call    l0bd6
        jr      c,l0cfe             ; (-16)
        jr      l0d30               ; (32)

l0d10   ld      b,$00
        call    l0c9f
        jr      l0d30               ; (25)

l0d17   push    de
        push    hl

l0d19   call    l1182
        ld      hl,$0020
        add     hl,de
        bit     3,(hl)
        jr      nz,l0d2b            ; (7)
        call    l0bfb
        jr      c,l0d19             ; (-16)
        jr      l0d30               ; (5)

l0d2b   ld      b,$1f
        call    l0caa

l0d30   pop     hl
        pop     de
        ret

l0d33   ld      a,(ed_flags)
        bit     3,a
        scf
        ret     z
        call    l1182
        ld      hl,$0020
        add     hl,de
        bit     3,(hl)
        scf
        ret     z
        jr      l0d59               ; (18)

l0d47   ld      a,(ed_flags)
        bit     3,a
        scf
        ret     z
        call    l1182
        ld      hl,$0020
        add     hl,de
        bit     0,(hl)
        scf
        ret     z

l0d59   ld      a,$02

l0d5b   call    l1182
        ld      hl,$0020
        add     hl,de
        bit     0,(hl)
        jr      nz,l0d6e            ; (8)
        dec     c
        jp      p,l0d5b
        ld      c,$00
        ld      a,$01

l0d6e   ld      hl,$ec00
        ld      de,$ec03
        or      $80
        ld      (hl),a
        ld      (de),a
        inc     hl
        inc     de
        ld      a,$00
        ld      (hl),a
        ld      (de),a
        inc     hl
        inc     de
        ld      a,c
        ld      (hl),a
        ld      (de),a
        ld      hl,$0000
        ld      ($ec06),hl
        call    l142d
        call    l1dfa
        push    ix
        call    l05a7
        ROM1    m24f0
        call    l05cc
        ei
        pop     ix
        ld      a,(ERR_NR)
        inc     a
        jr      nz,l0dbd            ; (24)
        ld      hl,ed_flags
        res     3,(hl)
        call    l1758
        ld      a,(process)
        cp      $04
        call    nz,l03fa
        call    l07a7
        call    l0ad2
        scf
        ret

l0dbd   ld      hl,$ec00
        ld      de,$ec03
        ld      a,(de)
        res     7,a
        ld      (hl),a
        inc     hl
        inc     de
        ld      a,(de)
        ld      (hl),a
        inc     hl
        inc     de
        ld      a,(de)
        ld      (hl),a
        call    l1df6
        jr      c,l0dd8             ; (4)
        ld      bc,($ec06)

l0dd8   ld      hl,($ec06)
        or      a
        sbc     hl,bc
        push    af
        push    hl
        call    l0ad2
        pop     hl
        pop     af
        jr      c,l0df8             ; (17)
        jr      z,l0e13             ; (42)

l0de9   push    hl
        ld      a,b
        call    l0c26
        pop     hl
        jr      nc,l0e13            ; (34)
        dec     hl
        ld      a,h
        or      l
        jr      nz,l0de9            ; (-13)
        jr      l0e13               ; (27)

l0df8   push    hl
        ld      hl,ed_flags
        res     7,(hl)
        pop     hl
        ex      de,hl
        ld      hl,$0000
        or      a
        sbc     hl,de

l0e06   push    hl
        ld      a,b
        call    l0c43
        pop     hl
        jr      nc,l0e13            ; (5)
        dec     hl
        ld      a,h
        or      l
        jr      nz,l0e06            ; (-13)

l0e13   ld      hl,ed_flags
        set     7,(hl)
        call    l0adc
        ld      a,$17
        call    l1ca3
        or      a
        ret

l0e22   ld      hl,$ec00
        bit     7,(hl)
        jr      z,l0e30             ; (7)
        ld      hl,($ec06)
        inc     hl
        ld      ($ec06),hl

l0e30   ld      hl,$ec00
        ld      a,(hl)
        inc     hl
        ld      b,(hl)
        inc     hl
        ld      c,(hl)
        push    hl
        and     $0f
        ld      hl,l0e53
        call    l2166
        ld      e,l
        pop     hl
        jr      z,l0e47             ; (2)
        ld      a,$0d

l0e47   ld      (hl),c
        dec     hl
        ld      (hl),b
        dec     hl
        push    af
        ld      a,(hl)
        and     $f0
        or      e
        ld      (hl),a
        pop     af
        ret
l0e53   defb    $03, $02
        defw    l0e7a
        defb    $04
        defw    l0eb7
        defb    $01
        defw    l0e5d
l0e5d   call    l1385
l0e60   call    l0edc
        jr      nc,l0e6c            ; (7)
        cp      $00
        jr      z,l0e60             ; (-9)
        ld      l,$01
        ret

l0e6c   inc     c
        ld      b,$00
      IF garry
        ld      hl, nr_above
      ELSE
        ld      hl,(nr_above)
      ENDIF
        ld      a,c
        cp      (hl)
        jr      c, l0e5d
        ld      b,$00
        ld      c,$00

l0e7a   push    hl
        ld      hl,$f6ee
        ld      a,(hl)
        cp      c
        jr      nz,l0e8c            ; (10)
        inc     hl
        ld      a,(hl)
        cp      b
        jr      nz,l0e8c            ; (5)
        ld      hl,$ec00
        res     7,(hl)

l0e8c   pop     hl

l0e8d   call    l1182
        call    l0edc
        jr      nc,l0e9c            ; (7)
        cp      $00
        jr      z,l0e7a             ; (-31)
        ld      l,$02
        ret

;End of row reached - no editable characters in the Screen Line Edit Buffer row

l0e9c   ld      hl,$0020        ;
        add     hl,de           ; Point to the flag byte for the row.
        bit     3,(hl)          ; Is it the last row of the BASIC line?
        jr      z,l0ea9         ; Jump if not.
      
;On last row of the BASIC line and finished fetching characters from the line

        ld      l,$08           ; L=Signal at the end of the last row of the BASIC line.
        ld      a,$0d           ; A='Enter' character.
        ret                     ; Return with zero flag reset to indicate match found.
      
;Not on the last row of the BASIC line so move to the beginning of the next, if it is on screen.
      
l0ea9   ld      hl,ed_area      ; Point to the 'top row scroll threshold' value.
        inc     c               ; Next row of the BASIC line in the Screen Line Edit Buffer.
        ld      a,(hl)          ; Fetch the number of the last row in the Screen Line Edit Buffer.
        cp      c               ; Exceeded the upper scroll threshold?
        ld      b,$00           ; Column 0.
        jr      nc,l0e8d        ; Jump back if not to retrieve the character from the next row.
      
;The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll up one line
      
        ld      b,$00           ; Column 0. [Redundant byte]
        ld      c,$01           ; Row 1. (Row 0 holds a copy of the last row visible on screen)
      
; Table entry point - Using lower screen and only top row of a multi-row BASIC line is visible
; --------------------------------------------------------------------------------------------
      
l0eb7   call    l1291           ; Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
      
l0eba   call    l0edc           ; Fetch character from Below-Screen Line Edit Buffer row, incrementing the column number.
        jr      nc,l0ec6        ; Jump if end of row reached.
      
        cp      $00             ; Is the character a null, i.e. not editable?
        jr      z,l0eba         ; Jump back if null to keep fetching characters until a character is found or the end of the row is reached.
      
        ld      l,$04           ; L=Signal a character was returned from the Below-Screen Line Edit Buffer row, with A holding the character.
        ret                     ; Return with zero flag reset to indicate match found.

;End of row reached - no editable characters in the (below screen) Below-Screen Line Edit Buffer row

l0ec6   ld      hl,$0020        ;
        add     hl,de           ; Point to the flag byte for the row.
        bit     3,(hl)          ; Is it the last row of the BASIC line?
        jr      nz,l0ed7        ; Jump if so.
      
        inc     c               ; Next row.
        ld      b,$00           ; Column 0.
      
        ld      a,(row_below)   ; Fetch number of rows in the Below-Screen Line Edit Buffer.
        cp      c               ; Exceeded last line in Below-Screen Line Edit Buffer?
        jr      nc,l0eb7        ; Jump back if not to retrieve the character from the next row.

;All characters from rows off bottom of screen fetched so return an 'Enter'

; [Note it is not possible to have more than 20 rows off the bottom of the screen]

l0ed7   ld      l,$08           ; L=Signal at the end of the last row of the BASIC line.
        ld      a,$0d           ; A='Enter' character.
        ret                     ; Return with zero flag reset to indicate match found.
; ------------------------------------
; Fetch Character from Edit Buffer Row
; ------------------------------------
; Entry: B =Column number.
;        DE=Start address of row in Edit Buffer.
; Exit : Carry flag set indicates character fetched, reset if column out of range.

l0edc   ld      a,$1f           ; Column 31.
        cp      b               ; Is column
        ccf                     ;
        ret     nc              ; Return if B is greater than 31.

        ld      l,b             ;
        ld      h,$00           ; HL=Column number.
        add     hl,de           ;
        ld      a,(hl)          ; Fetch the character at the specified column.
        inc     b               ; Increment the column number.
        scf                     ; Signal character fetched.
        ret                     ;

l0ee9   defb    $01
        defb    $14

l0eeb   defb    $01
        defb    $01

; Subroutine to ???

l0eed   ld      hl,TV_FLAG
        res     0,(hl)          ; signal "not using lower screen"
        ld      hl,l0ee9
        ld      de,ed_N_ROWS
        jp      l2152           ; copy $14 into ed_N_ROWS and exit

l0efb   ld      hl,TV_FLAG
        set     0,(hl)          ; signal "using lower screen"
        ld      bc,$0000
        call    l191d           ; output "AT 0,0"
        ld      hl,l0eeb
        ld      de,ed_N_ROWS
        jp      l2152           ; copy $01 into ed_N_ROWS and exit

l0f0f   ld      h,$00
        ld      l,b
        add     hl,de
        ld      a,(hl)
        cp      $00
        scf
        ret     nz
        ld      a,b
        or      a
        jr      z,l0f29             ; (13)
        push    hl
        dec     hl
        ld      a,(hl)
        cp      $00
        scf
        pop     hl
        ret     nz

l0f24   ld      a,(hl)
        cp      $00
        scf
        ret     nz

l0f29   inc     hl
        inc     b
        ld      a,b
        cp      $1f
        jr      c,l0f24             ; (-12)
        ret

l0f31   ld      h,$00
        ld      l,b
        add     hl,de
        ld      a,(hl)
        cp      $00
        scf
        ret     nz

l0f3a   ld      a,(hl)
        cp      $00
        jr      nz,l0f46            ; (7)
        ld      a,b
        or      a
        ret     z
        dec     hl
        dec     b
        jr      l0f3a               ; (-12)

l0f46   inc     b
        scf
        ret
        ld      h,$00
        ld      l,b
        add     hl,de
        ld      a,(hl)
        ret

l0f4f   ld      hl,ed_flags
        or      a
        bit     0,(hl)
        ret     nz
        push    bc
        push    af
        call    l1182
        pop     af

l0f5c   call    l0577
        push    af
        ex      de,hl
        call    l16fe
        ex      de,hl
        pop     af
        ccf
        jr      z,l0f9a             ; (49)
        push    af
        ld      b,$00
        inc     c
        ld      a,(ed_N_ROWS)
        cp      c
        jr      c,l0f96             ; (35)
        ld      a,(hl)
        ld      e,a
        and     $d7
        cp      (hl)
        ld      (hl),a
        ld      a,e
        set     1,(hl)
        push    af
        call    l1182
        pop     af
        jr      z,l0f90             ; (13)
        res     0,a
        call    l0fa1
        jr      nc,l0f9a            ; (16)
        call    l16ee
        pop     af
        jr      l0f5c               ; (-52)

l0f90   call    l0f0f
        pop     af
        jr      l0f5c               ; (-58)

l0f96   pop     af
        call    l123c

l0f9a   pop     bc
        ret

l0f9c   call    l1182
        ld      a,$09

l0fa1   push    bc
        push    de
        ld      b,c
        ld      hl,l0fbd
        ld      c,a
        push    bc
        call    l0540
        pop     bc
        ld      a,c
        jr      nc,l0fba            ; (10)
        ld      c,b
        call    l1182
        ld      hl,$0020
        add     hl,de
        ld      (hl),a
        scf

l0fba   pop     de
        pop     bc
        ret

l0fbd   defs    $20

        add     hl,bc

        defs    2

l0fe0   push    bc
        call    l1182
        push    bc

l0fe5   ld      hl,$0020
        add     hl,de
        bit     1,(hl)
        ld      a,$00
        jr      z,l0fff             ; (16)
        inc     c
        ld      hl,$0023
        add     hl,de
        ex      de,hl
        ld      a,(ed_N_ROWS)
        cp      c
        jr      nc,l0fe5            ; (-22)
        dec     c
        call    l1297

l0fff   pop     hl

l1000   push    hl
        call    l1182
        pop     hl
        ld      b,a
        ld      a,c
        cp      l
        ld      a,b
        push    af
        jr      nz,l100f            ; (3)
        ld      b,h
        jr      l1018               ; (9)

l100f   push    af
        push    hl
        ld      b,$00
        call    l0f0f
        pop     hl
        pop     af

l1018   push    hl
        ld      hl,$f6f4
        set     0,(hl)
        jr      z,l1022             ; (2)
        res     0,(hl)

l1022   call    l058c
        push    af
        push    bc
        push    de
l1028   ld      hl,$f6f4
        bit     0,(hl)
        jr      nz,l103d            ; (14)
        ld      b,$00
        call    l0c9f
        jr      c,l103d             ; (7)
        call    l104e
        pop     de
        pop     bc
        jr      l1042               ; (5)

l103d   pop     hl
        pop     bc
l103f   call    l16fe

l1042   pop     af
        dec     c

l1044   ld      b,a
        pop     hl
        pop     af
        ld      a,b
        jp      nz,l1000
        scf
        pop     bc
        ret

l104e   ld      hl,$0020
        add     hl,de
        ld      a,(hl)
        bit     0,(hl)
        jr      nz,l1080            ; (41)
        push    af
        push    bc
        ld      a,c
        or      a
        jr      nz,l1072            ; (21)
        push    bc
        ld      hl,($fc9a)
        call    l1418
        ld      ($fc9a),hl
        ld      a,(nr_above)
        ld      c,a
        dec     c
        call    l1385
        pop     bc
        jr      l1076               ; (4)

l1072   dec     c
        call    l1182

l1076   pop     bc
        pop     af
        ld      hl,$0020
        add     hl,de
        res     1,(hl)
        or      (hl)
        ld      (hl),a

l1080   ld      b,c
        call    l1182
        call    l11ad
        jp      l0513


; Editing keys: DELETE WORD LEFT

l108a   call    l1152
l108d   push    hl
        call    l1163
        jr      z,l10c5             ; (50)
        call    l0c26
        pop     hl
        jr      nc,l10c6            ; (45)
        call    l0ae5
        push    af
        push    hl
        call    l0fe0
        pop     hl
        pop     af
        cp      $20
        jr      z,l108d             ; (-26)

l10a7   push    hl
        call    l1163
        jr      z,l10c5             ; (24)
        call    l0c26
        pop     hl
        jr      nc,l10c6            ; (19)
        call    l0ae5
        cp      $20
        jr      z,l10c1             ; (7)
        push    hl
        call    l0fe0
        pop     hl
        jr      l10a7               ; (-26)

l10c1   push    hl
        call    l0c43

l10c5   pop     hl

l10c6   ld      a,b
        push    af
        push    hl
        ld      hl,$eef5
        res     2,(hl)
        ld      a,(ed_N_ROWS)
        push    bc
        ld      b,$00
        ld      c,a
        cp      a
        call    l04d0
        pop     bc
        ld      hl,ed_flags
        set     3,(hl)
        pop     hl
        call    l0ac3
        pop     af
        ret


; Editing keys: DELETE WORD RIGHT

l10e5   call    l1152
l10e8   push    hl
        call    l0ae5
        pop     hl
        cp      $00
        scf
        jr      z,l10c6             ; (-44)
        push    af
        push    hl
        call    l0fe0
        pop     hl
        pop     af
        cp      $20
        jr      nz,l10e8            ; (-21)

l10fd   call    l0ae5
        cp      $20
        scf
        jr      nz,l10c6            ; (-63)
        push    hl
        call    l0fe0
        pop     hl
        jr      l10fd               ; (-15)


; Editing keys: DELETE LINE LEFT

l110c   call    l1152
l110f   push    hl
        call    l1182
        ld      hl,$0020
        add     hl,de
        bit     0,(hl)
        jr      nz,l1127            ; (12)
        call    l0c26
        jr      nc,l113b            ; (27)
        call    l0fe0
        pop     hl
        jr      l110f               ; (-23)
        push    hl

l1127   ld      a,b
        cp      $00
        jr      z,l113b             ; (15)
        dec     b
        call    l0ae5
        inc     b
        cp      $00
        jr      z,l113b             ; (6)
        dec     b
        call    l0fe0
        jr      l1127               ; (-20)

l113b   pop     hl

l113c   scf
        jp      l10c6


; Editing keys: DELETE LINE RIGHT

l1140   call    l1152
l1143   call    l0ae5
        cp      $00
        scf
        jr      z,l113c             ; (-15)
        push    hl
        call    l0fe0
        pop     hl
        jr      l1143               ; (-15)

l1152   ld      hl,ed_flags
        res     0,(hl)
        call    l0ab7
        ld      hl,$eef5
        set     2,(hl)
        ld      hl,$f6f1
        ret

l1163   call    l1182
        ld      hl,$0020
        add     hl,de
        bit     0,(hl)
        jr      z,l117c             ; (14)
        ld      a,b
        cp      $00
        jr      z,l1180             ; (13)
        dec     b
        call    l0ae5
        inc     b
        cp      $00
        jr      z,l1180             ; (4)

l117c   ld      a,$01
        or      a
        ret

l1180   xor     a
        ret

l1182   ld      hl,$ec16

l1185   push    af
        ld      a,c
        ld      de,$0023

l118a   or      a
        jr      z,l1191             ; (4)
        add     hl,de
        dec     a
        jr      l118a               ; (-7)

l1191   ex      de,hl
        pop     af
        ret
        push    de
        call    l1182
        ld      h,$00
        ld      l,b
        add     hl,de
        pop     de
        ret


l119e   defb    $05
        defb    $00,$00,$00,$f8,$f6

; Subroutine to ???

l11a4   ld      hl,l119e
        ld      de,row_below
        jp      l2152

; Subroutine to ???

l11ad   push    bc
        push    de
        ld      hl,row_below    ; ???
        push    hl
        ld      a,(hl)
        or      a
        jr      nz,l11cf        ; move on if ???
        push    hl
        call    l142d           ; setup token routines in RAM
        ld      hl,($f9d7)
        call    l1420           ; get line number after ???
        jr      nc,l11c6        ; move on if none
        ld      ($f9d7),hl      ; store it
l11c6   ld      b,h
        ld      c,l
        pop     hl
        call    l13a4           ; ???
        dec     a
        jr      l11e4
l11cf   ld      hl,ed_flags
        res     0,(hl)
        ld      hl,$f6f8
        ld      d,h
        ld      e,l
        ld      bc,$0023
        add     hl,bc
        ld      bc,$02bc
        ldir
        dec     a
        scf
l11e4   pop     de
        ld      (de),a
        ld      hl,$f6f8
        pop     de
        pop     bc
        ret


l11ec   push    bc
        push    de
        ld      hl,$0020
        add     hl,de
        ld      a,(hl)
        cpl
        and     $11
        jr      nz,l120d            ; (21)
        push    hl
        push    de
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      e,(hl)
        push    de
        call    l142d
        pop     hl
        call    l1418
        jr      nc,l120b            ; (3)
        ld      ($f9d7),hl

l120b   pop     de
        pop     hl

l120d   bit     0,(hl)
        ld      hl,row_below
        push    hl
        jr      z,l121a             ; (5)
        ld      a,$00
        scf
        jr      l11e4               ; (-54)

l121a   ld      a,(hl)
        cp      $14
        jr      z,l11e4             ; (-59)
        ld      bc,$0023
        ld      hl,$f6f8
        ex      de,hl
        ldir
        ld      hl,$f9d6
        ld      d,h
        ld      e,l
        ld      bc,$0023
        or      a
        sbc     hl,bc
        ld      bc,$02bc
        lddr
        inc     a
        scf
        jr      l11e4               ; (-88)

l123c   push    bc
        push    de
        push    af
        ld      b,$00
        ld      c,$01
        push    hl
        call    l1291
        pop     hl
        bit     3,(hl)
        res     3,(hl)
        jr      nz,l126e            ; (32)

l124e   call    l0f0f
        pop     af

l1252   call    l0577
        jr      z,l1288             ; (49)
        push    af
        ld      b,$00
        inc     c
        ld      a,c
        cp      $15
        jr      c,l126e             ; (14)
        dec     hl
        ld      a,(hl)
        inc     hl
        cp      $00
        jr      z,l126e             ; (7)
        push    hl
        ld      hl,ed_flags
        set     0,(hl)
        pop     hl

l126e   bit     1,(hl)
        set     1,(hl)
        res     3,(hl)
        call    l1291
        jr      nz,l124e            ; (-43)
        push    bc
        push    de
        call    l16e0           ; pad line at DE with nulls to length 32
        ld      (hl),$08
        pop     de
        pop     bc
        call    l16ee
        pop     af
        jr      l1252               ; (-54)

l1288   ld      a,c
        ld      (row_below),a
        set     3,(hl)
        pop     de
        pop     bc
        ret

l1291   ld      hl,$f6f8
        jp      l1185

l1297   push    bc
        push    de
        ld      hl,ed_flags
        res     0,(hl)
        ld      a,(row_below)
        ld      c,a
        or      a
        ld      a,$00
        jr      z,l12e9             ; (66)

l12a7   call    l1291
        push    af
        ld      b,$00
        call    l0f0f
        jr      nc,l12c0            ; (14)
        pop     af
        call    l058c
        push    af
        push    bc
        ld      b,$00
        call    l0f0f
        pop     bc
        jr      c,l12e4             ; (36)

l12c0   inc     hl
        ld      a,(hl)
        push    af
        push    bc
        ld      a,c
        cp      $01
        jr      nz,l12d2            ; (9)
        ld      a,(ed_N_ROWS)
        ld      c,a
        call    l1182
        jr      l12d6               ; (4)

l12d2   dec     c
        call    l1291

l12d6   pop     bc
        pop     af
        ld      hl,$0020
        add     hl,de
        res     1,(hl)
        or      (hl)
        ld      (hl),a
        ld      hl,row_below
        dec     (hl)

l12e4   pop     af
        dec     c
        jr      nz,l12a7            ; (-65)
        scf

l12e9   pop     de
        pop     bc
        ret

; ???

l12ec   defb    $03
        defb    $00,$de,$f9

; Subroutine to ???

l12f0   ld      hl,l12ec
        ld      de,nr_above
        jp      l2152

l12f9   push    bc
        push    de
        ld      hl,nr_above
        push    hl
        ld      a,(hl)
        or      a
        jr      nz,l1321            ; (30)
        push    hl
        call    l142d
        ld      hl,($fc9a)
        call    l1418
        jr      nc,l1312            ; (3)
        ld      ($fc9a),hl

l1312   ld      b,h
        ld      c,l
        pop     hl
        inc     hl
        inc     hl
        inc     hl
        jr      nc,l132b            ; (17)
        call    l13a4
        dec     a
        ex      de,hl
        jr      l132b               ; (10)

l1321   ld      hl,($f9dc)
        ld      bc,$0023
        sbc     hl,bc
        scf
        dec     a

l132b   ex      de,hl
        pop     hl
        jr      nc,l1330            ; (1)
        ld      (hl),a

l1330   inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d
        ex      de,hl
        pop     de
        pop     bc
        ret

l1338   push    bc
        push    de
        ld      hl,$0020
        add     hl,de
        ld      a,(hl)
        cpl
        and     $11
        jr      nz,l1350            ; (12)
        push    de
        push    hl
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      e,(hl)
        ld      ($fc9a),de
        pop     hl
        pop     de

l1350   bit     3,(hl)
        ld      hl,nr_above
        push    hl
        jr      z,l136e             ; (22)
        push    hl
        call    l142d
        ld      hl,($fc9a)
        call    l1420
        ld      ($fc9a),hl
        pop     hl
        inc     hl
        inc     hl
        inc     hl
        ld      a,$00
        scf
        jr      l132b               ; (-67)

l136e   ld      a,(hl)
        cp      $14
        jr      z,l1381             ; (14)
        inc     a
        ld      hl,($f9dc)
        ld      bc,$0023
        ex      de,hl
        ldir
        ex      de,hl
        scf
        jr      l132b               ; (-86)

l1381   pop     hl
        pop     de
        pop     bc
        ret

l1385   ld      hl,$f9de
        jp      l1185

; Table of routine addresses for printing chars in EDITOR

l138b   defb    $08
        defb    $0d
        defw    l16c6           ; ???
        defb    $01
        defw    l16d4           ; ???
        defb    $12
        defw    l1428           ; for colour codes, skip embedded code
        defb    $13
        defw    l1428
        defb    $14
        defw    l1428
        defb    $15
        defw    l1428
        defb    $10
        defw    l1428
        defb    $11
        defw    l1428

; Subroutine to ???

l13a4   ld      d,h
        ld      e,l
        inc     de
        inc     de
        inc     de
l13a9   push    de
        ld      hl,$0020
        add     hl,de
        ld      (hl),$01        ; store ???
        inc     hl
        ld      (hl),b
l13b2   inc     hl
        ld      (hl),c          ; store line number
        ld      c,$01           ; coloumn 1 ???
        ld      b,$00           ; character position on screen line
l13b8   push    bc
        push    de
        ld      a,(process)
        cp      $04
        call    nz,l1611        ; unless in calculator, get next line char
        pop     de
        pop     bc
        jr      c,l13d5         ; move on if found character
        ld      a,c
        cp      $01
        ld      a,$0d
        jr      nz,l13d5        ; do CR unless no chars output
        ld      a,b
        or      a
        ld      a,$01
        jr      z,l13d5         ; ???
        ld      a,$0d           ; CR
l13d5   ld      hl,l138b
        call    l2166           ; perform actions for special chars
        jr      c,l13fa         ; if successful action, move on
        jr      z,l13b8         ; loop back if need new char
        push    af
        ld      a,$1f
        cp      b
        jr      nc,l13f4        ; move on unless need to start new line
        ld      a,$12
        call    l13ff           ; ???
        jr      c,l13f1         ; ???
        pop     af
        ld      a,$0d
        jr      l13d5
l13f1   call    l16ee           ; ???
l13f4   pop     af
        call    l16bf           ; ???
        jr      l13b8
l13fa   pop     hl
        ld      a,c             ; ???
        ret     z
        scf
        ret

; Subroutine to ???

l13ff   push    af
        call    l16e0           ; pad line at DE to length 32 with nulls
        pop     af
        xor     (hl)            ; ??
        ld      (hl),a
        ld      a,c
        cp      $14
        ret     nc
        inc     c
        ld      hl,$0023
        add     hl,de
        ex      de,hl
        ld      hl,$0020
        add     hl,de
        ld      (hl),$00
        scf
        ret

; Subroutine to get number (HL) of line before HL (or 0 if none)

l1418   call    l15b0           ; find line number before HL
        ret     c               ; exit if found
        ld      hl,$0000        ; else use 0
        ret

; Subroutine to get number (HL) of line after HL (or 0 if none)

l1420   call    l152a           ; get line number after HL
        ret     c               ; exit if found
        ld      hl,$0000        ; else use 0
        ret

; Subroutine to skip an embedded colour code in a line

l1428   call    l1611           ; get next char (skip colour code)
        ccf
        ret     nc              ; exit if success, else set no data left

; Subroutine to setup token scanning/expanding routines

l142d   ld      hl,$0000
        ld      ($fc9f),hl      ; set "no line data"
        ld      ($fca1),hl      ; set "no expanded token"
        ld      hl,l1442
        ld      de,$fcae
        ld      bc,$00e8
        ldir                    ; copy token routines into RAM
        ret

; Routine executed in RAM at $fcae
; On entry, A=zero-based token number (code-$a5), and on exit $fca1
; contains address of expanded token

l1442   di
        push    af
        ld      bc,$7ffd
        ld      a,$17
        out     (c),a           ; page in ROM 1 & RAM 7
        ld      bc,$1ffd
        ld      a,(BANK678)
        set     2,a
        out     (c),a           ; page in ROM 3
        pop     af
        cp      $50
        jr      nc,l148b        ; these parts start off search at every
        cp      $40             ; 16th token for speed
        jr      nc,l1484
        cp      $30
        jr      nc,l147d
        cp      $20
        jr      nc,l1476
        cp      $10
        jr      nc,l146f
        ld      hl,$0096        ; RND in token table
        jr      l1490
l146f   sub     $10
        ld      hl,$00cf        ; ASN in token table
        jr      l1490
l1476   sub     $20
        ld      hl,$0100        ; OR in token table
        jr      l1490
l147d   sub     $30
        ld      hl,$013e        ; MERGE in token table
        jr      l1490
l1484   sub     $40
        ld      hl,$018b        ; RESTORE in token table
        jr      l1490
l148b   sub     $50
        ld      hl,$01d4        ; PRINT in token table
l1490   ld      b,a             ; B=offset of token from current
        or      a
l1492   jr      z,l149d
l1494   ld      a,(hl)          ; get next character
        inc     hl
        and     $80
        jr      z,l1494         ; loop back until end of token found
        dec     b               ; decrement token offset
        jr      l1492           ; loop back
l149d   ld      de,$fca3
        ld      ($fca1),de      ; set expanded token address
        ld      a,($fc9e)
        or      a               ; test "leading space" flag
        ld      a,$00
        ld      ($fc9e),a       ; and set to zero
        jr      nz,l14b3
        ld      a,' '
        ld      (de),a          ; insert space if necessary
        inc     de
l14b3   ld      a,(hl)
        ld      b,a
        inc     hl
        ld      (de),a          ; copy token byte
        inc     de
        and     $80
        jr      z,l14b3         ; back until end of token
        ld      a,b
        and     $7f
        dec     de
        ld      (de),a          ; mask off high bit in last char
        inc     de
        ld      a,' '+$80       ; and add terminating space
        ld      (de),a
        ld      bc,$7ffd
        ld      a,(BANKM)
        out     (c),a           ; restore original ROM/RAM configuration
        ld      bc,$1ffd
        ld      a,(BANK678)
        out     (c),a
        ei
        ret

; Routine executed in RAM at $fd43
; On entry, bit-7 terminated word to check for is at $fda0
; On exit, if carry set, A=token code, else A=0

l14d7   di
        push    af
        ld      bc,$7ffd
        ld      a,$17
        out     (c),a           ; page in ROM 1 & RAM 7
        ld      bc,$1ffd
        ld      a,(BANK678)
        set     2,a
        out     (c),a           ; page in ROM 3
        pop     af
        ld      hl,$0096        ; token table start
        ld      b,$a5           ; first token number
l14f0   ld      de,$fda0        ; start of word to test
l14f3   ld      a,(de)          ; get next letter of word to test
        and     $7f
        cp      $61
        ld      a,(de)
        jr      c,l14fd
        and     $df             ; mask lowercase letters to uppercase
l14fd   cp      (hl)            ; test against current token letter
        jr      nz,l1509        ; move on if no match
        inc     hl
        inc     de
        and     $80
        jr      z,l14f3         ; loop back unless last token character
        scf                     ; success
        jr      l1515
l1509   inc     b               ; increment token number
        jr      z,l1514         ; exit if all checked
l150c   ld      a,(hl)
        and     $80
        inc     hl
        jr      z,l150c         ; loop back until current token finished
        jr      l14f0           ; back to check more tokens
l1514   or      a               ; failure
l1515   ld      a,b
        ld      d,a
        ld      bc,$7ffd
        ld      a,(BANKM)
        out     (c),a           ; page back original ROM/RAM configuration
        ld      bc,$1ffd
        ld      a,(BANK678)
        out     (c),a
        ld      a,d             ; A=token number
        ei
        ret

; Subroutine to form ASCII line number for next line after HL. Exits
; with DE=address of line data & HL=line number

l152a   call    l15e4           ; set "no line" addresses
        or      a
        ld      ($fc9e),a       ; set "leading spaces"
        call    l05a7           ; page in normal memory
        call    l15f0           ; get address of line HL
        jr      nc,l158b        ; exit if not found
        jr      nz,l1547
        ld      a,b
        or      c
        jr      z,l1547         ; move on if first line was required
        call    l15c9           ; get address of next line
        call    l15d3
        jr      nc,l158b        ; exit if end of program

; Subroutine to form ASCII line number for line at HL.
; Exits with HL=line number, DE=address of line data

l1547   ld      d,(hl)
        inc     hl
        ld      e,(hl)          ; get line number
        call    l05cc           ; page in DOS workspace
        push    de
        push    hl
        push    ix
        ld      ix,$fca3
        ld      ($fca1),ix      ; set ASCII line number address
        ex      de,hl
        ld      b,$00           ; don't form leading zeros
        ld      de,$fc18
        call    l158f           ; form 1000s
        ld      de,$ff9c
        call    l158f           ; form 100s
        ld      de,$fff6
        call    l158f           ; form 10s
        ld      de,$ffff
        call    l158f           ; form units
        dec     ix
        ld      a,(ix+$00)
        or      $80             ; set bit 7 of last digit
        ld      (ix+$00),a
        pop     ix
        pop     hl
        pop     de
        inc     hl
        inc     hl
        inc     hl              ; HL=address of line data
        ld      ($fc9f),hl      ; save it
        ex      de,hl
        scf                     ; success
        ret
l158b   call    l05cc           ; page in DOS workspace
        ret                     ; exit

; Subroutine to form next digit of line number at IX
; Line number in HL, unit size in DE, and print zero flag in B

l158f   xor     a               ; count 0
l1590   add     hl,de           ; reduce line number by unit size
        inc     a               ; increment count
        jr      c,l1590         ; loop until overflow
        sbc     hl,de           ; add back last try
        dec     a
        add     a,'0'           ; form ASCII digit
        ld      (ix+$00),a      ; store it
        cp      '0'
        jr      nz,l15ab        ; set flag if not zero
        ld      a,b
        or      a
        jr      nz,l15ad        ; if flag set, leave 0 digits
        ld      a,$00
        ld      (ix+$00),a      ; else replace with $00
        jr      l15ad
l15ab   ld      b,$01           ; set "print 0 digits" flag
l15ad   inc     ix              ; increment pointer
        ret

; Subroutine to get number (HL) and address (DE) of line before line HL
; forming ASCII line number in page 7. Carry reset if no prior line.

l15b0   call    l15e4           ; initialise "no line" addresses
        or      a
        ld      ($fc9e),a       ; ???
        call    l05a7           ; page in normal memory
        call    l15f0           ; find address of line HL
        jr      nc,l158b        ; if not found, exit with error
        ex      de,hl
        ld      a,l
        or      h               ; was there a previous line?
        scf
        jp      nz,l1547        ; form line number & address of data if so
        ccf
        jr      l158b           ; else exit with error

; Subroutine to get address of next program line in HL (current is
; saved in DE)

l15c9   push    hl
        inc     hl
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=line length
        inc     hl
        add     hl,de           ; HL=next line
        pop     de              ; DE=previous line
        ret

; Subroutine to check for end of program (carry reset if so)

l15d3   ld      a,(hl)          ; check next program byte
        and     $c0
        scf
        ret     z               ; exit with carry set if not end-of-program
        ccf                     ; clear carry if end-of-program
        ret

; Subroutine to check if line number at HL is equal to BC (carry set if so)

l15da   ld      a,b
        cp      (hl)
        ret     nz
        ld      a,c
        inc     hl
        cp      (hl)
        dec     hl
        ret     nz
        scf
        ret

; Subroutine to set "no line" addresses

l15e4   push    hl
        ld      hl,$0000
        ld      ($fca1),hl      ; set "no ASCII line number"
        ld      ($fc9f),hl      ; set "no line data"
        pop     hl
        ret

; Subroutine to search for address of line HL, returning in HL with
; carry set. If HL=0 first line address is returned. Carry reset if
; line not found. DE=address of previous line (or 0)

l15f0   push    hl
        pop     bc              ; BC=line to find
        ld      de,$0000        ; no previous line
        ld      hl,(PROG)       ; get start of program
        call    l15d3           ; check if end
      IF garry
        jp      l3871
l15fe   ld      hl, (CURCHL)
l1601   jp      l387f
      ELSE
        ret     nc              ; exit if so with failure
        call    l15da           ; is it line BC
        ret     c               ; exit if so with success
        ld      a,b
l1601   or      c
        scf
        ret     z               ; exit with first line if line 0 specified
      ENDIF
l1604   call    l15c9           ; get to next line
        call    l15d3
        ret     nc              ; exit if program end
        call    l15da
        jr      nc,l1604        ; loop back if not line BC yet
        ret

; Subroutine to get next character (A) from line. Carry reset if none left

l1611   ld      hl,($fca1)      ; get address of ASCII text
        ld      a,l
        or      h
        jr      z,l1636         ; move on if none
        ld      a,(hl)
        inc     hl
        cp      $a0             ; test for terminating space
        ld      b,a
        ld      a,$00           ; set "print leading space" if none
        jr      nz,l1623
        ld      a,$ff           ; else suppress
l1623   ld      ($fc9e),a       ; set flag
        ld      a,b
        bit     7,a
        jr      z,l162e
        ld      hl,$0000        ; if last character, set "no text left"
l162e   ld      ($fca1),hl      ; update address
        and     $7f             ; mask high bit
        jp      l1689           ; exit with success
l1636   ld      hl,($fc9f)      ; get address of line data
        ld      a,l
        or      h
        jp      z,l168b         ; exit with fail if none
        call    l05a7           ; page in normal memory
l1641   ld      a,(hl)
        cp      $0e             ; check for embedded number
        jr      nz,l164e
        inc     hl              ; if found, skip & loop back
        inc     hl
        inc     hl
        inc     hl
        inc     hl
        inc     hl
        jr      l1641
l164e   call    l05cc           ; page in DOS workspace
        inc     hl
        ld      ($fc9f),hl      ; update address
        cp      $a5
        jr      c,l1661         ; move on unless 48K BASIC token
        sub     $a5             ; get token number (0+)
        call    $fcae           ; expand to ASCII text
        jp      l1611           ; go to get first char
l1661   cp      $a3
        jr      c,l1675         ; move on unless +3 BASIC token
        jr      nz,l166c
        ld      hl,l168e        ; SPECTRUM token
        jr      l166f
l166c   ld      hl,l1696        ; PLAY token
l166f   call    $fd09           ; expand to ASCII text
        jp      l1611           ; go to get first char
l1675   push    af
        ld      a,$00
        ld      ($fc9e),a       ; flag "print leading space"
        pop     af
        cp      $0d
        jr      nz,l1689        ; exit with success unless end of line
        ld      hl,$0000
        ld      ($fca1),hl      ; set no ASCII text
        ld      ($fc9f),hl      ; and no line data
l1689   scf                     ; success
        ret
l168b   scf
        ccf                     ; fail
        ret

l168e   defm    "SPECTRU", 'M'+$80
l1696   defm    "PLA", 'Y'+$80
        defm    "GOT", 'O'+$80
        defm    "GOSU", 'B'+$80
        defm    "DEFF", 'N'+$80
        defm    "OPEN", '#'+$80
        defm    "CLOSE", '#'+$80




l16b3   defb    $02
        defb    $01
        defb    $05

l16b6   ld      hl,l16b3
        ld      de,$fd96
        jp      l2152



; Subroutine to ???

l16bf   ld      l,b
        ld      h,$00
        add     hl,de
        ld      (hl),a
        inc     b
        ret
l16c6   call    l16e0           ; pad line at DE to length 32 with nulls
        ld      a,(hl)
        or      $18
        ld      (hl),a
        ld      hl,$fd96
        set     0,(hl)
        scf
        ret
l16d4   call    l16e0           ; pad line at DE to length 32 with nulls
        set     3,(hl)
        ld      hl,$fd96
        set     0,(hl)
        scf
        ret

; Subroutine to pad line at DE (length B) with nulls to length B=32
; On exit, HL=end of line+1

l16e0   ld      l,b
        ld      h,0
        add     hl,de           ; get past last char on line
        ld      a,$20
l16e6   cp      b
        ret     z               ; exit if 32 chars already
        ld      (hl),0          ; pad with zeros
        inc     hl
        inc     b
        jr      l16e6


l16ee   ld      a,($fd97)
        ld      b,$00

l16f3   ld      h,$00
        ld      l,b
        add     hl,de
        ld      (hl),$00
        inc     b
        dec     a
        jr      nz,l16f3            ; (-10)
        ret

l16fe   push    bc
        push    de
        push    hl
        push    hl
        ld      hl,$eef5
        bit     2,(hl)
        pop     hl
        jr      nz,l170e            ; (4)
        ld      b,c
        call    l1d2b

l170e   pop     hl
        pop     de
        pop     bc
        ret

l1712   push    bc
        push    de
        push    hl
        push    hl
        ld      hl,$eef5
        bit     2,(hl)
        pop     hl
        jr      nz,l1722            ; (4)
        ld      e,c
        call    l1ccc

l1722   pop     hl
        pop     de
        pop     bc
        ret

l1726   push    bc
        push    de
        push    hl
        push    hl
        ld      hl,$eef5
        bit     2,(hl)
        pop     hl
        jr      nz,l1736            ; (4)
        ld      e,c
        call    l1cd3

l1736   pop     hl
        pop     de
        pop     bc
        ret

; Subroutine to place cursor at column B, line C (of editing area)

l173a   push    af
        push    bc
        push    de
        push    hl
        ld      a,b
        ld      b,c             ; B=line of editing area
        ld      c,a             ; C=column
        call    l1caa
        pop     hl
        pop     de
        pop     bc
        pop     af
        ret

; Subroutine to remove cursor from column B, line C (of editing area)

l1749   push    af
        push    bc
        push    de
        push    hl
        ld      a,b
        ld      b,c
        ld      c,a
        call    l1cbf
        pop     hl
        pop     de
        pop     bc
        pop     af
        ret

l1758   ld      a,$00
        ld      (MODE),a
        ld      a,$02
        ld      (REPPER),a
        call    l185a
        ret

      IF 1
        defb    $74, $DF, $DE, $55, $10, $52, $C9, $9E
        defb    $9E, $BD, $62, $C5, $C0, $55, $C2, $44
        defb    $10, $17, $FE, $5F, $90, $FE, $D1, $DD
        defb    $D5, $17, $90, $F7, $DF, $DF, $D4, $C7
        defb    $D9, $DE, $C3, $BD, $F3, $DC, $59, $D6
        defb    $56, $10, $17, $64, $47, $5F, $90, $60
        defb    $DF, $40, $43, $97, $10, $FC, $51, $C7
        defb    $43, $5F, $DE, $BD, $66, $D9, $5B, $90
        defb    $17, $E2, $D5, $54, $10, $F8, $55, $42
        defb    $42, $59, $DE, $57, $17, $90, $7F, $5C
        defb    $5C, $D9, $C6, $55, $C2, $90, $51, $DE
        defb    $BD, $E4, $D8, $D5, $90, $74, $5F, $C2
        defb    $5B, $59, $5E, $D7, $90, $7D, $5F, $D2
        defb    $BD, $64, $58, $D1, $5E, $DB, $C3, $10
        defb    $C4, $5F, $1E, $1E, $BD, $64, $D8, $D5
        defb    $10, $F2, $42, $D5, $47, $D5, $42, $C9
        defb    $90, $E4, $D1, $C0, $90, $18, $58, $D9
        defb    $D3, $19, $BD, $E2, $5F, $DC, $51, $DE
        defb    $54, $1C, $90, $62, $D9, $D3, $58, $51
        defb    $C2, $54, $90, $55, $44, $90, $D1, $5C
        defb    $BD, $51, $5E, $54, $90, $F9, $C6, $DF
        defb    $42, $10, $98, $C7, $D8, $49, $10, $DE
        defb    $5F, $C4, $19, $BD, $67, $42, $D9, $44
        defb    $C4, $D5, $5E, $90, $DF, $5E, $90, $60
        defb    $F3, $67, $90, $88, $05, $81, $02, $43
        defb    $1C, $10, $45, $43, $D9, $5E, $BD, $FD
        defb    $08, $00, $90, $51, $DE, $D4, $10, $FC
        defb    $08, $00, $10, $45, $5E, $D4, $55, $C2
        defb    $10, $F3, $60, $9F, $FD, $9B, $BD, $BD
        defb    $C3, $90, $C4, $DF, $1E, $9E, $BD, $64
        defb    $D8, $55, $10, $BD
      ELSE
        defs    244
      ENDIF

l185a   ld      hl,FLAGS
        ld      a,(hl)
        or      $0c
        ld      (hl),a
        ld      hl,ed_flags
        bit     4,(hl)
        ld      hl,FLAGS3
        jr      nz,l186e
        res     0,(hl)
        ret
l186e   set     0,(hl)
        ret


; Subroutine to get a key - this may include keypad keys which
; send extended mode before a keycode to give a token

l1871   push    hl              ; save HL
l1872   ld      hl,FLAGS
l1875   bit     5,(hl)
        jr      z,l1875         ; loop until a key is available
        res     5,(hl)          ; signal no key available
        ld      a,(LAST_K)      ; get key
        ld      hl,MODE
        res     0,(hl)          ; set "L" mode (?)
        cp      $20
        jr      nc,l1894        ; move on if not a control code
l1887   cp      $10
        jr      nc,l1872        ; loop back to ignore control codes>=$10
        cp      $06
        jr      c,l1872         ; ignore control codes<$06
        call    l1896           ; change mode if required
        jr      nc,l1872
l1894   pop     hl              ; restore HL
        ret
l1896   ROM3    o10DB           ; call key mode change routine
        ret

; Subroutine to display a menu
; On entry HL=address of menu

l189a   push    hl
        call    l194d           ; save menu window area of screen
        ld      hl,TV_FLAG
        res     0,(hl)          ; signal "using main screen"
        pop     hl
        ld      e,(hl)          ; E=number of menu lines
        inc     hl
        push    hl
        ld      hl,l19fe
        call    l1925           ; output control codes for top menu line
        pop     hl
        call    l1925           ; output menu title
        push    hl
        call    l1a34           ; output rainbow
        ld      hl,l1a0c
        call    l1925           ; output end of top menu line
        pop     hl
        push    de
        ld      bc,$0807
        call    l191d           ; output 'AT 8,7'
l18c3   push    bc              ; save screen position
        ld      b,$0c           ; B=menu width 12 (+2 border)
        ld      a,' '
        rst     $10             ; output border space
l18c9   ld      a,(hl)          ; get next char
        inc     hl
        cp      $80
        jr      nc,l18d2        ; move on if last char on menu line
        rst     $10             ; else output
        djnz    l18c9           ; & loop back for more
l18d2   and     $7f             ; mask off end marker bit
        rst     $10             ; output last character
l18d5   ld      a,$20
        rst     $10             ; output spaces for rest of menu width
        djnz    l18d5
        pop     bc
        inc     b               ; get to next line
        call    l191d           ; output AT command
        dec     e
        jr      nz,l18c3        ; loop back for more lines
        ld      hl,$6f38        ; HL=pixel coords for top left of menu
        pop     de              ; E=total number of menu lines
        sla     e
        sla     e
        sla     e
        ld      d,e
        dec     d               ; D=menu height in pixel lines-1
        ld      e,$6f           ; E=menu width in pixel lines-1
        ld      bc,$ff00
        ld      a,d
        call    l190b           ; draw line top to bottom
        ld      bc,$0001
        ld      a,e
        call    l190b           ; draw line left to right
        ld      bc,$0100
        ld      a,d
        inc     a
        call    l190b           ; draw line bottom to top
        xor     a
        call    l19dc           ; put highlight on top line
        ret

; Subroutine to draw a line, used in menu display
; On entry, H=Y coord, L=X coord, A=line length, BC=amount to
; add to HL to get to next pixel

l190b   push    af              ; save registers
        push    hl
        push    de
        push    bc
        ld      b,h
        ld      c,l
        ROM3    o22E9           ; plot a pixel
        pop     bc              ; restore registers
        pop     de
        pop     hl
        pop     af
        add     hl,bc           ; get coords of next pixel
        dec     a
        jr      nz,l190b        ; back for rest of line
        ret

; Subroutine to output 'AT b,c'

l191d   ld      a,$16
        rst     $10
        ld      a,b
        rst     $10
        ld      a,c
        rst     $10
        ret

; Subroutine to output a $ff-terminated message (used in menus)
; If '+3' is encountered and a disk interface is not present, '+2e'
; is substituted

l1925   ld      a,(hl)          ; get next character
        inc     hl
        cp      $ff
        ret     z               ; exit if end-of-message marker
        cp      '+'
        jr      z,l1931         ; move on to check '+'
l192e   rst     $10             ; else output and loop back for more
        jr      l1925
l1931   ld      a,(hl)
        cp      '3'             ; check for '+3' string
        ld      a,$2b           ; reload with '+'
        jr      nz,l192e        ; go back to output if not '+3'
        push    hl
        ld      hl,FLAGS3
        bit     4,(hl)
        pop     hl
        jr      nz,l192e        ; go back to output if disk interface present
        inc     hl
        inc     hl              ; skip '+3 '
        ld      a,'+'           ; and output '+2A' instead
        rst     $10
        ld      a,'2'
        rst     $10
      IF garry
        ld      a, 'e'
      ELSE
        ld      a,'A'
      ENDIF
        jr      l192e           ; back

; This routine has a dual purpose: to either copy a "window" area to the
; screen, or to save a "window" area in high memory (of page 7)
; The window area is of fixed size 12 lines x 14 chars, located at
; 7,7
; Enter at l194d to copy the area FROM the screen, or at l1950 to copy
; the area TO the screen
; A total of:  21 (system variables)
;            + 12x14x8 (bitmap)
;            + 12x14 (attributes)
;            = 1533 bytes are saved, at $eef6 to $f4f2

l194d   scf                     ; set carry (copying FROM screen)
        jr      l1951
l1950   and     a               ; reset carry (copying TO screen)
l1951   ld      de,$eef6        ; DE contains window save area in page 7
        ld      hl,TV_FLAG
        jr      c,l195a
        ex      de,hl           ; swap source & dest if necessary
l195a   ldi                     ; copy TV_FLAG system variable
        jr      c,l195f
        ex      de,hl           ; swap back
l195f   ld      hl,COORDS
        jr      c,l1965         ; swap source & dest
        ex      de,hl
l1965   ld      bc,$0014
        ldir                    ; copy COORDS to ATTR_T system variables
        jr      c,l196d
        ex      de,hl           ; swap back
l196d   ex      af,af'          ; save carry flag
        ld      bc,$0707        ; Top left of window is 7,7
        call    l1da1           ; get C=33-C and B=24-B-(IX+1)
        ld      a,(ix+$01)
        add     a,b
        ld      b,a             ; correct B to 24-B
        ld      a,$0c           ; for 12 character lines
l197b   push    bc              ; save registers
        push    af
        push    de
        ROM3    o0E9B           ; get HL=address of line B in display file
        ld      bc,$0007
        add     hl,bc           ; HL=address of left of window line
        pop     de              ; restore save area in page 7
        call    l1990           ; copy a character line (width 14)
        pop     af              ; restore registers
        pop     bc
        dec     b               ; move to next character line
        dec     a
        jr      nz,l197b        ; loop back for more lines
        ret

; Subroutine used by menu window transfer routine, to transfer a single
; character line (width 14)
; On entry, HL=screen address of top pixel line
;           DE=address of save area
;           Carry'=save/restore flag

l1990   ld      bc,$080e        ; B=8 pixel lines,C=14 bytes window width
l1993   push    bc              ; save counters
        ld      b,$00           ; BC=bytes to copy
        push    hl              ; save screen address
        ex      af,af'          ; get carry flag
        jr      c,l199b
        ex      de,hl           ; swap source & dest if necessary
l199b   ldir                    ; copy pixel line
        jr      c,l19a0
        ex      de,hl           ; swap back
l19a0   ex      af,af'          ; save carry flag
        pop     hl              ; restore screen address
        inc     h               ; get to next pixel line
        pop     bc              ; restore counts
        djnz    l1993           ; back for more pixel lines
        push    bc
        push    de
        ROM3    o0E88
        ex      de,hl           ; HL=attributes address
        pop     de
        pop     bc
        ex      af,af'          ; get carry flag
        jr      c,l19b2
        ex      de,hl           ; swap source & dest if necessary
l19b2   ldir                    ; copy attributes
        jr      c,l19b7
        ex      de,hl           ; swap back
l19b7   ex      af,af'          ; save carry flag
        ret

; Move menu highlight up a line
; On entry, A=current highlight line number, HL=address of menu size

l19b9   call    l19dc           ; remove current highlight
        dec     a               ; decrement line number
        jp      p,l19c3         ; move on if still positive
        ld      a,(hl)          ; else set to bottom line
        dec     a
        dec     a
l19c3   call    l19dc           ; replace highlight on new line
        scf                     ; set carry, so calling routine doesn't
        ret                     ;  immediately call "move highlight down"

; Move menu highlight down a line
; On entry, A=current highlight line number, HL=address of menu size

l19c8   push    de              ; save DE
        call    l19dc           ; remove current highlight
        inc     a               ; increment line number
        ld      d,a
        ld      a,(hl)
        dec     a
        dec     a
        cp      d               ; check against max line number
        ld      a,d
        jp      p,l19d7
        xor     a               ; set to 0 if too large
l19d7   call    l19dc           ; replace highlight on new line
        pop     de              ; restore DE
        ret

; Subroutine to switch menu line A (0=top) between highlighted and
; non-highlighted

l19dc   push    af              ; save registers
        push    hl
        push    de
        ld      hl,$5907        ; attribute address of top menu line
        ld      de,$0020
        and     a
        jr      z,l19ec
l19e8   add     hl,de           ; get to attribute address of required line
        dec     a
        jr      nz,l19e8
l19ec   ld      a,$78
        cp      (hl)            ; is it BRIGHT 1, PAPER 7, INK 0?
        jr      nz,l19f3        ; if not, change to this
        ld      a,$68           ; if so, change to BRIGHT 1, PAPER 5, INK 0
l19f3   ld      d,$0e           ; 14 characters to do
l19f5   ld      (hl),a          ; change attributes
        inc     hl
        dec     d
        jr      nz,l19f5
        pop     de              ; restore registers
        pop     hl
        pop     af
        ret

; Control codes for top line of menus

l19fe   defb    $16,$07,$07     ; AT 7,7
        defb    $15,$00,$14,$00 ; OVER 0,INVERSE 0
        defb    $10,$07,$11,$00 ; INK 7,PAPER 0
        defb    $13,$01         ; BRIGHT 1
        defb    $ff

; Control codes for end of top line of menus

l1a0c   defb    $11,$00         ; PAPER 0
        defb    ' '
        defb    $11,$07         ; PAPER 7
        defb    $10,$00         ; INK 0
        defb    $ff

; A two-character "character set" used for displaying the
; rainbow on menus and bars

l1a14   defb    $01,$03,$07,$0f
        defb    $1f,$3f,$7f,$ff
        defb    $fe,$fc,$f8,$f0
        defb    $e0,$c0,$80,$00

; The rainbow string

l1a24   defb    $10,$02,' '
        defb    $11,$06,'!'
        defb    $10,$04,' '
        defb    $11,$05,'!'
        defb    $10,$00,' '
        defb    $ff

; Subroutine to output the "rainbow" on menus and bars

l1a34   push    bc              ; save registers
        push    de
        push    hl
        ld      hl,l1a14
        ld      de,STRIP1
        ld      bc,$0010
        ldir                    ; copy rainbow charset into RAM
        ld      hl,(CHARS)
        push    hl              ; save CHARS
        ld      hl,STRIP1-$0100
        ld      (CHARS),hl      ; set to rainbow set
        ld      hl,l1a24
        call    l1925           ; output rainbow
        pop     hl
        ld      (CHARS),hl      ; restore CHARS
        pop     hl              ; restore registers
        pop     de
        pop     bc
        ret

; Subroutines to display the bars for various functions

l1a5a   ld      hl,l080f        ; +3 BASIC
        jr      l1a67

l1a5f   ld      hl,l0817        ; Calculator
        jr      l1a67

l1a64   ld      hl,l0809        ; Loader


; Subroutine to clear the bottom 3 lines to editor colours, and display
; a bar with a rainbow and the text at HL (bit 7-terminated) on line 21

l1a67   push    hl
        call    l1a8e           ; clear bottom 3 lines to editor colours
        ld      hl,$5aa0        ; attribute address of line 21
        ld      b,$20
        ld      a,$40
l1a72   ld      (hl),a          ; fill line 21 to BRIGHT 1, PAPER 0, INK 0
        inc     hl
        djnz    l1a72
        ld      hl,l19fe
        call    l1925           ; output control codes for top menu lines
        ld      bc,$1500
        call    l191d           ; output AT 21,0
        pop     de
        call    l029e           ; ouput the bar text
        ld      c,$1a           ; output AT 21,26
        call    l191d
        jp      l1a34           ; output the rainbow

; Subroutine to clear bottom 3 lines to editor colours

l1a8e   ld      b,$15
        ld      d,$17
l1a92   jp      l1d6b           ; clear bottom 3 lines to editor colours


; The renumber routine

l1a95   call    l05a7           ; page in normal memory
        call    l1c12           ; get number of lines in BASIC program
        ld      a,d
        or      e
        jp      z,l1bcd         ; if none, signal "command failed" & exit
        ld      hl,(RC_STEP)
        ROM3    o30A9           ; HL=STEP*number of lines
        ex      de,hl           ; DE=STEP*number of lines
        ld      hl,(RC_START)
        add     hl,de           ; HL=projected last line number
        ld      de,$2710
        or      a
        sbc     hl,de
        jp      nc,l1bcd        ; if >9999, signal "command failed" & exit
        ld      hl,(PROG)       ; get start of program
l1ab7   ROM3    o19B8           ; get address of next line
        inc     hl
        inc     hl
        ld      (RC_LINE),hl    ; store address of current line (after number)
        inc     hl
        inc     hl              ; point after line length
        ld      (STRIP2+$11),de ; store address of next line
l1ac5   ld      a,(hl)          ; get next character
        ROM3    o18B6           ; skip past embedded number if necessary
        cp      $0d
        jr      z,l1ad2         ; move on if end of line
        call    l1b1b           ; replace any line number in this command
        jr      l1ac5           ; loop back
l1ad2   ld      de,(STRIP2+$11) ; get address of next line
        ld      hl,(VARS)
        and     a
        sbc     hl,de
        ex      de,hl
        jr      nz,l1ab7        ; loop back if not end of program
        call    l1c12
        ld      b,d
        ld      c,e             ; BC=number of lines in program
        ld      de,$0000
        ld      hl,(PROG)       ; HL=address of first line
l1aea   push    bc              ; save registers
        push    de
        push    hl
        ld      hl,(RC_STEP)
        ROM3    o30A9           ; HL=(line-1)*STEP
        ld      de,(RC_START)
        add     hl,de
        ex      de,hl           ; DE=new line number
        pop     hl
        ld      (hl),d
        inc     hl
        ld      (hl),e          ; store new number at start of line
        inc     hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)
        inc     hl
        add     hl,bc           ; get to start of next line
        pop     de
        inc     de              ; increment line count
        pop     bc
        dec     bc              ; decrement lines to do
        ld      a,b
        or      c
        jr      nz,l1aea        ; loop back for more
        call    l05cc           ; page back DOS workspace
        ld      (RC_LINE),bc    ; reset "current line being renumbered"
        scf                     ; signal "command succeeded"
        ret

; Table of commands containing line numbers

l1b14   defb    $ca             ; LINE
        defb    $f0             ; LIST
        defb    $e1             ; LLIST
        defb    $ec             ; GOTO
        defb    $ed             ; GOSUB
        defb    $e5             ; RESTORE
        defb    $f7             ; RUN

; Subroutine to replace any line number in the current statement.
; On entry, HL=address of code, A=code
; On exit HL=address of next code to check

l1b1b   inc     hl
        ld      (STRIP2+$0f),hl ; save pointer after command
        ex      de,hl
        ld      bc,$0007
        ld      hl,l1b14
l1b26   cpir                    ; check if one of line number commands
        ex      de,hl
        ret     nz              ; exit if not
        ld      c,$00           ; set BC=0
l1b2c   ld      a,(hl)          ; get next character
        cp      $20
        jr      z,l1b4c         ; go to skip spaces
        ROM3    o2D1B           ; is it a digit?
        jr      nc,l1b4c        ; go to skip if so
        cp      '.'
        jr      z,l1b4c         ; go to skip decimal point
        cp      $0e
        jr      z,l1b50         ; move on if found embedded number
        or      $20
        cp      $65
        jr      nz,l1b48        ; if it's not an "e", exit
        ld      a,b
        or      c
        jr      nz,l1b4c        ; found any characters suggesting a number?
l1b48   ld      hl,(STRIP2+$0f) ; if not, exit with pointer after command
        ret
l1b4c   inc     bc              ; increment characters found
        inc     hl
        jr      l1b2c           ; loop back for more
l1b50   ld      (STRIP2+$07),bc ; save no of characters before embedded #
        push    hl              ; save pointer to embedded number
        ROM3    o18B6           ; skip past embedded number
        call    l1c43           ; skip past spaces
        ld      a,(hl)          ; get following character
        pop     hl              ; restore pointer to embedded number
        cp      ':'
        jr      z,l1b64
        cp      $0d
        ret     nz              ; exit if following character not : or ENTER
l1b64   inc     hl              ; HL points to next statement/line
        ROM3    o33B4           ; stack the embedded number
        ROM3    o2DA2           ; get embedded number to BC
        ld      h,b
        ld      l,c             ; HL=embedded line number
        ROM3    o196E           ; get HL=address of target line
        jr      z,l1b7c         ; move on if the actual line was found
        ld      a,(hl)
      IF garry
        cp      $28
        jr      c, l1b7c        ; or if there is a line afterwards (not end)
      ELSE
        cp      $80
        jr      nz,l1b7c        ; or if there is a line afterwards (not end)
      ENDIF
        ld      hl,$270f        ; use 9999 and move on
        jr      l1b8d
l1b7c   ld      (STRIP2+$0d),hl ; save target line address
        call    l1c18           ; get DE=number of lines before it
        ld      hl,(RC_STEP)
        ROM3    o30A9
        ld      de,(RC_START)
        add     hl,de           ; HL=target line's new number
l1b8d   ld      de,STRIP2+$09
        push    hl              ; save number
        call    l1c49           ; form ASCII representation of it
        ld      e,b
        inc     e
        ld      d,$00           ; DE=length of ASCII string
        push    de              ; save length
        push    hl              ; and address of string
        ld      l,e
        ld      h,$00
        ld      bc,(STRIP2+$07) ; get number of characters available
        or      a
        sbc     hl,bc
        ld      (STRIP2+$07),hl ; save number of extra chars required
        jr      z,l1bdc         ; move on if right size
        jr      c,l1bd2         ; move on if more chars available than needed
        ld      b,h
        ld      c,l             ; BC=chars to insert
        ld      hl,(STRIP2+$0f) ; HL=address to insert at
        push    hl              ; save registers
        push    de
        ld      hl,(STKEND)
        add     hl,bc
        jr      c,l1bcb         ; move on to signal error if no room
        ex      de,hl
        ld      hl,$0082
        add     hl,de
        jr      c,l1bcb         ; error if can't leave $82 bytes free
        sbc     hl,sp
        ccf
        jr      c,l1bcb         ; or if would encroach on stack
        pop     de              ; restore registers
        pop     hl
        ROM3    o1655           ; make room
        jr      l1bdc           ; move on
l1bcb   pop     de
        pop     hl
l1bcd   call    l05cc           ; page in DOS workspace
        and     a               ; signal "command failed"
        ret                     ; exit
l1bd2   dec     bc
        dec     e
        jr      nz,l1bd2        ; BC=number of bytes to reclaim
        ld      hl,(STRIP2+$0f)
        ROM3    o19E8           ; reclaim room
l1bdc   ld      de,(STRIP2+$0f)
        pop     hl
        pop     bc
        ldir                    ; copy ASCII text of line number
        ex      de,hl
        ld      (hl),$0e        ; store embedded number marker
        pop     bc              ; BC=new line number
        inc     hl
        push    hl              ; save address to place FP number
        ROM3    o2D2B           ; stack BC on FP stack (HL=address)
        pop     de
        ld      bc,$0005
        ldir                    ; copy FP representation
        ex      de,hl
        push    hl              ; save address of next byte to check
        ld      hl,(RC_LINE)
        push    hl              ; save address of current line
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=length of current line
        ld      hl,(STRIP2+$07)
        add     hl,de
        ex      de,hl           ; DE=new length of current line
        pop     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store new length
        ld      hl,(STRIP2+$11)
        ld      de,(STRIP2+$07)
        add     hl,de
        ld      (STRIP2+$11),hl ; store new next line address
        pop     hl              ; restore address of next byte to check
        ret

; Subroutine to count the number of lines in a BASIC program,
; either to the end (enter at l1c12), or to a certain address (enter
; at l1c18 with address in STRIP2+$0d).
; Number of lines is returned in DE

l1c12   ld      hl,(VARS)
        ld      (STRIP2+$0d),hl ; save VARS
l1c18   ld      hl,(PROG)
        ld      de,(STRIP2+$0d)
        or      a
        sbc     hl,de
        jr      z,l1c3e         ; move on if no BASIC program in memory
        ld      hl,(PROG)       ; start at PROG
        ld      bc,$0000        ; with 0 lines
l1c2a   push    bc
        ROM3    o19B8           ; find DE=address of next line
        ld      hl,(STRIP2+$0d)
        and     a
        sbc     hl,de
        jr      z,l1c3b         ; move on if no more lines
        ex      de,hl           ; else swap to HL
        pop     bc
        inc     bc              ; increment line count
        jr      l1c2a           ; loop back
l1c3b   pop     de              ; restore number of lines
        inc     de              ; increment for last line
        ret
l1c3e   ld      de,$0000        ; BASIC program length=0
        ret

; Subroutine to skip spaces

l1c42   inc     hl
l1c43   ld      a,(hl)          ; get next char
        cp      ' '
        jr      z,l1c42         ; skip if space
        ret                     ; exit with HL pointing to non-space

; Subroutine to form a text representation of a binary number up to 9999
; On entry, DE=address to form number, HL=number
; On exit, HL=start address of text number, DE=end address+1, B=#digits-1

l1c49   push    de              ; save start address of text number
        ld      bc,-1000
        call    l1c6d           ; form 1000s digit
        ld      bc,-100
        call    l1c6d           ; form 100s digit
        ld      c,-10
        call    l1c6d           ; form 10s digit
        ld      a,l
        add     a,'0'
        ld      (de),a          ; form units digit
        inc     de
        ld      b,$03           ; check first 3 digits
        pop     hl              ; restore start address of text number
l1c63   ld      a,(hl)
        cp      '0'
        ret     nz              ; exit if non-zero digit
        ld      (hl),' '        ; replace leading 0s with spaces
        inc     hl
        djnz    l1c63           ; loop back
        ret

; Subroutine to form a decimal digit from a binary number
; On entry, HL=number, DE=address to store digit, BC=-unit size
; On exit, HL is reduced and DE is incremented

l1c6d   xor     a               ; zero counter
l1c6e   add     hl,bc           ; subtract unit size
        inc     a               ; and increment digit counter
        jr      c,l1c6e         ; loop back for more until failed
        sbc     hl,bc           ; add back last unit
        dec     a               ; and decrement counter
        add     a,'0'
        ld      (de),a          ; place ASCII digit
        inc     de              ; increment address
        ret

l1c7a   defb    $08
        defb    0
        defb    0
        defb    $14
        defb    0
        defb    0
        defb    0
        defb    $0f
        defb    0

l1c83   defb    $08
        defb    0
        defb    $16
        defb    $01
        defb    0
        defb    0
        defb    0
        defb    $0f
        defb    0

; Subroutine to ???

l1c8c   ld      ix,$fd98
        ld      hl,l1c7a
        jr      l1c98               ; (3)

l1c95   ld      hl,l1c83
l1c98   ld      de,$fd98
        jp      l2152


l1c9e   rst     $10
        ld      a,d
        rst     $10
        scf
        ret

; Subroutine to set cursor colours to A

l1ca3   and     $3f             ; mask off FLASH/BRIGHT bits
        ld      (ix+$06),a      ; set colours
        scf
        ret

; Subroutine to place cursor at column C, line B (of editing area)

l1caa   ld      a,(ix+$01)      ; get line for top of editing area
        add     a,b
        ld      b,a             ; B=line
        call    l1dad           ; get attribute address
        ld      a,(hl)
        ld      (ix+$07),a      ; save attribute
        cpl
        and     $c0             ; get inverse of current FLASH/BRIGHT bits
        or      (ix+$06)        ; combine with cursor colour
        ld      (hl),a          ; set new attribute
        scf
        ret

; Subroutine to remove cursor from column C, line B (of editing area)

l1cbf   ld      a,(ix+$01)      ; get line for top of editing area
        add     a,b
        ld      b,a             ; B=line
        call    l1dad           ; get attribute address
        ld      a,(ix+$07)
        ld      (hl),a          ; restore attribute
        ret


l1ccc   push    hl
        ld      h,$00
        ld      a,e
        sub     b
        jr      l1cda               ; (7)

l1cd3   push    hl
        ld      a,e
        ld      e,b
        ld      b,a
        sub     e
        ld      h,$ff

l1cda   ld      c,a
        ld      a,b
        cp      e
        jr      z,l1d2a             ; (75)
        push    de
        call    l1da5

l1ce3   push    bc
        ld      c,h
        ROM3    o0E9B
        defb    $eb
        xor     a
        or      c
        jr      z,l1cf0             ; (3)
        inc     b
        jr      l1cf1               ; (1)

l1cf0   dec     b

l1cf1   push    de
        ROM3    o0E9B
        defb    $d1
        ld      a,c
        ld      c,$20
        ld      b,$08

l1cfb   push    bc
        push    hl
        push    de
        ld      b,$00
        ldir
        pop     de
        pop     hl
        pop     bc
        inc     h
        inc     d
        djnz    l1cfb               ; (-14)
        push    af
        push    de
        ROM3    o0E88
        defb    $eb
        ex      (sp),hl
        ROM3    o0E88
        defb    $eb
        ex      (sp),hl
        pop     de
        ld      bc,$0020
        ldir
        pop     af
        pop     bc
        and     a
        jr      z,l1d23             ; (3)
        inc     b
        jr      l1d24               ; (1)

l1d23   dec     b

l1d24   dec     c
        ld      h,a
        jr      nz,l1ce3            ; (-69)
        pop     de
        ld      b,e

l1d2a   pop     hl

l1d2b   call    l1dc5           ; swap editor/BASIC colours & P_FLAG
        ex      de,hl
        ld      a,(TV_FLAG)
        push    af
        ld      hl,ed_flags
        bit     6,(hl)
        res     0,a
        jr      z,l1d3e             ; (2)
        set     0,a

l1d3e   ld      (TV_FLAG),a
        ld      c,$00
        call    l191d
        ex      de,hl
        ld      b,$20

l1d49   ld      a,(hl)
        and     a
        jr      nz,l1d4f            ; (2)
        ld      a,$20

l1d4f   cp      $90
        jr      nc,l1d62            ; (15)
        ROM3    o0010

l1d56   inc     hl
        djnz    l1d49               ; (-16)
        pop     af
        ld      (TV_FLAG),a
        call    l1dc5           ; swap editor/BASIC colours & P_FLAG
        scf
        ret

l1d62   call    l05a7
        rst     $10
        call    l05cc
        jr      l1d56               ; (-21)

; Subroutine to clear an area of screen to the editor's colours
; On entry, B=first line number and D=last line number (0...23)

l1d6b   call    l1dc5           ; swap editor/BASIC colours & P_FLAG
        ld      a,d
        sub     b
        inc     a
        ld      c,a             ; C=number of lines to clear
        call    l1da5           ; convert line number as required by ROM 3
l1d75   push    bc
        ROM3    o0E9B           ; get HL=address of line B in display file
        ld      c,$08           ; 8 pixel lines per character
l1d7b   push    hl
        ld      b,$20           ; 32 characters per line
        xor     a
l1d7f   ld      (hl),a          ; clear a pixel line of a character
        inc     hl
        djnz    l1d7f           ; back for rest of line
        pop     hl
        inc     h
        dec     c
        jr      nz,l1d7b        ; back for rest of pixel lines
        ld      b,$20
        push    bc
        ROM3    o0E88           ; get attribute address
        ex      de,hl
        pop     bc
        ld      a,(ATTR_P)
l1d93   ld      (hl),a          ; clear attributes to editor's ATTR_P
        inc     hl
        djnz    l1d93           ; for rest of line
        pop     bc
        dec     b               ; next line
        dec     c               ; decrement counter
        jr      nz,l1d75        ; back for more
        call    l1dc5           ; swap editor/BASIC colours & P_FLAG
        scf
        ret

; Subroutine to convert line numbers and column numbers as required
; by certain ROM 3 routines

l1da1   ld      a,$21
        sub     c
        ld      c,a             ; C=33-oldC
l1da5   ld      a,$18
        sub     b
        sub     (ix+$01)
        ld      b,a             ; B=24-oldB-??
        ret

; Subroutine to get attribute address for line B, column C into HL

l1dad   push    bc
        xor     a
        ld      d,b
        ld      e,a
        rr      d
        rr      e
        rr      d
        rr      e
        rr      d
        rr      e               ; DE=B*32
        ld      hl,$5800        ; start of attribs
        ld      b,a
        add     hl,bc
        add     hl,de           ; form address
        pop     bc
        ret

; Subroutine to swap some system variables with copies in page 7, allowing
; BASIC & the editor to use different values for colours etc

l1dc5   push    af              ; save registers
        push    hl
        push    de
        ld      hl,(ATTR_P)     ; swap permanent & temporary colours with
        ld      de,(ATTR_T)     ; editor ones
        exx
        ld      hl,(ed_ATTR_P)
        ld      de,(ed_ATTR_T)
        ld      (ATTR_P),hl
        ld      (ATTR_T),de
        exx
        ld      (ed_ATTR_P),hl
        ld      (ed_ATTR_T),de
        ld      hl,ed_P_FLAG    ; swap P_FLAG with editor one
        ld      a,(P_FLAG)
        ld      d,(hl)
        ld      (hl),a
        ld      a,d
        ld      (P_FLAG),a
        pop     de              ; restore registers
        pop     hl
        pop     af
        ret

; ========================
; EDITOR ROUTINES - PART 5
; ========================

; -------------------
; Tokenize BASIC Line
; -------------------
; This routine serves two purposes. The first is to tokenize a typed BASIC line into a tokenized version. The second is when a syntax error is subsequently
; detected within the tokenized line, and it is then used to search for the position within the typed line where the error marker should be shown.
;
; This routine parses the BASIC line entered by the user and generates a tokenized version in the workspace area as pointed to by system variable E_LINE.
; It suffers from a number of bugs related to the handling of '>' and '<' characters. The keywords '<>', '>=' and '<=' are the only keywords that
; do not commence with letters and the routine traps these in a different manner to all other keywords. If a '<' or '>' is encountered then it is not
; immediately copied to the BASIC line workspace since the subsequent character must be examined as it could be a '>' or '=' character and therefore
; might form the keywords '<>', '>=' or '<='. A problem occurs if the subsequent character is a letter since the parser now expects the start of a
; possible keyword. It should at this point insert the '<' or '>' into the BASIC line workspace but neglects to do this. It is only when the next non-letter
; character is encountered that the '<' or '>' gets inserted, but this is now after the previously found string has been inserted. This results the following
; types of errors:
;
; 'PRINT varA>varB' is seen by the parser as 'PRINT varAvarB>' and hence a syntax error occurs.
; 'PRINT varA>varB1' is seen by the parser as 'PRINT varAvarB>1' and hence is accepted as a valid statement.
;
; A work-around is to follow the '<' or '>' with a space since this forces the '<' or '>' to be inserted before the next potential keyword is examined.
;
; A consequence of shifting a '<' or '>' is that a line such as 'PRINT a$>b$' is seen by the parser as 'PRINT a$b$>' and so it throws a syntax error.
; The parser saved the '>' character for consideration when the next character was examined to see if it was part of the keywords '<>', '>=' or '<=',
; but fails to discard it if the end of the statement is immediately encountered. Modifying the statement to a form that will be accepted will still cause
; a syntax error since the parser mistakenly believes the '>' character applies to this statement.
;
; The parser identifies string literals contained within quotes and will not tokenize any keywords that appear inside them, except for the keywords "<>",
; "<=" and ">=" which it neglects to check for. Keywords are also not tokenized following a REM statement, except again for "<>", "<=" and ">=", until the
; end of the line is reached. This differs slightly to 48K BASIC mode. In 48K BASIC mode, typing a ':' following a REM statement will cause a change from
; 'L' cursor mode to 'K' cursor mode and hence the next key press results in a keyword token being inserted. In 128K BASIC mode, typing a ':' will not change
; to 'K' cursor mode and hence the next key press will just be the letter, number or symbol. This does not affect the running of the program since 48K BASIC
; mode will ignore all characters after a REM command until the end of the line. However, creating such a REM statement in 128K BASIC mode that appears similar
; to one created in 48K BASIC mode will result in more memory being used since the 'keyword' must be spelled out letter by letter.
;
; When being used to locate the error marker position, the same process is performed as when tokenizing but no characters are actually inserted into the workspace
; (they are still there from when the line was originally tokenized). Instead, a check is made after each character is processed to see if the error marker address
; held in system variable X_PTR has been reached. If it does match then the routine returns with BC holding the character position where the error marker should
; be displayed at.

;Entry point - A syntax error was detected so the error marker must be located

l1df6   ld      a, $01          ; Signal to locate the error marker.
        jr      l1dfc           ; Jump forward.

;Entry point - Tokenize the BASIC line

l1dfa   ld      a,$00           ; Signal to tokenize the BASIC line. [Could have saved 1 byte by using XOR A]

l1dfc   ld      ($fdb6),a       ; Store the 'locate error marker' flag.
        ld      hl,$0000
        ld      ($fdb1),hl      ; Reset count of the number of characters in the typed BASIC line being inserted.
        ld      ($fdb3),hl      ; Reset count of the number of characters in the tokenized version of the BASIC line being inserted.
        add     hl,sp
        ld      ($fdb7),hl      ; Store the stack pointer.
        call    l15e4           ; Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the
                                ; address of the next character in the BASIC line within the program area being de-tokenized).
        ld      a,$00           ; [Could have saved 1 byte by using XOR A]
        ld      ($fdb0),a       ; Signal last character was not a keyword and was not a space.
                                ; [*BUG* - Should reset the '<' and '>' store at $FD89 to $00 here. Attempting to insert a BASIC line
                                ; such as 'PRINT VAL a$>b' will fail since the parser does not like '>' immediately after 'a$', due to the bug at $3C5F (ROM 0).
                                ; The parser stores the '>' in $FD89 since it will check the following character in case it should replace the two
                                ; characters with the token '<>', '>=' or '<='. After the parser throws the syntax error, it does not clear
                                ; $FD89 and so even if the line is modified such that it should be accepted, e.g. 'PRINT VAL a$=b', the parser
                                ; believes the line is really '>PRINT VAL n$=b' and so throws another syntax error. Since a letter follows the '>',
                                ; the contents of $FD89 will get cleared and hence a second attempt to insert the line will now succeed. Credit: Paul Farrow]
        ld      hl,$fda0        ; HL=Start address of the Keyword Conversion Buffer.
        ld      ($fda9),hl      ; Store as the next available location.
        call    l05a7           ; Use Normal RAM Configuration (physical RAM bank 0).
        ROM3    o16B0           ; $16B0. Clear the editing areas.
        call    l05cc           ; Use Workspace RAM configuration (physical RAM bank 7).
        ld      a,$00           ; [Could have saved 1 byte by using XOR A, or 2 bytes by clearing this above]
        ld      ($fdad),a       ; Clear Keyword Conversion Buffer flags - not within REM, not with Quotes, no characters in the buffer.
        ld      hl,(E_LINE)     ; E_LINE.
        ld      ($fdae),hl      ; Store the address of the workspace for the tokenized BASIC line.
        ld      hl,$0000        ; [Could have saved 1 byte by using LD H,A followed by LD L,A]
        ld      ($fdab),hl      ; Signal no space character between words in the Keyword Conversion Buffer.

;Enter a loop to fetch each character from the BASIC line and insert it into the workspace, tokenizing along the way

l1e34   ld      hl,($fdb1)
        inc     hl              ; Increment count of the number of characters in the typed BASIC line.
        ld      ($fdb1),hl
        call    l1f30           ; Fetch the next character from BASIC line being inserted, return in B.
        ld      c,a             ; Save the character status value.

;C=$01 if not a space, not a letter, not a '#' and not a '$'.
;  $02 if a '#' or '$'.
;  $03 if a space.
;  $06 if a letter.
;B=Character fetched.

        ld      a,($fdad)       ; Have any Keyword Conversion Buffer flags been set?
        cp      $00             ; Has anything be put into the buffer yet?
        jr      nz,l1e87        ; Jump if so.

;The first character to potentially put into the Keyword Conversion Buffer

l1e46   ld      a,c             ; Retrieve the character status value.
        and     $04             ; Is the character a letter?
        jr      z,l1e80         ; Jump if not.

;Insert the character

; [*BUG* - At this point a '>' or '<' that was previously stored should be inserted into the BASIC line workspace. However, the routine proceeds with the new potential
;          keyword and this is entered into the BASIC line workspace next. The '>' or '<' will only be inserted when the next non-letter character is encountered. This causes
;          an expression such as 'a>b1' to be translated into 'ab>1'. Credit: Ian Collier (+3), Paul Farrow (128)]

; [The bug can be fixed by testing if whether a '<' or '>' character is stored. Credit: Paul Farrow.
;
;       LD   A,($FD89)    ;
;       AND  A            ; Was the last character a '>' or '<'?
;       JR   Z,INSERT     ; Jump if not.
;
;       PUSH BC           ; Save the new character.
;       LD   B,A          ;
;       CALL $3E0B (ROM 0) ; Insert the '>' or '<' into the BASIC line workspace.
;       POP  BC           ; Retrieve the new character.
;       XOR  A            ;
;       LD   ($FD89),A    ; Clear the '>' or '<'.
;
;INSERT:                  ; ]

l1e4b   call    l1f7c           ; Insert the character into the Keyword Conversion Buffer.
        jr      nc,l1e57        ; Jump if no more room within the buffer, hence string is too large to be a token.
        ld      a,$01           ; Signal Keyword Conversion Buffer contains characters.
        ld      ($fdad),a
        jr      l1e34           ; Jump back to fetch and process the next character.

;No room to insert the character into the Keyword Conversion Buffer hence string is too large to be a valid token

l1e57   ld      hl,($fdab)      ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
        ld      a,l
        or      h               ; Is there an address set?
        jp      nz,l1eb1        ; Jump if so to copy the first word into the BASIC line workspace and the move the second word to the
                                ; start of the Keyword Conversion Buffer. Further characters can then be appended and the contents
                                ; re-evaluated in case a complete keyword is then available.

;Copy the Keyword Conversion Buffer into the BASIC line workspace

l1e5f   push    bc              ; Save the character to insert.
        call    l1f60           ; Copy Keyword Conversion Buffer contents into BASIC line workspace.
        pop     bc              ; Retrieve the character to insert.
        ld      a,$00
        ld      ($fdad),a       ; Signal the Keyword Conversion Buffer is empty.

;C=$01 if not a space, not a letter, not a '#' and not a '$'.
;  $02 if a '#' or '$'.
;  $03 if a space.
;  $06 if a letter.
;B=Character fetched.

l1e69   ld      a,c             ; Retrieve the character status value.
        and     $01             ; Is it a space, or not a letter and not a '#' and not a '$'?
        jr      nz,l1e46        ; Jump back if so to insert the character either into the Keyword Conversion Buffer or the BASIC line workspace.

;The string was too long to be a keyword and was followed by a space, a '#' or a '$'. Enter a loop to insert each character of the
;string into the BASIC line workspace.

        ld      a,b             ; Retrieve the character to insert.
        call    l1fa9           ; Insert character into BASIC line workspace.
        ret     nc              ; Return if tokenizing is complete.
        ld      hl,($fdb1)
        inc     hl              ; Increment the count of the number of characters in the typed BASIC line being inserted.
        ld      ($fdb1),hl
        call    l1f30           ; Fetch the next character from BASIC line being inserted.
        ld      c,a             ; Save the flags.
        jr      l1e69           ; Jump back to insert the character of the non-keyword string into the BASIC line workspace.

;The character is not a letter so insert directly into the BASIC line workspace

l1e80   ld      a,b             ; Retrieve the character to insert.
        call    l1fa9           ; Insert character into BASIC line workspace, tokenizing '<>', '<=' and '>=' if encountered.
        ret     nc              ; Return if tokenizing is complete.
        jr      l1e34           ; Jump back to fetch and process the next character.

;Keyword Conversion buffer flags are set - either the buffer already contains characters, or within quotes or within a REM statement

l1e87   cp      $01             ; Is the Keyword Conversion Buffer empty or the contents marked as being within quotes or within a REM?
        jr      nz,l1e80        ; Jump back if so to insert the character since this is either the first character of a new word or is within quotes or within a REM.

;C=$01 if not a space, not a letter, not a '#' and not a '$'.
;  $02 if a '#' or '$'.
;  $03 if a space.
;  $06 if a letter.

        ld      a,c             ; Retrieve the character status value.
        and     $01             ; Is it a letter or a '#' or a '$'?
        jr      z,l1e4b         ; Jump if so to simply insert the character.

;The character is a space, or is not a letter and not a '#' and not a '$', i.e. the last character was the end of a potential keyword

        push    bc              ; Save the next character to insert and the character status value.

l1e91   call    l2113           ; Attempt to identify the string in Keyword Conversion Buffer.
        pop     bc              ; Retrieve the next character to insert and the character status value.
        jr      c,l1f10         ; Jump if keyword identified.

;The string in the Keyword Conversion Buffer was not identified as a keyword

        ld      hl,($fdab)      ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
        ld      a,h
        or      l               ; Is there an address set, i.e. a space between words?
        jr      nz,l1eb1        ; Jump if there is a space character.
        ld      a,c             ; Retrieve the character status value.
        and     $02             ; Is it a space?
        jr      z,l1e5f         ; Jump if not to copy Keyword Conversion Buffer into the workspace since it is not a keyword.

;Character is a space. Allow this as the keyword could be DEF FN, GO TO, GO SUB, etc.

        call    l1f7c           ; Insert the character into the Keyword Conversion Buffer.
        jr      nc,l1e57        ; Jump back if no room to insert the character, i.e. not a keyword since too large.
        ld      hl,($fda9)      ; Fetch the next location address.
        dec     hl              ; Point back to the last character.
        ld      ($fdab),hl      ; Store as the address of the space character. This is used for double keywords such as DEF FN.
        jr      l1e34           ; Jump back to fetch and process the next character.

;The string in the Keyword Conversion Buffer contains two words separated by a space that do not form a
;valid double keyword (such as DEF FN, GO SUB, GO TO, etc).
;For a BASIC line such as 'IF FLAG THEN' the Keyword Conversion Buffer holds the characters 'FLAG THEN'.
;The 'FLAG' characters get moved to the workspace and the 'THEN' characters are shifted to the start of the
;Keyword Conversion Buffer before being re-evaluated to see if they form a keyword.

l1eb1   push    bc              ; Save the character to insert and the character status value.
        ld      hl,$fda0        ; Point to the start address of the Keyword Conversion Buffer.
        ld      de,($fdab)      ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
        ld      a,d
        cp      h               ; Is the space possibly at the start of the buffer?
        jr      nz,l1ec2        ; Jump if not.
        ld      a,e
        cp      l               ; Is the space at the start of the buffer?
        jr      nz,l1ec2        ; Jump if not.
        inc     de              ; Point to the next location within the buffer, counter-acting the following decrement.

l1ec2   dec     de              ; Point to the previous location within the buffer.
        jr      l1ec6           ; Jump ahead to copy all characters to the BASIC line workspace.

;Copy all characters from the Keyword Conversion Buffer prior to the space into the BASIC line workspace

l1ec5   inc     hl              ; Point to the next location within the Keyword Conversion Buffer.

l1ec6   ld      a,(hl)          ; Fetch a character from the Keyword Conversion Buffer.
        and     $7f             ; Mask off the terminator bit.
        push    hl              ; HL=Location within Keyword Conversion Buffer.
        push    de              ; DE=Location of last character within the Keyword conversion Buffer.
        call    l1fa9           ; Insert character into BASIC line workspace, including a stored '<' or '>' character.
        pop     de 
        pop     hl 
        ld      a,h
        cp      d               ; Possibly reached the character prior to the space?
        jr      nz,l1ec5        ; Jump back if not to copy the next character.
        ld      a,l
        cp      e               ; Reached the character prior to the space?
        jr      nz,l1ec5        ; Jump back if not to copy the next character.

;Now proceed to handle the next word

        ld      de,($fdab)      ; DE=Address of the space character between words.
        ld      hl,$fda0
        ld      ($fdab),hl      ; Set the address of the space character to be the start of the buffer.
        ld      bc,($fda9)      ; BC=Next location within the Keyword Conversion Buffer.
        dec     bc              ; Point to the last used location.
        ld      a,d
        cp      h               ; Is the space possibly at the start of the buffer?
        jr      nz,l1f03        ; Jump if not.
        ld      a,e
        cp      l               ; Is the space at the start of the buffer?
        jr      nz,l1f03        ; Jump if not.

;The space character is at the start of the Keyword Conversion Buffer

        inc     de              ; DE=Address after the space character within the Keyword Conversion Buffer.
        push    hl              ; HL=Start address of the Keyword Conversion Buffer.
        ld      hl,$0000        ;
        ld      ($fdab),hl      ; Signal no space character between words.
        pop     hl              ; HL=Start address of the Keyword Conversion Buffer.
        ld      a,b
        cp      h               ; Is the space possibly the last character in the buffer?
        jr      nz,l1f03        ; Jump if not.
        ld      a,c
        cp      l               ; Is the space the last character in the buffer?
        jr      nz,l1f03        ; Jump if not.
        pop     bc              ; Retrieve the character to insert and the character status value.
        jr      l1f22           ; Jump ahead to continue.

;The space is not at the start of the Keyword Conversion Buffer, i.e. the buffer contains another word after the space.
;The first word has already been copied to the BASIC line workspace so now copy the second word to the start of the Keyword Conversion Buffer
;and then see if it is a valid keyword. [It is not recommended to name a variable as per a keyword since statements such as 'PRINT then' will
;fail the syntax check since the variable 'then' is interpreted as the keyword 'THEN' and so the statement is seen as 'PRINT THEN', which in
;this case is invalid.]

;HL points to the start of the Keyword Conversion Buffer.
;DE points to the space between the two words.

l1f03   ld      a,(de)          ; Fetch a character from the second word.
        ld      (hl),a          ; Store it at the beginning of the buffer.
        inc     hl
        inc     de
        and     $80             ; Reached the last character in the buffer, i.e. the terminator bit set?
        jr      z,l1f03         ; Jump if not to copy the next character.
        ld      ($fda9),hl      ; Store the new address of the next free location.
        jr      l1e91           ; Jump back to attempt identification of the 'second' word as a keyword.

;The string in the Keyword Conversion Buffer was identified as a keyword, so insert the token character code of the
;keyword into the BASIC line workspace.
;A=Character code of identified token.

l1f10   push    bc              ; Save the next character to insert and the character status value.
        call    l1fa9           ; Insert character held in A into BASIC line workspace.
        pop     bc              ; Retrieve the next character to insert and the character status value.

;The token has been inserted into the BASIC line workspace so reset the Keyword Conversion Buffer

        ld      hl,$0000
        ld      ($fdab),hl      ; Indicate no space character between words in the Keyword Conversion Buffer.
        ld      a,($fdad)       ; Fetch the flag bits.
        cp      $04             ; Within a REM statement?
        jr      z,l1f27         ; Jump if so to retain the 'within a REM' flag bit.

l1f22   ld      a,$00
        ld      ($fdad),a       ; Signal no characters within the Keyword Conversion Buffer.

l1f27   ld      hl,$fda0        ; Start address of the Keyword Conversion Buffer.
        ld      ($fda9),hl      ; Store this as the next location within the buffer.
        jp      l1e46           ; Jump back to insert the next character either into the Keyword Conversion Buffer or the BASIC line workspace.

; -------------------------------------------------------------------
; Fetch Next Character and Character Status from BASIC Line to Insert
; -------------------------------------------------------------------
; Fetch the next character from the BASIC line being inserted and check whether a letter, a space, a '#' or a '$'.
; Exit: B=Character.
;       A=$01 if not a space, not a letter, not a '#' and not a '$'.
;         $02 if a '#' or '$'.
;         $03 if a space.
;         $06 if a letter.

l1f30   call    l0e22           ; Fetch the next character from the BASIC line being inserted.
        ld      b,a             ; Save the character.
        cp      $3f             ; $3F. Is it below '?' (the error marker)?
        jr      c,l1f42         ; Jump if so.
        or      $20             ; Make lowercase.
        call    l1f59           ; Is it a letter?
        jr      c,l1f56         ; Jump if so.

l1f3f   ld      a,$01           ; Indicate not space, not letter, not '#' and not '$'.
        ret

l1f42   cp      $20             ; Is it a space?
        jr      z,l1f53         ; Jump if so.
        cp      $23             ; $23. Is it '#'?
        jr      z,l1f50         ; Jump if so.
        jr      c,l1f3f         ; Jump if below '#'.
        cp      $24             ; $24. Is it '$'?
        jr      nz,l1f3f        ; Jump if not.

l1f50   ld      a,$02           ; Indicate a '#' or '$'.
        ret

l1f53   ld      a,$03           ; Indicate a space.
        ret

l1f56   ld      a,$06           ; Indicate a letter.
        ret

; --------------------
; Is Lowercase Letter?
; --------------------
; Entry: A=Character code.
; Exit : Carry flag set is a lowercase letter.

l1f59   cp      $7b             ; Is the character above 'z'?
        ret     nc              ; Return with carry flag reset if above 'z'.
        cp      $61             ; Is the character below 'a'?
        ccf                     ; Return with carry flag reset if below 'a'.
        ret

; -----------------------------------------------------------------
; Copy Keyword Conversion Buffer Contents into BASIC Line Workspace
; -----------------------------------------------------------------

; [To fix the error marker bug at $3EA2 (ROM 0), the code below up until the instruction at $3D81 (ROM 0) should have been as follows]
;
;       LD   HL,$FD74            ; Start address of the Keyword Conversion Buffer.
;       CALL $3D81 (ROM 0)       ; Copy all characters into the BASIC line workspace.
;       LD   HL,$FD74            ; Start address of the Keyword Conversion Buffer.
;       LD   ($FD7D),HL          ; Store the next available location.
;       SUB  A                   ; A=0.
;       LD   ($FD7F),A           ;
;       LD   ($FD80),A           ; Signal no space character between words in the Keyword Conversion Buffer.
;       RET

l1f60   ld      hl,$fda0        ; Start address of the Keyword Conversion Buffer.
        ld      ($fda9),hl      ; Store the next available location.
        sub     a               ; A=0.
        ld      ($fdab),a
        ld      ($fdac),a       ; Signal no space character between words in the Keyword Conversion Buffer.

l1f6d   ld      a,(hl)          ; Fetch a character from the buffer.
        and     $7f             ; Mask off the terminator bit.
        push    hl              ; Save buffer location.
      IF garry
        call    l1fa9           ; Insert the character into the BASIC line workspace, suppressing spaces as required.
      ELSE
        call    l202f           ; Insert the character into the BASIC line workspace, suppressing spaces as required.
      ENDIF
        pop     hl              ; Retrieve buffer location.
        ld      a,(hl)          ; Re-fetch the character from the buffer.
        and     $80             ; Is it the terminator character?
        ret     nz              ; Return if so.
        inc     hl              ; Point to the next character in the buffer.
        jr      l1f6d           ; Jump back to handle next buffer character.

; -----------------------------------------------
; Insert Character into Keyword Conversion Buffer
; -----------------------------------------------
; Entry; B=Character to insert.
; Exit : Carry flag reset if no room to insert the character within the buffer.

l1f7c   ld      hl,($fda9)      ; Fetch address within Keyword Conversion Buffer.
        ld      de,$fda9        ; Address after Keyword Conversion Buffer.
        ld      a,d
        cp      h               ; Has end of buffer possibly been reached?
        jr      nz,l1f8b        ; Jump if not.
        ld      a,e
        cp      l               ; Has end of buffer been reached?
        jp      z,l1fa6         ; Jump if so. [Could have saved a byte by using JR instead of JP]

;End of buffer not reached

l1f8b   ld      de,$fda0        ; Start address of Keyword Conversion Buffer.
        ld      a,d
        cp      h               ; Possibly at the start of the buffer?
        jr      nz,l1f96        ; Jump if not.
        ld      a,e
        cp      l               ; At the start of the buffer?
        jr      z,l1f9c         ; Jump if so to simply store the character.

;Not at the start of the buffer so need to remove terminator bit from the previous character

l1f96   dec     hl              ; Point to the last character.
        ld      a,(hl)
        and     $7f             ; Clear the terminator bit from the last character.
        ld      (hl),a
        inc     hl              ; Point back at the current location.

l1f9c   ld      a,b             ; Retrieve the new character.
        or      $80             ; Set the terminator bit.
        ld      (hl),a          ; Store the character in the buffer.
        inc     hl              ; Point to the next location.
        ld      ($fda9),hl      ; Store the address of the next location.
        scf                     ; Signal character inserted.
        ret

;End of buffer reached

l1fa6   scf
        ccf                     ; Clear the carry flag to indicate no room to insert the character within the buffer.
        ret

; ----------------------------------------------------------------
; Insert Character into BASIC Line Workspace, Handling '>' and '<'
; ----------------------------------------------------------------
; This routine inserts a character into the BASIC line workspace, tokenizing '>=', '<=' and '<>'.
; Entry: A=Character to insert.
; Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
;        If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
;        otherwise a return is made to the main calling routine with BC holding the number of characters in the typed BASIC line,
;        i.e. the error marker location is at the end of the line.

l1fa9   push    af              ; Save the character to insert.

; [*BUG* - The string characters "<>", "<=" and ">=" get tokenized to a single character '<>', '<=' and '>=' respectively
;          even within quotes or a REM statement. Credit: Paul Collins (+3), Paul Farrow (128)]
;
; [*BUG* - 128 BASIC mode handles a colon character found following a REM statement differently to 48K mode. In 48K mode, typing
;          a colon returns the cursor into 'K' mode and hence the next key press inserts a keyword token. In 128K mode, typing a colon
;          does not cause the characters following it to be interpreted as a possible keyword. There is no noticeable difference when
;          executing the REM statement since subsequent statements are ignored following a REM command. However, for consistency the
;          128K mode editor ought to generate identical BASIC lines to those that would be created from 48K mode. Credit: Paul Farrow]
;
; [The following instructions would be required fix the two bugs described above. Credit: Paul Farrow.
;
;       LD   A,($FD81)    ;
;       BIT  1,A          ; Within quotes?
;       JR   NZ,WITHIN    ; Jump forward if within quotes.
;
;       BIT  2,A          ; Within a REM statement?
;       JR   Z,NOT_WITHIN ; Jump forward if not within a REM statement.
;
;       POP  AF           ;
;       PUSH AF           ;
;       CP   ':'          ;
;       JR   NZ,WITHIN    ; Jump if not a colon.
;
;       LD   A,($FD81)    ;
;       AND  $FB          ; Signal not within a REM statement.
;       LD   ($FD81),A    ;
;
;WITHIN:
;       POP  AF           ; Retrieve the character to insert.
;       JP   $3E0B (ROM 0) ; Simply insert the character into the BASIC line workspace.
;
;NOT_WITHIN:              ; ]

        ld      a,($fdb5)       ; Was the previous character '<' or '>'?
        or      a
        jr      nz,l1fc2        ; Jump if so.
        pop     af              ; Retrieve the character to insert.
        cp      $3e             ; $3E. Is it '>'?
        jr      z,l1fbd         ; Jump if so to store for special treatment later.
        cp      $3c             ; $3C. Is it '<'?
        jr      z,l1fbd         ; Jump if so to store for special treatment later.

l1fb9   call    l1ff7           ; Insert the character into the BASIC line workspace.
        ret                     ; [Could have saved 1 byte by using JP $3E0B (ROM 0)]

;The character was '<' or '>'

l1fbd   ld      ($fdb5),a       ; Store '<' or '>'.
        scf                     ; Signal tokenizing not complete or error marker not found.
        ret

;The previous character was '<' or '>'

l1fc2   cp      $3c             ; $3C. Was the previous character '<'?
        ld      a,$00           ; Reset the indicator that the previous
        ld      ($fdb5),a       ; character was '<' or '>'.
        jr      nz,l1fe5        ; Jump ahead if not '<'.

;Previous character was '<'

        pop     af              ; Retrieve the character to insert.
        cp      $3e             ; $3E. Is it '>'?
        jr      nz,l1fd4        ; Jump ahead if not.
        ld      a,$c9           ; Tokenize to the single character '<>'.
        jr      l1fb9           ; Jump back to insert the character and return.

l1fd4   cp      $3d             ; $3D. Is it '='?
        jr      nz,l1fdc        ; Jump ahead if not.
        ld      a,$c7           ; Tokenize to '<='.
        jr      l1fb9           ; Jump back to insert the character and return.

;Previous character was '<' and new character is '<'

l1fdc   push    af              ; Save the current character to insert.
        ld      a,$3c           ; $3C.
        call    l1ff7           ; Put the preceding '<' character into the line.
        pop     af              ; Retrieve the character to insert.
        jr      l1fb9           ; Jump back to insert the character and return.

;Previous character was '>'

l1fe5   pop     af              ; Retrieve the character to insert.
        cp      $3d             ; $3D. Is it '='?
        jr      nz,l1fee        ; Jump ahead if not.
        ld      a,$c8           ; Tokenize to '>='.
        jr      l1fb9           ; Jump back to insert the character and return.

;Previous character was '>' and new character is '>'

l1fee   push    af              ; Save the current character to insert.
        ld      a,$3e           ; $3E.
        call    l1ff7           ; Put the preceding '>' character into the line.
        pop     af              ; Retrieve the character to insert.
        jr      l1fb9           ; Jump back to insert the character and return.

; ---------------------------------------------------------------------
; Insert Character into BASIC Line Workspace, Handling 'REM' and Quotes
; ---------------------------------------------------------------------
; This routine inserts a character into the BASIC line workspace, with special handling of a 'REM' command
; and strings contained within quotes.
; Entry: A=Character to insert.
; Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
;        If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
;        otherwise a return is made directly to the main calling routine with BC holding the number of characters in the typed BASIC line,
;        i.e. the error marker location is at the end of the line.

l1ff7   cp      $0d             ; Is it 'ENTER'?
        jr      z,l201b         ; Jump ahead if so.
        cp      $ea             ; Is it 'REM'?
        ld      b,a             ; Save the character.
        jr      nz,l2007        ; Jump ahead if not REM.

;It is a 'REM' character

        ld      a,$04           ; Indicate that within a REM statement.
        ld      ($fdad),a
        jr      l2015           ; Jump ahead to insert the character into the BASIC line workspace.

l2007   cp      $22             ; Is it a quote?
        jr      nz,l2015        ; Jump ahead if not.

;It is a quote character

        ld      a,($fdad)
        and     $fe             ; Signal last character was not a keyword.
        xor     $02             ; Toggle the 'within quotes' flag. Will be 1 for an opening quote, then 0 for a closing quote.
        ld      ($fdad),a

l2015   ld      a,b             ; Retrieve the character.
        call    l202f           ; Insert the character into the BASIC line workspace, suppressing spaces as required.
        scf                     ; Indicate BASIC line tokenization not complete.
        ret

;It is an 'ENTER' character

; [*BUG* - At this point a check should be made to see whether the last character was a space. If it was then it will not have
;          been inserted but instead the flag in $FD84 (ROM 0) will have been set. The purpose of the flag is to filter out double
;          spaces caused by the leading/trailing spaces of tokens. Only if the following character is not a space will the previous
;          character, the space, be inserted. When the end of the line is found, there is no attempt to insert this space.
;          The bug can be fixed by the two modifications shown below. Credit: Paul Farrow]

l201b   ld      a,($fdb6)       ; Fetch the 'locate error marker' flag.
        cp      $00             ; Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]
        jr      z,l202c         ; Jump if tokenizing the BASIC line.

;The end of the line was reached and no error marker was found so assume the error marker exists at the end of the typed line

        ld      bc,($fdb1)      ; BC=Count of number of the characters in the typed BASIC line being inserted.
        ld      hl,($fdb7)

; [The first part of the fix for the trailing space bug is as follows:
;
;       LD   A,($FD84)    ; Fetch the BASIC line insertion flags.
;       AND  $02          ; Was the last character a space?
;       JR   Z,GOT_COUNT  ; Jump if not.
;
;       INC  BC           ; Increment to account for the final space.
;
;GOT_COUNT:               ; ]

        ld      sp,hl           ; Restore the stack pointer.
        scf                     ; Indicate the error marker was not found within the tokenized BASIC line.
        ret                     ; Return back to the top level calling routine, to $2D2A (ROM 0).

;Tokenizing the BASIC line

; [The second part of the fix for the trailing space bug is as follows:
;
;       LD   A,($FD84)    ; Fetch the BASIC line insertion flags.
;       AND  $02          ; Was the last character a space?
;       LD   A,$20        ; Insert a space into the line.
;       CALL NZ,$3EA2 (ROM 0) ; If so then insert the character into the BASIC line workspace.]

l202c   scf
        ccf                     ; Carry flag reset to indicate tokenizing complete.
        ret

; -----------------------------------------------------------------
; Insert Character into BASIC Line Workspace With Space Suppression
; -----------------------------------------------------------------
; This routine is called to insert a character into the BASIC line workspace, suppressing both leading and trailing spaces
; around tokens, e.g. 'PRINT 10' does not require a space stored between 'PRINT' and '10' within the BASIC line.
; The routine maintains two flags which indicate whether the last character was a space or was a token. Whenever a space
; is encountered, it is noted but not inserted straight away. It is only after the subsequent character is examined that
; the routine can determine whether the space should or should not be inserted.
; Entry: A=Character to insert.
; Exit : A=Updated BASIC line insertion flags.

l202f   ld      e,a             ; Save the character to insert in E.
        ld      a,($fdb0)
        ld      d,a             ; D=BASIC line insertion flags.
        ld      a,e             ; Restore character to insert back to A.
        cp      $20             ; Is it a space?
        jr      nz,l2059        ; Jump ahead if not.

;Character to insert is a space

        ld      a,d             ; A=BASIC line insertion flags.
        and     $01             ; Was the last character a token?
        jr      nz,l2052        ; Jump ahead if so.
        ld      a,d             ; A=BASIC line insertion flags.
        and     $02             ; Was the last character a space?
        jr      nz,l204a        ; Jump ahead if so.

;Character to insert is a space and the last character was not a space/token. This could be the start of a new keyword
;so note the space but do not insert it now.

        ld      a,d             ; A=BASIC line insertion flags.
        or      $02             ; Signal the last character was a space.
        ld      ($fdb0),a       ; Store the updated BASIC line insertion flags.
        ret

;Character to insert is a space and the last character was a space. The new space could be the start of a new keyword
;so keep the 'last character was a space' flag set but insert a space for the previous space that was noted.

l204a   ld      a,e             ; Retrieve the character to insert.
        call    l208e           ; Insert the character into the BASIC line workspace.
        ld      a,($fdb0)       ; A=BASIC line insertion flags.
        ret

;Character to insert is a space and the last character was a token. Do not insert trailing spaces for tokens.

l2052   ld      a,d             ; A=BASIC line insertion flags.
        and     $fe             ; Signal last character was not a token.
        ld      ($fdb0),a       ; Store the updated BASIC line insertion flags.
        ret                     ; [Could have saved 2 bytes by using JR $3E5A (ROM 0)]

;Character to insert is not a space

l2059   cp      $a3             ; Compare against the token 'SPECTRUM' (the first 128K keyword).
        jr      nc,l2081        ; Jump ahead if a token.

;Character to insert is not a space and not a token

        ld      a,d             ; A=BASIC line insertion flags.
        and     $02             ; Was the last character a space?
        jr      nz,l206d        ; Jump ahead if it was.

;Character to insert is not a space and not a token and the last character inserted was not a space, so just insert the character

        ld      a,d             ; A=BASIC line insertion flags.
        and     $fe             ; Signal last character was not a keyword.
        ld      ($fdb0),a       ; Store the new flags.
        ld      a,e             ; Retrieve the character to insert.
        call    l208e           ; Insert the character into the BASIC line workspace.
        ret                     ; [Could have saved one byte by using JP $3EA2 (ROM 0)]

;Character to insert is not a space and not a token and the last character was a space. Since the new character is not a token, the previous
;space was not the start of a new keyword so insert a space and then the new character.

l206d   push    de              ; Save the BASIC line insertion flags.
        ld      a,$20           ; Insert a space into the line.
        call    l208e           ; Insert the character into the BASIC line workspace.
        pop     de              ; Retrieve the flags.
        ld      a,d             ; A=BASIC line insertion flags.
        and     $fe             ; Signal last character was not a keyword.
        and     $fd             ; Signal last character was not a space.
        ld      ($fdb0),a       ; Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3E79 (ROM 0)]
        ld      a,e             ; Retrieve the character to insert.
        call    l208e           ; Insert the character into the BASIC line workspace.
        ret

;Character to insert is a token. Clear any previously noted space since leading spaces are not required for tokens.

l2081   ld      a,d             ; A=BASIC line insertion flags.
        and     $fd             ; Signal last character was not a space.
        or      $01             ; Signal last character was a keyword.
        ld      ($fdb0),a       ; Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3E79 (ROM 0)]
        ld      a,e             ; Retrieve the character to insert.
        call    l208e           ; Insert the character into the BASIC line workspace.
        ret

; --------------------------------------------
; Insert a Character into BASIC Line Workspace
; --------------------------------------------
; This routine is called for two purposes. The first use is for inserting a character or token into the BASIC line workspace (situated at E_LINE).
; The second use is after a syntax error has been identified within the tokenized BASIC line in the workspace and the location of the error marker needs to be
; established. For the second case, the system variable X_PTR holds the address of where the error occurred within the tokenized BASIC line in the workspace.
; The Editor needs to identify how many characters there are before the equivalent error position is reached within the typed BASIC line. To locate it, the typed BASIC
; line is re-parsed but this time without inserting any characters into the BASIC line workspace, since this still contains the tokenized line from before. This tokenized line
; will now also include embedded floating point numbers for any numeric literals contained within the BASIC line. As the typed line is re-parsed, a count of the characters
; examined so far is kept and instead of inserting tokenized characters within the BASIC line workspace, a check is made to see whether the insertion location has
; reached the address of the error marker. If it has then the parsing of the BASIC line terminates and the count of the typed line characters indicates the equivalent
; position within it of the error. However, should the last character have been a token then the typed line count will also include the number of characters that form
; the keyword, and so this must be subtracted from the count.
; Entry: A=Character to insert.
;        DE=Address of insertion position within the BASIC line workspace.
; Exit : If searching for the error marker position and it is found then a return is made directly to the top level calling routine with BC holding the number of characters in
;        the typed BASIC line prior to the equivalent error marker position.

l208e   ld      hl,($fdb3)
        inc     hl              ; Increment the count of the number of characters in the tokenized BASIC line.
        ld      ($fdb3),hl
        ld      hl,($fdae)      ; HL=Address of next insertion position in the BASIC line workspace.
        ld      b,a             ; Save the character to insert.
        ld      a,($fdb6)       ; Fetch the 'locate error marker' flag.
        cp      $00             ; Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]
        ld      a,b             ; A=Character to insert.
        jr      z,l20c6         ; Jump if tokenizing the BASIC line.

;Locating the error marker

        ld      de,(X_PTR)      ; X_PTR. Fetch the address of the character after the error marker.
        ld      a,h
        cp      d               ; Has the error marker position possibly been reached?
        jr      nz,l20c3        ; Jump ahead if not.
        ld      a,l
        cp      e               ; Has the error marker position been reached?
        jr      nz,l20c3        ; Jump ahead if not.

;The error marker has been reached

; [*BUG* - The desired character count until the error marker is held at address $FD85 and needs the length of the last character to be removed from it,
;          which for a token would be several bytes. However, the routine simply returns the lower of the tokenized and typed counts, and this yields
;          very unhelpful error marker positions shown within the typed BASIC line. Credit: Ian Collier (+3), Andrew Owen (128)]

; [The code below up until the instruction at $3ED1 (ROM 0) should have been as follows. Changes to the code at $3D74 (ROM 0) are also required. Credit: Paul Farrow.
;
;       LD   HL,($FD7D)   ; Fetch the next address within the Keyword Conversion Buffer.
;       LD   DE,$FD74     ; Fetch the start address of the Keyword Conversion Buffer.
;       AND  A            ;
;       SBC  HL,DE        ; HL=Length of the keyword (excluding leading or trailing spaces).
;       EX   DE,HL        ; DE=Length of the keyword (excluding leading or trailing spaces).
;       LD   HL,($FD85)   ; BC=Count of the number of characters in the typed BASIC line until the error marker location was found.
;       SBC  HL,DE        ; Subtract the number of characters in the keyword text.
;       LD   B,H          ;
;       LD   C,L          ; Transfer the result to BC, and then return via the instructions at $3ED1 (ROM 0) onwards.]

        ld      bc,($fdb1)      ; Count of the number of characters in the typed BASIC line until the error marker location was found.
        ld      hl,($fdb3)      ; Count of the number of characters in the tokenized BASIC line until the error marker location.
        and     a
      IF garry
        defb    0, 0
      ELSE
        sbc     hl,bc
      ENDIF
        jr      nc,l20bd        ; Jump if the tokenized version is longer than the typed version.
        ld      bc,($fdb3)      ; Count of the number of characters in the tokenized version of the BASIC line until the error marker location.

l20bd   ld      hl,($fdb7)      ; Fetch the saved stack pointer.
        ld      sp,hl           ; Restore the stack pointer.
        scf                     ; Set the carry flag to indicate the error marker has been located.
        ret                     ; Return back to the top level calling routine, to $2D2A (ROM 0).

;The error marker has not yet been reached

l20c3   scf                     ; Set the carry flag to indicate error marker locating mode.
        jr      l20c8           ; Jump ahead to continue.

;Tokenizing the BASIC line

l20c6   scf
        ccf                     ; Reset carry flag to signal BASIC line tokenizing mode.

l20c8   call    l05a7           ; Use Normal RAM Configuration (physical RAM bank 0).
        jr      nc,l20da        ; Jump if tokenizing the BASIC line.

;Searching for the error marker so need to consider embedded floating point numbers

; [*BUG* - This should fetch the next character from the tokenized BASIC line and not the current character. This routine
;          is called to process every visible character in the BASIC line, but is not called for embedded floating point numbers.
;          It must therefore test whether the current character is followed by an embedded floating point number and if so to skip
;          over it. The routine does make an attempt to detect embedded floating point numbers but incorrectly performs the test
;          on the visible character and not the character that follows it. The bug can be fixed as replacing the LD A,(HL) instruction
;          with the following instructions. Credit: Paul Farrow.
;
;       INC  HL           ; Advance to the next character in the tokenized BASIC line.
;       LD   A,(HL)       ; Fetch the next character in the tokenized BASIC line.
;       DEC  HL           ; Point back to the current character in the tokenized BASIC line.]

        ld      a,(hl)          ; Fetch the current character in the tokenized BASIC line.
        ex      de,hl           ; DE=Insert position within the tokenized BASIC line.
        cp      $0e             ; Is it the 'number' marker?
        jr      nz,l20f0        ; Jump ahead if not.
        inc     de              ; Skip over the 5 byte hidden number representation.
        inc     de              ; [*BUG* - There should be another INC DE instruction here to take into account the character that the tokenizer would
        inc     de              ; have inserted. As a result, the attempt to locate the error marker location will drift off by one byte for every numeric
        inc     de              ; literal within the BASIC statement, and if there are many numeric literals in the statement then the error marker location
        inc     de              ; may never be found before the end of the statement is parsed. Credit: Ian Collier (+3), Andrew Owen (128)]
        jr      l20f0           ; Jump ahead to continue.

;Come here if tokenizing the BASIC line

l20da   push    af              ; Save the character to insert and the carry flag reset.
        ld      bc,$0001        ; Request to insert 1 byte.
        push    hl
        push    de
        call    l20f9           ; Check that there is memory available for 1 byte,
        pop     de              ; automatically producing error '4' if not.
        pop     hl
        ROM3    o1664           ; $1664. Update all system variables due to the insertion. Exit with DE pointing to old STKEND position, BC with number of bytes 'shifted'.
        ld      hl,(STKEND)     ; STKEND. Fetch the start of the spare memory.
        ex      de,hl           ; DE=Address of spare memory. HL=Address of character in the BASIC line.
        lddr                    ; Shift up all affected bytes to make the room for the new character.
        pop     af              ; Retrieve the character to insert and the flags. The carry flag will be reset and hence will indicate that tokenizing the BASIC line is not complete.
        ld      (de),a          ; Store the character in the BASIC line workspace.

l20f0   inc     de              ; Advance to the next character in the BASIC line.
        call    l05cc           ; Use Workspace RAM configuration (physical RAM bank 7).
        ld      ($fdae),de      ; Store the address of the next insertion position within the BASIC line workspace.
        ret

; ------------------
; Room for BC Bytes?
; ------------------
; Test whether there is room for the specified number of bytes in the spare memory,
; producing error "4 Out of memory" if not.
; Entry: BC=Number of bytes required.
; Exit : Returns if the room requested room is available else an error '4' is produced.

l20f9   ld      hl,(STKEND)     ; STKEND.
        add     hl,bc           ; Would adding the specified number of bytes overflow the RAM area?
        jr      c,l2109         ; Jump to produce an error if so.
        ex      de,hl           ; DE=New end address.
        ld      hl,$0082        ; Would there be at least 130 bytes at the top of RAM?
        add     hl,de
        jr      c,l2109         ; Jump to produce an error if not.
        sbc     hl,sp           ; If the stack is lower in memory, would there still be enough room?
        ret     c               ; Return if there would.

l2109   ld      a,$03
        ld      (ERR_NR),a      ; ERR_NR. Signal error "4 Out of Memory".
        ROM1    m25cb           ; Jump to error handler routine.

; ----------------
; Identify Keyword
; ----------------
; This routine identifies the string within the Keyword Conversion Buffer and returns
; the token character code. The last character of the string has bit 7 set.
; The routine attempts to identify 48K mode keywords, 128K mode keywords and a number of
; mis-spelled keywords (those that require a space within them).
; Exit: Carry flag set if a keyword was identified.
;       A=Token character code.

l2113   call    l142d           ; setup token routines in RAM
        call    $fd43           ; Attempt to identify 48K mode keyword.
        ret     c               ; Return if keyword identified.

;Attempt to identify 128K mode keywords and mis-spelled keywords.

        ld      b,$f9           ; Base character code (results in codes $F9-$FF).
        ld      de,$fda0        ; DE=Address of Keyword Conversion Buffer.
        ld      hl,l168e        ; HL=Keywords string table.
        call    $fd5c           ; Attempt to identify 128K mode/mis-spelled keyword.
        ret     nc              ; Return if no keyword identified.

;Attempt to convert mis-spelled keywords

        cp      $ff             ; Was it "CLOSE#"?
        jr      nz,l212e
        ld      a,$d4           ; Use character code for 'CLOSE #'.
        jr      l2150           ; Jump ahead to continue.

l212e   cp      $fe             ; Was it "OPEN#"?
        jr      nz,l2136        ; Jump if not.
        ld      a,$d3           ; Use character code for 'OPEN #'.
        jr      l2150           ; Jump ahead to continue.

l2136   cp      $fd             ; Was it "DEFFN"?
        jr      nz,l213e        ; Jump if not.
        ld      a,$ce           ; Use character code for 'DEF FN'.
        jr      l2150           ; Jump ahead to continue.

l213e   cp      $fc             ; Was it "GOSUB"?
        jr      nz,l2146        ; Jump if not.
        ld      a,$ed           ; Use character code for 'GO SUB'.
        jr      l2150           ; Jump ahead to continue.

l2146   cp      $fb             ; Was it "GOTO"?
        jr      nz,l214e        ; Jump if not.
        ld      a,$ec           ; Use character code for 'GO TO'.
        jr      l2150           ; Jump ahead to continue.

l214e   sub     $56             ; Reduce to $A3 for 'SPECTRUM' and $A4 for 'PLAY'.

l2150   scf                     ; Signal keyword identified.
        ret

; Subroutine to transfer a counted string (minus count) from (HL) to (DE)

l2152   ld      b,(hl)          ; get count
        inc     hl
l2154   ld      a,(hl)
        ld      (de),a          ; transfer a byte
        inc     de
        inc     hl
        djnz    l2154           ; back for more
        ret

; Subroutine to check if char in A is a digit. If so, carry set & A=value
; [Never called by this ROM]

l215b   cp      '0'
        ccf
        ret     nc              ; exit if less than "0"
        cp      ':'
        ret     nc              ; or if > "9"
        sub     '0'             ; convert to value
        scf                     ; success
        ret

; Subroutine to perform a routine found with a table lookup
; The value to look for is in A, and the table address is in HL
; The table consists of:
;   a number of entries byte
;   for each entry: a value byte followed by a routine address
; When a match is found, the routine is called. A is tested for
; zero before returning, carry status is preserved and should be
; set by the routine if action succeeded.
; If no match is found, carry is reset.

l2166   push    bc              ; save registers
        push    de
        ld      b,(hl)          ; B=# entries in table
        inc     hl
l216a   cp      (hl)            ; check next entry
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=address associated with current entry
        jr      z,l2179         ; if match, move on
        inc     hl
        djnz    l216a           ; loop back for more
        scf
        ccf                     ; clear carry to signal "no match"
        pop     de              ; restore registers
        pop     bc
        ret
l2179   ex      de,hl           ; HL=address
        pop     de              ; restore registers
        pop     bc
        call    l2186           ; call routine address in HL
        jr      c,l2183         ; if carry set, go to test A & set carry
        cp      a               ; test A (& clear carry)
        ret
l2183   cp      a               ; test A
        scf                     ; set carry
        ret
l2186   jp      (hl)

    IF garry
l2187   push    af
        push    hl
        ld      a, (ATTR_P)
        push    af
        ld      a, (BORDCR)
        ld      (ATTR_P), a
        ROM3    o0D6E
        ld      a, $fd
        ROM3    o1601
        pop     af
        ld      (ATTR_P), a
        pop     hl
l21a0   ld      a, (hl)
        inc     hl
        cp      $ff
        jr      z, l21a9
        rst     $10
        jr      l21a0
l21a9   pop     af
        jr      z, l21bb
        call    l1871
l21af   push    de
        ROM3    o0D6E
        ld      a, $fe
        ROM3    o1601
        pop     de
        ld      a, e
        ret
l21bb   call    l1871
        and     $df
        ld      e, 0
        cp      $43
        jr      z, l21af
        inc     e
        cp      $52
        jr      z, l21af
        inc     e
        cp      $49
        jr      z, l21af
        jr      l21bb
    ELSE
      IF spanish
l2187   push    hl
        push    de
        push    af
        ld      a,(ATTR_P)
        push    af
        ld      a,(BORDCR)
        ld      (ATTR_P),a
        ROM3    o0D6E
        ld      a,$fd
        ROM3    o1601
        pop     af
        ld      (ATTR_P),a
        pop     af
        pop     de
        pop     bc
        jr      z,l21eb
        ld      hl, msg1
        push    af
        call    x21df
        pop     af
        rst     $10
        ld      hl, msg2
        call    x21df
        call    l1871
x21d3   push    de
        ROM3    o0D6E
        ld      a,$fe
        ROM3    o1601
        pop     de
        ld      a,e
        ret
x21df   ld      a,(hl)
        bit     7,a
        push    af
        and     $7f
        rst     $10
        pop     af
        ret     nz
        inc     hl
        jr      x21df
l21eb   ld      hl, msg3
        call    x21df
        ld      a,c
        rst     $10
        ld      a,':'
        rst     $10
        ld      c,b
        ld      b,$00
        push    bc
        pop     hl
        add     hl,hl
        ld      bc, msg4
        add     hl,bc
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
        ld      a,(hl)
        cp      $03
        jr      nc,l2213
        call    x224f
        cp      $02
        jr      nz,l2213
        call    l2261
l2213   ld      a,(ATTR_T)
        push    af
        and     $38
        cp      $20
        jr      nc,l2221
        ld      e,$05
        jr      l2223
l2221   ld      e,$02
l2223   pop     af
        push    af
        and     $f8
        or      e
        ld      (ATTR_T),a
        call    x21df
        pop     af
        ld      (ATTR_T),a
        ld      hl, msg5
        call    x21df
l2238   call    l1871
        and     $df
        ld      e,$00
        cp      'C'
        jr      z,x21d3
        inc     e
        cp      'R'
        jr      z,x21d3
        inc     e
        cp      'I'
        jr      z,x21d3
        jr      l2238
x224f   push    af
        push    de
        push    hl
        ld      hl, msg6
        call    x21df
        ld      a,d
        call    l2275
        pop     hl
        pop     de
        pop     af
        inc     hl
        ret
l2261   push    af
        push    de
        push    hl
        ld      hl, msg7
        call    x21df
        ld      a,e
        call    l2275
        ld      a,$0d
        rst     $10
        pop     hl
        pop     de
        pop     af
        ret
l2275   ld      e,$00
l2277   sub     $64
        jr      c,l227e
        inc     e
        jr      l2277
l227e   add     a,$64
        call    l2295
        ld      e,$00
l2285   sub     $0a
        jr      c,l228c
        inc     e
        jr      l2285
l228c   add     a,$0a
        call    l2295
        add     a,$30
        rst     $10
        ret
l2295   push    af
        ld      a,e
        add     a,$30
        rst     $10
        pop     af
        ret
msg4    defw    msg8
        defw    msg9
        defw    msg10
        defw    msg11
        defw    msg12
        defw    msg13
        defw    msg14
        defw    msg15
        defw    msg16
        defw    msg17
msg3    defb    $16, $00, $00
        defm    "UNIDAD", ' '+$80
msg6    defm    " PISTA", ' '+$80
msg7    defm    " SECTOR", ' '+$80
msg5    defm    $5d, "REINTENTAR, IGNORAR O CANCELAR", '?'+$80
msg8    defm    $0d, "NO PREPARADA", $0d+$80
msg9    defm    $0d, "DISCO PROTEGIDO CONTRA ESCRITUR", 'A'+$80
msg10   defm    $01, $0d, "FALLO DE BUSQUEDA", $0d+$80
msg11   defm    $02, "ERROR DE DATOS", $0d+$80
msg12   defm    $02, "SIN DATOS", $0d+$80
msg13   defm    $02, "FALTA MARCA DE DIRECCIONES", $0d+$80
msg14   defm    $0d, "FORMATO INCORRECTO", $0d+$80
msg15   defm    $02, "ERROR DESCONOCIDO", $0d+$80
msg16   defm    $0d, "DISCO CAMBIADO; SUSTITUYALO", $0d+$80
msg17   defm    $0d, "DISCO NO ADECUADO", $0d+$80
msg1    defm    "Introduzca en la unidad el discopara", ' '+$80
msg2    defm    " y luego pulse una tecl", 'a'+$80
      ELSE

; Routine called from ROM 2 to display an error message in HL
; On entry Z is set if DE contains a response key list to use

l2187   jr      z,l218c
        ld      de,$0000        ; no response list
l218c   push    de
        push    hl
        ld      a,$fd
        ROM3    o1601           ; open channel to stream -3
        pop     hl
        push    hl
l2195   ld      b,$20           ; 32 chars per line
l2197   ld      a,(hl)          ; get next char
        cp      ' '
        jr      nz,l219e
        ld      d,h             ; if space, set DE to current position
        ld      e,l
l219e   cp      $ff
        jr      z,l21ab         ; move on if end of message
        inc     hl
        djnz    l2197           ; loop back for more
        ex      de,hl
        ld      a,$0d
        ld      (hl),a          ; insert a CR at last space
        jr      l2195           ; back for more lines
l21ab   ld      a,$16           ; start at 0,0 in stream -3
        rst     $10
        ld      a,$00
        rst     $10
        ld      a,$00
        rst     $10
        pop     hl              ; restore message start
l21b5   ld      a,(hl)          ; get next char
        cp      $ff
        jr      z,l21be         ; move on if end
        rst     $10             ; output char
        inc     hl
        jr      l21b5           ; back for more
l21be   call    l1871           ; get a key
        ld      b,a             ; B=key
        pop     hl              ; restore response key list
        ld      a,h
        or      l
        push    hl
        jr      z,l21d3         ; move on if none required
l21c8   ld      a,(hl)
        cp      b
        jr      z,l21d3         ; move on if response key found
        inc     hl
        cp      $ff
        jr      nz,l21c8        ; loop back if more possibilities to check
        jr      l21be           ; else get another key
l21d3   push    af
        ROM3    o0D6E           ; clear lower screen
        ld      a,$fe
        ROM3    o1601           ; open channel to stream -2
        pop     af
        pop     hl
        ret
      ENDIF
    ENDIF

    IF garry
        defw    l2562
        defw    l23f1
        defw    l24bd
        defw    l24e8
        defw    l254b
        defw    l2563
        defw    l2692
        defw    l2a49
        defw    l2569
        defw    l2584
        defw    l25be
        defw    l25db
        defw    l25ec
        defw    l2a16
        defw    l269f
        defw    l2739
        defw    l273f
        defw    l274c
        defw    l275c
        defw    l2767
        defw    l2772
        defw    l277d
        defw    l261c
        defw    l267c
        defw    l2ab9
        defw    l2788
        defw    l26a3
        defw    l2793
        defw    l27ac
        defw    l27b7
        defw    l2286
        defw    l2296
        defw    l2624
        defw    l2449
        defw    l2562
        defw    l24bd
        defw    l24e8
        defw    l254b
        defw    l2563
        defw    l2562
        defw    l2a49
        defw    l2562
        defw    l2562
        defw    l25be
        defw    l25db
        defw    l2562
        defw    l2423
        defw    l269f
        defw    l2739
        defw    l22de
        defw    l22de
        defw    l22de
        defw    l22de
        defw    l22de
        defw    l22de
        defw    l2562
        defw    l2562
        defw    l22de
        defw    l2562
        defw    l22de
        defw    l22de
        defw    l2562
        defw    l22de
        defw    l2254
        defw    l2562

l2254   set     7, (ix+$1a)     ; set freeze flag
        ret
l2259   ld      hl, (CURCHL)
        ld      de, 77
        add     hl, de
        ret
l2261   call    l2259
        ld      bc, $00ff
        bit     7, (ix+$1c)
        ret     nz
l226c   ld      a, (ix+$18)
        bit     4, (ix+$1a)
        jr      z, l2277
        srl     a
l2277   ld      c, a
        inc     c
        ret
l227a   push    af
        push    bc
        push    de
        push    hl
        call    l27d0
        pop     hl
        pop     de
        pop     bc
        pop     af
        ret
l2286   and     $03
        cp      $03
        ret     z
        ld      b, a
        ld      a, (ix+$1c)
        and     $fc
        or      b
        ld      (ix+$1c), a
        ret
l2296   res     7, (ix+$1c)
        rra
        ret     nc
        set     7, (ix+$1c)
        ret
l22a1   ld      ix, (CURCHL)
        ld      (ix+$23), a
        bit     2, (ix+$1a)
        jr      nz, l22c0
        cp      $a5
        jr      c, l22c0
        sub     $a5
l22b4   ld      hl, (RETADDR)
        push    hl
        ROM3    o0C10
        pop     hl
        ld      (RETADDR), hl
        ret
l22c0   bit     6, (ix+$1a)
        res     6, (ix+$1a)
        jr      nz, l22f5
        bit     7, (ix+$1a)
        res     7, (ix+$1a)
        jr      nz, l2286
        cp      $20
        jr      nc, l22e9
        ld      hl, $2214
        jp      l27e4
l22de   bit     7, (ix+$1c)
        ret     z
        set     6, (ix+$1a)
        jr      l22f5
l22e9   cp      $20
        jr      nz, l22f5
        call    l2468
        ld      a, (ix+$1e)
        and     a
        ret     z
l22f5   call    l2259
        ld      e, (ix+$1d)
        add     hl, de
        ld      a, (ix+$23)
        ld      (hl), a
        inc     (ix+$1d)
        call    l2468
        ld      a, (ix+$1d)
        cp      $ff
        jr      z, l2314
        call    l226c
        cp      (ix+$1e)
        ret     nc
l2314   call    l2468
l2317   call    l226c
        cp      (ix+$1e)
        jr      nc, l2359
        cp      (ix+$20)
        jr      c, l2338
        ld      a, (ix+$20)
        cp      $01
        ld      a, (ix+$1f)
        jr      z, l2331
        and     a
        jr      z, l2338
l2331   ld      c, a
        inc     c
        ld      b, (ix+$20)
        jr      l235f
l2338   call    l2259
        ld      bc, 0
l233e   ld      a, (hl)
        call    l227a
        inc     hl
        inc     c
        ld      a, (ix+$17)
        bit     4, (ix+$1a)
        jr      z, l2354
        inc     a
        cp      (ix+$18)
        jr      z, l23d2
        dec     a
l2354   and     a
        jr      nz, l233e
        jr      l23d2
l2359   ld      c, (ix+$1d)
        ld      b, (ix+$1e)
l235f   ld      a, c
        and     a
        ret     z
        call    l2259
        ld      a, (ix+$1c)
        and     $03
        jr      z, l239a
        push    bc
        call    l226c
        pop     bc
        sub     b
        ld      e, a
        ld      a, (ix+$1c)
        and     $02
        jr      nz, l238a
        ld      a, e
        srl     a
l237d   and     a
        jr      z, l239a
        push    af
        ld      a, $20
        call    l227a
        pop     af
        dec     a
        jr      l237d
l238a   push    bc
        push    hl
        ld      d, 0
l238e   ld      a, (hl)
        inc     hl
        cp      $20
        jr      nz, l2395
        inc     d
l2395   dec     c
        jr      nz, l238e
l2398   pop     hl
        pop     bc
l239a   ld      b, 0
        push    bc
        push    hl
l239e   ld      a, (hl)
        call    l227a
        cp      $20
        jr      nz, l23c5
        ld      a, (ix+$1c)
        and     $02
        jr      z, l23c5
        ld      a, e
        ld      b, 0
l23b0   sub     d
        jr      c, l23b6
        inc     b
        jr      l23b0
l23b6   dec     d
        ld      a, b
        and     a
        jr      z, l23c5
        ld      a, e
        sub     b
        ld      e, a
l23be   ld      a, $20
        call    l227a
        djnz    l23be
l23c5   inc     hl
        dec     c
        jr      nz, l239e
        ld      a, (ix+$17)
        and     a
        call    nz, l2a16
        pop     hl
        pop     bc
l23d2   push    bc
        call    l2261
        ex      de, hl
        pop     hl
        push    hl
        add     hl, de
        ldir
        pop     bc
        ld      a, (ix+$1d)
        sub     c
        ld      (ix+$1d), a
        jr      z, l2415
        call    l2259
        ld      c, 1
        ld      a, (hl)
        cp      $20
        jr      z, l23d2
        ret
l23f1   call    l2261
        push    bc
        call    l3fb0
        pop     bc
        ld      l, (ix+$0b)
        ld      h, (ix+$0c)
        add     hl, bc
        ld      (ix+$0b), l
        ld      (ix+$0c), h
        res     6, (ix+$1a)
        res     7, (ix+$1a)
        ld      a, (ix+$17)
        and     a
        call    nz, l2a16
l2415   ld      (ix+$1d), 0
        ld      hl, l22a1
l241c   ld      (ix+$05), l
        ld      (ix+$06), h
        ret
l2423   call    l2468
        ld      a, (ix+$1d)
        push    af
l242a   ld      a, (ix+$1c)
        push    af
        res     1, (ix+$1c)
        call    l2317
        pop     af
        ld      (ix+$1c), a
        ld      a, (ix+$1d)
        and     a
        jr      nz, l242a
        pop     af
        and     a
        ret     nz
        call    l25be
        ret     c
        jp      l2a49
l2449   call    l2423
        call    l2261
        push    bc
        call    l3f78
        pop     bc
        ld      l, (ix+$0b)
        ld      h, (ix+$0c)
        and     a
        sbc     hl, bc
        ld      (ix+$0b), l
        ld      (ix+$0c), h
        ld      hl, l27d0
        jr      l241c
l2468   call    l2259
        ld      d, 0
        ld      e, d
        ld      (ix+$1f), d
        ld      c, d
        ld      b, (ix+$1d)
        ld      a, b
        and     a
        jr      z, l24af
l2479   ld      a, (hl)
        cp      $20
        jr      c, l24b6
        jr      nz, l2486
        dec     d
        ld      (ix+$1f), d
        inc     d
        ld      c, e
l2486   inc     e
        cp      $21
        jr      z, l249f
        cp      $2e
        jr      z, l249f
        cp      $2c
        jr      z, l249f
        cp      $3f
        jr      z, l249f
        cp      $3a
        jr      z, l249f
        cp      $3b
        jr      nz, l24ab
l249f   push    bc
        call    l226c
        pop     bc
        cp      e
        jr      c, l24ab
        ld      (ix+$1f), d
        ld      c, e
l24ab   inc     d
        inc     hl
        djnz    l2479
l24af   ld      (ix+$1e), e
        ld      (ix+$20), c
        ret
l24b6   inc     d
        inc     hl
        dec     b
        jr      z, l24af
        jr      l24ab
l24bd   bit     3, (ix+$1a)
        jr      nz, l24e2
        call    l252a
        ld      hl, (CURCHL)
        ld      e, (ix+$0b)
        ld      d, (ix+$0c)
        add     hl, de
        push    bc
        push    de
        call    l3fb0
        pop     hl
        pop     bc
        add     hl, bc
        ld      (ix+$0b), l
        ld      (ix+$0c), h
        set     3, (ix+$1a)
l24e2   ld      (ix+$24), 2
        jr      l24f1
l24e8   bit     3, (ix+$1a)
        ret     z
        ld      (ix+$24), 1
l24f1   exx
        push    hl
        push    de
        ld      hl, (CURCHL)
        ld      e, (ix+$0b)
        ld      d, (ix+$0c)
        add     hl, de
        exx
        call    l26aa
        exx
        pop     de
        ex      (sp), hl
        exx
        pop     hl
        ld      a, (ix+$24)
        dec     a
        ret     nz
        push    hl
        call    l252a
        pop     hl
        push    bc
        call    l3f78
        ld      l, (ix+$0b)
        ld      h, (ix+$0c)
        pop     bc
        and     a
        sbc     hl, bc
        ld      (ix+$0b), l
        ld      (ix+$0c), h
        res     3, (ix+$1a)
        ret
l252a   ld      a, (ix+$0f)
        sub     (ix+$0d)
        inc     a
        ld      e, a
        ld      d, 0
        ld      a, (ix+$10)
        sub     (ix+$0e)
        inc     a
        ld      hl, 0
l253e   add     hl, de
        dec     a
        jr      nz, l253e
        ld      e, l
        ld      d, h
        add     hl, hl
        add     hl, hl
        add     hl, hl
        add     hl, de
        push    hl
        pop     bc
        ret
l254b   ld      a, (ix+$0e)
l254e   add     a, a
        add     a, a
        add     a, a
        ld      (ix+$12), a
        ld      a, (ix+$0d)
        ld      (ix+$11), a
        ld      (ix+$16), 0
        ld      (ix+$17), 0
l2562   ret
l2563   ld      a, (ix+$10)
        inc     a
        jr      l254e
l2569   ld      a, (ix+$17)
        and     a
        ret     z
        dec     (ix+$17)
        ld      a, (ix+$16)
        sub     (ix+$13)
        ld      (ix+$16), a
        ret     nc
        add     a, $08
        ld      (ix+$16), a
        dec     (ix+$11)
        ret
l2584   ld      a, (ix+$17)
        inc     a
        cp      (ix+$18)
        ret     nc
        ld      (ix+$17), a
        ld      a, (ix+$16)
        add     a, (ix+$13)
        ld      (ix+$16), a
        cp      $08
        ret     c
        sub     $08
        ld      (ix+$16), a
        inc     (ix+$11)
        ret
l25a4   ld      a, (ix+$12)
        add     a, $08
        bit     6, (ix+$1c)
        ret     z
        dec     a
        dec     a
        ret
l25b1   ld      a, (ix+$12)
        sub     $08
        bit     6, (ix+$1c)
        ret     z
        inc     a
        inc     a
        ret
l25be   ld      a, (ix+$10)
        add     a, a
        add     a, a
        add     a, a
        inc     a
        ld      b, a
        ld      a, (ix+$12)
        add     a, $08
        bit     6, (ix+$1c)
        jr      z, l25d5
        dec     a
        dec     a
        inc     b
        inc     b
l25d5   cp      b
        ret     nc
        ld      (ix+$12), a
        ret
l25db   ld      a, (ix+$0e)
        add     a, a
        add     a, a
        add     a, a
        ld      b, a
        call    l25b1
        ret     c
        cp      b
        ret     c
        ld      (ix+$12), a
        ret
l25ec   ld      a, (ix+$0e)
        add     a, a
        add     a, a
        add     a, a
        ld      b, a
        ld      a, (ix+$12)
        sub     b
        ld      (ix+$21), a
        ld      a, (ix+$17)
        and     a
        jr      nz, l260b
        call    l25b1
        sub     b
        ret     c
        ld      (ix+$21), a
        ld      a, (ix+$18)
l260b   dec     a
        push    af
        ld      (ix+$23), a
        call    l2624
        call    l2666
        pop     af
        ld      (ix+$23), a
        jr      l2624
l261c   ld      (ix+$21), a
        ld      (ix+$1b), $20
        ret
l2624   ld      a, (ix+$10)
        sub     (ix+$0e)
        inc     a
        add     a, a
        add     a, a
        add     a, a
        dec     a
        cp      (ix+$21)
        ret     c
        ld      a, (ix+$23)
        cp      (ix+$18)
        ret     nc
        ld      (ix+$17), a
        ld      b, a
        inc     b
        ld      a, (ix+$0e)
        add     a, a
        add     a, a
        add     a, a
        add     a, (ix+$21)
        ld      (ix+$12), a
        ld      c, (ix+$0d)
        ld      a, 0
l2650   dec     b
        jr      z, l265f
        add     a, (ix+$13)
        cp      $08
        jr      c, l2650
        sub     $08
        inc     c
        jr      l2650
l265f   ld      (ix+$11), c
        ld      (ix+$16), a
        ret
l2666   push    af
        ld      (ix+$23), $20
        ld      a, (ix+$1a)
        push    af
        res     4, (ix+$1a)
        call    l2800
        pop     af
        ld      (ix+$1a), a
        pop     af
        ret
l267c   ld      b, (ix+$18)
l267f   sub     b
        jr      nc, l267f
        add     a, b
        ld      c, (ix+$17)
        sub     c
        jr      nc, l268a
        add     a, b
l268a   and     a
        ret     z
        call    l2666
        dec     a
        jr      l268a
l2692   ld      a, (ix+$18)
        srl     a
        cp      (ix+$17)
        jr      nc, l267c
        xor     a
        jr      l267c
l269f   call    l254b
        xor     a
l26a3   ld      (l26e0+1), a
        ld      (ix+$24), 0
l26aa   ld      c, (ix+$0d)
        ld      b, (ix+$0e)
        call    l2abd
        ex      de, hl
        ld      a, (ix+$10)
        sub     (ix+$0e)
        inc     a
        ld      c, a
l26bc   push    hl
        ld      a, (ix+$0f)
        sub     (ix+$0d)
        inc     a
        ld      b, a
l26c5   push    bc
        push    hl
        ld      b, 8
l26c9   ld      a, (ix+$24)
        and     a
        jr      z, l26e0
        exx
        dec     hl
        dec     a
        jr      z, l26db
        exx
        ld      a, (hl)
        exx
        ld      (hl), a
        exx
        jr      l26e2
l26db   ld      a, (hl)
        exx
        ld      (hl), a
        jr      l26e2
l26e0   ld      (hl), 0
l26e2   inc     h
        djnz    l26c9
        pop     hl
        pop     bc
        inc     hl
        djnz    l26c5
        pop     hl
        ld      a, l
        add     a, $20
        ld      l, a
        jr      nc, l26f5
        ld      a, h
        add     a, 8
        ld      h, a
l26f5   dec     c
        jr      nz, l26bc
l26f8   ld      c, (ix+$0d)
        ld      b, (ix+$0e)
        call    l2abd
        ld      de, 32
        ld      a, (ix+$10)
        sub     (ix+$0e)
        inc     a
        ld      c, a
l270c   push    hl
        ld      a, (ix+$0f)
        sub     (ix+$0d)
        inc     a
        ld      b, a
l2715   ld      a, (ix+$24)
        and     a
        jr      z, l272c
        exx
        dec     hl
        dec     a
        jr      z, l2727
        exx
        ld      a, (hl)
        exx
        ld      (hl), a
        exx
        jr      l2730
l2727   ld      a, (hl)
        exx
        ld      (hl), a
        jr      l2730
l272c   ld      a, (ix+$19)
        ld      (hl), a
l2730   inc     hl
        djnz    l2715
        pop     hl
        add     hl, de
        dec     c
        jr      nz, l270c
        ret
l2739   ld      (ix+$24), 0
        jr      l26f8
l273f   and     $07
        ld      b, a
        ld      a, (ix+$19)
        and     $f8
        or      b
        ld      (ix+$19), a
        ret
l274c   and     $07
        add     a, a
        add     a, a
        add     a, a
        ld      b, a
        ld      a, (ix+$19)
        and     $c7
        or      b
        ld      (ix+$19), a
        ret
l275c   res     7, (ix+$19)
        rra
        ret     nc
        set     7, (ix+$19)
        ret
l2767   res     6, (ix+$19)
        rra
        ret     nc
        set     6, (ix+$19)
        ret
l2772   res     0, (ix+$1a)
        rra
        ret     nc
        set     0, (ix+$1a)
        ret
l277d   res     1, (ix+$1a)
        rra
        ret     nc
        set     1, (ix+$1a)
        ret
l2788   res     2, (ix+$1a)
        rra
        ret     nc
        set     2, (ix+$1a)
        ret
l2793   call    l254b
        ld      a, (ix+$10)
        sub     (ix+$0e)
        inc     a
        ld      c, a
l279e   ld      b, (ix+$18)
l27a1   push    bc
        call    l2800
        pop     bc
        djnz    l27a1
        dec     c
        jr      nz, l279e
        ret
l27ac   res     4, (ix+$1a)
        rra
        ret     nc
        set     4, (ix+$1a)
        ret
l27b7   res     5, (ix+$1a)
        rra
        jr      nc, l27c2
        set     5, (ix+$1a)
l27c2   res     6, (ix+$1c)
        rra
        ret     nc
        set     6, (ix+$1c)
        ret
        defb    0, 0, 0
l27d0   ld      ix, (CURCHL)
        ld      (ix+$23), a
        ld      a, (ix+$1b)
        and     a
        jr      z, l27f1
        ld      (ix+$1b), 0
l27e1   ld      hl, $21d2
l27e4   ld      e, a
        ld      d, 0
        add     hl, de
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ex      de, hl
        ld      a, (ix+$23)
        jp      (hl)
l27f1   ld      a, (ix+$23)
        cp      $20
        jr      nc, l2800
        cp      $10
        jr      c, l27e1
        ld      (ix+$1b), a
        ret
l2800   bit     2, (ix+$1a)
        jr      nz, l280e
        ld      a, (ix+$23)
        sub     $a5
        jp      nc, l22b4
l280e   ld      a, (ix+$23)
        ld      h, 0
        ld      l, a
        add     hl, hl
        add     hl, hl
        add     hl, hl
        cp      $80
        jr      c, l284a
        cp      $90
        jr      nc, l283d
        ld      e, a
        push    ix
        pop     hl
        ld      bc, 69
        add     hl, bc
        push    hl
        ld      a, (ix+$13)
        ld      c, a
        srl     c
        sub     c
        ld      b, a
        dec     b
        dec     c
        push    bc
        call    l2aeb
        pop     bc
        call    l2aeb
        pop     hl
        jr      l285c
l283d   ld      de, (UDG)
        add     hl, de
        ld      de, $0480
        and     a
        sbc     hl, de
        jr      l285c
l284a   ld      c, (ix+$14)
        ld      b, (ix+$15)
        ld      a, b
        and     $c0
        jr      nz, l285b
        ld      de, l285c
        push    de
        push    bc
        ret
l285b   add     hl, bc
l285c   ld      (ix+$22), 1
        bit     4, (ix+$1a)
        jr      z, l28e4
        ex      de, hl
        push    ix
        pop     hl
        ld      bc, 37
        add     hl, bc
        ld      b, 8
l2870   push    bc
        ld      b, (ix+$13)
        srl     b
        jr      c, l2893
        push    bc
        ld      (hl), 1
        ld      a, (de)
l287c   rla
        push    af
        rl      (hl)
        pop     af
        rl      (hl)
        djnz    l287c
        jr      c, l288b
l2887   rl      (hl)
        jr      nc, l2887
l288b   ld      bc, 8
        add     hl, bc
        ld      (hl), 1
        jr      l28af
l2893   push    bc
        ld      (hl), 1
        ld      a, (de)
l2897   rla
        push    af
        rl      (hl)
        pop     af
        rl      (hl)
        djnz    l2897
        rla
        push    af
l28a2   rl      (hl)
        jr      nc, l28a2
        ld      bc, 8
        add     hl, bc
        ld      (hl), 1
        pop     af
        rl      (hl)
l28af   pop     bc
l28b0   rla
        push    af
        rl      (hl)
        pop     af
        rl      (hl)
        djnz    l28b0
        jr      c, l28bf
l28bb   rl      (hl)
        jr      nc, l28bb
l28bf   ld      bc, 7
        and     a
        sbc     hl, bc
        inc     de
        pop     bc
        djnz    l2870
        ld      a, (ix+$17)
        inc     a
        cp      (ix+$18)
        call    z, l2a16
        push    ix
        pop     hl
        ld      bc, 37
        add     hl, bc
        call    l28e4
        push    ix
        pop     hl
        ld      bc, 45
        add     hl, bc
l28e4   bit     5, (ix+$1a)
        jr      z, l2935
        ex      de, hl
        push    ix
        pop     hl
        ld      bc, 53
        add     hl, bc
        ld      b, 8
l28f4   ld      a, (de)
        inc     de
        ld      (hl), a
        inc     hl
        ld      (hl), a
        inc     hl
        djnz    l28f4
        push    ix
        pop     hl
        ld      bc, 53
        add     hl, bc
        bit     6, (ix+$1c)
        jr      z, l290a
        inc     hl
l290a   ld      (ix+$22), 0
        call    l2935
        push    ix
        pop     hl
        ld      bc, 61
        add     hl, bc
        ld      a, (ix+$12)
        add     a, 8
        bit     6, (ix+$1c)
        jr      z, l2926
        dec     a
        dec     a
        dec     hl
l2926   ld      (ix+$12), a
        call    l2935
        call    l25b1
        ld      (ix+$12), a
        jp      l29fa
l2935   push    hl
        ld      a, (ix+$10)
        inc     a
        add     a, a
        add     a, a
        add     a, a
        inc     a
        ld      b, a
        call    l25a4
        cp      b
        jr      c, l2950
        ld      a, (ix+$12)
        sub     8
        ld      (ix+$12), a
        call    l2a49
l2950   ld      c, (ix+$11)
        ld      b, (ix+$12)
        call    l2ac2
        ld      b, (ix+$19)
        ld      (hl), b
        ld      a, (ix+$16)
        add     a, (ix+$13)
        cp      9
        jr      c, l296a
        inc     hl
        ld      (hl), b
        dec     hl
l296a   ld      a, (ix+$12)
        and     7
        jr      z, l298e
        bit     6, (ix+$1c)
        jr      z, l297b
        cp      3
        jr      c, l298e
l297b   push    de
        ld      de, 32
        add     hl, de
        pop     de
        ld      (hl), b
        ld      a, (ix+$16)
        add     a, (ix+$13)
        cp      9
        jr      c, l298e
        inc     hl
        ld      (hl), b
l298e   pop     hl
        ex      de, hl
        ld      b, (ix+$13)
        xor     a
l2994   scf
        rra
        djnz    l2994
        ld      b, a
        ld      c, 8
        bit     6, (ix+$1c)
        jr      z, l29a4
        dec     c
        dec     c
        inc     de
l29a4   push    bc
        ld      a, (de)
        inc     de
        push    de
        bit     0, (ix+$1a)
        jr      z, l29af
        cpl
l29af   and     b
        ld      d, a
        ld      c, 0
        ld      e, c
        ld      a, (ix+$16)
        and     a
        jr      z, l29c5
l29ba   rr      b
        rr      c
        rr      d
        rr      e
        dec     a
        jr      nz, l29ba
l29c5   bit     1, (ix+$1a)
        jr      z, l29d4
        ld      a, (hl)
        xor     d
        ld      (hl), a
        inc     hl			;<<<<<<<<<<< inc l
        ld      a, (hl)
        xor     e
        ld      (hl), a
        jr      l29df
l29d4   ld      a, b
        cpl
        and     (hl)
        or      d
        ld      (hl), a
        inc     hl			;<<<<<<<<<<< inc l
        ld      a, c
        cpl
        and     (hl)
        or      e
        ld      (hl), a
l29df   dec     hl			;<<<<<<<<<<< dec l
        inc     h
        ld      a, h
        and     7
        jr      nz, l29f0
        ld      a, l
        add     a, $20
        ld      l, a
        jr      c, l29f0
        ld      a, h
        sub     8
        ld      h, a
l29f0   pop     de
        pop     bc
        dec     c
        jr      nz, l29a4
        ld      a, (ix+$22)
        and     a
        ret     z
l29fa   inc     (ix+$17)
        ld      a, (ix+$16)
        add     a, (ix+$13)
        cp      8
        jr      c, l2a0c
        sub     8
        inc     (ix+$11)
l2a0c   ld      (ix+$16), a
        ld      a, (ix+$17)
        cp      (ix+$18)
        ret     c
l2a16   call    l2a3b
        bit     5, (ix+$1a)
        call    nz, l2a20
l2a20   call    l25a4
        ld      (ix+$12), a
        ld      a, (ix+$10)
        inc     a
        add     a, a
        add     a, a
        add     a, a
        cp      (ix+$12)
        ret     nc
        ld      a, (ix+$12)
        sub     8
        ld      (ix+$12), a
        jr      l2a49
l2a3b   xor     a
        ld      (ix+$16), a
        ld      (ix+$17), a
        ld      a, (ix+$0d)
        ld      (ix+$11), a
        ret
l2a49   ld      c, (ix+$0d)
        ld      b, (ix+$0e)
        call    l2abd
        ld      a, (ix+$10)
        sub     (ix+$0e)
        ld      b, a
        jr      z, l2a9c
l2a5b   push    bc
        push    de
        push    hl
        ld      a, (ix+$0f)
        sub     (ix+$0d)
        ld      b, a
        inc     b
l2a66   push    bc
        ld      bc, 32
        add     hl, bc
        ld      a, (hl)
        sbc     hl, bc
        ld      (hl), a
        push    de
        ld      b, 8
l2a72   push    de
        ld      a, e
        add     a, $20
        ld      e, a
        jr      nc, l2a7d
        ld      a, d
        add     a, 8
        ld      d, a
l2a7d   ld      a, (de)
        pop     de
        ld      (de), a
        inc     d
        djnz    l2a72
        pop     de
        inc     de
        inc     hl
        pop     bc
        djnz    l2a66
        pop     hl
        pop     de
        ld      bc, 32
        add     hl, bc
        ld      a, e
        add     a, $20
        ld      e, a
        jr      nc, l2a99
        ld      a, d
        add     a, 8
        ld      d, a
l2a99   pop     bc
        djnz    l2a5b
l2a9c   ex      de, hl
        ld      a, (ix+$0f)
        sub     (ix+$0d)
        ld      b, a
        inc     b
l2aa5   push    bc
        ld      a, (ix+$19)
        ld      (de), a
        ld      b, 8
        push    hl
l2aad   ld      (hl), 0
        inc     h
        djnz    l2aad
        pop     hl
        inc     de
        inc     hl
        pop     bc
        djnz    l2aa5
        ret
l2ab9   ld      (ix+$19), a
        ret
l2abd   ld      a, b
        add     a, a
        add     a, a
        add     a, a
        ld      b, a
l2ac2   ld      a, b
        rrca
        rrca
        rrca
        ld      l, a
        and     $18
        or      $40
        ld      d, a
        ld      a, b
        and     7
        or      d
        ld      d, a
        ld      a, b
        rlca
        rlca
        and     $e0
        or      c
        ld      e, a
            ld      a, l
            and     $1f
            ld      l, a
            ld      h, 0
            add     hl, hl
            add     hl, hl
            add     hl, hl
            add     hl, hl
            add     hl, hl
            ld      b, 0
            add     hl, bc
            ld      bc, $5800
            add     hl, bc
            ret

l2aeb   xor     a
        srl     e
        rra
l2aef   sra     a
        dec     c
        jr      nz, l2aef
        srl     e
        rra
l2af7   sra     a
        djnz    l2af7
        ld      b, 4
l2afd   ld      (hl), a
        inc     hl
        djnz    l2afd
        ret
        defs    29
l2b1f   ld      bc, $3c00
        add     hl, bc
        ex      de, hl
        ld      hl, (RETADDR)
        push    hl
        ld      hl, 69
        push    ix
        pop     bc
        add     hl, bc
        ex      de, hl
        push    de
        ld      bc, 8
        ROM3    o33C3
        pop     hl
        pop     de
        ld      (RETADDR), de
        ret
l2b3e   call    l2b1f
        sla     (ix+$45)
        sla     (ix+$46)
        sla     (ix+$47)
        sla     (ix+$48)
        sla     (ix+$49)
        sla     (ix+$4a)
        sla     (ix+$4b)
        sla     (ix+$4c)
        ret
l2b62   ld      bc, l2b95-$100
        add     hl, bc
        push    ix
        pop     de
        ld      bc, 69
        ex      de, hl
        add     hl, bc
        push    hl
        ld      b, 8
l2b71   ld      a, (de)
        inc     de
        and     $e0
        ld      (hl), a
        inc     hl
        djnz    l2b71
        pop     hl
        ret
l2b7b   ld      bc, l2b95-$100
        add     hl, bc
        push    ix
        pop     de
        ld      bc, 69
        ex      de, hl
        add     hl, bc
        push    hl
        ld      b, 8
l2b8a   ld      a, (de)
        inc     de
        add     a, a
        add     a, a
        add     a, a
        ld      (hl), a
        inc     hl
        djnz    l2b8a
        pop     hl
        ret
l2b95   defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000

        defb    %00000000
        defb    %01001000
        defb    %01001000
        defb    %01001000
        defb    %01001000
        defb    %00000000
        defb    %01001000
        defb    %00000000

        defb    %00000000
        defb    %10101010
        defb    %10101010
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000
        defb    %00000000

        defb    %00000000
        defb    %10101010
        defb    %11111111
        defb    %10101010
        defb    %10101010
        defb    %11111111
        defb    %10101010
        defb    %00000000

        defb    %00000000
        defb    %01000100
        defb    %11111110
        defb    %10010100
        defb    %11111110
        defb    %00100110
        defb    %11111110
        defb    %01000100

        defb    %00000000
        defb    %10010010
        defb    %10000010
        defb    %00100100
        defb    %01001000
        defb    %10010000
        defb    %00110010
        defb    %00100000

        defb    $00, $48, $b4, $48, $dd, $b2, $fd, $00
        defb    $00, $44, $88, $00, $00, $00, $00, $00
        defb    $00, $42, $84, $84, $84, $84, $42, $00
        defb    $00, $88, $44, $44, $44, $44, $88, $00
        defb    $00, $00, $aa, $44, $ee, $44, $aa, $00
        defb    $00, $00, $44, $44, $ee, $44, $44, $00
        defb    $00, $00, $00, $00, $00, $44, $44, $88
        defb    $00, $00, $00, $00, $ee, $00, $00, $00
        defb    $00, $00, $00, $00, $00, $cc, $cc, $00
        defb    $00, $20, $22, $42, $44, $88, $88, $00
        defb    $00, $ec, $b2, $b2, $b2, $b2, $ec, $00
        defb    $00, $4c, $c4, $44, $44, $44, $ee, $00
        defb    $00, $4c, $b2, $22, $4c, $90, $fe, $00
        defb    $00, $cc, $32, $c4, $22, $32, $cc, $00
        defb    $00, $24, $64, $ac, $b4, $fe, $24, $00
        defb    $00, $fe, $90, $dc, $22, $32, $cc, $00
        defb    $00, $6c, $90, $dc, $b2, $b2, $4c, $00
        defb    $00, $fe, $22, $44, $48, $88, $88, $00
        defb    $00, $ec, $b2, $4c, $b2, $b2, $ec, $00
        defb    $00, $4c, $b2, $b2, $6e, $22, $cc, $00
        defb    $00, $00, $00, $48, $00, $00, $48, $00
        defb    $00, $00, $44, $00, $00, $44, $44, $88
        defb    $00, $00, $22, $44, $88, $44, $22, $00
        defb    $00, $00, $00, $ee, $00, $ee, $00, $00
        defb    $00, $00, $88, $44, $22, $44, $88, $00
        defb    $00, $4c, $b2, $22, $44, $00, $44, $00
        defb    $00, $5e, $fe, $fa, $fe, $90, $ee, $00
        defb    $00, $4c, $b2, $b2, $fe, $b2, $b2, $00
        defb    $00, $dc, $b2, $dc, $b2, $b2, $dc, $00
        defb    $00, $4c, $b2, $90, $90, $b2, $4c, $00
        defb    $00, $dc, $b2, $b2, $b2, $b2, $dc, $00
        defb    $00, $fe, $90, $dc, $90, $90, $fe, $00
        defb    $00, $fe, $90, $fc, $90, $90, $90, $00
        defb    $00, $4c, $b2, $90, $f6, $b2, $4e, $00
        defb    $00, $b2, $b2, $fe, $b2, $b2, $b2, $00
        defb    $00, $ee, $44, $44, $44, $44, $ee, $00
        defb    $00, $22, $22, $22, $a2, $b2, $4c, $00
        defb    $00, $b2, $b4, $d8, $d4, $b2, $b2, $00
        defb    $00, $90, $90, $90, $90, $90, $fe, $00
        defb    $00, $b2, $fe, $fe, $f2, $b2, $b2, $00
        defb    $00, $f2, $ba, $ba, $b6, $b6, $b2, $00
        defb    $00, $4c, $b2, $b2, $b2, $b2, $4c, $00
        defb    $00, $dc, $b2, $b2, $dc, $90, $90, $00
        defb    $00, $ec, $b2, $b2, $b6, $f6, $ee, $20
        defb    $00, $fc, $b2, $b2, $dc, $d2, $b2, $00
        defb    $00, $6e, $90, $4c, $22, $32, $cc, $00
        defb    $00, $ee, $44, $44, $44, $44, $44, $00
        defb    $00, $b2, $b2, $b2, $b2, $b2, $ec, $00
        defb    $00, $aa, $aa, $aa, $aa, $aa, $44, $00
        defb    $00, $b2, $f2, $f2, $fe, $fe, $52, $00
        defb    $00, $aa, $aa, $44, $44, $aa, $aa, $00
        defb    $00, $aa, $aa, $aa, $44, $44, $44, $00
        defb    $00, $fe, $22, $44, $48, $90, $fe, $00
        defb    $00, $66, $44, $44, $44, $44, $66, $00
        defb    $00, $00, $88, $c8, $44, $62, $22, $00
        defb    $00, $cc, $44, $44, $44, $44, $cc, $00
        defb    $00, $44, $ee, $44, $44, $44, $44, $00
        defb    $00, $00, $00, $00, $00, $00, $00, $ff
        defb    $00, $4e, $b0, $9c, $f0, $90, $fe, $00
        defb    $00, $00, $cc, $22, $ee, $b2, $ee, $00
        defb    $00, $90, $90, $dc, $b2, $b2, $dc, $00
        defb    $00, $00, $6e, $90, $90, $90, $6e, $00
        defb    $00, $22, $22, $6e, $b2, $b2, $6e, $00
        defb    $00, $00, $4c, $b2, $dc, $90, $6e, $00
        defb    $00, $6c, $90, $d8, $90, $90, $90, $00
        defb    $00, $00, $6e, $b2, $b2, $6e, $22, $cc
        defb    $00, $90, $90, $dc, $b2, $b2, $b2, $00
        defb    $00, $44, $00, $4c, $44, $44, $4e, $00
        defb    $00, $22, $00, $22, $22, $22, $b2, $4c
        defb    $00, $90, $b4, $d8, $d8, $b4, $b2, $00
        defb    $00, $48, $48, $48, $48, $48, $46, $00
        defb    $00, $00, $ba, $f5, $f5, $f5, $b5, $00
        defb    $00, $00, $dc, $b2, $b2, $b2, $b2, $00
        defb    $00, $00, $4c, $b2, $b2, $b2, $4c, $00
        defb    $00, $00, $dc, $b2, $b2, $dc, $90, $90
        defb    $00, $00, $6e, $b2, $b2, $6e, $22, $22
        defb    $00, $00, $6e, $90, $90, $90, $90, $00
        defb    $00, $00, $6e, $90, $4e, $22, $dc, $00
        defb    $00, $48, $fc, $48, $48, $48, $46, $00
        defb    $00, $00, $b2, $b2, $b2, $b2, $ec, $00
        defb    $00, $00, $aa, $aa, $aa, $aa, $44, $00
        defb    $00, $00, $b1, $f5, $f5, $f5, $4a, $00
        defb    $00, $00, $aa, $aa, $44, $aa, $aa, $00
        defb    $00, $00, $b2, $b2, $b2, $6e, $22, $cc
        defb    $00, $00, $fe, $22, $44, $88, $fe, $00
        defb    $00, $66, $44, $88, $44, $44, $66, $00
        defb    $00, $44, $44, $44, $44, $44, $44, $00
        defb    $00, $cc, $44, $22, $44, $44, $cc, $00
        defb    $00, $4a, $b4, $00, $00, $00, $00, $00
        defb    $ee, $b1, $f7, $b5, $f5, $b7, $b1, $ee
        block   $36ba-$
    ELSE
; *************** START OF SELF-TEST PROGRAM SECTION ****************
; The self-test program, entered by pressing "QAZPLM" at the test screen
l21df   di                      ; disable interrupts
        ld      ix,$ffff        ; IX=top of RAM
        ld      a,$07
        out     ($fe),a         ; white border
        ld      sp,$7fff        ; set stack to top of page 5
        call    l28f7           ; initialise & show title page
        di                      ; disable interrupts
        ld      a,$07
        out     ($fe),a         ; white border
        call    l271a           ; clear screen
l21f6   ld      bc,$0700
        call    l270b           ; set INK 7, PAPER 0
        ld      hl,l3261
        call    l2703           ; display RAM test message
        call    l269a           ; pause for 0.8s
        ld      a,$04
l2207   out     ($fe),a         ; green border
        ld      de,$0002        ; D=test pattern,E=pass counter
l220c   ld      a,$00           ; start with page 0
        ld      bc,$7ffd
l2211   out     (c),a           ; page in next page
        ex      af,af'          ; save page number
        ld      hl,$c000
l2217   ld      (hl),d          ; fill page with D
        inc     hl
        ld      a,l
        or      h
        jr      nz,l2217        ; until page filled
        ex      af,af'
        inc     a
        cp      $08
        jr      nz,l2211        ; back for more pages
        ld      a,$00           ; start at page 0 again
l2225   out     (c),a           ; page in next page
        ex      af,af'          ; save page number
        ld      hl,$c000
l222b   ld      a,(hl)
        cp      d               ; check pattern
        jr      nz,l2262        ; move on if error
        cpl
        ld      (hl),a          ; store inverse pattern
        inc     hl
        ld      a,l
        or      h
        jr      nz,l222b        ; until page done
        ex      af,af'
        inc     a
        cp      $08
        jr      nz,l2225        ; back for more pages
        dec     a               ; back to page 7
l223d   ex      af,af'
        ld      hl,$0000        ; start at end of memory
l2241   dec     hl
        ld      a,h
        cp      $bf
        jr      z,l224f         ; move on if at start of page
        ld      a,d
        cpl
        cp      (hl)            ; check inverse pattern
        jr      nz,l2262        ; move on if error
        ld      (hl),d          ; store normal pattern
        jr      l2241           ; loop back
l224f   ex      af,af'
        cp      $00
        jr      z,l2259
        dec     a
        out     (c),a
        jr      l223d           ; back for more pages
l2259   dec     e               ; decrement pass counter
        jp      z,l2329         ; move on if successful
        ld      d,$ff
        jp      l220c           ; back for second pass with new pattern
l2262   ex      af,af'
        push    af              ; save page and address of failure
        push    hl
        call    l266f           ; re-initialise
        xor     a
        ld      bc,$7ffd
        ld      (BANKM),a
        out     (c),a           ; page in page 0
        ld      bc,$0700
        call    l270b           ; set INK 7, PAPER 0
        call    l271a           ; clear screen
        ld      hl,l22ba
        call    l2703           ; display RAM test fail message
        pop     hl
        ld      a,h
        call    l2299           ; output high byte of address
        ld      a,l
        call    l2299           ; output low byte of address
        exx
        ld      hl,l22fe
        call    l2703           ; output page message
        pop     af
        and     $07
        exx
        call    l2299           ; output page number
        di
        halt                    ; halt!

; Subroutine to output A as two hexadecimal digits

l2299   push    hl              ; save registers
        push    af
        push    af
        srl     a
        srl     a
        srl     a
        srl     a               ; A=A/16
        ld      b,$02           ; two digits
l22a6   exx
        ld      d,$00
        ld      e,a             ; DE=0...F
        ld      hl,l2306
        add     hl,de
        ld      a,(hl)          ; A=ASCII hex digit
        call    l2716           ; output it
        pop     af              ; restore value
        and     $0f             ; get low nibble
        exx
        djnz    l22a6           ; loop back for second digit
        pop     hl
        ret

l22ba   defm    $16, $0a, $0
        defm    "RAM fail: address ", $ff

; The "EUA" routine from the testcard, which changes attributes based
; on input at EAR

l22d0   ld      a,$00
        out     ($fe),a         ; set black border
        ld      hl,$4000
        ld      de,$4001
        ld      bc,$1800
        ld      (hl),$00
        ldir                    ; clear screen to black
l22e1   ld      hl,$5800        ; start of attributes
l22e4   ld      bc,$0300        ; B=loop counter,C=black paper
l22e7   in      a,($fe)
        and     $40             ; get EAR bit
        or      c
        ld      c,a
        rr      c               ; combine into C
        inc     ix              ; delay
        dec     ix
        djnz    l22e7           ; loop 3 times to form a paper colour
        ld      (hl),c          ; store in attributes
        inc     hl              ; move to next
        ld      a,h
        cp      $5b
        jr      nz,l22e4        ; loop back for whole screen
        jr      l22e1           ; start again


l22fe   defm    ", page ", $ff
l2306   defm    "0123456789ABCDEF"
l2316   defm    $16, $0a, $0
        defm    "RAM test passed", $ff

; Continuation of self-test program

l2329   ld      a,$00           ; start with page 0
        ld      hl,$cafe        ; location to use
        ld      bc,$7ffd
l2331   out     (c),a           ; page in page
        ld      (hl),a          ; and store page number
        inc     a
        cp      $08
        jr      nz,l2331        ; back for more
l2339   dec     a
        out     (c),a           ; page in page
        cp      (hl)            ; check correct number
        jp      nz,l2457        ; if not, go to signal ULA error
        and     a
        jr      nz,l2339        ; back for more
        di
        ld      bc,$7ffd
        ld      a,$00           ; start at page 0
l2349   out     (c),a           ; page in page
        ld      ($e000),a       ; store number at midpoint of page
        inc     a
        cp      $08
        jr      nz,l2349        ; back for more
        dec     a
        call    l235f           ; copy routine to page 7
        ld      a,$03
        call    l235f           ; and to page 3
        jp      $d000           ; jump into it in page 3

; Subroutine to copy the following routine into page A at $d000

l235f   ld      bc,$7ffd
        out     (c),a           ; page in required page
        ld      hl,l2370
        ld      de,$d000
        ld      bc,$00b9
        ldir                    ; copy routine
        ret

; Routine to be executed in pages 3 & 7 ($2370-$2328 at $d000-$d0b8)
; to test the RAM configurations (all of which have one of these pages
; at the top)

l2370   ld      a,$01           ; start with RAM configuration 0,1,2,3
        ld      de,$d0a9        ; start of table of configs
        ld      hl,$2000        ; location of page number within lowest page
l2378   ld      bc,$1ffd
        out     (c),a           ; page in next configuration
        ex      af,af'
        ld      bc,$4000
l2381   ld      a,(de)
        inc     de
        cp      (hl)            ; check correct page in place
        jr      nz,l2394        ; if not, move on
        add     hl,bc           ; add offset to next segment
        jr      nc,l2381        ; loop back for more
        ex      af,af'
        add     a,$02           ; increment configuration
        bit     3,a
        jr      z,l2378         ; loop back if more to test
        ld      d,$01           ; flag "RAM configurations passed"
l2392   jr      l2397
l2394   ex      af,af'
        ld      d,$00           ; flag "RAM configurations failed"
l2397   exx
        ld      bc,$7ffd
        ld      a,$03
        out     (c),a           ; make sure page 3 is selected
        ld      b,$1f
        xor     a
        out     (c),a           ; and ROM 0
        call    $d09b           ; get checksum of ROM 0
        jr      nz,l23f2        ; if not zero, go to error
        ld      bc,$7ffd
        ld      a,$13
        out     (c),a           ; get ROM 1
        call    $d09b           ; and its checksum
        jr      nz,l23f2        ; if not zero, go to error
        scf
        call    $d08e           ; rotate ROM0/1 success into flags
l23b9   ld      bc,$1ffd
        ld      a,$04
        out     (c),a
        ld      bc,$7ffd
        ld      a,$03
        out     (c),a           ; get ROM 2
        call    $d09b           ; and its checksum
        jr      nz,l23f8        ; if not zero, go to error
        ld      a,$0b
        ld      bc,$7ffd
        out     (c),a           ; get ROM 3
        call    $d09b           ; and its checksum
        jr      nz,l23f8        ; if not zero, go to error
        scf
        call    $d08e           ; rotate ROM2/3 success into flags
l23dc   ld      a,$03
        ld      bc,$7ffd
        out     (c),a           ; make sure page 3 is paged in
        ld      a,$00
        ld      b,$1f
        out     (c),a           ; with ROM 0
        ld      (BANKM),a
        ld      (BANK678),a
        jp      l2436           ; jump back into routine in ROM
l23f2   xor     a
        call    $d08e           ; rotate ROM0/1 fail into flags
        jr      l23b9
l23f8   xor     a
        call    $d08e           ; rotate ROM2/3 fail into flags
        jr      l23dc

; Subroutine to rotate a test flag bit (1=success) into IX

        push    de
        push    ix
        pop     de
        rl      e
        rl      d
        push    de
        pop     ix
        pop     de
        ret

; Subroutine to form an 8-bit addition checksum of the current ROM
; All ROMs should checksum to zero

        xor     a               ; zero checksum
        ld      h,a
        ld      l,a             ; and address
l240e   add     a,(hl)          ; add next byte
        inc     hl
        ld      d,a
        ld      a,h
        cp      $40
        ld      a,d
        jr      nz,l240e        ; back for rest of page
        and     a               ; check if zero
        ret

; Table of +3 special RAM configurations to test

ld0a9   defb    $00,$01,$02,$03
        defb    $04,$05,$06,$07
        defb    $04,$05,$06,$03
        defb    $04,$07,$06,$03

; Subroutine to rotate carry flag (1=pass,0=fail) into IX

l2429   push    de              ; save DE
        push    ix
        pop     de              ; DE=test results
        rl      e               ; rotate carry into test results
        rl      d
        push    de
        pop     ix              ; IX=test results
        pop     de              ; restore DE
        ret

; Re-entry into self-test routine from RAM here

l2436   ld      bc,$7ffd
        ld      a,$00
        out     (c),a           ; page in page 0
        ld      sp,$7fff        ; set stack in page 5
        exx
        xor     a
        cp      d               ; set carry if RAM configs test passed
        call    l2429           ; rotate RAM configs test result into flags
        call    l266f           ; re-initialise
        call    l271a           ; clear screen
        ld      hl,l2316
        call    l2703           ; display RAM test passed message
        call    l269a           ; pause for 0.8s
        jr      l2461           ; move on

; routine comes here if ULA error with normal RAM paging

l2457   call    l266f           ; reinitialise
        ex      af,af'          ; get page
        ld      hl,$0000        ; specify address 0000 for page error
        jp      l2262           ; display error and halt

; More self-test program

l2461   call    l2c99           ; GI sound test
        call    l28b6           ; Symshift-A test
        call    l295d           ; ULA test
        call    l274d           ; keyboard test
        call    l2c1f           ; ULA sound test part 1
        call    l2c6e           ; ULA sound test part 2
        call    l29d0           ; joystick test
        call    l2b24           ; cassette output test
        call    l2a4b           ; screen switching test
        call    l2488           ; printer BUSY test & data test
        call    l3558           ; integral disk test
        call    l35a3           ; tape test
        jp      l2b91           ; move on to display results

; Printer BUSY test & data test

l2488   call    l271a           ; cls
        ld      hl,l25d5
        call    l2703           ; display test message
        ld      hl,l25f3        ; ask for printer OFFLINE then any key
        call    l2703
        ld      hl,l2613
        call    l2703
        ld      hl,l261e
        call    l2703
        call    l253d           ; wait for a key
        ld      bc,$0ffd
        in      a,(c)
        bit     0,a             ; check BUSY signal
        jr      z,l24c4         ; move on if not set
        ld      hl,l2608
        call    l2703           ; ask for ONLINE then any key
        call    l253d           ; wait for a key
        ld      bc,$0ffd
        in      a,(c)
        bit     0,a             ; check BUSY signal
        jr      nz,l24c4        ; move on if set
        scf                     ; signal success
        jr      l24c6
l24c4   scf
        ccf                     ; signal fail
l24c6   call    l2429           ; set success/fail flag
        call    l271a           ; cls
        ld      hl,BANK678
        set     4,(hl)
        ld      hl,l2549
        call    l2703           ; display test messages
        ld      hl,l255e
        call    l2703
        ld      e,$00           ; chars per line count
      IF v41 || spanish
        ld      b,$03
l24df   dec     b
        jr      z,l2530
        ld      a,' '           ; start with space
l24e1   push    bc
        push    af
        call    l24f4           ; output character
        pop     af
        pop     bc
      ELSE
l24df   ld      a,' '           ; start with space
l24e1   push    af
        call    l24f4           ; output character
        pop     af
      ENDIF
        inc     a               ; get next ASCII code
        cp      $80
        jr      z,l24f0         ; go to skip $80-$9f
        or      a
        jr      z,l24df         ; restart after $ff at space
        jr      l24e1
l24f0   ld      a,$a0
        jr      l24e1

; Subroutine to output a character to the printer

l24f4   call    l2507           ; output it
        push    af
        inc     e               ; increment chars printed this line
        ld      a,e
        cp      $48
        jr      nz,l2505
        ld      e,$00           ; if $48, reset and start new line
        ld      a,$0d
        call    l2507
l2505   pop     af
        ret

; Subroutine to output a character to the printer,
; checking for Quit from user, exiting to higher calling
; routine

l2507   push    af
l2508   ld      a,$fb
        in      a,($fe)
        rra                     ; get Q status in carry
        jr      nc,l252c        ; move on if pressed
        ld      bc,$0ffd
        in      a,(c)
        bit     0,a             ; check BUSY status
        jr      nz,l2508        ; loop back if busy
        pop     af
        out     (c),a           ; place character at port
        di
        ld      a,(BANK678)
l251f   ld      bc,$1ffd
        xor     $10
        out     (c),a           ; STROBE parallel port
        bit     4,a
        jr      z,l251f         ; loop back to change state if necessary
        ei
        ret
l252c   pop     af              ; discard AF
      IF v41 || spanish
        pop     af              ; discard return address
      ENDIF
        pop     af              ; discard return address
        pop     af              ; and two stacked values from calling routine
        pop     af
l2530   ld      hl,l2597
        call    l2703           ; ask if printed OK
        call    l26af           ; get SPACE/ENTER
        call    l2429           ; set success/fail
        ret                     ; exit to earlier routine

; Subroutine to wait until a new key is available

l253d   ld      hl,FLAGS
        res     5,(hl)
l2542   bit     5,(hl)
        jr      z,l2542
        res     5,(hl)
        ret

; Printer test messages

l2549   defm    $16, $4, $4
        defm    "Printer data test", $ff
l255e   defm    $16, $8, $1
        defm    "Make sure printer is ready"
        defm    $16, $0a, $1
        defm    "Press Q to quit printing", $ff
l2597   defm    $16, $0c, $01
        defm    "If characters printed OK,", $0d
        defm    "Press [ENTER], otherwise [SPACE]", $ff
l25d5   defm    $15, $0, $16, $4, $4
        defm    "Printer BUSY signal test", $ff
l25f3   defm    $16, $8, $8
        defm    "Turn the printer ", $ff
l2608   defm    $16, $0a, $0c
        defm    "ONLINE ", $ff
l2613   defm    $16, $0a, $0c
        defm    "OFFLINE", $ff
l261e   defm    $16, $0c, $4
        defm    "Press any key to continue", $ff
        defm    $16, $10, $5
        defm    "Passed - press [ENTER]", $ff
        defm    $16, $10, $5
        defm    "Failed - press [SPACE]", $ff

; Subroutine to do some initialisation

l266f   ld      a,$52           ; signal "in test program"
        ex      af,af'
        jp      l016c           ; do some initialisation & return here
l2675   ld      a,$02
        ROM3    o1601           ; open channel to stream 2
l267a   ld      hl,l2681
        call    l2703           ; output normal colour control codes
        ret

; "Normal" colour control codes

l2681   defb    $10,$00,$11,$07
        defb    $13,$00,$14,$00
        defb    $15,$00,$12,$00
        defb    $ff

; Apparently unused routine, to pause

l268e   push    bc
        push    hl
        ld      b,$19
        ei
l2693   halt
        djnz    l2693
l2696   pop     hl
l2697   pop     bc
        di
        ret


; Subroutine to pause for approx 0.8s

l269a   ld      b,$28
        ei
l269d   halt
        djnz    l269d
        di
        ret

; Pause subroutine

l26a2   ld      hl,$3000
l26a5   dec     hl
        push    ix
        pop     ix
        ld      a,l
        or      h
        jr      nz,l26a5
        ret

; Subroutine to wait for ENTER or SPACE to be pressed.
; On exit, carry is set if ENTER was pressed, reset if SPACE.

l26af   push    hl              ; save registers
        push    de
        push    bc
        ld      bc,$00fe
l26b5   in      a,(c)           ; scan all keyrows
        and     $1f
        cp      $1f
        jr      nz,l26b5        ; loop back if any are pressed
l26bd   call    l26d2           ; get a scancode
        cp      $21             ; check for ENTER
        scf
l26c3   jr      z,l26c9         ; if so, move on with carry set
        cp      $20             ; check for SPACE
        jr      nz,l26bd        ; loop back if not
l26c9   push    af              ; save carry
        call    l2720           ; make a beep
        pop     af              ; restore registers
        pop     bc
        pop     de
        pop     hl
        ret
l26d2   call    l26d6
        ret

; Subroutine to read the keyboard, returning a scancode
; in DE. This routine is a virtual copy of the routine
; at 028e in ROM 3, but doesn't return until a scancode
; has been detected.

l26d6   ld      l,$2f
        ld      de,$ffff
        ld      bc,$fefe
l26de   in      a,(c)
        cpl
        and     $1f
        jr      z,l26f4
        ld      h,a
        ld      a,l
l26e7   inc     d
        jr      nz,l26d6
l26ea   sub     $08
        srl     h
        jr      nc,l26ea
        ld      d,e
        ld      e,a
        jr      nz,l26e7
l26f4   dec     l
        rlc     b
        jr      c,l26de
        ld      a,e
        cp      $ff
        ret     nz
        ld      a,d
        cp      $ff
        jr      z,l26d6
        ret

; Subroutine to output an $ff-terminated string

l2703   ld      a,(hl)          ; get byte
        cp      $ff
        ret     z               ; exit if $ff
        rst     $10             ; else output
        inc     hl
        jr      l2703           ; back for more


; Subroutine to set colours to INK b, PAPER c

l270b   ld      a,$10
        rst     $10
        ld      a,b
        rst     $10
        ld      a,$11
        rst     $10
        ld      a,c
        rst     $10
        ret

; Subroutine to output a character

l2716   ROM3    o0010
l2719   ret

; Subroutine to clear screen

l271a   ROM3    o0DAF           ; call ROM 3 CLS
        jp      l267a           ; go to set "normal" colours & exit

; Subroutine to make a beep

l2720   ld      hl,$0100        ; parameters for the beep
        ld      de,$00a0
l2726   call    l34e9           ; call BEEPER
        di                      ; re-disable interrupts
        ret

; Copy of next routine, apparently unused

        ld      a,$7f
        in      a,($fe)
        rra
        ret

; Subroutine to check for SPACE, exiting with carry reset if pressed

l2731   ld      a,$7f
        in      a,($fe)
        rr      a
        ret

; Apparently unused routine, to check for SPACE+Symbol shift

        ld      a,$7f
        in      a,($fe)
        or      $e0
        cp      $fc
        ret

; Apparently unused routine, to output D spaces and set A'='8'

        ld      a,'8'
        ex      af,af'
l2744   ld      a,' '
        call    l2716
        dec     d
        jr      nz,l2744
        ret

; Keyboard test

l274d   call    l271a           ; cls
        ld      a,$38
        ld      (BORDCR),a
        ld      a,$07
        out     ($fe),a         ; white border
        ld      hl,l2f17
        call    l2703           ; display test message
        call    l26a2           ; pause
        call    l2766           ; execute test
        ret

l2766   ld      hl,l2841        ; keyboard test table
        push    hl
l276a   pop     hl
        ld      a,(hl)          ; get next test value
        inc     a
        ret     z               ; exit if end of table
        push    hl
        call    l26d2           ; get keyscan code
        ld      bc,$1000
l2775   dec     bc
        ld      a,b
        or      c
        jr      nz,l2775        ; timing loop
        ld      a,d
        cp      $ff
        jr      z,l27e0         ; move on if no first key
        cp      $27
        jr      z,l2790         ; move on if capsshift held
        cp      $18
        jr      z,l27db         ; move on if symshift held
        ld      a,e             ; swap scancodes
        ld      e,d
        ld      d,a
        cp      $18
        jr      z,l27db         ; move on if symshift held
        jr      l276a           ; loop back if no shifts
l2790   ld      a,e             ; here we substitute various codes for
        cp      $23             ;  keys with caps shift
        ld      e,$28
        jr      z,l27f9
        cp      $24
        ld      e,$29
        jr      z,l27f9
        cp      $1c
        ld      e,$2a
        jr      z,l27f9
        cp      $14
        ld      e,$2b
        jr      z,l27f9
        cp      $0c
        ld      e,$2c
        jr      z,l27f9
        cp      $04
        ld      e,$2d
        jr      z,l27f9
        cp      $03
        ld      e,$2e
        jr      z,l27f9
        cp      $0b
        ld      e,$2f
        jr      z,l27f9
        cp      $13
        ld      e,$30
        jr      z,l27f9
        cp      $1b
        ld      e,$31
        jr      z,l27f9
        cp      $20
        ld      e,$32
        jr      z,l27f9
        cp      $18
        ld      e,$37
        jr      z,l27f9
        jr      l276a           ; loop back for untested caps shift codes
l27db   ld      a,e             ; here we substitute various codes for keys
        cp      $10             ;  with symbol shift
        ld      e,$33
l27e0   jr      z,l27f9
        cp      $08
        ld      e,$34
        jr      z,l27f9
        cp      $1a
        ld      e,$35
        jr      z,l27f9
        cp      $22
        ld      e,$36
        jr      z,l27f9
        ld      e,$37
        jp      nz,l276a
l27f9   ld      a,e             ; A=final scancode
        pop     hl
        push    hl
        cp      (hl)            ; test against table entry
        jp      nz,l276a        ; loop back if not equal
        pop     hl
        inc     hl              ; get to next entry
        push    hl
        ld      hl,$0080
        ld      de,$0080
        push    af
        push    bc
        push    ix
        call    l2726           ; make a beep
        pop     ix
        pop     bc
        pop     af
        pop     hl
        push    hl
        ld      a,$11           ; set PAPER 2
        rst     $10
        ld      a,$02
        rst     $10
        dec     hl
        ld      de,$003b
        add     hl,de
        ld      a,(hl)          ; get position code from table
        and     $f0
        rra
        rra
        rra
        ld      b,$06
        add     a,b
        ld      b,a             ; B=line+1
        ld      a,(hl)
        and     $0f
        rla
        ld      c,$01
        add     a,c             ; C=column
        ld      c,a
        ld      a,$16           ; output space to blank key at correct pos
        rst     $10
        ld      a,b
        dec     a
        rst     $10
        ld      a,c
        rst     $10
        ld      a,' '
        rst     $10
        jp      l276a           ; back for more

; Keyboard test table of scancodes

l2841   defb    $2b,$2c,$24,$1c
        defb    $14,$0c,$04,$03
        defb    $0b,$13,$1b,$23
        defb    $32,$28,$31,$25
        defb    $1d,$15,$0d,$05
        defb    $02,$0a,$12,$1a
        defb    $22,$37,$29,$26
        defb    $1e,$16,$0e,$06
        defb    $01,$09,$11,$19
        defb    $21,$27,$2a,$1f
        defb    $17,$0f,$07,$00
        defb    $08,$10,$33,$27
        defb    $18,$35,$36,$2d
        defb    $30,$20,$2f,$2e
        defb    $34,$18,$ff

; Keyboard test table of screen positions

        defb    $00,$01,$02,$03
        defb    $04,$05,$06,$07
        defb    $08,$09,$0a,$0b
        defb    $0d,$10,$11,$13
        defb    $14,$15,$16,$17
        defb    $18,$19,$1a,$1b
        defb    $1c,$20,$21,$23
        defb    $24,$25,$26,$27
        defb    $28,$29,$2a,$2b
        defb    $2d,$30,$31,$33
        defb    $34,$35,$36,$37
        defb    $38,$39,$3a,$3d
        defb    $40,$41,$42,$43
        defb    $44,$47,$4a,$4b
        defb    $4c,$4d

; Symbolshift-A test

l28b6   call    l271a           ; cls
        ld      a,$05
        out     ($fe),a         ; cyan border
        ld      bc,$0600
        call    l270b           ; INK 6, PAPER 0
        ld      hl,l30d9
        call    l2703           ; display test message
l28c9   call    l28e5
        jr      nz,l28c9        ; loop back until symshift-A pressed
        ld      bc,$0200        ; timing counter
l28d1   push    bc
        call    l28e5           ; check for symshift-A
        pop     bc
        jr      nz,l28e1        ; exit with error if not pressed
        dec     bc
        ld      a,b
        or      c
        jr      nz,l28d1        ; loop back to test again
        scf
        jp      l2429           ; exit, setting "success" flag
l28e1   or      a
        jp      l2429           ; exit, setting "fail" flag

; Subroutine to check if symbol-shift & A are being pressed
; On exit, Z is set if both are being pressed

l28e5   call    l26d2           ; get key scan code
        ld      a,d
        cp      $18
        jr      z,l28f3         ; move on if first key is sym/shft
        ld      a,e             ; swap keys
        ld      e,d
        ld      d,a
        cp      $18
        ret     nz              ; exit with Z reset if 2nd key not sym/shft
l28f3   ld      a,e
        cp      $26             ; compare other key with A and exit
        ret

; Subroutine to initialise test environment, display title & get
; colour test results

l28f7   call    l266f           ; do some initialisation
        call    l291d           ; fill attributes, do sound registers
        ld      bc,$0000
        ld      hl,l311e
        call    l2703           ; output test program title
        call    l26af           ; wait for ENTER or SPACE
        call    l2429           ; update results flags
        ld      c,$fd           ; some sound stuff
        ld      d,$ff
        ld      e,$bf
        ld      h,$ff
        ld      b,d
        ld      a,$07
        out     (c),a
        ld      b,e
        out     (c),h
        ret

; Subroutine to fill attributes & set up some sound registers

l291d   xor     a
        ld      hl,$5800        ; start of attributes
        ld      b,$10           ; 16 x 2chars = 1 line
l2923   ld      (hl),a
        inc     hl
        ld      (hl),a          ; colour next two chars
        add     a,$08           ; increment paper & higher attributes
        inc     hl
        djnz    l2923           ; back for rest of line
        ld      de,$5820
        ld      bc,$02df
        ldir                    ; fill rest of attribs with what's on line 1
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      hl,l2d0c        ; sound data
l293c   ld      a,(hl)          ; loop to set up two sound registers
        inc     hl
        bit     7,a
        jr      nz,l294c
        ld      b,d
        out     (c),a
        ld      a,(hl)
        inc     hl
        ld      b,e
        out     (c),a
        jr      l293c
l294c   ld      c,$fd           ; set up more sound registers
        ld      d,$ff
        ld      e,$bf
        ld      h,$fb
        ld      b,d
        ld      a,$07
        out     (c),a
        ld      b,e
        out     (c),h
        ret


; ULA test

l295d   call    l271a           ; cls
        ld      hl,l324e
        call    l2703           ; display test message
        ld      de,$6000
        call    l298c           ; copy test routine to RAM at $6000
        call    $6000           ; execute test
        ld      a,$aa           ; test RAM integrity
        ld      ($8000),a
        ld      a,($8000)
        cp      $aa
        jr      nz,l2984        ; move on if error
        ld      de,$8000
        call    l298c           ; copy test routine to RAM at $8000
        call    $8000           ; execute test
l2984   ld      a,$06
        out     ($fe),a         ; yellow border
        scf
        jp      l2429           ; exit, setting "success" flag

; Subroutine to copy following routine to memory at DE

l298c   ld      hl,l2995
        ld      bc,$003b
        ldir
        ret

; Routine to execute in RAM to test ULA

l2995   ld      bc,$2000        ; $2000 times
l2998   ld      a,$00           ; alternately output $00/$ff to port $fe
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        out     ($fe),a
        cpl
        dec     bc
        ld      a,b
        or      c
        jr      nz,l2998        ; loop back for more
        ret

; Joystick test

l29d0   call    l271a           ; cls
        ld      hl,l32e0
        call    l2703           ; display test message
        ld      de,$1f1f        ; initially, no bits reset in D or E ports
l29dc   push    de
        ld      bc,$effe
        in      a,(c)
        cpl
        and     d
        xor     d
        ld      d,a             ; mask in reset bits from port 1 to D
        ld      bc,$f7fe
        in      a,(c)
        cpl
        and     e
        xor     e
        ld      e,a             ; mask in reset bits from port 2 to D
        pop     bc
        ld      a,d
        cp      b
        jr      nz,l2a06        ; move on if change in port 1
        ld      a,e
        cp      c
        jr      nz,l2a06        ; move on if change in port 2
        call    l2731           ; check for SPACE
        jr      c,l29dc
        jr      z,l29dc
        and     a
        jr      l2a03           ; fail if SPACE pressed
l2a02   scf                     ; set success
l2a03   jp      l2429           ; exit, setting success/fail flag
l2a06   push    de
        ld      hl,l3530        ; table of screen positions
        ld      b,$05           ; 5 bits for first joystick port in D
l2a0c   rrc     d
        call    nc,l2a28        ; blank screen chars if reset
        inc     hl
        inc     hl
        djnz    l2a0c
        ld      b,$05           ; 5 bits for second joystick port in E
l2a17   rrc     e
        call    nc,l2a28        ; blank screen chars if reset
        inc     hl
        inc     hl
        djnz    l2a17
        pop     de
        ld      a,d
        or      e
        jr      z,l2a02         ; exit with success once all reset
        jp      l29dc           ; back for more

; Joystick subroutine to output two red spaces at position
; in table referenced at HL

l2a28   push    bc
        ld      b,(hl)
        inc     hl
        ld      c,(hl)          ; get position from table
        ld      a,$16           ; output spaces at position
        rst     $10
        ld      a,b
        dec     a
        dec     a
        dec     a
        rst     $10
        ld      a,c
        rst     $10
        ld      a,$11
        rst     $10
        ld      a,$02
        rst     $10
        ld      a,' '
        rst     $10
        ld      a,' '
        rst     $10
        ld      a,$11
        rst     $10
        ld      a,$07
        rst     $10
        dec     hl
        pop     bc
        ret

; Screen switching test

l2a4b   call    l271a           ; cls
        di
        ld      hl,$5800
        ld      de,$5801
        ld      bc,$02ff
        ld      (hl),$00
        ldir                    ; set page 5 screen attributes to black
        ld      hl,l2acb
        call    l2703           ; display test message
        ld      hl,l2ae8
        call    l2703           ; and success - press ENTER message
        ld      a,(BANKM)
        push    af
        or      $07
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; switch in page 7
        ld      hl,$4000
        ld      de,$c000
        ld      bc,$1800
        ldir                    ; copy screen into page 7
        ld      hl,l2acb        ; display test message
        call    l2703
        ld      hl,l2b06        ; and fail - press SPACE message
        call    l2703
        ld      a,(BANKM)
        set     3,a
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; switch in alternate screen
        ld      hl,$5800
        ld      de,$5801
        ld      bc,$02ff
        ld      (hl),$38
        ldir                    ; change attribs on normal screen to visible
        ld      hl,$d800
        ld      de,$d801
        ld      bc,$02ff
        ld      (hl),$38
        ldir                    ; and on alternate screen
        call    l26af           ; get ENTER or SPACE as appropriate
        call    l2429           ; set success/failure flag
        call    l271a           ; cls
        pop     af
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; switch back original memory & screen
        call    l271a           ; cls
        ei
        ret

l2acb   defm    $16, $8, $3, $11, $0, $10, $0
        defm    "Screen switching test", $ff
l2ae8   defm    $16, $0c, $3, $11, $0, $10, $0
        defm    "Passed - press [ENTER]", $ff
l2b06   defm    $16, $0c, $3, $11, $0, $10, $0
        defm    "Failed - press [SPACE]", $ff

; Cassette output test

l2b24   call    l271a           ; cls
        ld      a,$02
        out     ($fe),a         ; red border
        ld      a,$08
        ld      (BORDCR),a
        ld      hl,l32c1
        call    l2703           ; display test message
        ld      hl,$0100        ; ouput a tone to MIC
        ld      de,$0a00
        di
        push    ix
        ld      a,l
        srl     l
l2b42   srl     l
        cpl
        and     $03
        ld      c,a
        ld      b,$00
        ld      ix,l2b5a
        add     ix,bc
        ld      a,(BORDCR)
        and     $38
        rrca
        rrca
        rrca
l2b58   or      $10
l2b5a   nop
        nop
        nop
        inc     b
        inc     c
l2b5f   dec     c
        jr      nz,l2b5f
        ld      c,$3f
        dec     b
        jp      nz,l2b5f
        xor     $08
        out     ($fe),a
        ld      b,h
        ld      c,a
        bit     3,a
        jr      nz,l2b7b
        ld      a,d
        or      e
        jr      z,l2b7f
        ld      a,c
        ld      c,l
l2b78   dec     de
        jp      (ix)
l2b7b   ld      c,l
        inc     c
        jp      (ix)
l2b7f   pop     ix
        ld      bc,$1200
        ld      hl,l2d21
l2b87   call    l2703           ; ask if heard sound
        call    l26af           ; get ENTER/SPACE
        call    l2429           ; signal success/failure
        ret


; End of test program - display results

l2b91   call    l271a           ; cls
        push    ix
        pop     de              ; DE=results
        ld      a,e
        and     d
        cp      $ff
        jr      nz,l2ba9        ; move on if any test failed
        ld      a,$04
        out     ($fe),a         ; green border
        ld      hl,l346f
        call    l2703           ; display success message
        jr      l2bee           ; move on
l2ba9   ld      a,$02
        out     ($fe),a         ; red border
        ld      hl,l3486
        call    l2703           ; display fail message
        ld      bc,$0807
        push    ix
        pop     de
        push    de              ; E=low byte of results
        ld      hl,l2ec7        ; HL=table of message addresses
        ld      d,$08           ; 8 bits
l2bbf   rr      e               ; get next result
        jr      c,l2bce         ; move on if passed
        push    hl
        push    de
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
        call    l2703           ; display appropriate message
        pop     de
        pop     hl
l2bce   inc     hl              ; get to next table entry
        inc     hl
        dec     d
        jr      nz,l2bbf        ; back for more bits
        pop     de
        ld      e,d             ; E=high byte of results
        ld      d,$08           ; 8 bits
l2bd7   rr      e               ; get next result
        jr      c,l2be9         ; move on if passed
        push    hl
        push    de
        push    bc
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
        call    l2703           ; display appropriate message
        pop     bc
        pop     de
        pop     hl
        inc     b
l2be9   inc     hl              ; get to next table entry
        inc     hl
        dec     d
        jr      nz,l2bd7        ; loop back for more bits
l2bee   ld      hl,l2c00
        ld      bc,$1000
        call    l2703           ; display end message
l2bf7   call    l26af           ; get SPACE or ENTER
        jr      c,l2bf7         ; loop until SPACE
        di
        jp      l0000           ; reset


l2c00   defm    $0d, $0d
        defm    "Hold [BREAK] to repeat tests", $ff

; ULA sound test

l2c1f   ld      c,$fd           ; some sound stuff
        ld      d,$ff           ; to clear AY registers ?
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a
        ld      a,$ff
        ld      b,e
        out     (c),a
        ld      b,d
        in      a,(c)
        cp      $ff
        jr      nz,l2c6a
        ld      a,$fe
        ld      b,e
        out     (c),a
        ld      b,d
        in      a,(c)
        cp      $7e
        jr      nz,l2c6a
        ld      a,$fd
        ld      b,e
        out     (c),a
        ld      b,d
        in      a,(c)
        cp      $bd
        jr      nz,l2c6a
        ld      a,$fb
        ld      b,e
        out     (c),a
        ld      b,d
        in      a,(c)
        cp      $db
        jr      nz,l2c6a
        ld      a,$f7
        ld      b,e
        out     (c),a
        ld      b,d
        in      a,(c)
        cp      $e7
        jr      nz,l2c6a
        scf
        jp      l2429           ; exit with success
l2c6a   or      a
        jp      l2429           ; exit with failure

; ULA sound test part 2

l2c6e   call    l271a           ; clear screen
        ld      a,$02
        out     ($fe),a         ; red border
        ld      a,$08
        ld      (BORDCR),a
        ld      hl,l32a6
        call    l2703           ; display test message
        ld      hl,$0100
        ld      de,$0a00
        call    l2726           ; make a beep
        ld      bc,$1200
        ld      hl,l2d21
        call    l2703           ; ask if heard sound
        call    l26af           ; get ENTER/SPACE
        call    l2429           ; set success/fail flag
        ret

; GI Sound Test routine

l2c99   call    l271a           ; clear screen
        ld      a,$05
        out     ($fe),a         ; cyan border
        ld      hl,l328d
        call    l2703           ; display GI message
        ld      c,$fd           ; make some sounds
        ld      d,$ff
        ld      e,$bf
        ld      hl,l2d0c
l2caf   ld      a,(hl)
        inc     hl
        bit     7,a
        jr      nz,l2cbf
        ld      b,d
        out     (c),a
        ld      a,(hl)
        inc     hl
        ld      b,e
        out     (c),a
        jr      l2caf
l2cbf   ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      l,$03
        ld      h,$fe
l2cc9   ld      b,d
        ld      a,$07
        out     (c),a
        ld      b,e
        out     (c),h
        push    hl
        push    de
        push    bc
        call    l269a           ; pause
        pop     bc
        pop     de
        pop     hl
        scf
        rl      h
        dec     l
        jr      nz,l2cc9        ; loop back for more
        ld      h,$f8
        ld      b,d
        ld      a,$07
        out     (c),a
        ld      b,e
        out     (c),h
        push    hl
        push    de
        push    bc
        call    l269a           ; pause
        pop     bc
        pop     de
        pop     hl
        ld      h,$ff
        ld      b,d
        ld      a,$07
        out     (c),a
        ld      b,e
        out     (c),h
        ld      bc,$0a00
        ld      hl,l34a8
        call    l2703           ; ask if heard sounds
        call    l26af           ; get ENTER/SPACE
        jp      l2429           ; rotate into flags & exit

l2d0c   defb    $00,$40,$01,$00
        defb    $02,$80
        defb    $03,$00,$04,$00
        defb    $05,$01,$06,$1f
        defb    $08,$0f,$09,$0f
        defb    $0a,$0f,$80

l2d21   defm    "Press [ENTER] if you heard the  tone, else press [SPACE]", $ff
l2d5a   defm    "colour test failed", $0d, $ff
l2d6e   defm    "ULA sound test failed", $0d, $ff
l2d85   defm    "Symshft/A key test failed", $0d, $ff
l2da0   defm    "ULA test failed", $0d, $ff
l2db1   defm    "RS232 test failed", $0d, $ff
l2dc4   defm    "GI sound test failed", $0d, $ff
l2dda   defm    "All-RAM page test failed", $0d, $ff
l2df4   defm    "Joystick test failed", $0d, $ff
l2e0a   defm    "IC 7 checksum failed", $0d, $ff
l2e20   defm    "IC 8 checksum failed", $0d, $ff
l2e36   defm    "Disk tests failed", $0d, $ff
l2e49   defm    "Second Screen test failed", $0d, $ff
l2e64   defm    "Cassette Output failed", $0d, $ff
l2e7c   defm    "Cassette Input failed", $0d, $ff
l2e93   defm    "Printer BUSY test failed", $0d, $ff
l2ead   defm    "Printer DATA test failed", $0d, $ff

; Table of test failure message addresses

l2ec7   defw    l2e7c
        defw    l2e36
        defw    l2ead
        defw    l2e93
        defw    l2e49
        defw    l2e64
        defw    l2df4
        defw    l2d6e
        defw    l2db1
        defw    l2da0
        defw    l2d85
        defw    l2dc4
        defw    l2dda
        defw    l2e20
        defw    l2e0a
        defw    l2d5a

; Test program messages

l2ee7   defm    $16, $5, $5, $12, $1
        defm    "ROM TEST FAILED", $12, $0, $0d, $ff
        defm    $16, $5, $5, $12, $1
        defm    "RAM TEST FAILED", $12, $0, $0d, $ff
l2f17   defm    $16, $2, $0
        defm    " >>> SPECTRUM KEYBOARD TEST <<< ", $0d, $0d
        defm    $14, $1
        defm    "                                 "
        defm    "t i 1 2 3 4 5 6 7 8 9 0   b"
        defm    "                                     "
        defm    "d g   Q W E R T Y U I O P  "
        defm    "                                     "
        defm    "e e   A S D F G H J K L   e"
        defm    "                                     "
        defm    "c c   Z X C V B N M .     c"
        defm    "                                     "
        defm    "s ; ", $22, " < >     S     ^ v , s"
        defm    "                                     "
        defm    "                               "
        defm    $14, $0, $16, $14, $5, $12, $1
        defm    "TEST ALL THE KEYS", $12, $0, $ff
l30d9   defm    $16, $5, $5, $14, $1
        defm    " SYM SHFT/A  TEST "
        defm    $16, $0a, $5
        defm    "   Press "
        defm    $16, $0c, $5, $12, $1
        defm    "SYM SHFT/A"
        defm    $12, $0, $16, $0e, $5
        defm    " for 1 sec ", $14, $0, $ff
l311e   defm    $16, $9, $0, $14, $1
      IF v41
        defm    " SPECTRUM +3 test program V 4.1  AMSTRAD 1987..."
      ELSE
        defm    " SPECTRUM +3 test program V 4.0  AMSTRAD 1987..."
      ENDIF
        defm    "  by RG/CL/VO ", $0d
        defm    "        Check TV tuning         "
        defm    "connect the loopback connector! ", $0d
        defm    "Press [ENTER] if colour is OK,  "
        defm    "press [SPACE] if it is not      ", $0d
        defm    $12, $1, $0d
        defm    "TAKE CARE - THESE TESTS CORRUPT DISKS, AND REQUIRE"
        defm    " FACTORY TEST EQUIPMENT! "
        defm    $14, $0
        defm    "YOU HAVE BEEN WARNED!"
        defm    $14, $0, $12, $0, $ff
l324e   defm    $16, $5, $5, $14, $1
        defm    " ULA TEST "
        defm    $14, $0, $0d, $ff
l3261   defm    $16, $5, $7, $14, $1
        defm    "RAM DATA TESTS", $16, $0a, $5, ".. STARTING NOW .."
        defm    $14, $0, $0d, $ff
l328d   defm    $16, $5, $5, $14, $1
        defm    " GI SOUND TEST "
        defm    $0d, $0d, $14, $0, $ff
l32a6   defm    $16, $5, $5, $14, $1
        defm    " ULA SOUND TEST "
        defm    $0d, $0d, $14, $0, $ff, $0
l32c1   defm    $16, $5, $5, $14, $1
        defm    "CASSETTE OUTPUT TEST"
        defm    $14, $0, $0d, $0d, $ff, $0
l32e0   defm    $16, $0, $0a, $14, $1
        defm    "JOYSTICK TEST"
        defm    $14, $0, $0d, $0d
        defm    "Move both joysticks and press", $0d
        defm    "the FIRE buttons until the", $0d
        defm    "letters below are wiped out", $0d, $0d
        defm    "Press [SPACE] to give up.", $0d, $0d, $0d, $0d
        defm    "+-----J1-----------J2------+", $0d
        defm    "!                          !", $0d
        defm    "!     UP           UP      !", $0d
        defm    "!                          !", $0d
        defm    "!  LF FI RI     LF FI RI   !", $0d
        defm    "!                          !", $0d
        defm    "!     DN           DN      !", $0d
        defm    "!                          !", $0d
        defm    "+--------------------------+", $0d, $ff
l346f   defm    $16, $5, $5
        defm    " ALL TESTS PASSED ", $0d, $ff
l3486   defm    $16, $0, $0, $12, $1
        defm    " TEST FAILED, because:- ", $0d, $12, $0, $0d, $ff
l34a8   defm    "press [ENTER] if you heard four sounds, "
        defm    "else press [SPACE].     ", $ff

; Subroutine to make a beep. This is a copy of the BEEPER
; subroutine at 03B5 in ROM3

l34e9   di
        push    ix
        ld      a,l
        srl     l
        srl     l
        cpl
        and     $03
        ld      c,a
        ld      b,$00
        ld      ix,l3507
        add     ix,bc
        ld      a,(BORDCR)
        and     $38
        rrca
        rrca
        rrca
        or      $08
l3507   nop
l3508   nop
        nop
l350a   inc     b
        inc     c
l350c   dec     c
        jr      nz,l350c
        ld      c,$3f
        dec     b
        jp      nz,l350c
        xor     $10
        out     ($fe),a
        ld      b,h
        ld      c,a
        bit     4,a
        jr      nz,l3528
        ld      a,d
l3520   or      e
        jr      z,l352c
        ld      a,c
        ld      c,l
        dec     de
l3526   jp      (ix)
l3528   ld      c,l
        inc     c
l352a   jp      (ix)
l352c   ei
        pop     ix
        ret

; Table of screen positions for joystick test

l3530   defb    $11,$06,$0f,$06
        defb    $13,$06,$11,$09
        defb    $11,$03,$11,$10
        defb    $11,$16,$13,$13
        defb    $0f,$13,$11,$13

; These bits don't seem to be used

l3544   defm    "FIUPDNRILFLFRIDNUPFI"

; Integral disk test

l3558   ld      hl,l3566        ; address of routine to execute in RAM
        ld      de,$5f00
        ld      bc,$003d
        ldir                    ; copy it
        jp      $5f00           ; jump into it

; Integral disk test routine to execute in RAM

l3566   ld      a,$04
        ld      bc,$1ffd
        out     (c),a           ; switch in ROM 2
        ld      hl, n6000
        ld      de,$6000
        ld      bc,$0c00
        ldir
        ld      a,$00
        ld      bc,$1ffd
        out     (c),a           ; switch in ROM 0
        ld      (BANK678),a
        ld      a,$10
        ld      b,$7f
        out     (c),a           ; switch in ROM 1
        ld      (BANKM),a
        ei
        push    ix
        call    $6000           ; call ROM 2 routine in RAM
        pop     ix
        push    af              ; save success/fail flag
        ld      a,$00
        ld      bc,$7ffd
        out     (c),a           ; switch in ROM 0
        ld      (BANKM),a
        pop     af
        call    l2429           ; set success/fail in flags
        ret                     ; done

; Tape test

l35a3   call    l271a           ; cls
        ld      hl,l362b
        call    l2703           ; display test message
        call    l3612           ; short pause
        di
        ld      hl,$58e1        ; set up attribs
        ld      de,$0006
        ld      b,e
        ld      a,d
l35b8   ld      (hl),a
        add     hl,de
        djnz    l35b8
l35bc   ld      hl,$0000        ; tape testing
        ld      de,$1000
        ld      c,$fe
        ld      b,$7f
        in      a,(c)
        bit     0,a
        jp      z,l361f         ; move on if SPACE pressed
        ld      bc,$bffe
        in      a,(c)
        bit     0,a
        jp      z,l3625         ; move on if ENTER pressed
l35d7   dec     de
        ld      a,d
        or      e
        jr      z,l35e7
        in      a,($fe)
        and     $40
        cp      c
        jr      z,l35d7
        inc     hl
        ld      c,a
        jr      l35d7
l35e7   rl      l
        rl      h
        rl      l
        rl      h
        rl      l
        rl      h
        ld      l,h
        ld      a,$20
        cp      h
        jr      nc,l35fb
        ld      l,$20
l35fb   xor     a
        ld      h,a
        ld      de,$591f
        ld      b,$20
        ld      a,$48
        ei
        halt
        di
l3607   ld      (de),a
        dec     de
        djnz    l3607
        inc     de
        add     hl,de
        ld      a,$68
        ld      (hl),a
        jr      l35bc

; Subroutine to pause for a short while

l3612   ei
        ld      b,$19
l3615   halt
        djnz    l3615           ; pause
        ld      hl,FLAGS
        res     5,(hl)          ; clear "new key" flag
        scf
        ret

; Set "tape test fail" flag

l361f   and     a
        call    l2429
        jr      l3612

; Set "tape test succeed" flag

l3625   scf
        call    l2429
        jr      l3612

l362b   defm    $16, $0, $0
        defm    "Insert test tape, press PLAY,", $0d
        defm    "and adjust azimuth screw for", $0d
        defm    "maximum reading on screen.", $0d
        defm    "Press [ENTER] if successful,", $0d
        defm    "press [SPACE] if failed", $0d, $ff


; *********** END OF SELF-TEST PROGRAM SECTION ***********
    ENDIF

      IF 1
        defb    $74, $DF, $DE, $55, $10, $52, $C9, $9E
        defb    $9E, $BD, $62, $C5, $C0, $55, $C2, $44
        defb    $10, $17, $FE, $5F, $90, $FE, $D1, $DD
        defb    $D5, $17, $90, $F7, $DF, $DF, $D4, $C7
        defb    $D9, $DE, $C3, $BD, $F3, $DC, $59, $D6
        defb    $56, $10, $17, $64, $47, $5F, $90, $60
        defb    $DF, $40, $43, $97, $10, $FC, $51, $C7
        defb    $43, $5F, $DE, $BD, $66, $D9, $5B, $90
        defb    $17, $E2, $D5, $54, $10, $F8, $55, $42
        defb    $42, $59, $DE, $57, $17, $90, $7F, $5C
        defb    $5C, $D9, $C6, $55, $C2, $90, $51, $DE
        defb    $BD, $E4, $D8, $D5, $90, $74, $5F, $C2
        defb    $5B, $59, $5E, $D7, $90, $7D, $5F, $D2
        defb    $BD, $64, $58, $D1, $5E, $DB, $C3, $10
        defb    $C4, $5F, $1E, $1E, $BD, $64, $D8, $D5
        defb    $10, $F2, $42, $D5, $47, $D5, $42, $C9
        defb    $90, $E4, $D1, $C0, $90, $18, $58, $D9
        defb    $D3, $19, $BD, $E2, $5F, $DC, $51, $DE
        defb    $54, $1C, $90, $62, $D9, $D3, $58, $51
        defb    $C2, $54, $90, $55, $44, $90, $D1, $5C
        defb    $BD, $51, $5E, $54, $90, $F9, $C6, $DF
        defb    $42, $10, $98, $C7, $D8, $49, $10, $DE
        defb    $5F, $C4, $19, $BD, $67, $42, $D9, $44
        defb    $C4, $D5, $5E, $90, $DF, $5E, $90, $60
        defb    $F3, $67, $90, $88, $05, $81, $02, $43
        defb    $1C, $10, $45, $43, $D9, $5E, $BD, $FD
        defb    $08, $00, $90, $51, $DE, $D4, $10, $FC
        defb    $08, $00, $10, $45, $5E, $D4, $55, $C2
        defb    $10, $F3, $60, $9F, $FD, $9B, $BD, $BD
        defb    $C3, $90, $C4, $DF, $1E, $9E, $BD, $64
        defb    $D8, $55, $10, $BD
      ELSE
        defs    244
      ENDIF

        defs    $1c

l37ca   defs    $11
l37db
  IF garry
        defs    $10
l37eb   defm    $16, $00, $00
m14e5   defm    $10, $00, $11, $07, $13, $00
      IF spanish
        defm    "Introduzca la cinta y pulse PLAY"
        defm    "Cancelar: pulse BREAK dos veces", '.'+$80
      ELSE
        defm    "Insert tape and press PLAY", $0d
        defm    "To cancel - press BREAK twic", 'e'+$80
        defb    0, 0, 0, 0, 0, 0, 0, 0
      ENDIF
     
l3834   defm    $7f, "1982, 1986, 1987 Amstrad Plc.", 13
        defm    $7f, "2000-2015 Garry Lancaster v1.4", '3'+$80
     
l3871   ret     nc
        call    l15da
        ret     c
        ld      a, b
        or      c
        scf
        ret     z
        jp      l1604
l387f   ex      de, hl
        and     a
        sbc     hl, de
        ld      c, l
        ld      b, a
        inc     de
        inc     de
        inc     de
        inc     de
        ld      a, (de)
        cp      $50
        jr      z, l38a2
        inc     de
        dec     c
        jr      z, l389b
        inc     de
        inc     de
        ex      de, hl
        ld      e, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, e
        jr      l38ab
l389b   ex      de, hl
        ld      e, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, e
        jr      l3907
l38a2   ld      hl, l3921
        dec     c
        jr      z, l3907
        ld      hl, l3927
l38ab   res     3, (iy+$02)
        push    hl
        ld      hl, (ERR_SP)
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        and     a
        ld      hl, $107f
        sbc     hl, de
        pop     hl
        jr      nz, l38f8
        ld      sp, (ERR_SP)
        pop     de
        pop     de
        ld      (ERR_SP), de
        push    ix
l38cb   push    hl
        ld      de, l38d1
        push    de
        jp      (hl)
l38d1   jr      c, l38dc
        jr      z, l38d9
l38d5   ld      a, 7
        jr      l3917
l38d9   pop     hl
        jr      l38cb
l38dc   cp      13
        jr      z, l38ee
        ld      hl, (RETADDR)
        push    hl
        ROM3    o0F85
        pop     hl
        ld      (RETADDR), hl
        pop     hl
        jr      l38cb
l38ee   pop     hl
        pop     ix
        ld      hl, l15fe
        push    hl
        jp      $5b00
l38f8   ld      de, l15fe
        push    de
        call    l3916
        jp      c, $5b00
        jp      z, $5b00
        jr      l38d5
l3907   ld      de, l15fe
        push    de
        ld      a, b
        push    ix
        call    l3916
        pop     ix
        jp      $5b00
l3916   jp      (hl)
l3917   ld      hl, (CH_ADD)
        ld      (X_PTR), hl
        ld      l, a
        ROM3    o0055
l3921   ROM1    m1f6e
        ret
l3927   ROM1    m1e70
        ret
l392d   ld      hl, (CURCHL)
        ld      a, (hl)
        cp      0
        jr      nz, l3967
        inc     hl
        ld      a, (hl)
        dec     hl
        cp      $5b
        jr      nz, l3967
        inc     hl
        inc     hl
        inc     hl
        inc     hl
        ld      a, (hl)
        inc     hl
        cp      $50
        jr      nz, l3955
        ld      a, e
        cp      4
        jr      z, l399c
        cp      2
        jp      z, l3927
        exx
        ld      a, c
        jp      l3921
l3955   ld      a, e
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        push    de
        cp      2
        jr      z, l3962
        exx
        ld      a, c
        ret
l3962   ld      hl, l3996
        ex      (sp), hl
        jp      (hl)
l3967   ld      a, e
        cp      4
        jr      z, l399c
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ld      hl, (RETADDR)
        push    hl
        cp      2
        jr      z, l3989
        ld      hl, l3985
        ld      (RETADDR), hl
        ex      de, hl
        exx
        ld      a, c
        exx
        jp      l00ae
l3985   ld      (RETADDR), hl
        ret
l3989   ld      hl, l3993
        ld      (RETADDR), hl
        ex      de, hl
        jp      l00ae
l3993   ld      (RETADDR), hl
l3996   ret     c
        ld      de, 2
        jr      l392d
l399c   ld      a, $12
        jp      l3917
l39a1   ld      hl, (CURCHL)
        ld      de, 13
        add     hl, de
        ld      a, (hl)
        push    hl
        ld      hl, (VARS)
        ld      c, a
l39ae   ld      a, (hl)
        cp      $80
        jr      z, l399c
        cp      c
        jr      z, l39be
        push    bc
        ROM3    o19B8
        pop     bc
        ex      de, hl
        jr      l39ae
l39be   inc     hl
        inc     hl
        inc     hl
        ld      a, (hl)
        inc     hl
        dec     a
        jr      nz, l399c
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ex      de, hl
        pop     hl
        inc     hl
        ld      a, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, a
        push    hl
        and     a
        sbc     hl, bc
        pop     hl
        ret
l39d7   call    l39a1
        jp      nc, l38d5
        add     hl, de
        ld      a, (hl)
l39df   ld      hl, (CURCHL)
        ld      de, 14
        add     hl, de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     de
        ld      (hl), d
        dec     hl
        ld      (hl), e
        scf
        ret
l39ef   push    af
        call    l39a1
        jp      nc, l38d5
        add     hl, de
        pop     af
        ld      (hl), a
        jr      l39df
l39fb   push    hl
        push    de
        ld      a, b
        push    af
        call    l39a1
        pop     af
        and     a
        jr      nz, l3a0c
        pop     bc
        pop     bc
        ld      de, 0
        ret
l3a0c   dec     a
        jr      nz, l3a29
        pop     hl
        ld      a, h
        or      l
        jp      nz, l38d5
        pop     hl
        and     a
        sbc     hl, bc
        jp      nc, l38d5
        add     hl, bc
        ex      de, hl
        ld      hl, (CURCHL)
        ld      bc, 14
        add     hl, bc
        ld      (hl), e
        inc     hl
        ld      (hl), d
        ret
l3a29   pop     hl
        pop     hl
        ld      h, b
        ld      l, c
        ld      de, 0
        ret
        defs    $3cf
  ELSE
    IF v41
        defs    $4c
    ELSE
      IF spanish
        defs    $51
      ELSE
        defs    $59
      ENDIF
    ENDIF
      IF spanish
        defs    $3b9
      ELSE
        defs    $05cc
      ENDIF
  ENDIF

l3e00   ld      (OLDHL),hl
        push    af
        pop     hl

l3e05   ld      (OLDAF),hl
        ex      (sp),hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)
        inc     hl
        ex      (sp),hl
        push    bc
        pop     hl
        ld      a,(BANK678)
        ld      bc,$1ffd
        res     2,a
        di
        ld      (BANK678),a
        out     (c),a
        ei
        ld      bc,$3e2d
        push    bc
        push    hl
        ld      hl,(OLDAF)
        push    hl
        pop     af
        ld      hl,(OLDHL)
        ret
        push    bc
        push    af
        ld      a,(BANK678)
        ld      bc,$1ffd
        set     2,a
        di
        ld      (BANK678),a
        out     (c),a
        ei
        pop     af
        pop     bc
        ret
      IF garry
l3e41   ld      hl, (CURCHL)    ; get address of current channel information
        ld      de, 13
        add     hl, de
        ld      b, (hl)
        pop     hl
        call    l05cc
        jp      (hl)
l3e4e   exx
        call    l3e41
        push    bc
        exx
        ld      a, b
        pop     bc
        and     a
        jr      z, l3e63
        dec     a
        jr      z, l3e6c
        call    l3ec9
        add     hl, sp
        ld      bc, $0518
l3e63   call    l3ec9
        inc     sp
        ld      bc, 22
        jr      l3ee9
l3e6c   call    l3ec9
        ld      (hl), 1
        jr      l3ee9
        call    l3e41
        call    l3ec9
        jr      l3e7c
l3e7b   ld      a, c
l3e7c   jr      l3ee9
        defs    2
      ELSE
        defs    $3f
      ENDIF
; Subroutine to call a subroutine in ROM 1
; The address to call is stored inline after the call to this routine

l3e80   ld      (OLDHL),hl      ; save HL in OLDHL
        ld      (OLDBC),bc      ; save BC in OLDBC
        push    af
        pop     hl
        ld      (OLDAF),hl      ; save AF in OLDAF
        ex      (sp),hl         ; HL=return address
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address for ROM 1
        inc     hl
        ex      (sp),hl         ; restore proper return address
        push    bc
        pop     hl              ; HL=address in ROM 1 to call
        ld      a,(BANKM)
        or      $10
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 1

; The rest of the routine continues at $3ea2 in ROM 1
; The following is a continuation of a mirrored routine in ROM 1 for
; returning to this ROM

l3ea2   ei
        ld      bc,$3eb5
        push    bc              ; stack return add to swap back ROMS
        push    hl              ; stack address of routine to call
        ld      hl,(OLDAF)
        push    hl
        pop     af              ; restore AF
        ld      bc,(OLDBC)      ; restore BC
        ld      hl,(OLDHL)      ; restore HL
        ret                     ; exit to routine in this ROM

; This is the routine which returns control to the calling routine in ROM 1

l3eb5   push    af              ; save AF & BC
        push    bc
        ld      a,(BANKM)
        or      $10
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page back ROM 1

; The rest of the routine continues at $3ec5 in ROM 1
; The following is a continuation of a mirrored routine in ROM 1 for
; returning to this ROM

l3ec5   ei
        pop     bc
        pop     af
        ret

      IF garry
l3ec9   ld      (OLDHL),hl      ; save HL in OLDHL
        ld      (OLDBC),bc      ; save BC in OLDBC
        push    af
        pop     hl
        ld      (OLDAF),hl      ; save AF in OLDAF
        ex      (sp),hl         ; HL=return address
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address for ROM 1
        inc     hl
        ex      (sp),hl         ; restore proper return address
        ld      hl, l3f63
        jr      l3f15
l3ee0   ld      c, a
        call    l3e41
        call    l3ec9
        dec     de
        defb    1               ; ld bc, xxxx
l3ee9   call    l05a7
        ret     c
        ld      a, $12
        jp      l3917
        defs    14
      ELSE
        defs    $37
      ENDIF

; Subroutine to call a subroutine in ROM 2, with inline address
; This routine is not used in this ROM, but is a duplicate of a
; routine in ROM 1, which takes over during ROM switching to ROM 2
; via this ROM, and back again at the end.

l3f00   ld      (OLDHL),hl      ; save HL, BC and AF
        ld      (OLDBC),bc
        push    af
        pop     hl
        ld      (OLDAF),hl
        ex      (sp),hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address
        inc     hl
        ex      (sp),hl         ; restack updated return address
      IF garry
        ld      hl, l3f42
l3f15   push    hl
      ENDIF
        push    bc
        pop     hl
        ld      a,(BANKM)
        and     $ef
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; switch in ROM 0
        ld      a,(BANK678)
        or      $04
        ld      (BANK678),a
        ld      bc,$1ffd
        out     (c),a           ; switch in ROM 2
        ei
      IF garry=0
        ld      bc,l3f42
        push    bc              ; stack routine address to return to ROM 1
      ENDIF
        push    hl              ; stack routine address to call in ROM 2
        ld      hl,(OLDAF)      ; restore registers
        push    hl
        pop     af
        ld      bc,(OLDBC)
        ld      hl,(OLDHL)
        ret                     ; exit to routine

; This part of the routine then returns control to ROM 1

l3f42   push    bc              ; save registers
        push    af
        ld      a,(BANK678)
        and     $fb
        di
        ld      (BANK678),a
        ld      bc,$1ffd
        out     (c),a           ; page in ROM 0
        ld      a,(BANKM)
        or      $10
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 1
        ei
        pop     af              ; restore registers
        pop     bc
        ret                     ; done!

      IF garry
l3f63   push    bc
        push    af
        ld      a, (BANK678)
        and     $fb
        di
        ld      (BANK678), a
        ld      bc, $1ffd
        out     (c), a
        ei
        pop     af
        pop     bc
        ret
l3f77   exx
l3f78   push    hl
        push    bc
        push    hl
        ld      hl, (RETADDR)
        ex      (sp), hl
        ROM3    o19E8
        pop     hl
        ld      (RETADDR), hl
        pop     bc
        pop     hl
        ld      de, (CHANS)
        and     a
        sbc     hl, de
        push    hl
        ld      a, $13
        ld      hl, STRMS
l3f95   ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ex      (sp), hl
        and     a
        sbc     hl, de
        add     hl, de
        jr      nc, l3fa4
        ex      de, hl
        and     a
        sbc     hl, bc
        ex      de, hl
l3fa4   ex      (sp), hl
        dec     hl
        ld      (hl), e
        inc     hl
        ld      (hl), d
        inc     hl
        dec     a
        jr      nz, l3f95
        pop     hl
        ret
l3faf   exx
l3fb0   push    hl
        push    bc
        push    hl
        ld      hl, (RETADDR)
        ex      (sp), hl
        ROM3    o1655
        pop     hl
        ld      (RETADDR), hl
        ld      hl, (DATADD)
        ld      de, (PROG)
        dec     de
        and     a
        sbc     hl, de
        jr      nc, l3fcf
        ld      (DATADD), de
l3fcf   pop     bc
        pop     hl
        ld      de, (CHANS)
        and     a
        sbc     hl, de
        push    hl
        ld      a, $13
        ld      hl, STRMS
l3fde   ld      e, (hl)
        inc     hl
        ld      d, (hl)
        ex      (sp), hl
        and     a
        sbc     hl, de
        add     hl, de
        jr      nc, l3fec
        ex      de, hl
        and     a
        add     hl, bc
        ex      de, hl
l3fec   ex      (sp), hl
        dec     hl
        ld      (hl), e
        inc     hl
        ld      (hl), d
        inc     hl
        dec     a
        jr      nz, l3fde
        pop     hl
        ret
      ELSE
        defs    $8d
      ENDIF

; This routine is called from ROM 2 to display error messages, and
; optionally get a response

l3ff0   jp      l2187           ; go to the routine

  IF garry
        defb    0, 0, 0, 0, 0, 0
  ELSE
        defb    $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
        defb    $ff, $ff, $ff, $ff

    IF v41
      IF spanish
        defb    $b6
      ELSE
        defb    $1f
      ENDIF
    ELSE
      IF spanish
        defb    $66
      ELSE
        defb    $8b
      ENDIF
    ENDIF
  ENDIF


; **************************************************
; *** SPECTRUM +3 ROM 1 DISASSEMBLY (SYNTAX ROM) ***
; **************************************************

; The Spectrum ROMs are copyright Amstrad, who have kindly given permission
; to reverse engineer and publish Spectrum ROM disassemblies.


; =====
; NOTES
; =====

; ------------------------
; Disassembly Contributors
; ------------------------
; Garry Lancaster
;
; The ROM disassembly was created with the aid of dZ80 V1.10, and incorporates work from
; "The canonical list of +3 oddities" by Ian Collier.

; -----------------
; Assembler Details
; -----------------

; This file can be assembled to produce a binary image of the ROM
; with Interlogic's Z80ASM assembler (available for Z88, QL, DOS and Linux).
; Note that the defs directive is used and this causes a block of $00 bytes to be created.

;**************************************************

; +3DOS routine addresses

;        include "p3dos.def"
        define  IDE_STREAM_OPEN     $0056
        define  IDE_STREAM_CLOSE    $0059
        define  IDE_STREAM_IN       $005c
        define  IDE_STREAM_OUT      $005f
        define  IDE_STREAM_PTR      $0062
        
        define  IDE_VERSION         $00a0
        define  IDE_INTERFACE       $00a3
        define  IDE_INIT            $00a6
        define  IDE_DRIVE           $00a9
        define  IDE_SECTOR_READ     $00ac
        define  IDE_SECTOR_WRITE    $00af
        define  IDE_FORMAT          $00b2
        define  IDE_PARTITION_FIND  $00b5
        define  IDE_PARTITION_NEW   $00b8
        define  IDE_PARTITION_INIT  $00bb
        define  IDE_PARTITION_ERASE $00be
        define  IDE_PARTITION_RENAME $00c1
        define  IDE_PARTITION_READ  $00c4
        define  IDE_PARTITION_WRITE $00c7
        define  IDE_PARTITION_WINFO $00ca
        define  IDE_PARTITION_OPEN  $00cd
        define  IDE_PARTITION_CLOSE $00d0
        define  IDE_PARTITION_GETINFO $00d3
        define  IDE_PARTITION_SETINFO $00d6
        define  IDE_SWAP_OPEN       $00d9
        define  IDE_SWAP_CLOSE      $00dc
        define  IDE_SWAP_OUT        $00df
        define  IDE_SWAP_IN         $00e2
        define  IDE_SWAP_EX         $00e5
        define  IDE_SWAP_POS        $00e8
        define  IDE_SWAP_MOVE       $00eb
        define  IDE_SWAP_RESIZE     $00ee
        define  IDE_DOS_MAP         $00f1
        define  IDE_DOS_UNMAP       $00f4
        define  IDE_DOS_MAPPING     $00f7
        define  IDE_DOS_UNPERMANENT $00fa
        define  IDE_SNAPLOAD        $00fd

        define  DOS_INITIALISE      $0100
        define  DOS_VERSION         $0103
        define  DOS_OPEN            $0106
        define  DOS_CLOSE           $0109
        define  DOS_ABANDON         $010c
        define  DOS_REF_HEAD        $010f
        define  DOS_READ            $0112
        define  DOS_WRITE           $0115
        define  DOS_BYTE_READ       $0118
        define  DOS_BYTE_WRITE      $011b
        define  DOS_CATALOG         $011e
        define  DOS_FREE_SPACE      $0121
        define  DOS_DELETE          $0124
        define  DOS_RENAME          $0127
        define  DOS_BOOT            $012a
        define  DOS_SET_DRIVE       $012d
        define  DOS_SET_USER        $0130
        define  DOS_GET_POSITION    $0133
        define  DOS_SET_POSITION    $0136
        define  DOS_GET_EOF         $0139
        define  DOS_GET_1346        $013c
        define  DOS_SET_1346        $013f
        define  DOS_FLUSH           $0142
        define  DOS_SET_ACCESS      $0145
        define  DOS_SET_ATTRIBUTES  $0148
        define  DOSOPEN_DRIVE      $014b
        define  DOS_SET_MESSAGE     $014e
        define  DOS_REF_XDPB        $0151
        define  DOS_MAP_B           $0154

        define  DD_INTERFACE        $0157
        define  DD_INIT             $015a
        define  DD_SETUP            $015d
        define  DD_SET_RETRY        $0160
        define  DD_READ_SECTOR      $0163
        define  DD_WRITE_SECTOR     $0166
        define  DD_CHECK_SECTOR     $0169
        define  DD_FORMAT           $016c
        define  DD_READ_ID          $016f
        define  DD_TEST_UNSUITABLE  $0172
        define  DD_LOGIN            $0175
        define  DD_SEL_FORMAT       $0178
        define  DD_ASK_1            $017b
        define  DD_DRIVE_STATUS     $017e
        define  DD_EQUIPMENT        $0181
        define  DD_ENCODE           $0184
        define  DD_L_XDPB           $0187
        define  DD_L_DPB            $018a
        define  DD_L_SEEK           $018d
        define  DD_L_READ           $0190
        define  DD_L_WRITE          $0193
        define  DD_L_ON_MOTOR       $0196
        define  DD_L_T_OFF_MOTOR    $0199
        define  DD_L_OFF_MOTOR      $019c

        define  IDE_ACCESS_DATA     $019f
        define  IDE_IDENTIFY        $01a2
        define  IDE_PARTITIONS      $01a5
        define  IDE_FS_UNIT         $01a8
        define  IDE_FS_DRIVE        $01ab
        define  IDE_FS_FILE         $01ae
        define  IDE_PATH            $01b1

; +3DOS Error codes

        define  rc_ready    $00
        define  rc_wp       $01
        define  rc_seek     $02
        define  rc_crc      $03
        define  rc_nodata   $04
        define  rc_mark     $05
        define  rc_unrecog  $06
        define  rc_unknown  $07
        define  rc_diskchg  $08
        define  rc_unsuit   $09

        define  rc_badname  $14
        define  rc_badparam $15
        define  rc_nodrive  $16
        define  rc_nofile   $17
        define  rc_exists   $18
        define  rc_eof      $19
        define  rc_diskfull $1a
        define  rc_dirfull  $1b
        define  rc_ro       $1c
        define  rc_number   $1d
        define  rc_denied   $1e
        define  rc_norename $1f
        define  rc_extent   $20
        define  rc_uncached $21
        define  rc_toobig   $22
        define  rc_notboot  $23
        define  rc_inuse    $24
;--------------------------------------------------

; The floating-point calculator commands

;        include "fpcalc.def"
        define  jump_true $00
        define  exchange  $01
        define  delete    $02
        define  subtract  $03
        define  multiply  $04
        define  division  $05
        define  to_power  $06
        define  logic_or  $07
        define  no_and_no $08
        define  no_l_eql  $09
        define  no_gr_eq  $0a
        define  nos_neql  $0b
        define  no_grtr   $0c
        define  no_less   $0d
        define  nos_eql   $0e
        define  addition  $0f
        define  strandno  $10
        define  str_l_eql $11
        define  str_gr_eq $12
        define  strs_neql $13
        define  str_grtr  $14
        define  str_less  $15
        define  strs_eql  $16
        define  strs_add  $17
        define  val_str   $18
        define  usr_str   $19
        define  read_in   $1a
        define  negate    $1b
        define  code      $1c
        define  val       $1d
        define  len       $1e
        define  sin       $1f
        define  cos       $20
        define  tan       $21
        define  asn       $22
        define  acs       $23
        define  atn       $24
        define  ln        $25
        define  exp       $26
        define  int       $27
        define  sqr       $28
        define  sgn       $29
        define  abs       $2a
        define  peek      $2b
        define  in_port   $2c
        define  usr_no    $2d
        define  str_str   $2e
        define  chr_str   $2f
        define  not       $30
        define  duplicate $31
        define  n_mod_m   $32
        define  jump      $33
        define  stk_data  $34
        define  dec_jr_nz $35
        define  less_0    $36
        define  greater_0 $37
        define  end_calc  $38
        define  get_argt  $39
        define  truncate  $3a
        define  fp_calc_2 $3b
        define  e_to_fp   $3c
        define  re_stack  $3d
        define  series_06 $86
        define  series_08 $88
        define  series_0c $8c
        define  stk_zero  $a0
        define  stk_one   $a1
        define  stk_half  $a2
        define  stk_pi_2  $a3
        define  stk_ten   $a4
        define  st_mem_0  $c0
        define  st_mem_1  $c1
        define  st_mem_2  $c2
        define  st_mem_3  $c3
        define  st_mem_4  $c4
        define  st_mem_5  $c5
        define  get_mem_0 $e0
        define  get_mem_1 $e1
        define  get_mem_2 $e2
        define  get_mem_3 $e3
        define  get_mem_4 $e4
        define  get_mem_5 $e5
;--------------------------------------------------

        org     $0000

; ROM 1 Header

m0000   defm    "Syntax"
        defs    2

; RST $08 - The "Error" restart

m0008   jp      m2ada           ; jump to error handler

        defs    5

; RST $10 - The "Print a character restart"

m0010   ROM3    o0010           ; call RST $10 in ROM 3
        ret

        defs    4

; RST $18 - The "Collect character" restart

m0018   ROM3    o0018           ; call RST $18 in ROM 3
        ret

        defs    4

; RST $20 - The "Collect next character" restart

m0020   ROM3    o0020           ; call RST $20 in ROM 3
        ret

        defs    4

; RST $28 : Call a routine in ROM 3, then return to ROM 1
; The address following the RST 28 instruction is called, then control
; is returned to the instruction following the address

m0028   ex      (sp),hl         ; save HL, get return address
        push    af              ; save AF
        ld      a,(hl)          ; A=low byte of address to call
        inc     hl
        inc     hl              ; HL=address of instruction to return to
        ld      (RETADDR),hl    ; save
m0030   dec     hl
        ld      h,(hl)
        ld      l,a             ; HL=address to call in ROM 3
        pop     af              ; restore AF
        jp      m00aa           ; jump on

        nop

; The maskable interrupt routine

m0038   push    af              ; save registers
        push    hl
        ld      hl,(FRAMES)     ; increment FRAMES
        inc     hl
        ld      (FRAMES),hl
        ld      a,h
        or      l
        jr      nz,m0048
        inc     (iy+$40)
m0048   push    bc
        push    de
        call    m0176           ; scan keyboard
        call    m0074           ; call disk motor timeout routine
        pop     de              ; restore registers
        pop     bc
        pop     hl
        pop     af
        ei                      ; re-enable interrupts & exit
        ret
    IF garry
      IF spanish
m0056   defm    "Inicio:", 0
m005e   defm    "sistema", 0
      ELSE
m0056   defm    "Start: ", 0
m005e   defm    "system", 0, 0
      ENDIF
    ELSE
        defs    $10
    ENDIF

; The NMI routine

m0066   push    af              ; save registers
        push    hl
        ld      hl,(NMIADD)     ; get routine address
        ld      a,h
        or      l
        jr      z,m0070
        jp      (hl)            ; execute if non-zero address
m0070   pop     hl              ; restore registers & exit
        pop     af
        retn

; The disk motor timeout routine

m0074   ld      bc,$7ffd
        ld      a,(BANKM)
        or      $07
        out     (c),a           ; page in page 7
        ld      a,(timeout)
        or      a
        jr      z,m00a1         ; move on if already off
        ld      a,(FRAMES)
        bit     0,a
        jr      nz,m00a1        ; only decrement counter every other frame
        ld      a,(timeout)
        dec     a               ; decrement timeout counter
        ld      (timeout),a
        jr      nz,m00a1        ; move on if non-zero
        ld      bc,$1ffd
        ld      a,(BANK678)
        and     $f7
        ld      (BANK678),a
        out     (c),a           ; turn motor off
m00a1   ld      bc,$7ffd
        ld      a,(BANKM)
        out     (c),a           ; page in last memory configuration
        ret

; Continuation of RST 28: call a routine in ROM 3

m00aa   ld      (TARGET),hl     ; save ROM 3 address in TARGET
        ld      hl,REGNUOY
        ex      (sp),hl         ; stack REGNUOY address beneath TOS
        push    hl
        ld      hl,(TARGET)     ; get HL=target address in ROM 3
        ex      (sp),hl         ; restore HL & save target address on stack
        push    af              ; stack AF & BC
        push    bc
        di                      ; disable interrupts
        jp      STOO            ; jump to STOO - pages in ROM 3, returns to
                                ; target routine which returns to REGNUOY
                                ; where ROM 1 is paged back and jump made
                                ; back to RETADDR


; These are copies of the key tables from ROM 3


; The L-mode keytable with CAPS-SHIFT

m00bc   defm    "BHY65TGV"
        defm    "NJU74RFC"
        defm    "MKI83EDX"
        defm    $0e, "LO92WSZ"
        defm    " ", $0d, "P01QA"

; The extended-mode keytable (unshifted letters)

m00e3   defb    $e3,$c4,$e0,$e4
        defb    $b4,$bc,$bd,$bb
        defb    $af,$b0,$b1,$c0
        defb    $a7,$a6,$be,$ad
        defb    $b2,$ba,$e5,$a5
        defb    $c2,$e1,$b3,$b9
        defb    $c1,$b8

; The extended mode keytable (shifted letters)

m00fd   defb    $7e,$dc,$da,$5c
        defb    $b7,$7b,$7d,$d8
        defb    $bf,$ae,$aa,$ab
        defb    $dd,$de,$df,$7f
        defb    $b5,$d6,$7c,$d5
        defb    $5d,$db,$b6,$d9
        defb    $5b,$d7

; The control code keytable (CAPS-SHIFTed digits)

m0117   defb    $0c,$07,$06,$04
        defb    $05,$08,$0a,$0b
        defb    $09,$0f

; The symbol code keytable (letters with symbol shift)

m0121   defb    $e2,$2a,$3f,$cd
        defb    $c8,$cc,$cb,$5e
        defb    $ac,$2d,$2b,$3d
        defb    $2e,$2c,$3b,$22
        defb    $c7,$3c,$c3,$3e
        defb    $c5,$2f,$c9,$60
        defb    $c6,$3a

; The extended mode keytable (SYM-SHIFTed digits)

m013b   defb    $d0,$ce,$a8,$ca
        defb    $d3,$d4,$d1,$d2
        defb    $a9,$cf


; This is a copy of the "keyboard scanning" subroutine from
; $028e in ROM 3

m0145   ld      l,$2f
        ld      de,$ffff
        ld      bc,$fefe
m014d   in      a,(c)
        cpl
        and     $1f
        jr      z,m0162
        ld      h,a
        ld      a,l
m0156   inc     d
        ret     nz
m0158   sub     $08
        srl     h
        jr      nc,m0158
        ld      d,e
        ld      e,a
        jr      nz,m0156
m0162   dec     l
        rlc     b
        jr      c,m014d
        ld      a,d
        inc     a
        ret     z
        cp      $28
        ret     z
        cp      $19
        ret     z
        ld      a,e
        ld      e,d
        ld      d,a
        cp      $18
        ret

; This is a copy of the "keyboard" subroutines from $02bf in ROM 3

m0176   call    m0145
        ret     nz
        ld      hl,KSTATE
m017d   bit     7,(hl)
        jr      nz,m0188
        inc     hl
        dec     (hl)
        dec     hl
        jr      nz,m0188
        ld      (hl),$ff
m0188   ld      a,l
        ld      hl,KSTATE+$04
        cp      l
        jr      nz,m017d
        call    m01d5
        ret     nc
        ld      hl,KSTATE
        cp      (hl)
        jr      z,m01c7
        ex      de,hl
        ld      hl,KSTATE+$04
        cp      (hl)
        jr      z,m01c7
        bit     7,(hl)
        jr      nz,m01a8
        ex      de,hl
        bit     7,(hl)
        ret     z
m01a8   ld      e,a
        ld      (hl),a
        inc     hl
        ld      (hl),$05
        inc     hl
        ld      a,(REPDEL)
        ld      (hl),a
        inc     hl
        ld      c,(iy+$07)
        ld      d,(iy+$01)
        push    hl
        call    m01ea
        pop     hl
        ld      (hl),a
m01bf   ld      (LAST_K),a
        set     5,(iy+$01)
        ret
m01c7   inc     hl
        ld      (hl),$05
        inc     hl
        dec     (hl)
        ret     nz
        ld      a,(REPPER)
        ld      (hl),a
        inc     hl
        ld      a,(hl)
        jr      m01bf

; This is a copy of the "K-Test" subroutine from $031e in ROM 3

m01d5   ld      b,d
        ld      d,$00
        ld      a,e
        cp      $27
        ret     nc
        cp      $18
        jr      nz,m01e3
        bit     7,b
        ret     nz
m01e3   ld      hl,m00bc        ; the main keytable
        add     hl,de
        ld      a,(hl)
        scf
        ret

; This is a copy of the "Keyboard decoding" subroutine from $0333 in
; ROM 3

m01ea   ld      a,e
        cp      $3a
        jr      c,m021e
        dec     c
        jp      m,m0206
        jr      z,m01f8
        add     a,$4f
        ret
m01f8   ld      hl,m00e3-'A'
        inc     b
        jr      z,m0201
        ld      hl,m00fd-'A'
m0201   ld      d,$00
        add     hl,de
        ld      a,(hl)
        ret
m0206   ld      hl,m0121-'A'
        bit     0,b
        jr      z,m0201
        bit     3,d
        jr      z,m021b
        bit     3,(iy+$30)
        ret     nz
        inc     b
        ret     nz
        add     a,$20
        ret
m021b   add     a,$a5
        ret
m021e   cp      $30
        ret     c
        dec     c
        jp      m,m0254
        jr      nz,m0240
        ld      hl,m013b-'0'
        bit     5,b
        jr      z,m0201
        cp      $38
        jr      nc,m0239
        sub     $20
        inc     b
        ret     z
        add     a,$08
        ret
m0239   sub     $36
        inc     b
        ret     z
        add     a,$fe
        ret
m0240   ld      hl,m0117-'0'
        cp      $39
        jr      z,m0201
        cp      $30
        jr      z,m0201
        and     $07
        add     a,$80
        inc     b
        ret     z
        xor     $0f
        ret
m0254   inc     b
        ret     z
        bit     5,b
        ld      hl,m0117-'0'
        jr      nz,m0201
        sub     $10
        cp      $22
        jr      z,m0269
        cp      $20
        ret     nz
        ld      a,$5f
        ret
m0269   ld      a,$40
        ret


; The FORMAT command

m026c   ROM3    o0018           ; get character after FORMAT
m026f   cp      $e0
        jp      z,m03e3         ; move on if LPRINT
        cp      $ca
      IF garry
        jp      z, m1e02        ; move on if not LINE
        cp      $cc
        jp      z, m1dd9
      ELSE
        jr      nz,m027e        ; move on if not LINE
        ROM3    o0020           ; get next character
        jp      m1e05           ; and move on for FORMAT LINE
      ENDIF
m027e   ROM3    o1C8C           ; get a string expression
        call    m10b1           ; check for end-of-statement
        ROM3    o2BF1           ; get string from stack
        ld      a,c
        dec     a
        dec     a
        or      b
        jr      z,m0291         ; move on if length is 2
m028d   call    m2ada
        defb    $4e             ; else error "Invalid drive"
m0291   inc     de
        ld      a,(de)          ; check 2nd char
        dec     de
        cp      ':'
        jr      z,m029c
        call    m2ada
        defb    $4e             ; error "Invalid drive" if not colon
m029c   ld      a,(de)
        and     $df             ; get capitalised drive letter
        cp      'A'
        jr      z,m02ab         ; move on if A:
        cp      'B'
        jr      z,m02ab         ; or B:
        call    m2ada
        defb    $4e             ; else error "Invalid drive"
m02ab   call    m2b89           ; page in DOS workspace
        sub     'A'
        push    af              ; save unit number to format
        ld      hl,FLAGS3
        bit     4,(hl)
        jr      nz,m02bf        ; move on if disk interface present
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $4c             ; else error "Format not supported on +2A"
m02bf   pop     af
        or      a
        jr      z,m02d3         ; move on for unit 0
        push    af
        ld      hl,FLAGS3
        bit     5,(hl)
        jr      nz,m02d2        ; move on if drive B: present
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $4b             ; else error "Drive B: not present"
m02d2   pop     af              ; get unit
m02d3   push    af
        ld      c,a
        push    bc
        add     a,'A'
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_XDPB    ; point IX at XDPB
        call    m32ee           ; restore TSTACK
        jr      c,m02ec         ; move on if no error
        call    m2b64           ; page in DOS memory
        call    m0e9a           ; cause DOS error
        defb    $ff
m02ec   pop     bc
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_LOGIN        ; login disk
        call    m32ee           ; restore TSTACK
        jr      nc,m0306        ; move on if error
        or      a
        jr      nz,m0315        ; move on if disk isn't +3 format
        call    m0381           ; ask if wish to abandon
        jr      nz,m0315        ; move on if not
        call    m2b64           ; page in normal memory
        ret                     ; exit
m0306   cp      $05
        jr      z,m0315         ; move on if error was "missing address mark"
        cp      $09
        jr      z,m0315         ; or "unsuitable media"
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause DOS error
        defb    $ff
m0315   pop     af              ; get unit number
        push    af
        add     a,'A'
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_XDPB    ; point IX to XDPB
        call    m32ee           ; restore TSTACK
        jr      c,m032d
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause any DOS error
        defb    $ff
m032d   xor     a
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_SEL_FORMAT   ; select +3 format
        call    m32ee           ; restore TSTACK
        jr      c,m0342
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause any DOS error
        defb    $ff
m0342   pop     af
        ld      c,a             ; C=unit number
        xor     a               ; start at track 0
m0345   ld      d,a
      IF bluerom
        call    newfill         ; new fill format buffer for interleave factor 3
      ELSE
        call    m036f           ; fill format buffer
      ENDIF
        ld      e,$e5           ; filler byte
        ld      b,$07           ; page 7
        ld      hl,tmp_buff     ; buffer address
        push    af
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_FORMAT       ; format a track
        call    m32ee           ; restore TSTACK
        jr      c,m0365
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause any DOS error
        defb    $ff
m0365   pop     af
        inc     a               ; increment track
        cp      $28
        jr      nz,m0345        ; back if more to do
        call    m2b64           ; page in normal memory
        ret                     ; done

; Subroutine to fill scratch area with format buffer details

m036f   ld      b,$09           ; 9 sectors
        ld      hl,tmp_buff+$23 ; end of scratch area
m0374   ld      (hl),$02        ; 512-byte sectors
        dec     hl
        ld      (hl),b          ; sector number
        dec     hl
        ld      (hl),$00        ; head 0
        dec     hl
        ld      (hl),d          ; track number
        dec     hl
        djnz    m0374
        ret

; Subroutine to display "disk already formatted message",
; and get a key, exiting with Z set if user wishes to abandon

m0381   ld      hl,m03a7
m0384   ld      a,(hl)          ; get next char
        or      a
        jr      z,m038e         ; move on if null
        ROM3    o0010           ; output char
m038b   inc     hl
        jr      m0384           ; loop back
m038e   res     5,(iy+$01)      ; signal "no key"
m0392   bit     5,(iy+$01)
        jr      z,m0392         ; wait for key
        ld      a,(LAST_K)      ; get key
        and     $df             ; capitalise
        cp      'A'             ; is it "A"?
        push    af
        push    hl
        ROM3    o0D6E           ; clear lower screen
        pop     hl
        pop     af
        ret                     ; exit with Z set if abandon requested

; Formatting message

    IF spanish
m03a7   defm    "Ya formateado. Tecla A para", $0d
        defm    "abandonar/otra para continuar", 0
      IF garry
        defb    0, 0
      ENDIF
    ELSE
m03a7   defm    "Disk is already formatted.", $0d
        defm    "A to abandon, other key continue", 0
    ENDIF

; The FORMAT LPRINT command

m03e3   ROM3    o0020           ; get next char
m03e6   ROM3    o1C8C           ; get string expression
        ROM3    o0018           ; get next char
m03ec   cp      ';'
        call    nz,m10b1        ; check for end-of-statement if not ";"
        jr      nz,m041c        ; move on if not ";"
        ROM3    o0020           ; get next char
m03f6   ROM3    o1C8C           ; get string expression
        call    m10b1           ; check for end-of-statement
        ROM3    o2BF1           ; get 2nd string from stack
        ld      a,c
        dec     a
        or      b               ; check length
        jr      z,m0407
      IF v41
        jp      m045b           ; "Invalid drive" error if not 1
      ELSE
        jp      m028d           ; "Invalid drive" error if not 1
      ENDIF
m0407   ld      a,(de)
        and     $df             ; capitalise 2nd string character
        ld      hl,FLAGS3       ; prepare to change FLAGS3
        cp      'E'
        jr      nz,m0415
m0411   set     2,(hl)          ; if 2nd string "E", set "expand tokens" flag
        jr      m041c
m0415   cp      'U'
      IF v41
        jp      nz,m045b        ; if 2nd string not "U", error
      ELSE
        jp      nz,m028d        ; if 2nd string not "U", error
      ENDIF
        res     2,(hl)          ; if "U", reset "expand tokens" flag
m041c   ROM3    o2BF1           ; get first string from stack
        ld      a,c
        dec     a
        or      b               ; check length
        jr      z,m0427
      IF v41
        jp      m045b           ; "Invalid drive" error if not 1
      ELSE
        jp      m028d           ; "Invalid drive" error if not 1
      ENDIF
m0427   ld      a,(de)
        and     $df             ; capitalise 1st string character
        ld      hl,FLAGS3       ; prepare to change FLAGS3
        cp      'R'
        jr      nz,m0434
        set     3,(hl)          ; if "R", set print to RS232 flag
        ret
m0434   cp      'C'
        jr      nz,m043b
        res     3,(hl)          ; if "C", reset print to RS232 flag
        ret
m043b   cp      'E'
        jr      nz,m0442
        set     2,(hl)          ; if "E", set "expand tokens" flag
        ret
m0442   cp      'U'
      IF v41
        jr      nz,m0449
        res     2,(hl)
        ret
m0449   ld      hl,FLAGS2
        cp      'N'
        jr      nz,m0453
        res     6,(hl)
        ret
m0453   cp      'A'
        jp      nz,m045b
        set     6,(hl)
        ret
m045b   call    m2ada
        dec     bc
      ELSE
        jp      nz,m028d        ; if not "U", error
        res     2,(hl)          ; if "U", reset "expand tokens" flag
        ret
      ENDIF

; The ERASE command
; *BUG* No channel is opened before outputting the "Erase (Y/N)?" message,
;       so this is output to the last used stream.
; *BUG* The lower screen is not cleared if "N" is pressed

m044a   ROM3    o2BF1           ; get string from stack
        ld      a,b
        or      c               ; check length
        jr      nz,m0455
        call    m2ada
        defb    $2c             ; bad filename error if zero
m0455   push    bc              ; save addresses
        push    de
        push    de
        pop     hl              ; HL=address of filename
        push    bc
        ld      a,'*'
        cpir
        pop     bc
        jr      z,m046d         ; move on if * wildcard present
        push    de
        pop     hl
        push    bc
        ld      a,'?'
        cpir
        pop     bc
        jr      z,m046d         ; move on if ? wildcard present
      IF garry
        jr      m04a1           ; move on for a single file
m046d   push    bc
        push    de
        ld      a, $fd
        ROM3    o1601           ; open channel to stream
        pop     de
        pop     bc
        ld      hl, merase
        call    m04c1           ; output "Erase "
        call    m04ca           ; output filespec
        ld      hl, myn
      ELSE
        jr      m0499           ; move on for a single file
m046d   ld      hl,m04d5
        call    m04c1           ; output "Erase "
        call    m04ca           ; output filespec
        ld      hl,m04dc
      ENDIF
        call    m04c1           ; output "? (Y/N"
m047c   ld      hl,FLAGS
        res     5,(hl)          ; signal "no key available"
m0481   bit     5,(hl)
        jr      z,m0481         ; loop until keypress
        res     5,(hl)          ; signal "no key available"
        ld      a,(LAST_K)      ; get key
        and     $df             ; make uppercase
        cp      'N'
    IF garry
        jr      nz,m049c
m0499   ROM3    o0D6E           ; clear lower screen
        pop     de
        pop     bc
        ret
      IF spanish
m049c   cp      'S'
      ELSE
m049c   cp      'Y'
      ENDIF
        jr      z, m04a1
        jr      m047c
m04a1   ROM3    o0D6E           ; clear lower screen
        pop     de
        pop     bc
    ELSE
        jr      nz,m0493        ; move on if not "N"
        pop     de              ; exit without doing anything
        pop     bc              ; (lower screen should have been cleared)
        ret
      IF spanish
m0493   cp      'S'
      ELSE
m0493   cp      'Y'
      ENDIF
        jr      z,m0499
        jr      m047c           ; loop back for another key if not "Y"
m0499   ROM3    o0D6E           ; clear lower screen
        pop     de
        pop     bc
    ENDIF
m4b0    ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy filespec into page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        ld      hl,tmp_fspec
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_DELETE      ; delete filespec
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ret     c               ; exit if ok
        call    m0e9a           ; cause DOS error
        defb    $ff

; Subroutine to output a null-terminated string

m04c1   ld      a,(hl)          ; get next char
        or      a
        ret     z               ; exit if null
        inc     hl
        ROM3    o0010           ; output char
m04c8   jr      m04c1           ; loop back

; Subroutine to output a filespec at DE, length BC

m04ca   ld      a,(de)          ; get next char
        ROM3    o0010           ; output char
m04ce   inc     de
        dec     bc
        ld      a,b
        or      c
        jr      nz,m04ca        ; back for more
        ret

; Erase messages
    IF garry
m04d5
        defb    0, 0, 0, 0
    ELSE
      IF spanish
m04d5   defm    "]Borrar ", 0
m04dc   defm    " (S/N)?", 0
      ELSE
m04d5   defm    "Erase ", 0
m04dc   defm    " ? (Y/N)", 0
      ENDIF
    ENDIF

; The MOVE command

m04e5   ROM3    o2BF1           ; get 2nd string
        ld      a,b
        or      c               ; check length
        jr      nz,m04f0
        call    m2ada
        defb    $2c             ; bad filename error if zero
m04f0   ld      a,(de)
        cp      '+'
        jp      z,m0541         ; move on if changing attributes
        cp      '-'
        jp      z,m0541         ; move on if changing attributes
        ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy filename to page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
m0508   inc     de
        call    m2b64           ; page in normal memory
        push    de              ; save pointer for source filename
        ROM3    o2BF1           ; get 1st string
        ld      a,b
        or      c               ; check length
        jr      nz,m0518
        call    m2ada
        defb    $2c             ; bad filename error if zero
m0518   pop     hl              ; HL=address to place source filename
        push    hl
        ex      de,hl
        call    m3f63           ; copy source filename to page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        call    m2b64           ; page in normal memory
        pop     hl
        ld      de,tmp_fspec
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_RENAME      ; do rename
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ret     c               ; exit if done ok
        call    m0e9a           ; cause DOS error
        defb    $ff

; Here we use MOVE to alter attributes of a file

m0541   ld      a,c
        dec     a
        dec     a
        or      b
        jr      z,m054b         ; move on if 2nd string length=2
        call    m2ada
        defb    $47             ; invalid attribute error
m054b   ld      a,(de)
        ld      b,a             ; B='+' or '-'
        inc     de
        ld      a,(de)
        and     $df             ; A=uppercase attribute
        cp      'P'             ; check attribute letter
        jr      z,m0561
        cp      'S'
        jr      z,m0561
        cp      'A'
        jr      z,m0561
        call    m2ada
        defb    $47             ; invalid attribute error
m0561   push    bc              ; save attribute flags
        push    af
        ROM3    o2BF1           ; get 1st string
        ld      a,b
        or      c               ; check length
        jr      nz,m056e
        call    m2ada
        defb    $2c             ; bad filename error if zero
m056e   ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy to page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        call    m2b64           ; page in normal memory
        ld      de,$0000        ; don't set or clear anything yet
        ld      c,$00           ; attribute byte to set/clear
        pop     af              ; get attribute letter
        cp      'P'
        jr      nz,m058c
        set     2,c             ; bit 2 for P
        jr      m0596
m058c   cp      'S'
        jr      nz,m0594
        set     1,c             ; bit 1 for S
        jr      m0596
m0594   set     0,c             ; bit 0 for A
m0596   pop     af              ; get '+' or '-'
        cp      '+'
        jr      nz,m059e
        ld      d,c             ; if +, we're setting attributes
        jr      m059f
m059e   ld      e,c             ; if -, we're clearing attributes
m059f   ld      hl,tmp_fspec
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_ATTRIBUTES ; set the attributes
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ret     c               ; exit if done ok
        call    m0e9a           ; else cause DOS error
        defb    $ff

; The CAT command
; *BUG* Only one buffer of entries is ever considered (64 entries), as a
;       SUB $40 is used (should be SUB $3f)

m05b8   ld      hl,FLAGS3
        res     6,(hl)          ; signal "standard catalog"
        ROM3    o2070           ; consider stream information
        jr      c,m05dd         ; move on if default stream to be used
        ld      hl,(CH_ADD)
        ld      a,(hl)          ; get next char
        cp      ','
        jr      z,m05da         ; move on if comma to get filespec
        cp      $0d
        jr      z,m062b         ; move on if end-of-line
        cp      ':'
        jr      z,m062b         ; or if end-of-statement
        cp      $b9
        jr      z,m062b         ; or if EXP
      IF garry
        jp      m3b48
        nop
      ELSE
        call    m2ada
        defb    $0b             ; else nonsense in BASIC error
      ENDIF
m05da   rst     $20             ; get next char
        jr      m05f8
m05dd   ld      a,$02           ; use stream 2
        bit     7,(iy+$01)
        jr      z,m05e8         ; move on if only syntax-checking
        ROM3    o1601           ; else open channel to stream
m05e8   ld      hl,(CH_ADD)
        ld      a,(hl)          ; check next char
        cp      $0d
        jr      z,m062b         ; move on if end-of-line
        cp      ':'
        jr      z,m062b         ; or if end-of-statement
      IF garry
        jp      m3b50
        nop
      ELSE
        cp      $b9
        jr      z,m062b         ; or if EXP
      ENDIF
m05f8   ROM3    o1C8C           ; get string expression
        ROM3    o0018           ; get next char
m05fe   cp      $b9
        jr      nz,m060a        ; move on if not EXP
        ld      hl,FLAGS3
        set     6,(hl)          ; signal "expanded catalog"
        ROM3    o0020           ; get next char
m060a   call    m10b1           ; check for end-of-statement
        ROM3    o2BF1           ; get string value from stack
        push    bc
        push    de
        pop     hl              ; HL=string address
        ld      a,':'           ; check for drive specification
        cpir
        jr      nz,m0623        ; move on if not found
        dec     hl
        dec     hl
        ld      a,(hl)
        and     $df
      IF garry
        cp      $41
        jr      c, m0623
        cp      $5b
        jr      nc, m0623
        ld      (DEFADD),a      ; else save capitalised drive letter
        jr      m0628           ; move on
m0623   xor     a
      ELSE
        ld      (DEFADD),a      ; else save capitalised drive letter
        jr      m0628           ; move on
m0623   ld      a,$00
      ENDIF
        ld      (DEFADD),a      ; signal "use default drive"
m0628   pop     bc
        jr      m0645           ; move on
m062b   ROM3    o0018           ; get next char
m062e   cp      $b9
        jr      nz,m063a        ; move on if not EXP
        ld      hl,FLAGS3
        set     6,(hl)          ; signal "expanded catalog"
        ROM3    o0020           ; get next char
m063a   call    m10b1           ; check for end-of-statement
      IF garry
        xor     a
        ld      (DEFADD),a      ; signal "use default drive"
        ld      b, a
        ld      c, a
      ELSE
        ld      bc,$0000        ; filespec length=0
        ld      a,$00
        ld      (DEFADD),a      ; signal "use default drive"
      ENDIF
m0645   ld      a,c
        dec     a
        dec     a
        or      b
        jr      nz,m065c        ; move on unless just 2 chars specified
        inc     de
        ld      a,(de)
        dec     de
        cp      ':'
        jr      nz,m065c        ; move on if not drive specifier
        ld      a,(de)
        and     $df             ; get drive letter capitalised
        cp      'T'
        jr      nz,m065c
        jp      m34c6           ; move on to catalog tape
m065c   ld      hl,tmp_fspec
        ex      de,hl
        push    bc
        ld      a,b
        or      c
        jr      z,m0668         ; move on if no filespec
        call    m3f63           ; copy to page 7 (entry 0)
m0668   pop     bc
        ld      hl,tmp_fspec
        add     hl,bc
        call    m2b89
        ld      (hl),$ff        ; add terminator
        ld      hl,tmp_buff
        ld      de,tmp_buff+1
        ld      bc,$000b
      IF garry
        ld      (hl), b
        ldir                    ; zero entry 0
m067f   ld      b,$40           ; 64 entries in buffer
      ELSE
        ld      (hl),$00
        ldir                    ; zero entry 0
m067f   ld      b,$40           ; 64 entries in buffer
        ld      c,$00           ; C=0 for standard catalog
      ENDIF
        ld      hl,FLAGS3
        bit     6,(hl)
        jr      z,m068c
        ld      c,$01           ; C=1 for expanded catalog (inc system files)
m068c   ld      de,tmp_buff
        ld      hl,tmp_fspec
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CATALOG     ; get next lot of entries
        call    m32ee           ; restore TSTACK
        jp      nc,m06ab        ; move on if error
        ld      hl,tmp_buff+$0d ; address of first returned entry
        dec     b               ; B=# entries found (discard preloaded one)
        ld      a,b
        or      a
        jr      nz,m06b7        ; move on if entries to display
        jp      m07ba           ; move on if catalog finished
m06ab   cp      $17
        jp      z,m07ba         ; move on if error "file not found"
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause DOS error
        defb    $ff
m06b7   push    bc              ; save number of entries to do
m06b8   push    af
        ld      b,$08           ; 8 bytes in first half of filename
m06bb   ld      a,(hl)
        and     $7f             ; get byte and mask bit
        call    m2b64           ; page in normal memory
        ROM3    o0010           ; output char
m06c4   call    m2b89           ; page in DOS workspace
        inc     hl
        djnz    m06bb           ; loop back for rest of filename
        call    m2b64           ; page in normal memory
        ld      a,'.'
        ROM3    o0010           ; output "."
m06d2   xor     a
        ld      (RAMERR),a      ; zeroise attributes
        ld      b,$03
m06d8   call    m2b89           ; page in DOS workspace
        ld      a,(hl)          ; get next byte
        bit     7,a
        jr      z,m06fc         ; move on if bit 7 not set
        push    af
        push    hl
        ld      hl,RAMERR
        ld      a,b
        cp      $03
        jr      nz,m06ee
        set     3,(hl)          ; set bit 3 if first extension byte
        jr      m06f8
m06ee   cp      $02
        jr      nz,m06f6
        set     2,(hl)          ; set bit 2 if second extension byte
        jr      m06f8
m06f6   set     1,(hl)          ; set bit 1 if third extension byte
m06f8   pop     hl              ; restore values
        pop     af
        and     $7f             ; mask bit 7
m06fc   call    m2b64           ; page in normal memory
        ROM3    o0010           ; output char
m0702   inc     hl
        djnz    m06d8           ; loop back for more extension
        push    hl
        ld      hl,FLAGS3
        bit     6,(hl)          ; test if want expanded catalog
        pop     hl
        jr      z,m073e         ; if not, move on
m070e   ld      a,(RAMERR)      ; get attributes
        push    hl
        ld      hl,m0812        ; blank message
        bit     3,a
        jr      z,m071c
        ld      hl,m0818        ; if bit 3 set, PROT message
m071c   push    af
        call    m07e2           ; output message
        pop     af
        ld      hl,m0813        ; blank message
        bit     2,a
        jr      z,m072b
        ld      hl,m081e        ; if bit 2 set, SYS message
m072b   push    af
        call    m07e2           ; output message
        pop     af
        ld      hl,m0813        ; blank message
        bit     1,a
        jr      z,m073a
        ld      hl,m0823        ; if bit 1 set, ARC message
m073a   call    m07e2           ; output message
        pop     hl
m073e   ld      a,' '
        ROM3    o0010           ; output space
m0743   push    hl
        call    m2b89           ; page in DOS workspace
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        inc     hl              ; HA=filesize in K
        call    m2b64           ; page in normal memory
        ld      l,a
        ld      e,' '
      IF garry
        call    m07f1
      ELSE
        call    m0800           ; output filesize
      ENDIF
        pop     hl
        inc     hl
        inc     hl              ; move to next file entry
        ld      a,'K'
        ROM3    o0010           ; output "K"
m075c   call    m07eb           ; output CR
        call    m2b89           ; page in DOS workspace
        pop     af
        dec     a
        jp      nz,m06b8        ; move back for more files in buffer
        pop     bc
        ld      a,b
      IF garry
        sub     $3f
      ELSE
        sub     $40             ; was buffer full? (*BUG* should be $3f)
      ENDIF
        jr      c,m077b         ; if not, move on
        ld      hl,$f044
        ld      de,tmp_buff
      IF garry
        ld      bc, 11
        ldir                    ; if so, copy last entry to first
        ex      de, hl
        ld      (hl), d
      ELSE
        ld      bc, 13
        ldir                    ; if so, copy last entry to first
      ENDIF
        jp      m067f           ; and back for more
m077b   call    m2b64           ; page in normal memory
m077e   call    m07eb           ; output CR
        call    m2b89           ; page in DOS workspace
m0784   ld      a,(DEFADD)      ; get drive letter
        or      a
        jr      nz,m079a        ; move on if not default
        ld      a,$ff
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_DRIVE   ; get default drive
        call    m32ee           ; restore TSTACK
        jp      nc,m06ab        ; go if error
m079a   call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_FREE_SPACE  ; get free space on drive
        call    m32ee           ; restore TSTACK
        jp      nc,m06ab        ; go if error
        call    m2b64           ; page in normal memory
      IF garry
        ld      e, $ff
        call    m07f1
      ELSE
        ld      e,' '
        call    m0800           ; output number
      ENDIF
        ld      hl,m07c9
        call    m07e2           ; output "K free" message
        call    m07eb           ; output CR
        ret                     ; done
m07ba
    IF garry
        ld      a, ($ed1c)
        and     a
        call    m2b64           ; page in normal memory
        ld      hl, m07d1
        call    z, m07e2
        jp      m077e
m07cf   call    m2b64
        rst     $10
m07d3   call    m2b89
        ret
m07d7   call    m2b64
        call    m07e2
        jr      m07d3
m07df   call    m2b64
        call    m07f1
        jr      m07d3
    ELSE
        call    m2b64           ; page in normal memory
        ld      hl,m07d1
        call    m07e2           ; output no files message
        call    m2b89           ; page in DOS workspace
        jp      m0784           ; go to display free space
      IF spanish
m07c9   defm    "K LIBRES", $0d, 0
m07d1   defm    "NINGUN FICHERO ENCONTRADO", $0d, $0d, 0
      ELSE
m07c9   defm    "K free", $0d, 0
m07d1   defm    "No files found", $0d, $0d, 0
      ENDIF
    ENDIF

; Subroutine to output a null-terminated message

m07e2   ld      a,(hl)          ; get next char
        or      a
        ret     z               ; exit if null
        ROM3    o0010           ; output char
m07e8   inc     hl
        jr      m07e2           ; loop back

; Subroutine to output a CR char

m07eb   ld      a,$0d
        ROM3    o0010           ; output CR
m07f0   ret


; Subroutine to output a number up to 65535 (in HL)

m07f1   push    hl
        ld      bc,$d8f0        ; -10000
        ROM3    o192A           ; output 10000s
        ld      bc,$fc18        ; -1000
        ROM3    o192A           ; output 1000s
        jr      m0801

; Subroutine to output a number up to 999 (in HL)

m0800   push    hl
m0801   ld      bc,$ff9c        ; -100
        ROM3    o192A           ; output 100s
        ld      c,$f6           ; -10
        ROM3    o192A           ; output 10s
        ld      a,l             ; units
        ROM3    o15EF           ; output units
        pop     hl              ; restore number
        ret

; Catalog attribute messages

      IF garry
        defb    0
m0812   
m0813   defm    "    ", 0
        defb    0
m0818   defm    " PRT", 0
      ELSE
m0812   defm    " "
m0813   defm    "    ", 0
m0818   defm    " PROT", 0
      ENDIF
m081e   defm    " SYS", 0
m0823   defm    " ARC", 0

; Subroutine to save a block to tape

m0828   ld      hl,m0830
        push    hl              ; stack SA-RET routine address (why??)
        ROM3    o04C6           ; save bytes
        ret
m0830   ROM3    o053F           ; SA-RET
        ret

; Subroutine to LOAD/VERIFY a block of data, from tape or disk
; On entry, IX=start, DE=length, A=type (usually $ff), carry set for LOAD
; or reset for VERIFY
; File 0 will be open for disk operations, which should be closed before exit
; On exit, carry is set if okay, reset if error

m0834   push    af
        ld      a,(RAMERR)
        cp      'T'
        jp      z,m0883         ; move on for tape operations
        pop     af
        jr      nc,m087a        ; go to exit for disk verify (won't get here)
        push    hl              ; save registers
        push    de
        push    bc
        ld      b,$00           ; file 0
        ld      c,$00           ; page 0
        push    ix
        pop     hl              ; HL=address
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_READ        ; read the block
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        jr      c,m0865         ; move on to exit if okay
        cp      $19
        jr      nz,m087f        ; move on if error not end-of-file
        call    m0e9a           ; cause error
        defb    $31
m0865   ld      b,$00
        call    m2b89           ; page in DOS workspace
m086a   call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        jr      nc,m087f        ; move on if error
m087a   scf                     ; signal success
        pop     bc              ; restore registers
        pop     de
        pop     hl
        ret
m087f   call    m0e9a           ; cause DOS error
        defb    $ff
m0883   pop     af              ; if tape,restore flags and enter next routine

; Subroutine to call LD-BYTES subroutine in ROM 3

m0884   ROM3    o0556           ; call it
        ret

; The SAVE/LOAD/VERIFY/MERGE commands

; section 1 - initialisation

m0888   pop     af              ; discard return address of scan-loop
        ld      a,(T_ADDR)
        sub     m0f83 and $ff   ; store command code (0=SAVE,1=LOAD,
        ld      (T_ADDR),a      ; 2=VERIFY,3=MERGE)
        call    m1129           ; get a string expression
        bit     7,(iy+$01)
        jp      z,m09ba         ; move on if syntax-checking
        ld      bc,$0011        ; 17 bytes required for LOAD
        ld      a,(T_ADDR)
        and     a
        jr      z,m08a6
        ld      c,$22           ; but 34 for others
m08a6   ROM3    o0030           ; make space
        push    de
        pop     ix              ; IX points to space
        ld      b,$0b
        ld      a,' '
m08b0   ld      (de),a          ; fill 11-byte name with spaces
        inc     de
        djnz    m08b0
        ld      (ix+$01),$ff    ; place terminator in 2nd byte
        ROM3    o2BF1           ; get string value from stack
        push    de
        push    bc

; section 2 - booting a disk

        ld      a,c
        dec     a
        or      b               ; check length
        jr      nz,m08e4        ; move on if not 1
        ld      a,(de)
        cp      '*'
        jr      nz,m08e4        ; or if not "*"
      IF v41
        ld      a,(T_ADDR)
        cp      $01
        jr      nz,m08e4
      ENDIF
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_BOOT        ; boot a disk
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        cp      $23
        jr      nz,m08e0        ; if error isn't "disk not bootable", move on
        call    m0e9a           ; cause error
        defb    $3b
m08e0   call    m0e9a           ; cause DOS error
        defb    $ff

; section 3 - setting drive for operation in RAMERR

m08e4   inc     de
        ld      a,(de)
        dec     de
        cp      ':'
        jr      nz,m08fe        ; move on if no drive specified
        ld      a,(de)
        and     $df             ; get capitalised drive letter
      IF garry
        cp      'T'             ; check for valid drives
        jr      z,m090f         ; moving on if found
        cp      'A'             ; check for valid drives
        jr      c,m08fe         ; moving on if found
        cp      'Q'             ; check for valid drives
        jr      c,m090f         ; moving on if found
      ELSE
        cp      'A'             ; check for valid drives
        jr      z,m090f         ; moving on if found
        cp      'B'
        jr      z,m090f
        cp      'M'
        jr      z,m090f
        cp      'T'
        jr      z,m090f
      ENDIF
m08fe   ld      a,(T_ADDR)
        or      a
        ld      a,(SAVDRV)      ; use SAVDRV as drive for SAVE
        jr      z,m090a
        ld      a,(LODDRV)      ; or LODDRV otherwise
m090a   ld      (RAMERR),a      ; store drive in RAMERR
        jr      m096c           ; move on

; section 4 - changing default drives for LOAD "A:" etc

m090f
      IF garry
        ld      (RAMERR), a
      ELSE
        ld      l,a             ; save drive in L
      ENDIF
        ld      a,c
        dec     a
        dec     a
        or      b               ; check string length
      IF garry
        jr      nz,m0969        ; move on if not 2
        ld      a, (RAMERR)
      ELSE
        jr      nz,m0966        ; move on if not 2
        ld      a,(T_ADDR)
        or      a
        jr      z,m0923         ; if SAVE, go to set default SAVE drive
        cp      $01
        jr      z,m0960         ; if LOAD, go to set default LOAD drive
        ld      a,l
        jr      m096c           ; else move on
m0923   ld      a,l
        cp      'M'
        jr      z,m093f         ; move on if setting drive M:
        cp      'T'
        jr      z,m093f         ; or T: as default
        ld      hl,FLAGS3
        bit     4,(hl)
        jr      z,m093b         ; go to error if no disk interface
        cp      'A'
        jr      z,m093f         ; move on if setting A:
        bit     5,(hl)
        jr      nz,m093f        ; move on if setting B: and drive B: present
m093b   call    m2ada
        defb    $4e             ; cause "Invalid drive" error
m093f   ld      (SAVDRV),a      ; store in SAVDRV
      ENDIF
m0942   cp      'T'
        jr      z,m095d         ; move on for T:
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_DRIVE   ; set default drive
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        jr      c,m095d         ; move on if no error
        call    m0e9a
        defb    $ff             ; cause DOS error
      IF garry
m095d   ld      a, (T_ADDR)
        or      a
        ld      a, (RAMERR)
        jr      z, m0945
        ld      (LODDRV), a
        jr      m0948
m0945   ld      (SAVDRV), a
m0948   ld      d, a
        ld      e, $10
        rst     $18
        cp      $b5
        jr      nz, m0966
        rst     $20
        ex      de, hl
        xor     a
        ld      b, a
        ld      c, a
        call    m2b89           ; page in DOS workspace
        call    m32b6
        ROM2    IDE_PARTITION_SETINFO
        call    m32ee
        call    m2b64
m0966   pop     bc
        pop     de
        ret
m0969   ld      a, (RAMERR)
        cp      $54
        jr      nz, m096c
m0970   pop     bc
        pop     de
        inc     de
        inc     de
        dec     bc
        dec     bc
        jr      m099a
      ELSE
m095d   pop     bc              ; exit
        pop     de
        ret
m0960   ld      a,l
        ld      (LODDRV),a      ; store in LODDRV
        jr      m0942           ; go to set default DOS drive
m0966   ld      a,(de)
        and     $df
        ld      (RAMERR),a      ; save capitalised drive in RAMERR
      ENDIF

; section 5 - copying filename to page 7 (disk operations only)

m096c   cp      'T'
        jr      z,m0998         ; move on for tape operations
        ld      a,(T_ADDR)
        cp      $02
        jr      nz,m097a        ; move on if not VERIFY
        pop     hl              ; for VERIFY on disk, just exit
        pop     hl
        ret
m097a   ld      a,b
        or      c               ; test length of string
        jr      nz,m0982
        call    m0e9a
        defb    $0e             ; invalid filename error if zero
m0982   ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy filename to page 7
        pop     bc
        ld      bc,$000a
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        call    m2b64           ; page in normal memory
        jr      m0999           ; move on with disk operations

; section 6 - copying filename into 1st header
; *BUG* If filename was specified as "T:name", the "T:" is never stripped

m0998   pop     bc              ; restore length & add of filename
m0999   pop     de
m099a   ld      hl,$fff6
        dec     bc
        add     hl,bc
        inc     bc
        jr      nc,m09b3        ; move on if filename 10 letters or less
        ld      a,(T_ADDR)
        and     a
        jr      nz,m09ac
        call    m0e9a
        defb    $0e             ; bad filename error if SAVEing
m09ac   ld      a,b
        or      c
        jr      z,m09ba         ; move on if no filename
        ld      bc,$000a        ; copy 10 chars
m09b3   push    ix
        pop     hl
        inc     hl
        ex      de,hl
        ldir                    ; copy filename to header+1 in workspace

; At this point, syntax-checking rejoins the routines
; Each of the following sections fills in the remaining header information
; for their filetype & ensures syntax is correct to end-of-statement.
; At run-time the sections recombine at section 11, with HL=address
; to load/verify/merge/save at

; section 7 - DATA operations
m09ba
      IF garry
        rst     $18
      ELSE
        ROM3    o0018           ; get next char
      ENDIF
        cp      $e4
        jr      nz,m0a11        ; move on if not DATA
        ld      a,(T_ADDR)
        cp      $03
        jp      z,m1125         ; error if used with MERGE
      IF garry
        rst     $20
      ELSE
        ROM3    o0020           ; get current char
      ENDIF
m09cc   ROM3    o28B2           ; search for variable
        set     7,c             ; set bit 7 of array's name
        jr      nc,m09e0        ; jump if handling existing array
        ld      hl,$0000
        ld      a,(T_ADDR)
        dec     a
        jr      z,m09f4
        call    m0e9a
        defb    $01             ; error 2 if trying to SAVE/VERIFY new array
m09e0   jp      nz,m1125        ; error if just a numeric variable
        bit     7,(iy+$01)
        jr      z,m0a01         ; move on if checking syntax
        inc     hl
        ld      a,(hl)
        ld      (ix+$0b),a      ; copy array length into workspace header
        inc     hl
        ld      a,(hl)
        ld      (ix+$0c),a
        inc     hl
m09f4   ld      (ix+$0e),c      ; copy array name into workspace header
        ld      a,$01           ; type 1
        bit     6,c
        jr      z,m09fe         ; move on if numeric array
        inc     a               ; else type 2
m09fe   ld      (ix+$00),a      ; copy type into workspace header
m0a01   ex      de,hl
      IF garry
        rst     $20
      ELSE
        ROM3    o0020           ; get current char
      ENDIF
        cp      ')'
        jr      nz,m09e0        ; error if not ")"
        rst     $20
        call    m10b1           ; check for end-of-statement
m0a0d   ex      de,hl
        jp      m0ad5           ; jump on

; section 8 - SCREEN$ operations

m0a11   cp      $aa             ; check for SCREEN$
        jr      nz,m0a36        ; move on if not
        ld      a,(T_ADDR)
        cp      $03
        jp      z,m1125         ; error if trying to MERGE
      IF garry
        rst     $20
      ELSE
        ROM3    o0020           ; get current char
      ENDIF
        call    m10b1           ; check for end-of-statement
        ld      (ix+$0b),$00    ; store screen length
        ld      (ix+$0c),$1b
        ld      hl,$4000
        ld      (ix+$0d),l      ; and start
        ld      (ix+$0e),h
        jr      m0a89           ; jump on

; section 9 - CODE operations

m0a36   cp      $af             ; check for CODE
        jr      nz,m0a8f        ; move on if not
        ld      a,(T_ADDR)
        cp      $03
        jp      z,m1125         ; error if trying to MERGE
      IF garry
        rst     $20
      ELSE
        ROM3    o0020           ; get current char
      ENDIF
m0a45   call    m0e94
        jr      nz,m0a56        ; move on if not end-of-statement
        ld      a,(T_ADDR)
        and     a
        jp      z,m1125         ; error if trying to SAVE with no parameters
        ROM3    o1CE6           ; get zero to calculator stack
        jr      m0a67           ; move on
m0a56   call    m1121           ; get numeric expression
      IF garry
        rst     $18
      ELSE
        ROM3    o0018           ; get next char
      ENDIF
        cp      ','
        jr      z,m0a6c         ; move on if comma
        ld      a,(T_ADDR)
        and     a
        jp      z,m1125         ; error if trying to SAVE with 1 parameter
m0a67   ROM3    o1CE6           ; get zero to calculator stack
        jr      m0a72           ; move on
m0a6c   ROM3    o0020           ; get next char
m0a6f   call    m1121           ; get numeric expression
m0a72   call    m10b1           ; check for end-of-statement
        ROM3    o1E99           ; get length to BC
        ld      (ix+$0b),c      ; store in workspace header
        ld      (ix+$0c),b
        ROM3    o1E99           ; get address to BC
        ld      (ix+$0d),c      ; store in workspace header
        ld      (ix+$0e),b
        ld      h,b             ; HL=address
        ld      l,c
m0a89   ld      (ix+$00),$03    ; type 3 to workspace header
        jr      m0ad5           ; move on

; section 10 - BASIC operations

m0a8f   cp      $ca             ; check for LINE
        jr      z,m0a9c         ; move on if present
      IF garry
        jp      m24c7           ; check for end-of-statement
      ELSE
        call    m10b1           ; check for end-of-statement
      ENDIF
m0a96   ld      (ix+$0e),$80    ; no auto-run
        jr      m0ab5           ; move on
m0a9c   ld      a,(T_ADDR)
        and     a
        jp      nz,m1125        ; error unless SAVE with LINE
        ROM3    o0020           ; get next char
m0aa6   call    m1121           ; get numeric expression
        call    m10b1           ; check for end-of-line
        ROM3    o1E99           ; get line to BC
        ld      (ix+$0d),c      ; store in workspace header
        ld      (ix+$0e),b
m0ab5   ld      (ix+$00),$00    ; type 0
        ld      hl,(E_LINE)
        ld      de,(PROG)
        scf
        sbc     hl,de           ; HL=program+vars length
        ld      (ix+$0b),l      ; store in workspace header
        ld      (ix+$0c),h
        ld      hl,(VARS)
        sbc     hl,de           ; HL=program only length
        ld      (ix+$0f),l      ; store in workspace header
        ld      (ix+$10),h
        ex      de,hl

; section 11 - LOAD/VERIFY/MERGE tape operations

m0ad5   ld      a,(T_ADDR)
        and     a
        jp      z,m0d6e         ; move on if saving
        push    hl
        ld      bc,$0011
        add     ix,bc           ; IX points to 2nd header
        ld      a,(RAMERR)
        cp      'T'
        jr      nz,m0b41        ; move on if disk operation
m0ae9   push    ix
        ld      de,$0011
        xor     a
        scf
        call    m0884           ; load header from tape to 2nd header area
        pop     ix
        jr      nc,m0ae9        ; loop back if error
        ld      a,$fe
        ROM3    o1601           ; open channel to stream -2
        ld      (iy+$52),$03    ; set scroll count
        ld      c,$80           ; signal "names don't match"
        ld      a,(ix+$00)
        cp      (ix-$11)        ; compare types
        jr      nz,m0b0c        ; jump if no match
        ld      c,$f6           ; C must be incremented 10 times to match
m0b0c   cp      $04
        jr      nc,m0ae9        ; error for types 4+
        ld      de,$09c0        ; address of message block in ROM 3
        push    bc
        ROM3    o0C0A           ; print filetype message
        pop     bc
        push    ix
        pop     de              ; DE points to filename to check for
        ld      hl,$fff0
        add     hl,de           ; HL points to loaded filename
        ld      b,$0a           ; check 10 chars
        ld      a,(hl)          ; get next char
        inc     a
        jr      nz,m0b28        ; move on if name to check not null
        ld      a,c             ; if null, signal "10 chars match"
        add     a,b
        ld      c,a
m0b28   inc     de
        ld      a,(de)
        cp      (hl)            ; compare names
        inc     hl
        jr      nz,m0b2f
        inc     c               ; increment C if chars match
m0b2f   ROM3    o0010           ; output char
        djnz    m0b28           ; loop back
        bit     7,c
        jr      nz,m0ae9        ; loop back if no match
        ld      a,$0d
        ROM3    o0010           ; output CR
        pop     hl
        jp      m0ba6           ; move on

; section 12 - LOAD/MERGE disk operations

m0b41   ld      a,(T_ADDR)
        cp      $02
        jr      z,m0ba6         ; move on if VERIFY (can't be here if so!)
        push    ix
        ld      b,$00           ; file 0
        ld      c,$01           ; exclusive-read
        ld      d,$00
        ld      e,$01
        ld      hl,tmp_fspec
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open file
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        jr      c,m0b6c
        call    m0e9a           ; cause any DOS error
        defb    $ff
m0b6c   ld      b,$00
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_HEAD    ; IX to header
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ex      (sp),ix
        pop     hl
        call    m2b89           ; page in DOS workspace
        ld      a,(hl)
        call    m2b64           ; page in normal memory
        cp      (ix-$11)        ; compare types
        jr      z,m0b92
        call    m0e9a
        defb    $1d             ; error if different
m0b92   ld      (ix+$00),a      ; store in 2nd header area
        push    ix
        pop     de
        ex      de,hl
        ld      bc,$000b
        add     hl,bc
        ex      de,hl
        inc     hl
        ld      bc,$0006
        call    m3f8a           ; copy parameters from page 7 into 2nd header
        pop     hl

; section 13 - Perform tape/disk VERIFY (any type) or LOAD (CODE only)

m0ba6   ld      a,(ix+$00)
        cp      $03
        jr      z,m0bb9         ; move on for type 3
        ld      a,(T_ADDR)
        dec     a
        jp      z,m0c04         ; move on if LOADing
        cp      $02
        jp      z,m0cb2         ; move on if MERGEing
m0bb9   push    hl              ; save address to LOAD/VERIFY at
        ld      l,(ix-$06)
        ld      h,(ix-$05)      ; HL=length from 1st header
        ld      e,(ix+$0b)
        ld      d,(ix+$0c)      ; DE=length from 2nd header
        ld      a,h
        or      l
        jr      z,m0bd7         ; move on if length not specified (CODE only)
        sbc     hl,de
        jr      c,m0c00         ; error if block larger than requested
        jr      z,m0bd7
        ld      a,(ix+$00)
        cp      $03
        jr      nz,m0bfc        ; error for uneven lengths except in CODE
m0bd7   pop     hl              ; restore address
        ld      a,h
        or      l
        jr      nz,m0be2
        ld      l,(ix+$0d)
        ld      h,(ix+$0e)      ; if zero, use start address of 2nd header
m0be2   push    hl
        pop     ix              ; IX=address to load
        ld      a,(T_ADDR)
        cp      $02
        scf                     ; set carry for LOAD
        jr      nz,m0bf6
        and     a               ; reset carry for VERIFY
        ld      a,(RAMERR)
        cp      'T'
        jr      z,m0bf6
        ret                     ; exit if VERIFY with disk (won't get here!)
m0bf6   ld      a,$ff           ; data block
m0bf8   call    m0834           ; load/verify block from tape/disk
        ret     c               ; exit if okay
m0bfc   call    m0e9a           ; error R - tape loading error
        defb    $1a
m0c00   call    m0e9a           ; error ???
        defb    $4f

; section 14 - Perform tape/disk LOAD (types 0-2)

m0c04   ld      e,(ix+$0b)
        ld      d,(ix+$0c)      ; DE=length from 2nd header
m0c0a   push    hl
        ld      a,h
        or      l               ; test start=0 (previously undeclared array)
        jr      nz,m0c15        ; move on if not
        inc     de
        inc     de
        inc     de              ; add 3 bytes for name (1) & length (2)
        ex      de,hl
        jr      m0c21           ; move on
m0c15   ld      l,(ix-$06)
        ld      h,(ix-$05)      ; HL=size of existing prog+vars or array
        ex      de,hl
        scf
        sbc     hl,de
        jr      c,m0c2a         ; move on if no extra space required
m0c21   ld      de,$0005        ; allow for 5-byte overhead
        add     hl,de
        ld      b,h
        ld      c,l
        ROM3    o1F05           ; test if space available
m0c2a   pop     hl              ; restore destination address
        ld      a,(ix+$00)
        and     a
        jr      z,m0c6f         ; move on for BASIC programs
        ld      a,h
        or      l
        jr      z,m0c48         ; move on if loading new array
        dec     hl
        ld      b,(hl)
        dec     hl
        ld      c,(hl)          ; get existing array length from vars area
        dec     hl
        inc     bc
        inc     bc
        inc     bc              ; add 3 for name & length
        ld      (X_PTR),ix      ; save IX
        ROM3    o19E8           ; reclaim space
        ld      ix,(X_PTR)      ; restore IX
m0c48   ld      hl,(E_LINE)
        dec     hl              ; HL points to $80 at end of vars
        ld      c,(ix+$0b)
        ld      b,(ix+$0c)      ; get length of new array
        push    bc              ; save
        inc     bc
        inc     bc
        inc     bc              ; add 3 for name & length
        ld      a,(ix-$03)
        push    af              ; save array name (from old header)
        ROM3    o1655           ; make the room
        defb    $23
        pop     af
        ld      (hl),a          ; store name
        pop     de
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; and length
        inc     hl
        push    hl
        pop     ix              ; IX points to array start
        scf                     ; set carry for LOAD
        ld      a,$ff           ; data block
        jp      m0bf8           ; go to load it
m0c6f   ex      de,hl           ; save DE=destination
        ld      hl,(E_LINE)
        dec     hl              ; end of vars
        ld      (X_PTR),ix      ; save IX
        ld      c,(ix+$0b)
        ld      b,(ix+$0c)      ; get length of new data block
        push    bc
        ROM3    o19E5           ; reclaim entire prog+vars
        pop     bc
        push    hl
        push    bc
        ROM3    o1655           ; make room for new block
        ld      ix,(X_PTR)      ; restore IX
        inc     hl
        ld      c,(ix+$0f)
        ld      b,(ix+$10)      ; BC=length of program only
        add     hl,bc
        ld      (VARS),hl       ; set new start of vars
        ld      h,(ix+$0e)
        ld      a,h
        and     $c0
        jr      nz,m0ca9        ; move on if no auto-run number
        ld      l,(ix+$0d)
        ld      (NEWPPC),hl     ; set new line & statement
        ld      (iy+$0a),$00
m0ca9   pop     de              ; restore length & start
        pop     ix
        scf                     ; set carry for LOAD
        ld      a,$ff           ; data block
        jp      m0bf8           ; go to load it

; section 15 - Perform tape/disk MERGE

m0cb2   ld      c,(ix+$0b)
        ld      b,(ix+$0c)      ; fetch length of new block
        push    bc
        inc     bc
        ROM3    o0030           ; make length+1 bytes in workspace
m0cbd   ld      (hl),$80        ; terminate with an end-marker
        ex      de,hl           ; HL=start
        pop     de              ; DE=length
        push    hl              ; save start
        push    hl
        pop     ix              ; IX=start
        scf                     ; set carry for LOAD
        ld      a,$ff           ; data block
        call    m0bf8           ; load the block
        pop     hl              ; HL=start of new prog
        ld      de,(PROG)       ; DE=start of old prog
m0cd0   ld      a,(hl)
        and     $c0
        jr      nz,m0cee        ; move on if all lines done
m0cd5   ld      a,(de)
        inc     de
        cp      (hl)            ; compare high bytes of line number
        inc     hl
        jr      nz,m0cdd        ; skip next test if no match
        ld      a,(de)
        cp      (hl)            ; compare low bytes of line number
m0cdd   dec     de
        dec     hl
        jr      nc,m0ce9        ; move on if can place line here
        push    hl
        ex      de,hl
        ROM3    o19B8           ; get address of next line in old prog
        pop     hl
        jr      m0cd5           ; loop back
m0ce9   call    m0d2a           ; enter the new line
        jr      m0cd0           ; loop back
m0cee   ld      a,(hl)          ; get var name from workspace
        ld      c,a
        cp      $80
        ret     z               ; exit if all done
        push    hl
        ld      hl,(VARS)       ; fetch start of vars
m0cf7   ld      a,(hl)
        cp      $80
        jr      z,m0d21         ; move on if reached end
        cp      c
        jr      z,m0d07         ; move on if found match
m0cff   push    bc
        ROM3    o19B8           ; get to next var
        pop     bc
        ex      de,hl
        jr      m0cf7           ; loop back
m0d07   and     $e0
        cp      $a0
        jr      nz,m0d1f        ; move on if not long-named var
        pop     de
        push    de
        push    hl
m0d10   inc     hl
        inc     de
        ld      a,(de)
        cp      (hl)            ; compare long names
        jr      nz,m0d1c        ; move on if mismatch
        rla
        jr      nc,m0d10        ; loop back
        pop     hl
        jr      m0d1f
m0d1c   pop     hl
        jr      m0cff           ; go back if unsuccessful
m0d1f   ld      a,$ff           ; signal "replace variable"
m0d21   pop     de
        ex      de,hl
        inc     a
        scf                     ; signal "variables"
        call    m0d2a           ; merge in the variable
        jr      m0cee           ; loop back

; Subroutine to merge a line or variable (part of section 15)

m0d2a   jr      nz,m0d3c        ; move on if not replacing a line/variable
        ex      af,af'          ; save flags
        ld      (X_PTR),hl      ; save pointer in new program/vars
        ex      de,hl
        ROM3    o19B8
        ROM3    o19E8           ; reclaim old line/var
        ex      de,hl
        ld      hl,(X_PTR)      ; restore
        ex      af,af'
m0d3c   ex      af,af'          ; save flags
        push    de
        ROM3    o19B8           ; find length of new line/var
        ld      (X_PTR),hl      ; save pointer in new program/vars
        ld      hl,(PROG)
        ex      (sp),hl         ; save PROG to avoid corruption
        push    bc
        ex      af,af'
        jr      c,m0d53         ; move on if adding a variable
        dec     hl
        ROM3    o1655           ; make room for new line
        inc     hl
        jr      m0d56
m0d53   ROM3    o1655           ; make room for new var
m0d56   inc     hl              ; point to first new location
        pop     bc
        pop     de
        ld      (PROG),de       ; restore PROG
        ld      de,(X_PTR)      ; retrieve new pointer
        push    bc
        push    de
        ex      de,hl
        ldir                    ; copy new var/line into space made
        pop     hl
        pop     bc
        push    de
        ROM3    o19E8           ; reclaim workspace holding new var/line
        pop     de
        ret

; section 16 - Perform disk SAVE

m0d6e   ld      a,(RAMERR)
        cp      'T'
        jp      z,m0e10         ; move on for tape operations
        call    m2b89           ; page in DOS workspace
        push    hl
        ld      b,$00           ; file 0
        ld      c,$03           ; exclusive read-write
        ld      d,$01
        ld      e,$03
        ld      hl,tmp_fspec
        push    ix
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; create the file
        call    m32ee           ; restore TSTACK
        jr      c,m0d9b         ; move on unless error
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause DOS error
        defb    $ff
m0d9b   ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_HEAD    ; get IX=header data
        call    m32ee           ; restore TSTACK
        jr      c,m0db1
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause DOS error
        defb    $ff
m0db1   ex      (sp),ix         ; IX=pointer to header in normal memory
        pop     hl              ; HL=pointer to header in page 7
        call    m2b64           ; page in normal memory
        ld      a,(ix+$00)
        call    m2b89           ; page in DOS workspace
        ld      (hl),a          ; transfer type
        inc     hl
        push    ix
        pop     de
        ex      de,hl           ; DE=DOS header address+1
        ld      bc,$000b
        add     hl,bc           ; HL=page 0 header parameters
        ld      bc,$0006
        call    m2b64           ; page in normal memory
        call    m3f63           ; copy parameters to DOS header
        ld      b,$00           ; file 0
        ld      c,$00
        ld      e,(ix+$0b)
        ld      d,(ix+$0c)      ; DE=length
        ld      a,d
        or      e
        call    m2b89           ; page in DOS workspace
        jr      z,m0df6         ; move on if zero length
        pop     hl              ; restore start address
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_WRITE       ; write block to file
        call    m32ee           ; restore TSTACK
        jr      c,m0df6
        call    m2b64           ; page in normal memory
        call    m0e9a           ; cause any DOS error
        defb    $ff
m0df6   ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file
        call    m32ee           ; restore TSTACK
        jr      c,m0e0c
        call    m2b64
        call    m0e9a           ; cause any DOS error
        defb    $ff
m0e0c   call    m2b64           ; page in normal memory
        ret                     ; done

; section 17 - Perform tape SAVE

m0e10   push    hl
        ld      a,$fd
        ROM3    o1601           ; open channel to stream -3
        xor     a
        ld      de,$09a1
        ROM3    o0C0A           ; output ROM 3's start tape message
        set     5,(iy+$02)      ; signal "screen needs clearing"
        ROM3    o15D4           ; wait for a key
        push    ix              ; save header address
        ld      de,$0011
        xor     a               ; header block
        call    m0828           ; save header
        pop     ix
        ld      b,$32
m0e31   halt                    ; delay for 1 sec
        djnz    m0e31
        ld      e,(ix+$0b)
        ld      d,(ix+$0c)      ; DE=length
        ld      a,$ff           ; data block
        pop     ix              ; IX=start
        jp      m0828           ; save & exit

; Looks like these bits aren't used
    IF garry
msg18   defb    $16, 0, 0, $10, 0, $11, $07, $13, 0
      IF spanish
        defm    "Introduzca la cinta y pulse PLAY"
        defm    "Cancelar: pulse BREAK dos veces.", $ff
m297c   defm    "SIN DATO", 'S'+$80
      ELSE
        defm    "Insert tape and press PLAY", $0d
        defm    "To cancel - press BREAK twice", $ff
        defb    0, 0, 0, 0, 0, 0, 0, 0
        defb    0, 0, 0, 0, 0, 0, 0, 0, 0
      ENDIF
    ELSE
        defb    $80
m0e42   defm    "Press REC & PLAY, then any key", $ae
        defm    $0d, "Program:", $a0
        defm    $0d, "Number array:", $a0
        defm    $0d, "Character array:", $a0
        defm    $0d, "Bytes:", $a0
    ENDIF

; Subroutine to check if char in A is a statement terminator

m0e94   cp      $0d
        ret     z
        cp      ':'
        ret

; Subroutine to cause a +3DOS error
; Routine will attempt to close file 0 before causing error
; On entry, A=+3DOS error code and byte following call is $ff
; or, byte following call is +3 BASIC error

m0e9a   push    af              ; save error code
m0e9b   ld      a,(RAMERR)
        cp      $54
        jr      z,m0eca         ; move on if SAVE/LOAD was using drive T:
        ld      b,$00
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file 0
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        jr      c,m0eca         ; move on if no error
        ld      b,$00
        call    m2b89           ; page in DOS workspace
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_ABANDON     ; else abandon file 0
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
m0eca   pop     af              ; restore error code
m0ecb   pop     hl              ; get return address
        ld      e,(hl)          ; get inline code
        bit     7,e
        jr      z,m0edc         ; use it as error code if not $ff
        cp      $0a             ; convert DOS error code to +3 BASIC error
        jr      nc,m0ed9
m0ed5   add     a,$3d
        jr      m0edb
m0ed9   add     a,$18
m0edb   ld      e,a
m0edc   ld      h,e             ; place code CALL m2ada, DEFB error
        ld      l,m2ada/$100    ; on stack
        push    hl
        ld      l,$cd
        ld      h,m2ada and $ff
        push    hl
        xor     a
        ld      hl,$0000
        add     hl,sp
        jp      (hl)            ; jump to execute code on stack & cause error

; The parameter offset table
; This contains offsets from each entry's position into the following
; parameter table

m0eeb   defb    m0f9c-$         ; DEF FN
        defb    m0fb6-$         ; CAT
        defb    m0fa9-$         ; FORMAT
        defb    m0fac-$         ; MOVE
        defb    m0fb2-$         ; ERASE
        defb    m0f9f-$         ; OPEN#
        defb    m0fa5-$         ; CLOSE#
        defb    m0f85-$         ; MERGE
        defb    m0f84-$         ; VERIFY
        defb    m0f86-$         ; BEEP
        defb    m0f8a-$         ; CIRCLE
        defb    m0f8e-$         ; INK
        defb    m0f8f-$         ; PAPER
        defb    m0f90-$         ; FLASH
        defb    m0f91-$         ; BRIGHT
        defb    m0f92-$         ; INVERSE
        defb    m0f93-$         ; OVER
        defb    m0f94-$         ; OUT
        defb    m0f7c-$         ; LPRINT
        defb    m0f7f-$         ; LLIST
        defb    m0f2d-$         ; STOP
        defb    m0f6c-$         ; READ
        defb    m0f6f-$         ; DATA
        defb    m0f72-$         ; RESTORE
        defb    m0f4b-$         ; NEW
        defb    m0f98-$         ; BORDER
        defb    m0f5b-$         ; CONTINUE
        defb    m0f45-$         ; DIM
        defb    m0f48-$         ; REM
        defb    m0f33-$         ; FOR
        defb    m0f20-$         ; GOTO
        defb    m0f29-$         ; GOSUB
        defb    m0f42-$         ; INPUT
        defb    m0f83-$         ; LOAD
        defb    m0f51-$         ; LIST
        defb    m0f1d-$         ; LET
        defb    m0f68-$         ; PAUSE
        defb    m0f3b-$         ; NEXT
        defb    m0f54-$         ; POKE
        defb    m0f3f-$         ; PRINT
        defb    m0f64-$         ; PLOT
        defb    m0f4e-$         ; RUN
        defb    m0f82-$         ; SAVE
        defb    m0f58-$         ; RANDOMIZE
        defb    m0f24-$         ; IF
        defb    m0f61-$         ; CLS
        defb    m0f75-$         ; DRAW
        defb    m0f5e-$         ; CLEAR
        defb    m0f30-$         ; RETURN
        defb    m0f79-$         ; COPY

; The parameter table for the BASIC commands
; These comprise command classes ($00-$0e), separators and
; where appropriate, command addresses
; The classes are:
;       00      No further operands
;       01      Used in LET: a variable is required
;       02      Used in LET: an expression (numeric or string) must follow
;       03      A numeric expression may follow (default=0)
;       04      A single character variable must follow
;       05      A set of items may be given
;       06      A numeric expression must follow
;       07      Handles colour items
;       08      Two numeric expressions separated by a comma must follow
;       09      As 08, but colour items may precede the expressions
;       0a      A string expression must follow
;       0b      Handles cassette/disk routines
;       0c      As 00, but handled in ROM 1 not ROM 3
;       0d      As 03, but handled in ROM 1 not ROM 3
;       0e      As 05, but handled in ROM 1 not ROM 3

m0f1d   defb    $01,'=',$02     ; LET
      IF garry
m0f20   defb    $0e
        defw    m35da
        defb    $00
      ELSE
m0f20   defb    $06,$00
        defw    o1E67           ; GOTO
      ENDIF
m0f24   defb    $06,$cb,$0e
        defw    m115e           ; IF
m0f29   defb    $06,$0c
        defw    m124a           ; GOSUB
m0f2d   defb    $00
        defw    o1CEE           ; STOP
      IF garry
m0f30   defb    $0e
        defw    m2b09
      ELSE
m0f30   defb    $0c
        defw    m1266           ; RETURN
      ENDIF
m0f33   defb    $04,'=',$06
        defb    $cc,$06
        defb    $0e
        defw    m1178           ; FOR
      IF garry
m0f3b   defb    $0e
        defw    $1506           ; NEXT
        defb    $00
      ELSE
m0f3b   defb    $04,$00
        defw    o1DAB           ; NEXT
      ENDIF
m0f3f   defb    $0e
        defw    m217b           ; PRINT
m0f42   defb    $0e
        defw    m218f           ; INPUT
m0f45   defb    $0e
      IF garry
        defw    m14e2           ; DIM
      ELSE
        defw    m22ad           ; DIM
      ENDIF
m0f48   defb    $0e
        defw    m1072           ; REM
      IF garry
m0f4b   defb    $0e
        defw    m3880           ; NEW
      ELSE
m0f4b   defb    $0c
        defw    m2280           ; NEW
      ENDIF
m0f4e   defb    $0d
        defw    m11f9           ; RUN
m0f51   defb    $0e
        defw    m1539           ; LIST
m0f54   defb    $08,$00
        defw    $1e80           ; POKE
m0f58   defb    $03
        defw    $1e4f           ; RANDOMIZE
m0f5b   defb    $00
        defw    $1e5f           ; CONTINUE
m0f5e   defb    $0d
        defw    m1204           ; CLEAR
m0f61   defb    $00
        defw    o0D6B           ; CLS
m0f64   defb    $09,$00
        defw    $22dc           ; PLOT
m0f68   defb    $06,$00
        defw    $1f3a           ; PAUSE
m0f6c   defb    $0e
        defw    m11a2           ; READ
m0f6f   defb    $0e
        defw    m11e2           ; DATA
m0f72   defb    $03
        defw    $1e42           ; RESTORE
m0f75   defb    $09,$0e
        defw    m2296           ; DRAW
m0f79   defb    $0e
        defw    m21aa           ; COPY
m0f7c   defb    $0e
        defw    m2177           ; LPRINT
m0f7f   defb    $0e
        defw    m1535           ; LLIST
m0f82   defb    $0b             ; SAVE
m0f83   defb    $0b             ; LOAD
m0f84   defb    $0b             ; VERIFY
m0f85   defb    $0b             ; MERGE
m0f86   defb    $08,$00
        defw    $03f8           ; BEEP
m0f8a   defb    $09,$0e
        defw    m2286           ; CIRCLE
m0f8e   defb    $07             ; INK
m0f8f   defb    $07             ; PAPER
m0f90   defb    $07             ; FLASH
m0f91   defb    $07             ; BRIGHT
m0f92   defb    $07             ; INVERSE
m0f93   defb    $07             ; OVER
m0f94   defb    $08,$00
        defw    $1e7a           ; OUT
m0f98   defb    $06,$00
        defw    $2294           ; BORDER
m0f9c   defb    $0e
        defw    m1283           ; DEF FN
      IF garry
m0f9f   defb    $06,',',$0a,$0c
        defw    m35d0           ; OPEN#
m0fa5   defb    $06,$0c
        defw    m35d7           ; CLOSE#
m0fa9   defb    $0e
        defw    m026c           ; FORMAT
m0fac   defb    $0a,$0e
        defw    m39bb           ; MOVE
        defb    0, 0
m0fb2   defb    $0a,$0c
        defw    m044a           ; ERASE
m0fb6   defb    $0e
        defw    m05b8           ; CAT
m0fb9   defb    $0e
        defw    m3aaf           ; SPECTRUM
      ELSE
m0f9f   defb    $06,',',$0a,$00
        defw    o1736           ; OPEN#
m0fa5   defb    $06,$00
        defw    $16e5           ; CLOSE#
m0fa9   defb    $0e
        defw    m026c           ; FORMAT
m0fac   defb    $0a,$cc,$0a,$0c
        defw    m04e5           ; MOVE
m0fb2   defb    $0a,$0c
        defw    m044a           ; ERASE
m0fb6   defb    $0e
        defw    m05b8           ; CAT
m0fb9   defb    $0c
        defw    m1465           ; SPECTRUM
      ENDIF
m0fbc   defb    $0e
        defw    m23f1           ; PLAY

; The main parser entry point
; Enter here for syntax checking

m0fbf   res     7,(iy+$01)      ; signal "syntax checking"
        ROM3    o19FB           ; point to the first code after any line no
        xor     a
        ld      (SUBPPC),a      ; initialise SUBPPC to zero statements
        dec     a
        ld      (ERR_NR),a      ; signal "OK" error code
        jr      m0fd1           ; jump to start checking

; The statement loop

m0fd0   rst     $20             ; advance CH_ADD
m0fd1   ROM3    o16BF           ; clear workspace
        inc     (iy+$0d)        ; increment SUBPPC on each statement
        jp      m,m1125         ; error if more than 127 statements on line
        rst     $18             ; fetch character
        ld      b,$00
        cp      $0d
        jp      z,m1073         ; move on if end-of-line
        cp      ':'
        jr      z,m0fd0         ; loop back if end-of-statement
        ld      hl,m1031
        push    hl              ; load stack with return address to STMT-RET
        ld      c,a             ; save command code
        rst     $20             ; advance CH_ADD
        ld      a,c
        sub     $ce             ; put command code in range $00..$31
        jr      nc,m1004        ; move on if valid keyword
        add     a,$ce           ; else reform character
        ld      hl,m0fb9        ; address of SPECTRUM parameter entries
        cp      $a3
        jr      z,m1010         ; move on if SPECTRUM command
        ld      hl,m0fbc        ; address of PLAY parameter entries
        cp      $a4
        jr      z,m1010         ; move on if PLAY command
        jp      m1125           ; else give Nonsense in BASIC
m1004   ld      c,a
        ld      hl,m0eeb        ; syntax offset table start
        add     hl,bc
        ld      c,(hl)
        add     hl,bc           ; get start of entries in parameter table
        jr      m1010           ; move on
m100d   ld      hl,(T_ADDR)     ; get pointer into parameter table
m1010   ld      a,(hl)          ; get next parameter type
        inc     hl
        ld      (T_ADDR),hl     ; save pointer
        ld      bc,m100d
        push    bc              ; stack return address back into this loop
        ld      c,a
        cp      $20
        jr      nc,m102a        ; move on if entry is a separator
        ld      hl,m10c5        ; base of command class table
        ld      b,$00
        add     hl,bc
        ld      c,(hl)          ; get offset
        add     hl,bc
        push    hl              ; stack computed command class routine address
        rst     $18             ; get next char to A
        dec     b               ; B=$ff
        ret                     ; call command class routine
m102a   rst     $18             ; get next char
        cp      c
        jp      nz,m1125        ; nonsense in BASIC if not required separator
        rst     $20             ; get next character
        ret                     ; back into loop at m100d

; The "STMT-RET" routine. A return is made here after correct interpretation
; of a statement

m1031   call    m2af9           ; test BREAK key
        jr      c,m103a         ; move on if not pressed
        call    m2ada
        defb    $14             ; error L - BREAK into program
m103a   bit     7,(iy+$0a)
        jp      nz,m10b8        ; move on if a jump is not being made
        ld      hl,(NEWPPC)     ; get new line number
        bit     7,h             ; check if running line in edit area
        jr      z,m105c         ; move on if not

; Enter here if running a line in the edit area

m1048   ld      hl,$fffe
        ld      (PPC),hl        ; this is line "-2"
        ld      hl,(WORKSP)
        dec     hl              ; HL points to end of edit area
        ld      de,(E_LINE)
        dec     de              ; DE points to location before edit area
        ld      a,(NSPPC)       ; fetch number of next statement to handle
        jr      m1092           ; move on

; Perform a jump in the program

m105c   ROM3    o196E           ; get start address of line to jump to
        ld      a,(NSPPC)       ; get statement number
        jr      z,m1080         ; move on if correct line was found
        and     a               ; else check statement number
        jr      nz,m10ad        ; if not zero, N - statement lost error
        ld      b,a
        ld      a,(hl)
        and     $c0             ; check for end of program
        ld      a,b
        jr      z,m1080         ; move on if not
        call    m2ada
        defb    $ff             ; else end with 0 - OK error

m1072   pop     bc              ; REM command - drop STMT-RET address to
                                ; ignore rest of command

; The Line-end routine

m1073   bit     7,(iy+$01)
        ret     z               ; exit if syntax-checking
        ld      hl,(NXTLIN)     ; get address of NXTLIN
        ld      a,$c0
        and     (hl)
        ret     nz              ; exit if end of program
        xor     a               ; use statement zero

; The line-use routine

m1080   cp      $01
        adc     a,$00           ; change statement zero to 1
        ld      d,(hl)
        inc     hl
        ld      e,(hl)
        ld      (PPC),de        ; store line number in PPC
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl           ; DE holds start of line
        add     hl,de
        inc     hl              ; HL holds start of next line
m1092   ld      (NXTLIN),hl     ; store next line address
        ex      de,hl
        ld      (CH_ADD),hl     ; update CH_ADD to current line start
        ld      d,a
        ld      e,$00
        ld      (iy+$0a),$ff    ; signal "no jump"
        dec     d
        ld      (iy+$0d),d      ; statement number-1 to SUBPPC
        jp      z,m0fd0         ; enter loop if want first statement
        inc     d
        ROM3    o198B           ; else find required statement
        jr      z,m10b8         ; move on if found
m10ad   call    m2ada
        defb    $16             ; report N - statement lost


; The "Check-end" subroutine. During syntax-checking, it ensures that
; the end of the statement has been reached, generating an error if not.

m10b1   bit     7,(iy+$01)      ; check bit 7 of FLAGS
        ret     nz              ; return if run-time
        pop     bc              ; drop return address of statement routine
        pop     bc              ; drop return address of scan-loop routine
m10b8   rst     $18             ; get next character
        cp      $0d
        jr      z,m1073         ; move back if end-of-line
        cp      $3a
        jp      z,m0fd0         ; move back if end-of-statement
        jp      m1125           ; else Nonsense in BASIC error


; The command class offset table
; This contains offsets from the entry in the table to the
; actual command class routines following

m10c5   defb    m10e9-$
        defb    m110c-$
        defb    m1110-$
        defb    m10e6-$
        defb    m1118-$
        defb    m10ea-$
        defb    m1121-$
        defb    m112d-$
        defb    m111d-$
        defb    m1157-$
        defb    m1129-$
        defb    m115b-$
        defb    m10d7-$
        defb    m10d4-$
        defb    m10d8-$

; Class $0c,$0d,$0e routines
; Enter at m10d4 for $0d, m10d7 for $0c and m10d8 for $0e

m10d4   ROM3    o1CDE           ; fetch a number (or 0 if none)
m10d7   cp      a               ; set zero flag for classes $0c & $0d
m10d8   pop     bc              ; drop the scan-loop return address
        call    z,m10b1         ; for classes $0c,$0d check for statement end
        ex      de,hl           ; save line pointer in DE
        ld      hl,(T_ADDR)     ; get address in parameter table
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=command address
        ex      de,hl           ; restore line pointer in HL
        push    bc              ; stack command address
        ret                     ; and "return" to it

; Class $00,$03,$05 routines
; Enter at m10e6 for $03, m10e9 for $00 and m10ea for $05

m10e6   ROM3    o1CDE           ; fetch a number (or 0 if none)
m10e9   cp      a               ; set zero flag for classes $00 & $03
m10ea   pop     bc              ; drop the scan-loop return address
        call    z,m10b1         ; for classes $00,$03 check for statement end
        ex      de,hl           ; save line pointer in DE
        ld      hl,(T_ADDR)     ; get address in parameter table
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=command address in ROM 3
        ex      de,hl           ; restore line pointer
        push    hl              ; and stack it
        ld      hl,m110b        ; place ROM 1 return address in RETADDR
        ld      (RETADDR),hl
        ld      hl,REGNUOY
        ex      (sp),hl         ; place REGNUOY routine as return address
        push    hl
        ld      h,b
        ld      l,c
        ex      (sp),hl         ; stack ROM 3 address, restore line pointer
        push    af              ; stack registers
        push    bc
        di                      ; disable interrupts
        jp      STOO            ; call ROM 3 routine
m110b   ret                     ; done

; Class $01 routine

m110c   ROM3    o1C1F           ; use ROM 3 to deal with class $01
        ret

; Class $02 routine

m1110   pop     bc              ; drop scan-loop return address
        ROM3    o1C56           ; fetch a value
        call    m10b1           ; check for end of statement
        ret

; Class $04 routine

m1118   ROM3    o1C6C           ; use ROM 3 to deal with class $04
        ret

; Class $08 routine

m111c   rst     $20
m111d   ROM3    o1C7A           ; use ROM 3 to deal with class $08
        ret

; Class $06 routine

m1121   ROM3    o1C82           ; use ROM 3 to deal with class $06
        ret

; Generate C - Nonsense in BASIC error

m1125   call    m2ada
        defb    $0b             ; error C

; Class $0a routine

m1129   ROM3    o1C8C           ; use ROM 3 to deal with class $0a
        ret

; Class $07 routine

m112d   bit     7,(iy+$01)      ; are we running or checking syntax?
        res     0,(iy+$02)      ; signal "main screen"
        jr      z,m113a
        ROM3    o0D4D           ; if running, make sure temp colours are used
m113a   pop     af              ; drop scan-loop return address
        ld      a,(T_ADDR)
        sub     (m0f8e and $ff)+$28 ; form token code INK to OVER
        ROM3    o21FC           ; change temporary colours as directed
        call    m10b1           ; check for statement end
        ld      hl,(ATTR_T)
        ld      (ATTR_P),hl     ; make temporary colours permanent
        ld      hl,P_FLAG       ; now copy even bits of P_FLAG to odd bits
        ld      a,(hl)
        rlca
        xor     (hl)
        and     $aa
        xor     (hl)
        ld      (hl),a
        ret

; Class $09 routine

m1157   ROM3    o1CBE           ; use ROM 3 to handle class $09
        ret

; Class $0b routine

m115b   jp      m0888           ; jump to cassette/disk handling routines


; The IF command

m115e   pop     bc              ; drop return address to STMT-RET
        bit     7,(iy+$01)
        jr      z,m1175         ; move on if syntax-checking
        ld      hl,(STKEND)     ; "delete" item on calculator stack
        ld      de,$fffb
        add     hl,de
        ld      (STKEND),hl
        ROM3    o34E9           ; call "test zero" with HL holding add of value
        jp      c,m1073         ; if false, go to next line
m1175   jp      m0fd1           ; if true or syntax-checking, do next statement

; The FOR command

m1178   cp      $cd
        jr      nz,m1185        ; move on if no STEP
        rst     $20             ; advance CH_ADD
        call    m1121           ; fetch step value
        call    m10b1           ; check end of statement if syntax-checking
        jr      m119d           ; else move on
m1185   call    m10b1           ; if no STEP, check end of statement
        ld      hl,(STKEND)     ; and stack value "1"
        ld      (hl),$00
        inc     hl
        ld      (hl),$00
        inc     hl
        ld      (hl),$01
        inc     hl
        ld      (hl),$00
        inc     hl
        ld      (hl),$00
        inc     hl
        ld      (STKEND),hl
m119d   ROM3    o1D16           ; use ROM 3 to perform command
        ret


; The READ command (enter at m11a2)

m11a1   rst     $20             ; move along statement
m11a2   call    m110c           ; check for existing variable
        bit     7,(iy+$01)
        jr      z,m11d9         ; move on if syntax-checking
        rst     $18             ; save current CH_ADD in X_PTR
        ld      (X_PTR),hl
        ld      hl,(DATADD)     ; fetch data list pointer
        ld      a,(hl)
        cp      ','
        jr      z,m11c2         ; move on unless new statement must be found
        ld      e,$e4
        ROM3    o1D86           ; search for "DATA" statement
        jr      nc,m11c2
        call    m2ada
        defb    $0d             ; error E - out of data if not found
m11c2   inc     hl              ; advance pointer
        ld      (CH_ADD),hl
        ld      a,(hl)
        ROM3    o1C56           ; assign value to variable
        rst     $18
        ld      (DATADD),hl     ; store CH_ADD as data pointer
        ld      hl,(X_PTR)      ; get pointer to READ statement
        ld      (iy+$26),$00    ; clear high byte of X_PTR
        ld      (CH_ADD),hl
        ld      a,(hl)          ; get next READ statement character
m11d9   rst     $18
        cp      ','
        jr      z,m11a1         ; loop back if more items
        call    m10b1           ; check for statement end
        ret

; The DATA command

m11e2   bit     7,(iy+$01)
        jr      nz,m11f3        ; move on if not syntax-checking
m11e8   ROM3    o24FB           ; scan next expression
        cp      ','
        call    nz,m10b1        ; if no more items, check for statement end
        rst     $20
        jr      m11e8           ; loop back for more
m11f3   ld      a,$e4           ; we're passing by a DATA statement

; Subroutine to pass by a DEF FN or DATA statement during run-time

m11f5   ROM3    o1E39           ; use ROM 3 routine
        ret

; The RUN command

m11f9   ROM3    o1E67           ; set NEWPPC as required
        ld      bc,$0000
        ROM3    o1E45           ; do a RESTORE 0
        jr      m1207           ; exit via CLEAR command

; The CLEAR command

m1204   ROM3    o1E99           ; get operand, use 0 as default
m1207   ld      a,b
        or      c
        jr      nz,m120f        ; move on if non-zero
        ld      bc,(RAMTOP)     ; use existing RAMTOP if zero
m120f   push    bc
        ld      de,(VARS)
        ld      hl,(E_LINE)
        dec     hl
        ROM3    o19E5           ; reclaim whole variables area
        ROM3    o0D6B           ; cls
        ld      hl,(STKEND)
        ld      de,$0032
        add     hl,de
        pop     de
        sbc     hl,de
        jr      nc,m1232        ; move on if ramtop value too low
        ld      hl,(P_RAMT)
        and     a
        sbc     hl,de
        jr      nc,m1236        ; move on if ramtop value not too high
m1232   call    m2ada
        defb    $15             ; error M - RAMTOP no good
m1236   ld      (RAMTOP),de     ; store new RAMTOP
        pop     de
        pop     hl
        pop     bc
        ld      sp,(RAMTOP)     ; reset SP
        inc     sp
        push    bc
        push    hl
        ld      (ERR_SP),sp     ; reset ERR_SP
        push    de
        ret

; The GOSUB command

m124a   pop     de              ; save STMT_RET address
        ld      h,(iy+$0d)
        inc     h               ; increment SUBPPC statement number
        ex      (sp),hl         ; exchange error address with statement number
        inc     sp              ; reclaim a location
        ld      bc,(PPC)
        push    bc              ; save line number
        push    hl              ; restack error address
        ld      (ERR_SP),sp     ; reset ERR_SP to error address
        push    de              ; restack STMT_RET address
        ROM3    o1E67           ; set NEWPPC & NSPPC to required values
        ld      bc,$0014
        ROM3    o1F05           ; test for room before making jump
        ret

; The RETURN command

m1266   pop     bc              ; get STMT_RET address
        pop     hl              ; get error address
        pop     de              ; get next stack entry
        ld      a,d
        cp      $3e
        jr      z,m127d         ; move on if end of GOSUB stack
        dec     sp              ; full entry only uses 3 bytes
        ex      (sp),hl         ; exchange error address with statement no
        ex      de,hl
        ld      (ERR_SP),sp     ; reset ERR_SP
        push    bc              ; restack STMT_RET
        ld      (NEWPPC),hl     ; store new line
        ld      (iy+$0a),d      ; and statement
        ret
m127d   push    de              ; reform stack
        push    hl
        call    m2ada
        defb    $06             ; error 7 - RETURN without GOSUB

; The DEF FN command

m1283   bit     7,(iy+$01)
        jr      z,m128e         ; move on if checking syntax
        ld      a,$ce
        jp      m11f5           ; else go to skip DEF FN
m128e   set     6,(iy+$01)      ; signal "numeric variable" in FLAGS
        ROM3    o2C8D           ; check present code is a letter
        jr      nc,m12ad        ; error C if not
        rst     $20             ; get next char
        cp      '$'
        jr      nz,m12a1        ; move on if not a string
        res     6,(iy+$01)      ; signal "string variable" in FLAGS
        rst     $20             ; get next char
m12a1   cp      '('
        jr      nz,m12e1        ; error if not (
        rst     $20
        cp      ')'
        jr      z,m12ca         ; move on if no parameters
m12aa   ROM3    o2C8D           ; check present code is letter
m12ad   jp      nc,m1125        ; error if not
        ex      de,hl
        rst     $20
        cp      '$'
        jr      nz,m12b8        ; move on if not string
        ex      de,hl
        rst     $20
m12b8   ex      de,hl
        ld      bc,$0006
        ROM3    o1655           ; make 6 bytes of room after parameter name
        inc     hl
        inc     hl
        ld      (hl),$0e        ; store a number marker in first location
        cp      ','
        jr      nz,m12ca        ; move on if end of parameters
        rst     $20
        jr      m12aa           ; loop back
m12ca   cp      ')'
        jr      nz,m12e1        ; error if no )
        rst     $20
        cp      '='
        jr      nz,m12e1        ; error if no =
        rst     $20
        ld      a,(FLAGS)
        push    af              ; save nature (number/string) of variable
        ROM3    o24FB           ; scan the expression
        pop     af
        xor     (iy+$01)
        and     $40
m12e1   jp      nz,m1125        ; error if expression not correct type
        call    m10b1           ; check for end of statement
        ret

      IF garry
        nop
      ENDIF

; The Loader routine, called from ROM 0

m12e8   call    m2b89           ; page in DOS workspace
        ld      hl,process
        ld      (hl),$ff        ; signal "current process is Loader"
      IF garry
        ld      a, (LODDRV)
        cp      'T'
      ELSE
        ld      hl,FLAGS3
        bit     4,(hl)
      ENDIF
        jp      z,m13c6         ; move on if no disk interface present
        xor     a
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_MESSAGE ; disable ALERT routine
        call    m32ee           ; restore TSTACK
        push    hl
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_BOOT        ; attempt to boot a disk from the boot sector
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ROM3    o16B0           ; clear editing workspaces
        ld      hl,(E_LINE)
        ld      bc,$0007
        ROM3    o1655           ; create 7 bytes of space at E_LINE
        ld      hl,m152e
        ld      de,(E_LINE)
        ld      bc,$0007
        ldir                    ; copy LOAD "disk" into E_LINE
        ld      hl,(E_LINE)
        ld      (CH_ADD),hl     ; set CH_ADD
        call    m22c7           ; clear whole display if necessary
        bit     6,(iy+$02)
        jr      nz,m133d        ; move on if shouldn't clear lower screen
        ROM3    o0D6E           ; clear lower screen
m133d   res     6,(iy+$02)      ; signal "lower screen can be cleared"
        call    m2b89           ; page in DOS workspace
        ld      hl,ed_flags
        bit     6,(hl)
        jr      nz,m1356        ; ???
        inc     hl
        ld      a,(hl)
        cp      $00
        jr      nz,m1356        ; ???
        call    m3e80
        defw    l1a8e
m1356   call    m2b64           ; page in normal memory
        ld      hl,TV_FLAG
        res     3,(hl)          ; signal "mode unchanged"
        ld      a,$19
        sub     (iy+$4f)
        ld      (SCR_CT),a      ; set scroll count according to current line
        set     7,(iy+$01)      ; signal "execution mode"
        ld      (iy+$0a),$01    ; statement 1
        ld      hl, n3e00
        push    hl
        ld      hl,ONERR
        push    hl
        ld      (ERR_SP),sp     ; set up error stack
        ld      hl,m1383
        ld      (SYNRET),hl     ; error return address
        jp      m1048           ; execute the edit line, returning here on error
m1383   call    m2b89           ; page in DOS workspace
        pop     hl              ; retrieve old ALERT address
        ld      a,$ff
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_MESSAGE ; re-enable ALERT routine
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in normal memory
        ld      a,(ERR_NR)      ; get error code
        bit     7,a
        jp      nz,m25cb        ; if OK, exit via standard syntax return
        ld      hl,(PPC)
        ld      de,$fffe
        xor     a
        sbc     hl,de
        ld      a,h
        or      l
        jp      nz,m25cb        ; or if error occurred in program
        ld      a,'T'
        ld      (LODDRV),a      ; set default load drive to cassette
        ld      hl,TV_FLAG
        set     0,(hl)          ; signal "using lower screen"
        ld      hl,msg18
        call    m1524           ; output cassette loader message
        ld      hl,TV_FLAG
        res     0,(hl)          ; signal "using main screen"
        set     6,(hl)          ; signal "don't clear lower screen"
        jr      m13c9
m13c6   call    m2b64           ; page in normal memory
m13c9   ROM3    o16B0           ; clear editing workspaces
        ld      hl,(E_LINE)
        ld      bc,$0003
        ROM3    o1655           ; make 3 bytes space at E_LINE
        ld      hl,m14df
        ld      de,(E_LINE)
        ld      bc,$0003
        ldir                    ; copy LOAD "" command into E_LINE
        ld      hl,(E_LINE)
        ld      (CH_ADD),hl     ; set interpretation address
        call    m22c7           ; clear whole screen if necessary
        bit     6,(iy+$02)
        jr      nz,m13f3
        ROM3    o0D6E           ; clear lower screen if necessary
m13f3   res     6,(iy+$02)      ; signal "lower screen can be cleared"
        call    m2b89           ; page in DOS workspace
        ld      hl,ed_flags
        bit     6,(hl)
        jr      nz,m140c        ; ???
        inc     hl
        ld      a,(hl)
        cp      $00
        jr      nz,m140c        ; ???
        call    m3e80
        defw    l1a8e
m140c   call    m2b64           ; page in normal memory
        ld      hl,TV_FLAG
        res     3,(hl)          ; signal "mode unchanged"
        ld      a,$19
        sub     (iy+$4f)
        ld      (SCR_CT),a      ; set scroll count according to current line
        set     7,(iy+$01)      ; signal "execution mode"
        ld      (iy+$0a),$01    ; set statement 1
        ld      hl, n3e00
        push    hl
        ld      hl,ONERR
        push    hl
        ld      (ERR_SP),sp     ; set up error stack
        ld      hl,m1439
        ld      (SYNRET),hl     ; set error return address
        jp      m1048           ; execute line in editing area
m1439   ld      a,(ERR_NR)      ; get error code
        bit     7,a
        jp      nz,m25cb        ; exit via standard error return if OK
        ld      hl,FLAGS3
        bit     4,(hl)
        jp      z,m25cb         ; or if no disk interface present
        ld      a,'A'
        ld      (LODDRV),a      ; else set default load drive to A:
        jp      m25cb           ; and exit

; The Print option, called from ROM 0

m1451   ROM3    o16B0           ; clear E_LINE, WORKSP, STKBOT etc
        ld      hl,(E_LINE)
        ld      bc,$0001
        ROM3    o1655           ; make a byte of space at E_LINE
        ld      hl,(E_LINE)
        ld      (hl),$e1        ; insert LLIST command
        call    m24f0           ; execute it

; The SPECTRUM command

m1465   call    m14c4           ; set "P" channel to use screen
        ld      sp,(ERR_SP)
        pop     hl              ; discard current error return address
        ld      hl,$1303
        push    hl              ; address to enter ROM 3 at, in main loop
      IF garry
        ld      hl,$0003        ; "AF"
      ELSE
        ld      hl,$0013        ; "AF"
      ENDIF
        push    hl
        ld      hl,$0008        ; "BC"
        push    hl
        ld      a,$20
        ld      (BANKM),a       ; page 0, paging disabled
        push    af
        push    bc
        di
        res     4,(iy+$01)      ; signal "48K BASIC" mode
        jp      STOO            ; enter 48K ROM

; The routine to enter 48K BASIC, called from ROM 0

m1488   ld      hl,$6000
        push    hl              ; stack address to return to (in RAM)
        ld      de,$6000
        ld      hl, m14b5
        ld      bc,$000f
        ldir                    ; copy following routine into RAM
        ld      a,(BANK678)
        res     3,a             ; turn off disk motor
        ld      bc,$1ffd
        di
        ld      (BANK678),a
        out     (c),a
        ei
        ld      a,$30           ; select ROM 3 with paging disabled
        di
        res     4,(iy+$01)      ; signal "48K BASIC" mode
        ld      (BANKM),a
        push    af
        push    bc
        jp      STOO            ; page in ROM 3 & jump to following routine

m14b5   ld      a,$30
        ld      bc,$7ffd
        di
        out     (c),a           ; page in ROM 3 & disable paging
        ei
        jp      $0000           ; reset machine with 48K ROM locked in

; Cliff J Lawson's initials

        defm    "CJL"

; Subroutine to copy screen channel addresses over printer channel addresses

m14c4   ld      hl,(CHANS)
        ld      de,$0005
        add     hl,de           ; HL=channel info for "S"
        ld      de,$000a
        ex      de,hl
        add     hl,de
        ex      de,hl           ; DE=channel info for "P"
        ld      bc,$0004
        ldir                    ; overwrite it
        res     3,(iy+$30)      ; set caps lock off
        res     4,(iy+$01)      ; signal "48K BASIC" mode
        ret

; LOAD "" command

m14df   defb    $ef,$22,$22

; The Loader message
    IF garry
m14e2   rst     $18
        cp      '#'
        jp      nz, m22ad
        call    m2b35
        ld      b, 2
        jp      m2b19
m14f0   ld      a, b
        cpl
        ld      h, a
        ld      a, c
        cpl
        ld      l, a
        inc     hl              ; HL= -BC
        add     hl, sp          ; HL= SP-BC
        ld      sp, hl          ; SP= SP-BC
        push    bc
        push    hl
        ex      de, hl
        ldir
        pop     hl
        ROM3    o250E
        pop     hl
        add     hl, sp
        ld      sp, hl          ; SP= SP+BC
        ret
m1506   rst     $18
        cp      '#'
        jr      z, m1515
        ROM3    o1C6C
        call    m10b1
        ROM3    o1DAB
        ret
m1515   call    m2b35
        ROM2    IDE_STREAM_IN
        ROM3    o2D28
        ROM3    o2AFF
        ret
    ELSE
msg18   defm    $16, $00, $00
m14e5   defm    $10, $00, $11, $07, $13, $00
      IF spanish
        defm    "Introduzca la cinta y pulse PLAY", $0d
        defm    "Cancelar: pulse BREAK dos veces.", $ff
      ELSE
        defm    "Insert tape and press PLAY", $0d
        defm    "To cancel - press BREAK twice", $ff
      ENDIF
    ENDIF


; Subroutine to output a $ff-terminated message

m1524   ld      a,(hl)          ; get next char
        cp      $ff
        ret     z               ; exit if end
        ROM3    o0010           ; output
        inc     hl
        jr      m1524           ; loop back

; LOAD "disk" command

m152e   defb    $ef             ; LOAD keyword
m152f   defm    $22, "disk", $22

; The LIST & LLIST commands (enter at m1535 for LLIST, m1539 for LIST)

m1535   ld      a,$03           ; default stream 3 for LLIST
        jr      m153b
m1539   ld      a,$02           ; default stream 2 for LIST
m153b   ld      (iy+$02),$00    ; signal ordinary listing in main screen
m153f   ROM3    o2530           ; are we checking syntax?
        jr      z,m1547
        ROM3    o1601           ; open channel if not
m1547   ROM3    o0018           ; get character
        ROM3    o2070           ; see if stream must be altered
        jr      c,m1567         ; move on if not
        ROM3    o0018           ; get character
        cp      ';'
        jr      z,m155a         ; move on if ;
        cp      ','
        jr      nz,m1562        ; move on if not ,
m155a   ROM3    o0020           ; get next character
m155d   call    m1121           ; get numeric expression
        jr      m156a           ; move on with line number to list from
m1562   ROM3    o1CE6           ; else use zero
        jr      m156a
m1567   ROM3    o1CDE           ; fetch a numeric expression or use zero
m156a   call    m10b1           ; check for end of statement
m156d   ROM3    o1825           ; use ROM 3 for actual listing operation
        ret

; PLAY command (enters here after syntax-checking)

m1571   di
        push    bc              ; save count of strings
        ld      de,$0037        ; $37 bytes required per string
        ld      hl,$003c        ; plus $3c bytes overhead
m1579   add     hl,de
        djnz    m1579
        ld      c,l
        ld      b,h             ; BC=workspace required
        ROM3    o0030           ; make space
        di
        push    de
m1583   pop     iy              ; IY=start of space
        push    hl              ; stack HL=end of space+1
m1586   pop     ix
        ld      (iy+$10),$ff
m158c   ld      bc,$ffc9
        add     ix,bc           ; IX=start of next string parameter space
        ld      (ix+$03),$3c
        ld      (ix+$01),$ff
        ld      (ix+$04),$0f
        ld      (ix+$05),$05
        ld      (ix+$21),$00
        ld      (ix+$0a),$00
        ld      (ix+$0b),$00
        ld      (ix+$16),$ff
        ld      (ix+$17),$00
        ld      (ix+$18),$00
        ROM3    o2BF1           ; get string from top of stack
        di
        ld      (ix+$06),e
        ld      (ix+$07),d      ; store address of string (twice)
        ld      (ix+$0c),e
        ld      (ix+$0d),d
        ex      de,hl
        add     hl,bc
        ld      (ix+$08),l
        ld      (ix+$09),h      ; store address of end-of-string+1
        pop     bc              ; restore count of strings
        push    bc
        dec     b
        ld      c,b
        ld      b,$00           ; BC=number of strings left on stack
        sla     c
        push    iy
        pop     hl
        add     hl,bc           ; HL=overheadspace+2*(string number-1)
        push    ix
        pop     bc
        ld      (hl),c
        inc     hl
        ld      (hl),b          ; store string parameter block address
        or      a
        rl      (iy+$10)        ; shift in 0 bit for each string
        pop     bc
        dec     b               ; decrement string count
        push    bc
        ld      (ix+$02),b      ; store string number (0...7) in parameters
        jr      nz,m158c        ; back for another string
        pop     bc              ; restore count of strings
        ld      (iy+$27),$1a
        ld      (iy+$28),$0b
        push    iy
        pop     hl
        ld      bc,$002b
        add     hl,bc
        ex      de,hl
        ld      hl,m161d
        ld      bc,$000d
        ldir                    ; copy FP routine in
        ld      d,$07
        ld      e,$f8
        call    m1a6a           ; output $f8 to AY register 7
        ld      d,$0b
        ld      e,$ff
        call    m1a6a           ; output $ff to AY register 11
        inc     d
        call    m1a6a           ; output $ff to AY register 12
        jr      m1669           ; move on

; FP routine used to calculate tempo values, executed in RAM with ROM 3
; paged in

m161d   defb    $ef, $a4, $01, $05, $34, $df, $75, $f4, $38, $75, $05, $38, $c9

; Subroutine to check if BREAK is being pressed (exit with carry reset if so)

m162a   ld      a,$7f
        in      a,($fe)
        rra
        ret     c               ; exit with carry set if not pressed
        ld      a,$fe
        in      a,($fe)
        rra                     ; test other key & exit
        ret

; Subroutine to initialise string pointers to first string (m163b)

m1636   ld      bc,$0011
        jr      m163e
m163b   ld      bc,$0000
m163e   push    iy
        pop     hl
        add     hl,bc           ; get address of pointer to string
        ld      (iy+$23),l
        ld      (iy+$24),h      ; store address
        ld      a,(iy+$10)
        ld      (iy+$22),a      ; copy available strings byte
        ld      (iy+$21),$01    ; set string bit marker
        ret

; Subroutine to get address of current string parameter block in IX

m1653   ld      e,(hl)
        inc     hl
        ld      d,(hl)
        push    de
        pop     ix
        ret

; Subroutine to increment pointer to next string parameter block address

m165a   ld      l,(iy+$23)
        ld      h,(iy+$24)      ; get current parameter block pointer address
        inc     hl
        inc     hl              ; move to next
        ld      (iy+$23),l
        ld      (iy+$24),h      ; store
        ret

; More PLAY command

m1669   call    m163b           ; copy initial info
m166c   rr      (iy+$22)        ; rotate string counter
        jr      c,m1678         ; move on if no string
        call    m1653           ; get IX=address of current string parm block
        call    m1748           ; interpret string for standard parms
m1678   sla     (iy+$21)
        jr      c,m1683         ; move on if tried 8 strings
        call    m165a           ; increment pointer to string parms address
        jr      m166c           ; loop back
m1683   call    m1b7f           ; find shortest current notelength
        push    de
        call    m1b30           ; output next note from each string
        pop     de
m168b   ld      a,(iy+$10)
        cp      $ff
        jr      nz,m1697        ; move on unless no strings,or stop encountered
        call    m1a81           ; close down AY channels for this command
        ei
        ret                     ; exit
m1697   dec     de
        call    m1b64           ; pause
        call    m1baf           ; decrement note lengths & change notes if nec
        call    m1b7f           ; find shortest current notelength
        jr      m168b           ; loop back

; List of PLAY string parameters

m16a3   defm    "HZYXWUVMT)(NO!"

; Subroutine to get next character from string and increment string
; interpretation address (carry set if no char available)

m16b1   call    m1ad1           ; get next character
        ret     c               ; exit if end of string
        inc     (ix+$06)        ; increment string interpretation address
        ret     nz
        inc     (ix+$07)
        ret

; Subroutine to get a note from the string, returning semitone value A (or 0)
; If A=$80, a rest was found

m16bd   push    hl
        ld      c,$00           ; C=initial semitone value (natural)
m16c0   call    m16b1           ; get next char from string
        jr      c,m16cd         ; move on if none
        cp      '&'
        jr      nz,m16d8        ; move on if not a rest
        ld      a,$80           ; signal "rest"
m16cb   pop     hl
        ret
m16cd   ld      a,(iy+$21)
        or      (iy+$10)
        ld      (iy+$10),a      ; set string to not in use & exit
        jr      m16cb
m16d8   cp      '#'             ; test for sharp sign
        jr      nz,m16df
        inc     c               ; if so, increment semitone value & loop back
        jr      m16c0
m16df   cp      '$'             ; test for flat sign
        jr      nz,m16e6
        dec     c               ; if so, decrement semitone value & loop back
        jr      m16c0
m16e6   bit     5,a
        jr      nz,m16f0        ; move on if lowercase letter
        push    af
        ld      a,$0c
        add     a,c             ; for uppercase, add octave to semitone value
        ld      c,a
        pop     af
m16f0   and     $df             ; make uppercase
        sub     'A'
        jp      c,m1b10         ; error k if <A
        cp      $07
        jp      nc,m1b10        ; or if >G
        push    bc
m16fd   ld      b,$00
        ld      c,a
        ld      hl,m19e7
        add     hl,bc
        ld      a,(hl)          ; get note semitone value
        pop     bc
        add     a,c             ; add octave/sharp/flat value
        pop     hl
        ret

; Subroutine to get a numeric value from the string into BC (defaults to 0)

m1709   push    hl
        push    de
        ld      l,(ix+$06)
        ld      h,(ix+$07)      ; get string interpretation address
        ld      de,$0000        ; initial value 0
m1714   ld      a,(hl)          ; get next char
        cp      '0'
        jr      c,m1731
        cp      '9'+1
        jr      nc,m1731        ; move on if not a digit
        inc     hl
        push    hl
        call    m173c           ; multiply current value by 10
        sub     '0'
        ld      h,$00
        ld      l,a
        add     hl,de           ; add in digit
        jr      c,m172e         ; jump if overflow
        ex      de,hl
        pop     hl
        jr      m1714           ; back for more digits
m172e   jp      m1b08           ; error l - number too big
m1731   ld      (ix+$06),l
        ld      (ix+$07),h      ; replace updated interpretation address
        push    de
        pop     bc              ; BC=value
        pop     de              ; restore registers
        pop     hl
        ret

; Subroutine to multiply DE by 10

m173c   ld      hl,$0000        ; start with zero
        ld      b,$0a
m1741   add     hl,de           ; add DE 10 times
        jr      c,m172e         ; jump if overflow
        djnz    m1741
        ex      de,hl
        ret

; Subroutine to interpret a string

m1748   call    m162a           ; check for break
        jr      c,m1755         ; move on if not pressed
        call    m1a81           ; close down channels for this command
        ei                      ; re-enable interrupts
        call    m2ada
        defb    20              ; error L - BREAK into program
m1755   call    m16b1           ; get next character of string
        jp      c,m1990         ; move on if no more available
        call    m19de           ; search for char in parameter list
        ld      b,$00
        sla     c
        ld      hl,m19b8
        add     hl,bc           ; form pointer to routine address
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl           ; HL=routine address
        call    m1770           ; call routine
        jr      m1748           ; loop back for more standard params
        ret                     ; exit when note length changed, or note found
m1770   jp      (hl)

; Parameter !: comment

m1771   call    m16b1           ; get next character from string
        jp      c,m198f         ; move on if end of string
        cp      '!'
        ret     z               ; exit if end of comment
        jr      m1771           ; loop back

; Parameter O: octave

m177c   call    m1709           ; get number from string
        ld      a,c
        cp      $09
        jp      nc,m1b00        ; error n if not 1-8
        sla     a
        sla     a
        ld      b,a
        sla     a
        add     a,b
        ld      (ix+$03),a      ; store base note number (12*octave)
        ret

; Parameter N: number separator

m1791   ret                     ; ignore

; Parameter (: start of repeat section

m1792   ld      a,(ix+$0b)      ; get current bracket depth
        inc     a               ; increment
        cp      $05
        jp      z,m1b18         ; if depth now 5, cause error d
        ld      (ix+$0b),a      ; store new depth
        ld      de,$000c        ; offset for bracket addresses
        call    m1813           ; get pointer to next bracket address down
        ld      a,(ix+$06)
        ld      (hl),a
        inc     hl
        ld      a,(ix+$07)
        ld      (hl),a          ; store address to repeat from
        ret

; Parameter ): end of repeat section

m17ae   ld      a,(ix+$16)      ; get number of )s encountered so far
        ld      de,$0017        ; offset for close bracket addresses
        or      a
        jp      m,m17dc         ; move on if none so far
        call    m1813           ; get address of current
        ld      a,(ix+$06)
        cp      (hl)
        jr      nz,m17dc
        inc     hl
        ld      a,(ix+$07)
        cp      (hl)
        jr      nz,m17dc        ; move on if not the same
        dec     (ix+$16)        ; decrement close bracket depth
        ld      a,(ix+$16)
        or      a
        ret     p               ; exit if still positive
        bit     0,(ix+$0a)
        ret     z               ; exit if not infinite repeat
        ld      (ix+$16),$00    ; set no close brackets
        xor     a
        jr      m17f7
m17dc   ld      a,(ix+$16)
        inc     a               ; increment close bracket depth
        cp      $05
        jp      z,m1b18         ; error d if depth of 5
        ld      (ix+$16),a      ; restore depth
        call    m1813           ; get pointer to next close bracket address
        ld      a,(ix+$06)
        ld      (hl),a
        inc     hl
        ld      a,(ix+$07)
        ld      (hl),a          ; store address to repeat to
        ld      a,(ix+$0b)      ; get current open bracket depth
m17f7   ld      de,$000c
        call    m1813           ; get pointer to address (or string start)
        ld      a,(hl)
        ld      (ix+$06),a
        inc     hl
        ld      a,(hl)
        ld      (ix+$07),a      ; reset interpretation address to correct point
        dec     (ix+$0b)        ; decrement open bracket depth
        ret     p
        ld      (ix+$0b),$00    ; reset to zero if no open brackets
        set     0,(ix+$0a)      ; set "infinite repeat"
        ret

; Subroutine to get HL=Ath word entry after IX+DE
; Used to find address for bracket address entries

m1813   push    ix
        pop     hl
        add     hl,de           ; add offset to string area
        ld      b,$00
        ld      c,a
        sla     c
        add     hl,bc           ; add offset to Ath word
        ret

; Parameter T: tempo

m181e   call    m1709           ; get number from string
        ld      a,b
        or      a
        jp      nz,m1b00        ; error n if >255
        ld      a,c
        cp      $3c
        jp      c,m1b00         ; error n if <60
        cp      $f1
        jp      nc,m1b00        ; error n if >240
        ld      a,(ix+$02)
        or      a
        ret     nz              ; ignore unless in first string
        ld      b,$00
        push    bc
        pop     hl
        add     hl,hl
        add     hl,hl
        push    hl
        pop     bc              ; BC=tempo*4
        push    iy
        ROM3    o2D2B           ; stack BC on calculator stack
        di
        pop     iy
        push    iy
        push    iy
        pop     hl
        ld      bc,$002b        ; offset to FP calculation routine
        add     hl,bc
        ld      iy,ERR_NR
        push    hl              ; stack FP routine address
        ld      hl,m1864
        ld      (RETADDR),hl    ; set up return address
        ld      hl,REGNUOY
        ex      (sp),hl
        push    hl
        push    af
        push    hl
        jp      STOO            ; call FP calculator - TOS=10/(tempo*4*val)
m1864   di
        ROM3    o2DA2           ; get value to BC
        di
        pop     iy
        ld      (iy+$27),c
        ld      (iy+$28),b      ; store tempo value
        ret

; Parameter M: channel

m1872   call    m1709           ; get number from string
        ld      a,c
        cp      $40
        jp      nc,m1b00        ; error n if >63
        cpl
        ld      e,a
        ld      d,$07
        call    m1a6a           ; output channel complement to AY register 7
        ret

; Parameter V: volume level

m1883   call    m1709           ; get number from string
        ld      a,c
        cp      $10
        jp      nc,m1b00        ; error n if >15
        ld      (ix+$04),a      ; store volume level
        ld      e,(ix+$02)
        ld      a,$08
        add     a,e
        ld      d,a             ; AY register=channel+8 (channel=0..7)
        ld      e,c
        call    m1a6a           ; output volume level to register
        ret

; Parameter U: volume effect in a string

m189b   ld      e,(ix+$02)
        ld      a,$08
        add     a,e
        ld      d,a             ; AY register=channel+8 (channel=0..7)
        ld      e,$1f
        ld      (ix+$04),e      ; store volume effect marker
        ret

; Parameter W: volume effect

m18a8   call    m1709           ; get number from string
        ld      a,c
        cp      $08
        jp      nc,m1b00        ; error n if >7
        ld      b,$00
        ld      hl,m19d6
        add     hl,bc
        ld      a,(hl)          ; get envelope byte
        ld      (iy+$29),a      ; store it
        ret

; Parameter X: volume duration

m18bc   call    m1709           ; get number from string
        ld      d,$0b
        ld      e,c
        call    m1a6a           ; output duration to AY registers 11
        inc     d
        ld      e,b
        call    m1a6a           ; and 12
        ret

; Parameter Y: MIDI channel

m18cb   call    m1709           ; get number from string
        ld      a,c
        dec     a               ; decrement
        jp      m,m1b00         ; error n if was 0
        cp      $10
        jp      nc,m1b00        ; error n if >15
        ld      (ix+$01),a      ; store channel
        ret

; Parameter Z: MIDI programming code

m18dc   call    m1709           ; get number from string
        ld      a,c
        call    m1d91           ; output code to MIDI
        ret

; Parameter H: stop PLAY command

m18e4   ld      (iy+$10),$ff    ; signal "no strings in use"
        ret

; Notes and other parameters

m18e9   call    m1a07           ; is char a digit? (ie note length)
        jp      c,m196f         ; move on if not
        call    m199a           ; get HL=pointer to note lengths for string
        call    m19a2           ; save in overhead area
        xor     a
        ld      (ix+$21),a      ; zero number of tied notes
        call    m1ab6           ; decrement interpretation address
        call    m1709           ; get number from string
        ld      a,c
        or      a
        jp      z,m1b00         ; error n if <1
        cp      $0d
        jp      nc,m1b00        ; or >12
        cp      $0a
        jr      c,m1920         ; move on unless dealing with triplets
        call    m19ee           ; get note length value
        call    m1962           ; increment number of tied notes
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store note length for first note
m1916   call    m1962           ; increment number of tied notes
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store note length for next tied note
        inc     hl
        jr      m1926
m1920   ld      (ix+$05),c      ; save new note length
        call    m19ee           ; get note length value
m1926   call    m1962           ; increment number of tied notes
m1929   call    m1ad1           ; test next character
        cp      '_'
        jr      nz,m195c        ; move on unless tieing notes
        call    m16b1           ; get the character
        call    m1709           ; get number from string
        ld      a,c
        cp      $0a
        jr      c,m194d         ; move on if not triplet
        push    hl
        push    de
        call    m19ee           ; get new note length value
        pop     hl
        add     hl,de
        ld      c,e
        ld      b,d             ; BC=old note length value+new note length val
        ex      de,hl           ; so does DE
        pop     hl              ; restore address to store
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store value
        ld      e,c
        ld      d,b
        jr      m1916           ; loop back
m194d   ld      (ix+$05),c      ; store new note length
        push    hl
        push    de
        call    m19ee           ; get note length value
        pop     hl
        add     hl,de
        ex      de,hl           ; DE=old note length val+new note length val
        pop     hl
        jp      m1929           ; loop back

; Store note length value & move on

m195c   ld      (hl),e
        inc     hl
        ld      (hl),d          ; store note length value
        jp      m198a           ; move on

; Subroutine to increment number of tied notes for a string

m1962   ld      a,(ix+$21)      ; get number of tied notes
        inc     a               ; increment
m1966   cp      $0b
        jp      z,m1b28         ; error o - too many tied notes
        ld      (ix+$21),a
        ret

; Notes and other parameters (continued)

m196f   call    m1ab6           ; decrement string interpretation pointer
        ld      (ix+$21),$01    ; set 1 tied note
        call    m199a           ; get pointer to note lengths for string
        call    m19a2           ; save in overhead area
        ld      c,(ix+$05)      ; get current note length
        push    hl
        call    m19ee           ; calc note length value
        pop     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store it
        jp      m198a
m198a   pop     hl              ; retrieve return address
m198b   inc     hl
        inc     hl              ; move on by two
        push    hl              ; restack
        ret                     ; return

; Subroutine to set current string to "finished"

m198f   pop     hl              ; discard return address
m1990   ld      a,(iy+$21)      ; get string mask bit
        or      (iy+$10)
        ld      (iy+$10),a      ; place into strings counter
        ret

; Subroutine to set HL=pointer to note lengths for current string

m199a   push    ix
        pop     hl
        ld      bc,$0022
        add     hl,bc
        ret

; Subroutine to save note lengths pointer of string in overhead area

m19a2   push    hl              ; save note lengths pointer
        push    iy
        pop     hl
        ld      bc,$0011
        add     hl,bc           ; HL=overhead area+$11
        ld      b,$00
        ld      c,(ix+$02)
m19af   sla     c
        add     hl,bc           ; HL=overhead area+$11+(string*2)
        pop     de
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store note lengths pointer
        ex      de,hl           ; restore HL=note lengths pointer
        ret

; Table of routine addresses for elements of PLAY strings

m19b8   defw    m18e9           ; note or other parameter
        defw    m1771           ; Z
        defw    m177c           ; Y
        defw    m1791           ; X
        defw    m1792           ; W
        defw    m17ae           ; U
        defw    m181e           ; V
        defw    m1872           ; M
        defw    m1883           ; T
        defw    m189b           ; )
        defw    m18a8           ; (
        defw    m18bc           ; N
        defw    m18cb           ; O
        defw    m18dc           ; !
        defw    m18e4           ; H

; Table of waveforms for volume effects

m19d6   defb    $00,$04,$0b,$0d
        defb    $08,$0c,$0e,$0a

; Subroutine to search for string character A in parameter list
; Z set if found

m19de   ld      bc,$000f
        ld      hl,m16a3
        cpir
        ret

; Table of note semitone values

m19e7   defb    $09,$0b,$00,$02,$04,$05,$07

; Subroutine to get note length value (DE) for note length C (1-12)

m19ee   push    hl
        ld      b,$00
        ld      hl,m19fa        ; start of table
        add     hl,bc
        ld      d,$00
        ld      e,(hl)          ; DE=note length value
        pop     hl
        ret

; Table of note length values

m19fa   defb    $80
        defb    $06,$09,$0c,$12
        defb    $18,$24,$30,$48
        defb    $60,$04,$08,$10

; Subroutine to test if A is a digit (carry reset if so)

m1a07   cp      '0'
        ret     c
        cp      '9'+1
        ccf
        ret

; Subroutine to play note A through AY channel for current string

m1a0e   ld      c,a             ; save semitone value
        ld      a,(ix+$03)
        add     a,c             ; add in base note value
        cp      $80
        jp      nc,m1b20        ; error m if out of range
        ld      c,a             ; save note value
        ld      a,(ix+$02)
        or      a
        jr      nz,m1a2d        ; move on unless first string
        ld      a,c
        cpl
        and     $7f
        srl     a
m1a25   srl     a
        ld      d,$06
        ld      e,a
        call    m1a6a           ; output value to AY register 6
m1a2d   ld      (ix+$00),c      ; save last note value
        ld      a,(ix+$02)
        cp      $03
        ret     nc              ; exit unless outputting AY channel 0-2
        ld      hl,m1c84
        ld      b,$00
        ld      a,c
        sub     $15
        jr      nc,m1a45
      IF garry
        ld      de,$0fbe        ; lowest note possible
      ELSE
        ld      de,$0fbf        ; lowest note possible
      ENDIF
        jr      m1a4c
m1a45   ld      c,a
        sla     c               ; form offset into semitone table
        add     hl,bc
        ld      e,(hl)
        inc     hl
m1a4b   ld      d,(hl)          ; get DE=note value
m1a4c   ex      de,hl
        ld      d,(ix+$02)
        sla     d               ; AY register=0,2 or 4
        ld      e,l
        call    m1a6a           ; output low byte of note value
        inc     d               ; AY register=1,3 or 5
        ld      e,h
        call    m1a6a           ; output high byte of note value
        bit     4,(ix+$04)
        ret     z               ; exit unless envelope to be used
        ld      d,$0d
        ld      a,(iy+$29)
        ld      e,a
        call    m1a6a           ; output waveform number to AY register 13
        ret

; Subroutine to output value E to sound register D

m1a6a   push    bc
        ld      bc,$fffd
        out     (c),d           ; select register D
        ld      bc,$bffd
        out     (c),e           ; output value E
        pop     bc
        ret

; Subroutine to get value of AY register A

m1a77   push    bc
        ld      bc,$fffd
        out     (c),a           ; select register
        in      a,(c)           ; get value
        pop     bc
        ret

; Subroutine to close down AY channels associated with this PLAY command

m1a81   ld      d,$07
        ld      e,$ff
        call    m1a6a           ; output $ff to AY register 7
        ld      d,$08
        ld      e,$00
        call    m1a6a           ; output 0 to AY register 8
        inc     d
        call    m1a6a           ; output 0 to AY register 9
        inc     d
        call    m1a6a           ; output 0 to AY register 10
        call    m163b           ; initialise string pointer info
m1a9a   rr      (iy+$22)        ; test for string
        jr      c,m1aa6         ; move on if none
        call    m1653           ; get IX=address of string parameter block
        call    m1d7b           ; output terminator if MIDI channel
m1aa6   sla     (iy+$21)
        jr      c,m1ab1         ; move on when 8 strings tested for
        call    m165a           ; increment pointer to next string block
        jr      m1a9a           ; loop back
m1ab1   ld      iy,ERR_NR       ; reset IY to system variables
        ret                     ; done

; Subroutine to decrement string interpretation pointer (skipping white space)

m1ab6   push    hl
        push    de
        ld      l,(ix+$06)
        ld      h,(ix+$07)      ; get current pointer
m1abe   dec     hl              ; decrement
        ld      a,(hl)
        cp      $20
        jr      z,m1abe
        cp      $0d
        jr      z,m1abe         ; loop back while on white space
        ld      (ix+$06),l
        ld      (ix+$07),h      ; store updated pointer
        pop     de
        pop     hl
        ret

; Subroutine to get next character from string in A, skipping any white space
; Carry set on exit if end of string reached

m1ad1   push    hl
        push    de
        push    bc
        ld      l,(ix+$06)
        ld      h,(ix+$07)      ; get HL=string interpretation address
m1ada   ld      a,h
        cp      (ix+$09)        ; compare against string end address
        jr      nz,m1ae9
        ld      a,l
        cp      (ix+$08)
        jr      nz,m1ae9
        scf                     ; set carry if end of string
        jr      m1af3
m1ae9   ld      a,(hl)
        cp      ' '
        jr      z,m1af7         ; move to skip any spaces
        cp      $0d
        jr      z,m1af7         ; or CRs
        or      a               ; reset carry
m1af3   pop     bc
        pop     de
        pop     hl
m1af6   ret
m1af7   inc     hl              ; increment string interpretation address
        ld      (ix+$06),l
        ld      (ix+$07),h
        jr      m1ada           ; loop back

; Error routines for PLAY

m1b00   call    m1a81           ; close down
        ei
        call    m2ada
        defb    41              ; error n - Out of range
m1b08   call    m1a81           ; close down
        ei
        call    m2ada
        defb    39              ; error l - Number too big
m1b10   call    m1a81           ; close down
        ei
        call    m2ada
        defb    38              ; error k - Invalid note name
m1b18   call    m1a81           ; close down
        ei
        call    m2ada
        defb    31              ; error d - Too many brackets
m1b20   call    m1a81           ; close down
        ei
        call    m2ada
        defb    40              ; error m - Note out of range
m1b28   call    m1a81           ; close down
        ei
        call    m2ada
        defb    42              ; error o - Too many tied notes

; Subroutine to output next note from each string

m1b30   call    m163b           ; initialise string pointer info
m1b33   rr      (iy+$22)        ; test for next string
        jr      c,m1b5a         ; move on if not present
        call    m1653           ; get address of string parameter block to IX
        call    m16bd           ; get note from string
        cp      $80
        jr      z,m1b5a         ; move on if rest found
        call    m1a0e           ; calculate semitone & play if string 0-2
        ld      a,(ix+$02)
        cp      $03
        jr      nc,m1b57        ; move on if strings 3-7
        ld      d,$08
        add     a,d
        ld      d,a
        ld      e,(ix+$04)
        call    m1a6a           ; output volume level to AY register 8+channel
m1b57   call    m1d5c           ; output semitone to MIDI channels
m1b5a   sla     (iy+$21)
        ret     c               ; exit when 8 strings done
        call    m165a           ; get to next string parameter block
        jr      m1b33           ; loop back

; Subroutine to pause for current notelength (DE)

m1b64   push    hl
        ld      l,(iy+$27)
        ld      h,(iy+$28)      ; HL=tempo value
        ld      bc,$0064
        or      a
        sbc     hl,bc
        push    hl
        pop     bc
        pop     hl
m1b74   dec     bc
        ld      a,b
        or      c
        jr      nz,m1b74        ; timing delay
        dec     de
        ld      a,d
        or      e
        jr      nz,m1b64        ; loop DE times
        ret

; Subroutine to find shortest cuurent note across all strings

m1b7f   ld      de,$ffff        ; largest notelength so far (-1)
        call    m1636           ; initialise pointers to first string
m1b85   rr      (iy+$22)        ; test for next string
        jr      c,m1b9d         ; move on if not present
        push    de
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; get notelength pointer
        ex      de,hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; get note length
        push    de
        pop     hl
        pop     bc
        or      a
        sbc     hl,bc
        jr      c,m1b9d         ; move on if already found smaller
        push    bc
        pop     de              ; keep current
m1b9d   sla     (iy+$21)        ; shift string bit marker
        jr      c,m1ba8         ; move on if done 8 strings
        call    m165a           ; increment pointer to next strings pointer
        jr      m1b85           ; loop back
m1ba8   ld      (iy+$25),e
        ld      (iy+$26),d      ; store shortest current note length
        ret

; Subroutine to decrement remaining note lengths for each string, changing
; notes if necessary

m1baf   xor     a
        ld      (iy+$2a),a      ; set no strings have changed notes
        call    m163b           ; initialise string pointers
m1bb6   rr      (iy+$22)
        jp      c,m1c48         ; move on if string not present
        call    m1653           ; get address of current string parameter block
        push    iy
        pop     hl
        ld      bc,$0011
        add     hl,bc
        ld      b,$00
        ld      c,(ix+$02)
        sla     c
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl
        push    hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl           ; HL=notelength for this string
        ld      e,(iy+$25)
        ld      d,(iy+$26)      ; DE=length to play
        or      a
        sbc     hl,de
        ex      de,hl
        pop     hl
        jr      z,m1bea         ; move on if same length
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; else store remaining length
        jr      m1c48           ; and move on
m1bea   ld      a,(ix+$02)
        cp      $03
        jr      nc,m1bfa        ; move on if MIDI channel
        ld      d,$08
        add     a,d
        ld      d,a             ; select AY register 8+channel
        ld      e,$00
        call    m1a6a           ; output 0 to register
m1bfa   call    m1d7b           ; output terminator if MIDI channel
        push    ix
        pop     hl
        ld      bc,$0021
        add     hl,bc
        dec     (hl)            ; decrement number of tied notes
        jr      nz,m1c14        ; move on if still some left
        call    m1748           ; interpret string for parameters
        ld      a,(iy+$21)
        and     (iy+$10)
        jr      nz,m1c48        ; move on if string no longer in use
        jr      m1c2b           ; move on
m1c14   push    iy
        pop     hl
        ld      bc,$0011
        add     hl,bc
        ld      b,$00
        ld      c,(ix+$02)
        sla     c
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     de
        inc     de
        ld      (hl),d
        dec     hl
        ld      (hl),e          ; store pointer to next tied note length
m1c2b   call    m16bd           ; get note from string
        ld      c,a
        ld      a,(iy+$21)
        and     (iy+$10)
        jr      nz,m1c48        ; move on if string no longer in use
        ld      a,c
        cp      $80
        jr      z,m1c48         ; move on if rest found
        call    m1a0e           ; play note through channel
        ld      a,(iy+$21)
        or      (iy+$2a)
        ld      (iy+$2a),a      ; signal "note changed for this string"
m1c48   sla     (iy+$21)
        jr      c,m1c54         ; move on if no more strings
        call    m165a           ; get to next string parameter block
        jp      m1bb6           ; loop back
m1c54   ld      de,$0001
        call    m1b64           ; pause
        call    m163b           ; initialise pointers to first string
m1c5d   rr      (iy+$2a)
        jr      nc,m1c7a        ; move on if note didn't change
        call    m1653           ; get pointer to string parameter block
        ld      a,(ix+$02)
        cp      $03
        jr      nc,m1c77        ; move on if MIDI channel
        ld      d,$08
        add     a,d
        ld      d,a
        ld      e,(ix+$04)
        call    m1a6a           ; output volume to AY register 8+channel
m1c77   call    m1d5c           ; output semitone to MIDI channel
m1c7a   sla     (iy+$21)
        ret     c               ; exit if 8 strings done
        call    m165a           ; move to next string parameter block
        jr      m1c5d           ; loop back

; The semitone table of note values

m1c84   defw    $0fbf,$0edc,$0e07,$0d3d
        defw    $0c7f,$0bcc,$0b22,$0a82
        defw    $09eb,$095d,$08d6,$0857
        defw    $07df,$076e,$0703,$069f
        defw    $0640,$05e6,$0591,$0541
        defw    $04f6,$04ae,$046b,$042c
        defw    $03f0,$03b7,$0382,$034f
        defw    $0320,$02f3,$02c8,$02a1
        defw    $027b,$0257,$0236,$0216
        defw    $01f8,$01dc,$01c1,$01a8
        defw    $0190,$0179,$0164,$0150
        defw    $013d,$012c,$011b,$010b
        defw    $00fc,$00ee,$00e0,$00d4
        defw    $00c8,$00bd,$00b2,$00a8
        defw    $009f,$0096,$008d,$0085
        defw    $007e,$0077,$0070,$006a
        defw    $0064,$005e,$0059,$0054
        defw    $004f,$004b,$0047,$0043
        defw    $003f,$003b,$0038,$0035
        defw    $0032,$002f,$002d,$002a
        defw    $0028,$0025,$0023,$0021
        defw    $001f,$001e,$001c,$001a
        defw    $0019,$0018,$0016,$0015
        defw    $0014,$0013,$0012,$0011
        defw    $0010,$000f,$000e,$000d
        defw    $000c,$000c,$000b,$000b
        defw    $000a,$0009,$0009,$0008

; Subroutine to output a semitone if a MIDI channel

m1d5c   ld      a,(ix+$01)
        or      a
        ret     m               ; exit if not a MIDI channel
        or      $90
        call    m1d91           ; output channel selector to MIDI
        ld      a,(ix+$00)
        call    m1d91           ; output last semitone value
        ld      a,(ix+$04)
        res     4,a             ; ignore waveform flag
        sla     a
        sla     a
        sla     a
        call    m1d91           ; output volume to MIDI
        ret

; Subroutine to output terminator to MIDI channel

m1d7b   ld      a,(ix+$01)
        or      a
        ret     m               ; exit if not a MIDI channel
        or      $80
        call    m1d91           ; output channel selector to MIDI
        ld      a,(ix+$00)
        call    m1d91           ; output semitone to MIDI
        ld      a,$40
        call    m1d91           ; output terminator to MIDI
        ret

; Subroutine to output a value (A) to the MIDI port (uses AUX)

m1d91   ld      l,a             ; save value
        ld      bc,$fffd
        ld      a,$0e
        out     (c),a           ; select AY register 14 (RS232/AUX)
        ld      bc,$bffd
        ld      a,$fa
        out     (c),a           ; output data low to AUX
        ld      e,$03
m1da2   dec     e
        jr      nz,m1da2        ; delay loop
        nop
        nop
        nop
        nop
        ld      a,l
        ld      d,$08           ; 8 bits to output
m1dac   rra                     ; get next LSB of value to carry
        ld      l,a
        jp      nc,m1db7
        ld      a,$fe
        out     (c),a           ; if set, output data high to AUX
        jr      m1dbd
m1db7   ld      a,$fa
        out     (c),a           ; if reset, output data low to AUX
        jr      m1dbd
m1dbd   ld      e,$02
m1dbf   dec     e
        jr      nz,m1dbf        ; delay loop
        nop
        add     a,$00
        ld      a,l
        dec     d
        jr      nz,m1dac        ; loop back for more bits
        nop
        nop
        add     a,$00
        nop
        nop
        ld      a,$fe
        out     (c),a           ; output data high to register
        ld      e,$06
m1dd5   dec     e
        jr      nz,m1dd5        ; delay loop
        ret

; Unused code for a FORMAT "P";n command, used in same way as FORMAT LINE n

m1dd9
      IF garry
        rst     $20
        ROM3    o1C82           ; get a string expression
        rst     $18
        cp      ','
        jp      nz, m1125
        rst     $20             ; get next char
        ROM3    o1C82           ; get numeric expression
        rst     $18
        ld      hl, FLAGS3
        res     6, (hl)
        cp      ','
        jr      nz, m1df7
        set     6, (hl)
        rst     $20
        ROM3    o1C82           ; get a string expression
m1df7   call    m10b1
        ld      a, 1
        ROM3    o1601
        jp      m37fe
      ELSE
        ROM3    o0018           ; get character at CH_ADD
        ROM3    o1C8C           ; get a string expression
        bit     7,(iy+$01)
        jr      z,m1df9         ; move on if just syntax-checking
        ROM3    o2BF1           ; get string from stack
        ld      a,c
        dec     a
        or      b
        jr      z,m1df1         ; if length 1, move on
        call    m2ada
        defb    36              ; else error j - invalid baud rate
m1df1   ld      a,(de)
        and     $df             ; get string char & make uppercase
        cp      'P'
        jp      nz,m1125        ; nonsense in BASIC error if not "P"
m1df9   ld      hl,(CH_ADD)
        ld      a,(hl)
        cp      ';'
        jp      nz,m1125        ; nonsense in BASIC error if next char not ";"
      ENDIF
m1e02   ROM3    o0020           ; get next char & continue into FORMAT LINE

; The FORMAT LINE command

m1e05   ROM3    o1C82           ; get numeric expression
        bit     7,(iy+$01)
        jr      z,m1e15         ; move on if syntax-checking
        ROM3    o1E99           ; get value to BC
        ld      (BAUD),BC       ; set BAUD rate
m1e15   ROM3    o0018           ; get next char
        cp      $0d
        jr      z,m1e21         ; move on if end-of-line
        cp      ':'
        jp      nz,m1125        ; error if not end-of-statement
m1e21   call    m10b1           ; check for end-of-statement
        ld      bc,(BAUD)
        ld      a,b
        or      c
        jr      nz,m1e30        ; move on if baud rate not zero
        call    m2ada
        defb    $25             ; else error "invalid baud rate"
m1e30   ld      hl,m1e50        ; baud rate table
m1e33   ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; get next baud rate
        inc     hl
        ex      de,hl
        ld      a,h
        cp      $25
        jr      nc,m1e47        ; move on if end of table
        and     a
        sbc     hl,bc
        jr      nc,m1e47        ; move on if >= required rate
        ex      de,hl
        inc     hl              ; skip timing constant
        inc     hl
        jr      m1e33           ; loop back for next
m1e47   ex      de,hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; get appropriate timing constant
        ld      (BAUD),de       ; save in BAUD
        ret

; The baud rate table

m1e50   defw    $0032,$0aa5     ; 50
        defw    $006e,$04d4     ; 110
        defw    $012c,$01c3     ; 300
        defw    $0258,$00e0     ; 600
        defw    $04b0,$006e     ; 1200
        defw    $0960,$0036     ; 2400
        defw    $12c0,$0019     ; 4800
        defw    $2580,$000b     ; 9600

; Printer input channel routine

m1e70   ld      hl,FLAGS3
        bit     3,(hl)
        jp      z,m1e85         ; move on if using Centronics
        ld      hl,SERFL
        ld      a,(hl)
        and     a
        jr      z,m1e89         ; move on if no RS232 character waiting
        ld      (hl),$00        ; reset SERFL flag
        inc     hl
        ld      a,(hl)          ; and get character
        scf
        ret
m1e85   ROM3    o15C4           ; invalid I/O device error
        ret
m1e89   call    m2af9           ; test for BREAK
      IF v41
        ld      hl,FLAGS2
        bit     6,(hl)
        jr      z,m1e8c
        jp      m1f94
      ENDIF
m1e8c   di
        exx
        ld      de,(BAUD)       ; DE=BAUD
        ld      hl,(BAUD)
        srl     h
        rr      l               ; HL=BAUD/2
        or      a
        ld      b,$fa           ; B=timing constant
        exx
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a           ; select AY register 14
        in      a,(c)           ; get RS232/AUX value
        or      $f0
        and     $fb             ; set CTS low
        ld      b,e
        out     (c),a           ; output CTS low
        ld      h,a             ; save RS232/AUX value with CTS low
m1eb2   ld      b,d
        in      a,(c)           ; get RS232/AUX value
        and     $80
        jr      z,m1ec2         ; move on if TXD was low (ie data ready)
m1eb9   exx
        dec     b               ; decrement timer
        exx
        jr      nz,m1eb2        ; loop back
        xor     a               ; carry reset for no data
        push    af
        jr      m1efb           ; move on if no data received
m1ec2   in      a,(c)
        and     $80
        jr      nz,m1eb9        ; back if TXD high
        in      a,(c)
        and     $80
        jr      nz,m1eb9        ; back if TXD high
        exx
        ld      bc,$fffd
        ld      a,$80           ; A'=char to build (carry will be set when
        ex      af,af'          ; all 8 bits have been read)
m1ed5   add     hl,de
        nop
        nop
        nop
        nop
m1eda   dec     hl
        ld      a,h
        or      l
        jr      nz,m1eda        ; baud rate timing loop
        in      a,(c)           ; get RS232/AUX data
        and     $80             ; mask data bit
        jp      z,m1eef         ; move on if zero
        ex      af,af'
        scf
        rra                     ; rotate a 1 bit in
        jr      c,m1ef8         ; move on if byte complete
        ex      af,af'
        jp      m1ed5           ; loop back for more bits
m1eef   ex      af,af'
        or      a
        rra                     ; rotate a 0 bit in
        jr      c,m1ef8         ; move on if byte complete
        ex      af,af'
        jp      m1ed5           ; loop back for more bits
m1ef8   scf                     ; carry set for data received
        push    af
        exx
m1efb   ld      a,h
        or      $04
        ld      b,e
        out     (c),a           ; set RS232 CTS high
        exx
        ld      h,d
        ld      l,e             ; HL=BAUD
        ld      bc,$0007
        or      a
        sbc     hl,bc
m1f0a   dec     hl
        ld      a,h
        or      l
        jr      nz,m1f0a        ; timing loop
        ld      bc,$fffd
        add     hl,de
        add     hl,de
        add     hl,de
m1f15   in      a,(c)
        and     $80
        jr      z,m1f23         ; move on if TXD low (2nd byte available)
        dec     hl
        ld      a,h
        or      l
        jr      nz,m1f15        ; timing loop
        pop     af              ; restore value
        ei
        ret                     ; exit
m1f23   in      a,(c)
        and     $80
        jr      nz,m1f15        ; move back if TXD high
        in      a,(c)
        and     $80
        jr      nz,m1f15        ; move back if TXD high
        ld      h,d
        ld      l,e
        ld      bc,$0002
        srl     h
        rr      l
        or      a
        sbc     hl,bc
        ld      bc,$fffd
        ld      a,$80           ; prepare 2nd byte in A'
        ex      af,af'
m1f41   nop
        nop
        nop
        nop
        add     hl,de
m1f46   dec     hl
        ld      a,h
        or      l
        jr      nz,m1f46        ; timing loop
        in      a,(c)
        and     $80             ; test bit
        jp      z,m1f5b         ; move on if zero
        ex      af,af'
        scf
        rra                     ; rotate a 1 bit in
        jr      c,m1f64         ; move on if byte complete
        ex      af,af'
        jp      m1f41           ; back for more bits
m1f5b   ex      af,af'
        or      a
        rra                     ; rotate a 0 bit in
        jr      c,m1f64         ; move on if byte complete
        ex      af,af'
        jp      m1f41           ; back for more bits
m1f64   ld      hl,SERFL
        ld      (hl),$01        ; flag "2nd byte available"
        inc     hl
        ld      (hl),a          ; store 2nd byte
        pop     af              ; restore the 1st byte
        ei
        ret                     ; done

m1f94 IF v41
        di
        exx
        ld      de,(BAUD)       ; DE=BAUD
        ld      hl,(BAUD)
        srl     h
        rr      l               ; HL=BAUD/2
        or      a
        ld      b,$fa           ; B=timing constant
        exx
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a           ; select AY register 14
        in      a,(c)           ; get RS232/AUX value
        or      $f0
        and     $fd             ; set CTS low
        ld      b,e
        out     (c),a           ; output CTS low
        ld      h,a             ; save RS232/AUX value with CTS low
x1eb2   ld      b,d
        in      a,(c)           ; get RS232/AUX value
        and     $10
        jr      z,x1ec2         ; move on if TXD was low (ie data ready)
x1eb9   exx
        dec     b               ; decrement timer
        exx
        jr      nz,x1eb2        ; loop back
        xor     a               ; carry reset for no data
        push    af
        jr      x1efb           ; move on if no data received
x1ec2   in      a,(c)
        and     $10
        jr      nz,x1eb9        ; back if TXD high
        in      a,(c)
        and     $10
        jr      nz,x1eb9        ; back if TXD high
        exx
        ld      bc,$fffd
        ld      a,$80           ; A'=char to build (carry will be set when
        ex      af,af'          ; all 8 bits have been read)
x1ed5   add     hl,de
        nop
        nop
        nop
        nop
x1eda   dec     hl
        ld      a,h
        or      l
        jr      nz,x1eda        ; baud rate timing loop
        in      a,(c)           ; get RS232/AUX data
        and     $10             ; mask data bit
        jp      z,x1eef         ; move on if zero
        ex      af,af'
        scf
        rra                     ; rotate a 1 bit in
        jr      c,x1ef8         ; move on if byte complete
        ex      af,af'
        jp      x1ed5           ; loop back for more bits
x1eef   ex      af,af'
        or      a
        rra                     ; rotate a 0 bit in
        jr      c,x1ef8         ; move on if byte complete
        ex      af,af'
        jp      x1ed5           ; loop back for more bits
x1ef8   scf                     ; carry set for data received
        push    af
        exx
x1efb   ld      a,h
        or      $02
        ld      b,e
        out     (c),a           ; set RS232 CTS high
        exx
        ld      h,d
        ld      l,e             ; HL=BAUD
        ld      bc,$0007
        or      a
        sbc     hl,bc
x1f0a   dec     hl
        ld      a,h
        or      l
        jr      nz,x1f0a        ; timing loop
        ld      bc,$fffd
        add     hl,de
        add     hl,de
        add     hl,de
x1f15   in      a,(c)
        and     $10
        jr      z,x1f23         ; move on if TXD low (2nd byte available)
        dec     hl
        ld      a,h
        or      l
        jr      nz,x1f15        ; timing loop
        pop     af              ; restore value
        ei
        ret                     ; exit
x1f23   in      a,(c)
        and     $10
        jr      nz,x1f15        ; move back if TXD high
        in      a,(c)
        and     $10
        jr      nz,x1f15        ; move back if TXD high
        ld      h,d
        ld      l,e
        ld      bc,$0002
        srl     h
        rr      l
        or      a
        sbc     hl,bc
        ld      bc,$fffd
        ld      a,$80           ; prepare 2nd byte in A'
        ex      af,af'
x1f41   nop
        nop
        nop
        nop
        add     hl,de
x1f46   dec     hl
        ld      a,h
        or      l
        jr      nz,x1f46        ; timing loop
        in      a,(c)
        and     $10             ; test bit
        jp      z,x1f5b         ; move on if zero
        ex      af,af'
        scf
        rra                     ; rotate a 1 bit in
        jr      c,x1f64         ; move on if byte complete
        ex      af,af'
        jp      x1f41           ; back for more bits
x1f5b   ex      af,af'
        or      a
        rra                     ; rotate a 0 bit in
        jr      c,x1f64         ; move on if byte complete
        ex      af,af'
        jp      x1f41           ; back for more bits
x1f64   ld      hl,SERFL
        ld      (hl),$01        ; flag "2nd byte available"
        inc     hl
        ld      (hl),a          ; store 2nd byte
        pop     af              ; restore the 1st byte
        ei
        ret                     ; done
      ENDIF

; Printer output channel routine

m1f6e   push    hl
        ld      hl,FLAGS3
        bit     2,(hl)
        pop     hl
        jp      z,m2051         ; go to output if pure binary channel
        push    af
        ld      a,(TVPARS)
        or      a
        jr      z,m1f8e         ; move on if no inline parameters expected
        dec     a
        ld      (TVPARS),a      ; decrement # parameters
        jr      nz,m1f89        ; move on if more still needed
        pop     af
        jp      m2020           ; move on
m1f89   pop     af
        ld      (TVDATA+1),a    ; save first parameter & exit
        ret
m1f8e   pop     af
        cp      $a3
        jr      c,m1fa0         ; move on unless BASIC token
        ld      hl,(RETADDR)
        push    hl              ; save RETADDR
        ROM3    o0B52           ; output tokens using ROM 3
        pop     hl
        ld      (RETADDR),hl    ; restore RETADDR
        scf
        ret
m1fa0   ld      hl,FLAGS
        res     0,(hl)          ; reset "outputting space" flag
        cp      ' '
        jr      nz,m1fab
        set     0,(hl)          ; set "outputting space" flag
m1fab   cp      $7f
        jr      c,m1fb1
        ld      a,'?'           ; substitute ? for graphics
m1fb1   cp      ' '
        jr      c,m1fcc         ; move on for control codes
        push    af
        ld      hl,COL
        inc     (hl)            ; increment column
        ld      a,(WIDTH)
        cp      (hl)
        jr      nc,m1fc8        ; if within width, move on to print
        call    m1fd0           ; output CRLF
        ld      a,$01
        ld      (COL),a         ; set first column
m1fc8   pop     af
        jp      m2051           ; output character
m1fcc   cp      $0d
        jr      nz,m1fde        ; move on unless CR
m1fd0   xor     a
        ld      (COL),a         ; reset column counter
        ld      a,$0d
        call    m2051           ; output CRLF
        ld      a,$0a
        jp      m2051           ; & exit
m1fde   cp      $06
        jr      nz,m2001        ; move on unless PRINT comma
        ld      bc,(COL)        ; B=WIDTH, C=COL
        ld      e,$00
m1fe8   inc     e               ; increment COL & E
        inc     c
        ld      a,c
        cp      b
        jr      z,m1ff6         ; if end of line, go to do E spaces
m1fee   sub     $08
        jr      z,m1ff6         ; or if at a tab stop
        jr      nc,m1fee
        jr      m1fe8           ; loop back until reach a tab stop or eol
m1ff6   push    de
        ld      a,' '
        call    m1f6e           ; output a space
        pop     de
        dec     e
        ret     z
        jr      m1ff6           ; loop back for more
m2001   cp      $16
        jr      z,m200e         ; move on for AT (2 inline codes)
        cp      $17
      IF garry
        jr      z,m2017
      ELSE
        jr      z,m200e         ; move on for TAB (*BUG* 2 inline codes)
      ENDIF
        cp      $10
        ret     c               ; exit for codes 0-15
        jr      m2017           ; move on for colour codes (1 inline code)
m200e   ld      (TVDATA),a      ; store control code
        ld      a,$02
        ld      (TVPARS),a      ; & number of codes required
        ret
m2017   ld      (TVDATA),a      ; store control code
      IF garry
        ld      a,$01
      ELSE
        ld      a,$02           ; *BUG* should be 1
      ENDIF
        ld      (TVPARS),a      ; & number of codes required
        ret

; Here, we deal with inline parameters

m2020   ld      d,a             ; save last parameter
        ld      a,(TVDATA)      ; get control code
        cp      $16
        jr      z,m2030         ; move on for AT
        cp      $17
        ccf
        ret     nz              ; ignore other codes except TAB
        ld      a,(TVDATA+1)    ; use first parameter as column
        ld      d,a
m2030   ld      a,(WIDTH)       ; get width
        cp      d
        jr      z,m2038
        jr      nc,m203e
m2038   ld      b,a
        ld      a,d
        sub     b               ; reduce column by width until in range
        ld      d,a
        jr      m2030
m203e   ld      a,d
        or      a
        jp      z,m1fd0         ; for column 0, do CRLF
m2043   ld      a,(COL)
        cp      d
        ret     z               ; exit if at right column
        push    de
        ld      a,' '
        call    m1f6e           ; output a space
        pop     de
        jr      m2043           ; loop back

; Subroutine to output a character to the printer (Centronics or RS232)

m2051   push    hl
        ld      hl,FLAGS3
        bit     3,(hl)
        pop     hl
        jp      z,m20a8         ; move on if print output is centronics

      IF v41
        ld      hl,FLAGS2
        bit     6,(hl)
        jr      z,m205c
        jp      x216d
      ENDIF

m205c   push    af              ; save character
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a           ; select AY register 14
m2067   call    m2af9           ; test for BREAK
        in      a,(c)           ; read RS232/AUX
        and     $40
        jr      nz,m2067        ; loop until DTR low
        ld      hl,(BAUD)
        ld      de,$0002
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=BAUD-2
        pop     af              ; restore character
        cpl                     ; invert it
        scf                     ; set carry for initial bit
        ld      b,$0b           ; 11 bits to output
m207f   di                      ; disable interrupts
m2080   push    bc              ; save registers
        push    af
        ld      a,$fe
        ld      h,d             ; HL=BAUD-2
        ld      l,e
        ld      bc,$bffd
        jp      nc,m2092        ; move on to output a one bit
        and     $f7             ; mask RS232 RXD off
        out     (c),a           ; output zero bit to RS232
        jr      m2098
m2092   or      $08             ; set RS232 RXD on
        out     (c),a           ; output one bit to RS232
        jr      m2098
m2098   dec     hl
        ld      a,h
        or      l
        jr      nz,m2098        ; timing loop for baud rate
        nop                     ; more timing values
        nop
        nop
        pop     af              ; restore registers
        pop     bc
        or      a               ; clear carry (for stop bits)
        rra                     ; rotate next bit
        djnz    m2080           ; loop back for more
        ei
        ret

    IF v41
x216d   push    af
        ld      c,$fd
        ld      d,$ff
        ld      e,$bf
        ld      b,d
        ld      a,$0e
        out     (c),a
x2179   call    m2af9
        in      a,(c)
        and     $20
        jr      nz,x2179
        ld      hl,(BAUD)
        ld      de,$0002
        or      a
        sbc     hl,de
        ex      de,hl
        pop     af
        cpl
        scf
        ld      b,$0b
        di
x2192   push    bc
        push    af
        ld      a,$fe
        ld      h,d
        ld      l,e
        ld      bc,$bffd
        jp      nc,x21a4
        and     $fe
        out     (c),a
        jr      x21aa
x21a4   or      $01
        out     (c),a
        jr      x21aa
x21aa   dec     hl
        ld      a,h
        or      l
        jr      nz,x21aa
        nop
        nop
        nop
        pop     af
        pop     bc
        or      a
        rra
        djnz    x2192
        ei
        ret
m20a8   push    af              ; save character
        ld      bc,$1ffd
        ld      a,(BANK678)
        set     4,a
        di
        out     (c),a           ; output strobe
        ld      (BANK678),a
        ei
x2217   call    m2af9
        ld      bc,$0ffd
        in      a,(c)
        bit     0,a
        jr      nz,x2217        ; wait for printer ready
        pop     af
        out     (c),a           ; output strobe
        di
        ld      bc,$1ffd
        ld      a,(BANK678)
        res     4,a
        out     (c),a           ; output strobe
        set     4,a
        out     (c),a           ; output strobe
        ld      (BANK678),a
        ei
        scf
        ret
    ELSE
m20a8   push    af              ; save character
m20a9   call    m2af9           ; test for BREAK
        ld      bc,$0ffd
        in      a,(c)
        bit     0,a
        jr      nz,m20a9        ; wait for printer ready
        pop     af
        out     (c),a           ; output character
        di
m20b9   ld      bc,$1ffd
        ld      a,(BANK678)
      IF garry
        and     $ef
        out     (c),a           ; output strobe
        or      $10
        ld      (BANK678),a
        out     (c),a           ; output strobe
      ELSE
        xor     $10             ; toggle strobe bit
        ld      (BANK678),a
        out     (c),a           ; output strobe
        bit     4,a
        jr      z,m20b9         ; loop back to finish with strobe high
      ENDIF
        ei
        scf
        ret
        ret
    ENDIF

; The COPY (to printer) command routine

m20ce   bit     7,(iy+$01)
        ret     z               ; exit if syntax-checking
        ld      a,(BANK678)
        ld      bc,$1ffd
        set     4,a
        di                      ; disable interrupts
        ld      (BANK678),a
        out     (c),a           ; set strobe high
        ei
        ld      hl,YLOC
      IF bluerom
        ld      (hl),$2f        ; *BUG* fixed: the "COPY" command will give a full printer screen copy (all 24*8 lines, not only 22*8)
      ELSE
        ld      (hl),$2b        ; set Y location to 43 (4 bits on each row)
      ENDIF
m20e7   ld      hl,m216b
        call    m2151           ; output 120dpi line command
        call    m2107           ; output raster image
        ld      hl,m2172
        call    m2151           ; output linefeed
        ld      hl,YLOC
        xor     a
        cp      (hl)
        jr      z,m2100
        dec     (hl)
        jr      m20e7           ; loop back for more lines
m2100   ld      hl,m2174
        call    m2151           ; reset linespacing and done
        ret

; Subroutine to output a raster line for a non-expanded copy

m2107   ld      hl,XLOC
        ld      (hl),$ff        ; set XLOC
m210c   call    m2118           ; output a pixel's width
        ld      hl,XLOC
        xor     a
        cp      (hl)
        ret     z               ; exit if done line
        dec     (hl)
        jr      m210c           ; back for next pixel width

; Subroutine to output a pixel's width of a non-expanded copy

m2118   ld      de,$c000        ; D=pixel position mask
        ld      bc,(XLOC)       ; C=x-position, B=y-position
        scf
        rl      b
        scf
        rl      b               ; B=top row of required bits
        ld      a,c
        cpl
        ld      c,a             ; start at left of screen
        xor     a               ; initialise raster byte
        push    af
        push    de
        push    bc
m212c   call    m215f           ; get pixel state
        pop     bc
        pop     de
        ld      e,$00
        jr      z,m2136         ; set E=0 for no pixel
        ld      e,d             ; or E=mask for pixel
m2136   pop     af
        or      e               ; combine pixel into raster byte
        push    af
        dec     b               ; decrement Y position
        srl     d
        srl     d               ; shift mask right twice (4 pixels per row)
        push    de
        push    bc
        jr      nc,m212c        ; loop back if more pixels to get
        pop     bc
        pop     de
        pop     af
        ld      b,$03
m2147   push    bc
        push    af
        call    m2051           ; output raster byte
        pop     af
        pop     bc
        djnz    m2147           ; loop back for 3 passes
        ret

; Subroutine to output a counted string at HL to the printer

m2151   ld      b,(hl)          ; get count
        inc     hl
m2153   ld      a,(hl)          ; get next char
        push    hl
        push    bc
        call    m2051           ; output char to printer
        pop     bc
        pop     hl
        inc     hl
        djnz    m2153           ; loop back for more
        ret

; Subroutine to check pixel at B=y,C=x
; On exit, Z is reset if pixel is ink, set if pixel is paper
;rst     $28
;defw    o22AA
m215f   ROM3    o22AA           ; get address of pixel in HL
        ld      b,a
        inc     b               ; B=counter to get required pixel
        xor     a               ; zero A
        scf                     ; set carry
m2166   rra                     ; rotate bit into position
m2167   djnz    m2166
        and     (hl)            ; mask against screen byte
        ret

; The line header for a non-expanded copy

m216b   defb    $06             ; 6 bytes
        defb    $1b,'1'         ; select 7/72" linespacing
        defb    $1b,'L',$00,$03 ; print 768 dots in 120dpi

; The line terminator for a non-expanded copy

m2172   defb    $01             ; 1 byte
        defb    $0a             ; linefeed

; The terminator for a non-expanded copy

m2174   defb    $02             ; 2 bytes
        defb    $1b,'2'         ; select 1/6" linespacing

; The PRINT & LPRINT commands (enter at m2177 for LPRINT, m217b for PRINT)

m2177   ld      a,$03           ; use stream 3 for LPRINT
        jr      m217d
m217b   ld      a,$02           ; use stream 2 for PRINT
m217d   ROM3    o2530           ; are we syntax-checking?
        jr      z,m2185
        ROM3    o1601           ; open channel if not
m2185   ROM3    o0D4D           ; set temporary colours
        ROM3    o1FDF           ; use ROM 3 for command routine
        call    m10b1           ; check for end-of-statement
        ret

; The INPUT command

m218f   ROM3    o2530
        jr      z,m219c         ; move on if syntax-checking
        ld      a,$01
m2196   ROM3    o1601           ; open channel to stream 1
        ROM3    o0D6E           ; clear lower screen
m219c   ld      (iy+$02),$01    ; set DF_SZ to 1
        ROM3    o20C1           ; deal with the input items
        call    m10b1           ; check for end-of-statement
        ROM3    o20A0           ; use ROM 3 for actual routine
        ret

; The COPY command

m21aa   rst     $18
        cp      $0d
        jp      z,m20ce         ; go to do printer copy if end of line
        cp      ':'
        jp      z,m20ce         ; or end of statement
        cp      $b9
        jp      z,m3328         ; go to do expanded copy if COPY EXP
      IF garry
        defs    3
      ELSE
        cp      $f9
        jp      z,m35c4         ; move on if COPY RANDOMIZE
      ENDIF
        ROM3    o1C8C           ; get a string expression
        ROM3    o0018           ; get character
m21c5   cp      $cc
        jr      z,m21cd         ; move on if found TO
        call    m2ada
        defb    $0b             ; error C - nonsense in BASIC
m21cd   ROM3    o0020           ; get next char
m21d0   cp      $aa
        jp      z,m2237         ; move on if COPY f$ TO SCREEN$
        cp      $a3
        jp      z,m2257         ; move on if COPY f$ TO SPECTRUM FORMAT
        cp      $e0
        jp      z,m2237         ; move on if COPY f$ TO LPRINT
        ROM3    o1C8C           ; get a string expression
        call    m10b1           ; check for end-of-statement
        ROM3    o2BF1           ; fetch last value from calculator stack
        ld      a,b
        or      c               ; check length of second string
        jr      nz,m21f0
        call    m2ada
        defb    $2c             ; error "Bad filename"
m21f0
      IF garry=0
        inc     de
        ld      a,(de)          ; check 2nd char of 2nd string
        dec     de
        cp      ':'
        jr      nz,m21fb        ; move on if not specifying a drive
        ld      a,(de)
        and     $df             ; convert drive letter to uppercase
        ld      (de),a
      ENDIF
m21fb   ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy 2nd string to page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; terminate 2nd filename with $ff
        inc     de              ; increment pointer after 2nd filename
        call    m2b64           ; page in normal memory
        push    de              ; save pointer
        ROM3    o2BF1           ; fetch value from calculator stack
        ld      a,b
        or      c
        jr      nz,m2218        ; check length of first string
        call    m2ada
        defb    $2c             ; error "Bad filename"
m2218
      IF garry=0
        inc     de
        ld      a,(de)          ; check 2nd char of first string
        dec     de
        cp      ':'
        jr      nz,m2223        ; move on if not specifying a drive
        ld      a,(de)
        and     $df             ; convert drive letter to uppercase
        ld      (de),a
      ENDIF
m2223   pop     hl              ; restore address in page 7
        ex      de,hl
        call    m3f63           ; copy 1st filename to page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; terminate 1st filename with $ff
        call    m2b64           ; page in normal memory
        xor     a               ; signal "copying to a file"
        scf
        call    m2ba3           ; do the copy
        ret

; The COPY...TO SCREEN$/LPRINT commands

m2237   push    af              ; save keyword
        ROM3    o0020           ; get next char
      IF garry
        pop     bc
m223b   call    m10b1           ; check for end-of-statement
        push    bc
      ELSE
m223b   call    m10b1           ; check for end-of-statement
      ENDIF
        ROM3    o2BF1           ; get string
        ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy into page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        call    m2b64           ; page in normal memory
        pop     af              ; restore keyword as destination flag
        and     a               ; reset Z flag
        call    m2ba3           ; copy the file
        ret

; The COPY....TO SPECTRUM FORMAT command

m2257   ROM3    o0020           ; get next char
m225a   cp      $d0             ; check for FORMAT
        jr      z,m2262
        call    m2ada
        defb    $0b             ; nonsense in BASIC if not
m2262   ROM3    o0020           ; get to next char
m2265   call    m10b1           ; check for end-of-statement
        ROM3    o2BF1           ; get string
        ld      hl,tmp_fspec
        ex      de,hl
        call    m3f63           ; copy into page 7
        call    m2b89           ; page in DOS workspace
        ld      a,$ff
        ld      (de),a          ; add terminator
        call    m2b64           ; page in normal memory
        xor     a
        call    m2ba3           ; copy the file
        ret

; The NEW command

m2280   di
        call    m3e80
        defw    $01b0           ; use routine in ROM 0

; The CIRCLE command

m2286   rst     $18             ; get current char
        cp      ','
        jr      nz,m22c3        ; error C if not comma
        rst     $20             ; get next char
        ROM3    o1C82           ; get numeric expression
        call    m10b1           ; check for end-of-statement
        ROM3    o232D           ; use ROM 3 for actual routine
        ret

; The DRAW command

m2296   rst     $18             ; get current char
        cp      ','
        jr      z,m22a2         ; move on if comma
        call    m10b1           ; check for end-of-statement
        ROM3    o2477           ; use ROM 3 to draw line
        ret
m22a2   rst     $20             ; get next char
        ROM3    o1C82           ; get numeric expression
        call    m10b1           ; check for end of statement
        ROM3    o2394           ; use ROM 3 to draw curve
        ret

; The DIM command

m22ad   ROM3    o28B2           ; search variables area
        jr      nz,m22c3        ; move on if error
        ROM3    o2530
        jr      nz,m22bf        ; move on if runtime
        res     6,c             ; test string syntax as if numeric
        ROM3    o2996           ; check syntax of parenthesised expression
        call    m10b1           ; check for end-of-statement
m22bf   ROM3    o2C15           ; use ROM 3 for actual command
        ret
m22c3   call    m2ada
        defb    $0b             ; error C - nonsense in BASIC


; Subroutine to clear whole display unless unnecessary

m22c7   bit     0,(iy+$30)      ; check FLAGS2
        ret     z               ; exit if not necessay
        ROM3    o0DAF           ; cls
        ret

; Subroutine to evaluate an expression for the calculator, & set the
; result to be used by the next calculation

m22d0   ld      hl,$fffe
        ld      (PPC),hl        ; set statement -2
        res     7,(iy+$01)      ; signal "syntax checking"
        call    m2368           ; set interpreter to start of line
        ROM3    o24FB           ; evaluate an expression
        bit     6,(iy+$01)
        jr      z,m2312         ; move on if value not numeric
        rst     $18
        cp      $0d
        jr      nz,m2312        ; or if next character isn't end-of-line
        set     7,(iy+$01)      ; signal "executing"
        call    m2368           ; set interpreter to start of line
        ld      hl,m25cb
        ld      (SYNRET),hl     ; set up error return address
        ROM3    o24FB           ; evaluate an expression
        bit     6,(iy+$01)
        jr      z,m2312         ; move on if value not numeric
        ld      de,LASTV
        ld      hl,(STKEND)
        ld      bc,$0005
        or      a
        sbc     hl,bc
        ldir                    ; copy result into LASTV variable
        jp      m2316
m2312   call    m2ada
        defb    25              ; error Q - parameter error
m2316   ld      a,$0d
        call    m2347           ; do a newline
        ld      bc,$0001
        ROM3    o0030           ; make a byte in the workspace
m2321   ld      (K_CUR),hl      ; save address of cursor
        push    hl
        ld      hl,(CURCHL)     ; get address of current channel information
        push    hl
        ld      a,$ff
        ROM3    o1601           ; open channel to stream -1
        ROM3    o2DE3           ; print the result value
        pop     hl
        ROM3    o1615           ; restore old channel
        pop     de
        ld      hl,(K_CUR)      ; get new cursor address
        and     a
        sbc     hl,de           ; HL=# of result chars
m233c   ld      a,(de)
        call    m2347           ; "type" each result character
        inc     de
        dec     hl
        ld      a,h
        or      l
        jr      nz,m233c        ; loop back for more
        ret

; Subroutine to "do" a key (A) using ROM 0's editing keys

m2347   push    hl
        push    de
        call    m2b89           ; page in DOS workspace
        ld      hl,ed_flags
        res     3,(hl)          ; ???
        push    af
        ld      a,$02
        ROM3    o1601           ; open channel to stream 2
        pop     af
        call    m3e80
      IF v41
        defw    $071b           ; "do" the key
      ELSE
        defw    $0716           ; "do" the key
      ENDIF
        ld      hl,ed_flags
        res     3,(hl)          ; ???
        call    m2b64           ; page in normal memory
        pop     de
        pop     hl
        ret

; Subroutine to set interpreter to entered line, with A=first char

m2368   ld      hl,(E_LINE)
        dec     hl
        ld      (CH_ADD),hl     ; CH_ADD=E_LINE-1
        rst     $20             ; get next char
        ret

; Subroutine to determine if line is a single LET statement (Z set if so)

m2371   call    m2368           ; get first char in E_LINE
        cp      $f1
        ret     nz              ; exit unless LET
        ld      hl,(CH_ADD)
m237a   ld      a,(hl)
        inc     hl
        cp      $0d
        ret     z               ; exit when end of line found (with Z set)
        cp      ':'
        jr      nz,m237a
        or      a
        ret                     ; or when end of statement found (with Z reset)

; Subroutine to check if character is a binary operator (Z set if so)

m2385   ld      b,a             ; save char
        ld      hl,m2397        ; list of operators
m2389   ld      a,(hl)          ; get next
        inc     hl
        or      a
        jr      z,m2393         ; if end of list, exit with Z reset
        cp      b
        jr      nz,m2389        ; loop back if no match
        ld      a,b             ; restore char
        ret                     ; exit with Z set
m2393   or      $ff             ; reset Z
        ld      a,b             ; restore character
        ret

; List of valid binary operators for numeric calculations

m2397   defm    "+-*/^=><"
        defb    $c7,$c8,$c9     ; <=,>=,<>
        defb    $c5,$c6         ; OR,AND
        defb    0

; Subroutine to check if a character is a valid function (Z set if so)

m23a5   cp      $a5
        jr      c,m23b7         ; move on if before RND
        cp      $c4
        jr      nc,m23b7        ; or after NOT
        cp      $ac
        jr      z,m23b7         ; or if AT
        cp      $ad
        jr      z,m23b7         ; or if TAB
        cp      a               ; set Z for valid functions
        ret
m23b7   cp      $a5             ; reset Z
        ret

; Subroutine to check if character is start of a value

m23ba   ld      b,a             ; save character
        or      $20             ; make lowercase
        cp      'a'
        jr      c,m23c7
        cp      'z'+1
        jr      nc,m23c7
        cp      a               ; set Z if character is a letter
        ret
m23c7   ld      a,b
        cp      '.'
        ret     z               ; exit with Z set if "."
        call    m23e4           ; check for digits
        jr      nz,m23e1        ; if not, junk character & exit
m23d0   rst     $20             ; get next char
        call    m23e4
        jr      z,m23d0         ; loop back while still digits
        cp      '.'
        ret     z               ; exit with Z set if "."
        cp      'E'
        ret     z               ; or "E"
        cp      'e'
        ret     z               ; or "e"
        jr      m2385           ; else check for a binary operator
m23e1   or      $ff             ; junk character & reset Z
        ret

; Subroutine to check if A is a digit (Z set if so)

m23e4   cp      '0'
        jr      c,m23ee
        cp      '9'+1
        jr      nc,m23ee
        cp      a               ; set Z if char is a digit
        ret
m23ee   cp      '0'             ; reset Z otherwise
        ret

; The PLAY command

m23f1   ld      b,$00           ; string counter
        rst     $18             ; get char
m23f4   push    bc
        ROM3    o1C8C           ; get a string
        pop     bc
        inc     b               ; increment counter
        cp      ','
        jr      nz,m2401        ; move on if no more strings
        rst     $20             ; get next char
        jr      m23f4           ; loop back
m2401   ld      a,b
        cp      $09
        jr      c,m240a         ; up to 9 strings allowed
        call    m2ada
        defb    $2b             ; error "Too many tied notes"
m240a   call    m10b1           ; check for end-of-statement
        jp      m1571           ; go to execute command

; Subroutine called from ROM 0 to initialise DOS & check the status
; of drives on the system, displaying information to the user.

      IF garry
        defs    22
m2410   call    m2b89           ; page in DOS workspace (page 7)
        call    m32b6
        ld      hl,FLAGS3
        bit     7,(hl)
        jr      nz,m2427        ; move on if DOS already initialised
        set     7,(hl)          ; signal "DOS initialised"
        ROM2    IDE_INTERFACE
        ld      ($df9d), a
m2427   ROM2    DOS_INITIALISE
        call    m32ee
        ld      hl, m36b0
        call    m24b5
m242a   ld      a,$ff
        ld      hl, $0002       ; standard ALERT routine in ROM 2
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_MESSAGE
        call    m32ee           ; restore TSTACK
        ld      hl,FLAGS3
        res     4,(hl)          ; signal "disk interface not present"
      ELSE
m2410   call    m2b89           ; page in DOS workspace (page 7)
        ld      hl,FLAGS3
        bit     7,(hl)
        jr      nz,m242a        ; move on if DOS already initialised
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_INITIALISE
        call    m32ee           ; restore TSTACK
        ld      hl,FLAGS3
        set     7,(hl)          ; signal "DOS initialised"
m242a   ld      a,$ff
        ld      hl,$244e        ; standard ALERT routine in ROM 2
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_MESSAGE
        call    m32ee           ; restore TSTACK
        call    m2b64           ; page in page 0
        ld      hl,m24be
        call    m24b5           ; display "Drive"
        ld      hl,FLAGS3
        res     4,(hl)          ; signal "disk interface not present"
        call    m2b89           ; page in DOS workspace
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_INTERFACE
        call    m32ee           ; restore TSTACK
      IF garry
        ld      a, $30
        jr      nc, m2488
      ELSE
        call    m2b64           ; page in page 0
        jr      c,m2463         ; move on if interface present
        ld      hl,m24c4
        call    m24b5           ; display " M:" if no interface
        jr      m24ae           ; move on
m2463   ld      a,'A'           ; set "A:" as default load/save drive
        ld      (LODDRV),a
        ld      (SAVDRV),a
      ENDIF
        ld      hl,FLAGS3
        set     4,(hl)          ; signal "disk interface present"
        res     5,(hl)          ; signal "no drive B:"
      IF garry=0
        call    m2b89           ; page in DOS workspace
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_ASK_1
        call    m32ee           ; restore TSTACK
      IF garry=0
        call    m2b64           ; page in page 0
      ENDIF
        jr      c,m24a3         ; move on if drive B exists
        ld      c,$00
      IF garry
        ld      hl, 5
      ELSE
        ld      hl, n2455
        call    m2b89           ; page in DOS workspace
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_MAP_B       ; map drive B: to unit 0
        call    m32ee           ; restore TSTACK
      IF garry
        ld      a, $31
        jr      m2488
      ELSE
        call    m2b64           ; page in page 0
        ld      hl,m24c8
        call    m24b5           ; display " A:"
        jr      m24ae           ; move on
      ENDIF
m24a3   ld      hl,FLAGS3
        set     5,(hl)          ; signal "drive B: present"
      IF garry
        ld      a, $32
m2488   rst     $10
        ld      hl, m36b1
        call    m24b5
        ld      a, ($df9d)
        add     a, $30
        rst     $10
        ld      hl, m36b2
        call    m24b5
        ld      hl, $e2a0
        ld      c, $41
        ld      b, $10
m24a2   ld      a, (hl)
        inc     hl
        or      (hl)
        inc     hl
        jr      z, m24b9
        ld      a, (LODDRV)
        cp      c
        ld      e, 0
        jr      nz, m24b2
        ld      e, 1
m24b2   ld      a, $13
        rst     $10
        ld      a, e
        rst     $10
        ld      a, c
        rst     $10
m24b9   inc     c
        djnz    m24a2
        call    m2b64           ; page in normal memory
        ret
      ELSE
        ld      hl,m24d4
        call    m24b5           ; display "s A: and B:"
m24ae   ld      hl,m24e4
        call    m24b5           ; display " available."
        ret
      ENDIF

; Subroutine to print a null-terminated string

m24b5   ld      a,(hl)          ; get next char
        or      a
        ret     z               ; exit if null
      IF garry
        rst     $10
      ELSE
        ROM3    o0010           ; print it
      ENDIF
        inc     hl
        jr      m24b5           ; back for more

; Drives present messages
    IF garry
m24c7   cp      $b5
        jr      nz, m24cc
        rst     $20
m24cc   call    m10b1
        jp      m0a96
        defs    30
    ELSE
      IF spanish
m24be   defm    "Unidades disponibles:  ", 0
m24c4   defm    "M", 0
m24c8   defm    "A y M", 0
m24d4   defm    "A, B y M", 0
m24e4   defm    ".", 0
      ELSE
m24be   defm    "Drive", 0
m24c4   defm    " M:", 0
m24c8   defm    "s A: and M:", 0
m24d4   defm    "s A:, B: and M:", 0
m24e4   defm    " available.", 0
      ENDIF
    ENDIF
; Subroutine used to execute a command line or evaluate an expression

m24f0   ld      (iy+$00),$ff    ; clear error
        ld      (iy+$31),$02    ; set lower screen to 2 lines
        ld      hl,ONERR
        push    hl
        ld      (ERR_SP),sp     ; set up error stack
        ld      hl,m2560
        ld      (SYNRET),hl     ; set error return address
        call    m2368           ; set interpretation address & get first char
        call    m23a5           ; test for function
m250c   jp      z,m22d0         ; if so, evaluate the expression
        cp      '('
        jp      z,m22d0         ; or if bracketed expression
        cp      '-'
        jp      z,m22d0         ; or a unary operator (+ or -)
        cp      '+'
        jp      z,m22d0
        call    m23ba           ; check for start of a value (var or number)
        jp      z,m22d0         ; if so, evaluate the expression
        call    m2b89           ; page in DOS workspace
        ld      a,(process)     ; get current process
        call    m2b64           ; page in normal memory
        cp      $04             ; is it the calculator?
m252f   jp      nz,m0fbf        ; if not, execute it
        call    m2371           ; is line a single LET statement?
        jp      z,m0fbf         ; if so, execute it
        pop     hl              ; unstack ONERR address
        ret                     ; exit

m253a
      IF v41
        ei
      ENDIF
; The +3-specific error-handling routine
; ONERR jumps here

        call    m2b89           ; page in DOS workspace
        ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file 0
        call    m32ee           ; restore TSTACK
        jr      c,m2559         ; move on if no error
        ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_ABANDON     ; abandon file 0
        call    m32ee           ; restore TSTACK
m2559   call    m2b64           ; page back normal memory
        ld      hl,(SYNRET)
        jp      (hl)            ; return to syntax return address

; This is one of the syntax return addresses, used when entering a line
; as a direct command

m2560   bit     7,(iy+$00)
        jr      nz,m2567
        ret                     ; exit if error in line
m2567   ld      hl,(E_LINE)
        ld      (CH_ADD),hl     ; reset CH_ADD to editing line
        ROM3    o19FB           ; get line number of editing line
        ld      a,b
        or      c
        jp      nz,m268e        ; move on if it exists, to add to program
        rst     $18             ; get character
        cp      $0d
        ret     z               ; exit if empty line
        call    m22c7           ; clear display if necessary
        bit     6,(iy+$02)
        jr      nz,m2585
        ROM3    o0D6E           ; clear lower screen if necessary
m2585   res     6,(iy+$02)      ; signal "lower screen clear"
        call    m2b89           ; page in DOS workspace
        ld      hl,ed_flags
        bit     6,(hl)          ; ???
        jr      nz,m259e
        inc     hl
        ld      a,(hl)          ; ???
        cp      $00
        jr      nz,m259e
        call    m3e80
        defw    l1a8e
m259e   call    m2b64           ; page in normal memory
        ld      hl,TV_FLAG
        res     3,(hl)          ; signal "mode hasn't changed"
        ld      a,$19
        sub     (iy+$4f)
        ld      (SCR_CT),a      ; set appropriate scroll count
        set     7,(iy+$01)      ; signal "execution"
        ld      (iy+$0a),$01    ; jump to statement 1
        ld      hl, n3e00
        push    hl              ; stack GOSUB stack end marker
        ld      hl,ONERR
        push    hl              ; stack error address
        ld      (ERR_SP),sp     ; reset ERR_SP
        ld      hl,m25cb
        ld      (SYNRET),hl     ; store execution error handler address
        jp      m1048           ; execute immediate command

; This is one of the syntax return addresses, used during execution

m25cb   ld      sp,(RAMTOP)
        inc     sp              ; clear return stack
        ld      hl,TSTACK
        ld      (OLDSP),hl      ; set OLDSP to temporary stack area
      IF garry
        nop
      ELSE
        halt                    ; wait for an interrupt
      ENDIF
        res     5,(iy+$01)      ; signal no key available
        ld      a,(ERR_NR)
        inc     a               ; A=error code
m25df   push    af              ; save error code
        ld      hl,$0000
        ld      (iy+$37),h      ; clear FLAGX
        ld      (iy+$26),h      ; clear high byte of X_PTR
        ld      (DEFADD),hl     ; clear DEFADD
        ld      hl,$0001
        ld      (STRMS+6),hl    ; reset stream 0
        ROM3    o16B0           ; clear editing areas and calculator etc
        res     5,(iy+$37)      ; ???
        ROM3    o0D6E           ; clear lower screen
        set     5,(iy+$02)      ; signal "clear lower screen after keystroke"
        pop     af              ; get back error code
        ld      b,a             ; save it
        cp      $0a
        jr      c,m2614         ; move on if 0-9
        cp      $1d
        jr      c,m2612         ; move on if A-R
        cp      $2c
        jr      nc,m261a        ; move on if +3DOS error
        add     a,$14           ; else convert for errors a-o
        jr      m2614
m2612   add     a,$07           ; convert to code to letter
m2614   ROM3    o15EF           ; output error character (0-9 or A-R or a-o)
        ld      a,' '
        rst     $10             ; output space
m261a   ld      a,b             ; get back error code
        cp      $1d
        jr      c,m2631         ; move on if old 48K Spectrum error
        sub     $1d
        ld      b,$00
        ld      c,a
        ld      hl,m2705
        add     hl,bc
        add     hl,bc           ; HL points to address of error message
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=error message address
        call    m2ace           ; output it
        jr      m2637
m2631   ld      de,$1391        ; base address of ROM 3 message table
        ROM3    o0C0A           ; output 48K Spectrum error message
m2637   xor     a
        ld      de,$1536
        ROM3    o0C0A           ; output "comma" message
        ld      bc,(PPC)        ; get error line number
        ROM3    o1A1B           ; output it
        ld      a,':'
        rst     $10             ; output ":"
        ld      c,(iy+$0d)      ; get error statement number
        ld      b,$00
        ROM3    o1A1B           ; output it
        ROM3    o1097           ; clear editing area/workspace
        ld      a,(ERR_NR)
        inc     a
        jr      z,m2674         ; move on if error "OK"
        cp      $09
        jr      z,m2661         ; move on if error "9 - STOP statement"
        cp      $15
        jr      nz,m2664        ; move on if not "L - BREAK into program"
m2661   inc     (iy+$0d)        ; increment statement for CONTINUE
m2664   ld      bc,$0003
        ld      de,OSPCC
        ld      hl,NSPPC
        bit     7,(hl)
        jr      z,m2672
        add     hl,bc
m2672   lddr                    ; copy line/statement to CONTINUE at
m2674   ld      (iy+$0a),$ff    ; clear NSPPC
        res     3,(iy+$01)      ; signal "K" mode
        ld      hl,FLAGS3
        res     0,(hl)          ; ???
        call    m3e80
        defw    l067b
m2686   ld      a,$10           ; error G - no room for line
        ld      bc,$0000
        jp      m25df           ; loop back

; Routine to ???

m268e   ld      (E_PPC),bc      ; ???
        call    m2b89           ; page in DOS workspace
        ld      a,b
        or      c
        jr      z,m26a1
        ld      (E_PPC),bc      ; ???
        ld      ($ec08),bc
m26a1   call    m2b64           ; page in normal memory
        ld      hl,(CH_ADD)
        ex      de,hl
        ld      hl,m2686        ; error return address (no room)
        push    hl
        ld      hl,(WORKSP)
        scf
        sbc     hl,de
        push    hl              ; HL=line length
        ld      h,b
        ld      l,c
        ROM3    o196E           ; get address of line in program
        jr      nz,m26c0        ; if line not in program yet, move on
        ROM3    o19B8           ; get address of next line
        ROM3    o19E8           ; delete the existing line
m26c0   pop     bc              ; restore line length
        ld      a,c
        dec     a
        or      b
        jr      nz,m26db        ; move on if no line body (just deleting)
        call    m2b89           ; page in DOS workspace
        push    hl
        ld      hl,(E_PPC)
        call    m3e80
        defw    l1418
        ld      (E_PPC),hl
        pop     hl
        call    m2b64           ; page in normal memory
        jr      m2703
m26db   push    bc
        inc     bc
        inc     bc
        inc     bc
        inc     bc
        dec     hl
        ld      de,(PROG)
        push    de
m26e6   ROM3    o1655           ; make space for ???
        pop     hl
m26ea   ld      (PROG),hl
        pop     bc
        push    bc
        inc     de
        ld      hl,(WORKSP)
        dec     hl
        dec     hl
        lddr
        ld      hl,(E_PPC)
        ex      de,hl
        pop     bc
        ld      (hl),b
        dec     hl
        ld      (hl),c
        dec     hl
        ld      (hl),e
        dec     hl
        ld      (hl),d
m2703   pop     af              ; ???
        ret

; Table of error message addresses

m2705   defw    m276d
        defw    m2778
        defw    m2787
        defw    m2791
        defw    m27a2
        defw    m27b5
        defw    m27c1
        defw    m27c1
        defw    m27d4
        defw    m27e2
        defw    m27f3
        defw    m2804
        defw    m2812
        defw    m2823
        defw    m282f
        defw    m2842
        defw    m2842
        defw    m284e
        defw    m285c
        defw    m286b
        defw    m2879
        defw    m288c
        defw    m289d
        defw    m28a6
        defw    m28b4
        defw    m28c5
        defw    m28d2
        defw    m28e5
        defw    m28fd
        defw    m290b
        defw    m2913
        defw    m291f
        defw    m2933
        defw    m293f
        defw    m294e
        defw    m2965
        defw    m296e
        defw    m297c
        defw    m2983
        defw    m2997
        defw    m29af
        defw    m29c1
        defw    m29d6
        defw    m29e6
        defw    m29f7
        defw    m2a0f
        defw    m2a29
        defw    m2a42
        defw    m2a59
        defw    m2a74
        defw    m2a8a
        defw    m2a97
    IF garry
        defw    m36fb
        defw    m370c
        defw    m3724
        defw    m3733
        defw    m3741
        defw    m3759
        defw    m376d
        defw    m3781
        defw    m378d
        defw    m379e
    ELSE
      IF v41 || spanish
        defw    m2aa8
        defw    m2ac1
      ENDIF
    ENDIF

; The +3 BASIC and +3DOS error messages
    IF spanish
m276d   defm    "Error en MERG", 'E'+$80
m2778   defm    "FICHERO INCORRECT", 'O'+$80
m2787   defm    "Error en COD", 'E'+$80
m2791   defm    "EXCESO DE PARENTESI", 'S'+$80
m27a2   defm    "YA EXISTE EL FICHER", 'O'+$80
m27b5   defm    "NOMBRE NO VALID", 'O'+$80
m27c1   defm    "NO EXISTE ESE FICHER", 'O'+$80
m27d4   defm    "DIPOSITIVO NO VALID", 'O'+$80
      IF garry
m27e2   defm    "VELOCIDAD NO VALID", 'O'+$80   ;errata, velocidad es femenino
m27f3   defm    "NOTA NO VALID", 'O'+$80        ;errata, nota es femenino
m2804   defm    "NUMERO MUY GRAND", 'E'+$80
m2812   defm    "NOTA "
m2823   defm    "FUERA DE MARGE", 'N'+$80
      ELSE
m27e2   defm    "VELOCIDAD NO VALID", 'A'+$80   ;errata, velocidad es femenino
m27f3   defm    "NOTA NO VALID", 'A'+$80        ;errata, nota es femenino
m2804   defm    "NUMERO MUY GRAND", 'E'+$80
m2812   defm    "NOTA FUERA DE MARGE", 'N'+$80
m2823   defm    "FUERA DE MARGE", 'N'+$80
      ENDIF
m282f   defm    "DEMASIADAS NOTA", 'S'+$80
m2842   defm    "NOMBRE INCORRECT", 'O'+$80
m284e   defm    "PARAMETRO INCORRECT", 'O'+$80
m285c   defm    "UNIDAD NO ENCONTRAD", 'A'+$80
m286b   defm    "FICHERO NO ENCONTRAD", 'O'+$80
m2879   defm    "YA EXISTE EL FICHER", 'O'+$80
m288c   defm    "FIN DE FICHER", 'O'+$80
m289d   defm    "DISCO LLEN", 'O'+$80
m28a6   defm    "DIRECTORIO LLEN", 'O'+$80
m28b4   defm    "FICHERO SOLO LECTUR", 'A'+$80
m28c5   defm    "FICHERO NO ABIERT", 'O'+$80
m28d2   defm    "FICHERO YA EN US", 'O'+$80
m28e5   defm    "SINTAXIS INCORRECT", 'A'+$80
m28fd   defm    "FALTA SECCIO", 'N'+$80
m290b   defm    "FALTA CACH", 'E'+$80
m2913   defm    "FICH. DEMASIADO GRAND", 'E'+$80
m291f   defm    "DISCO NO DE ARRANQU", 'E'+$80
m2933   defm    "UNIDAD YA EN US", 'O'+$80
m293f   defm    "UNIDAD NO PREPARAD", 'A'+$80
m294e   defm    "DISCO PROTEGID", 'O'+$80
m2965   defm    "FALLO DE BUSQUED", 'A'+$80
      IF garry=0
m296e   defm    "ERROR DE DATO", 'S'+$80
m297c   defm    "SIN DATO", 'S'+$80
      ENDIF
m2983   defm    "SIN MARCA DIRECCIONE", 'S'+$80
m2997   defm    "FORMATO NO RECONOCID", 'O'+$80
m29af   defm    "ERROR DESCONOCID", 'O'+$80
m29c1   defm    "DISCO CAMBIAD", 'O'+$80
m29d6   defm    "SOPORTE NO ADECUAD", 'O'+$80
m29e6   defm    "ATRIBUTO NO VALID", 'O'+$80
m29f7   defm    "COPIA DE/HACIA CINT", 'A'+$80
m2a0f   defm    "DESTINO POLIVALENT", 'E'+$80
m2a29   defm    "DESTINO NO ES UNIDA", 'D'+$80
m2a42   defm    "UNIDAD B AUSENT", 'E'+$80
m2a59   defm    "+2A NO ADMITE FORMA", 'T'+$80
m2a74   defm    "LA UNIDAD NO ES A NI ", 'B'+$80
m2a8a   defm    "UNIDAD INCORRECT", 'A'+$80
m2a97   defm    "ERROR DE LONGITU", 'D'+$80
    ELSE
m276d   defm    "MERGE erro", 'r'+$80
m2778   defm    "Wrong file typ", 'e'+$80
m2787   defm    "CODE erro", 'r'+$80
m2791   defm    "Too many bracket", 's'+$80
m27a2   defm    "File already exist", 's'+$80
m27b5   defm    "Invalid nam", 'e'+$80
m27c1   defm    "File does not exis", 't'+$80
m27d4   defm    "Invalid devic", 'e'+$80
m27e2   defm    "Invalid baud rat", 'e'+$80
m27f3   defm    "Invalid note nam", 'e'+$80
m2804   defm    "Number too bi", 'g'+$80
m2812   defm    "Note out of rang", 'e'+$80
m2823   defm    "Out of rang", 'e'+$80
m282f   defm    "Too many tied note", 's'+$80
m2842   defm    "Bad filenam", 'e'+$80
m284e   defm    "Bad parameter", 's'+$80
m285c   defm    "Drive not foun", 'd'+$80
m286b   defm    "File not foun", 'd'+$80
m2879   defm    "File already exist", 's'+$80
m288c   defm    "End of file foun", 'd'+$80
m289d   defm    "Disk ful", 'l'+$80
m28a6   defm    "Directory ful", 'l'+$80
m28b4   defm    "File is read onl", 'y'+$80
m28c5   defm    "File not ope", 'n'+$80
m28d2   defm    "File already in us", 'e'+$80
m28e5   defm    "No rename between drive", 's'+$80
m28fd   defm    "Missing exten", 't'+$80
m290b   defm    "Uncache", 'd'+$80
m2913   defm    "File too bi", 'g'+$80
m291f   defm    "Disk is not bootabl", 'e'+$80
m2933   defm    "Drive in us", 'e'+$80
m293f   defm    "Drive not read", 'y'+$80
m294e   defm    "Disk is write protecte", 'd'+$80
m2965   defm    "Seek fai", 'l'+$80
m296e   defm    "CRC data erro", 'r'+$80
m297c   defm    "No dat", 'a'+$80
m2983   defm    "Missing address mar", 'k'+$80
m2997   defm    "Unrecognised disk forma", 't'+$80
m29af   defm    "Unknown disk erro", 'r'+$80
m29c1   defm    "Disk has been change", 'd'+$80
m29d6   defm    "Unsuitable medi", 'a'+$80
m29e6   defm    "Invalid attribut", 'e'+$80
m29f7   defm    "Cannot copy to/from tap", 'e'+$80
m2a0f   defm    "Destination cannot be wil", 'd'+$80
m2a29   defm    "Destination must be driv", 'e'+$80
m2a42   defm    "Drive B: is not presen", 't'+$80
m2a59   defm    "+2A does not support forma", 't'+$80
m2a74   defm    "Drive must be A: or B", ':'+$80
m2a8a   defm    "Invalid driv", 'e'+$80
m2a97   defm    "Code length erro", 'r'+$80
    ENDIF
      IF garry=0
m2aa8   defm    "You should never see thi", 's'+$80
m2ac1   defm    "Hello there !"
      ENDIF

; Subroutine to output an error message (terminated by
; a byte with bit 7 set)
; Enter with DE=message address

m2ace   ld      a,(de)          ; get next char
        and     $7f             ; mask bit 7
m2ad1   push    de
        rst     $10             ; output
        pop     de
        ld      a,(de)
m2ad5   inc     de
        add     a,a             ; check bit 7
        jr      nc,m2ace        ; loop back if not set
        ret

; The Error Handling routine
; Enter here with inline error code-1

m2ada   pop     hl              ; get address of error code
        ld      sp,(ERR_SP)     ; reset SP
        ld      a,(hl)
        ld      (RAMERR),a      ; store error number-1
        inc     a               ; get error code
        cp      $1e
        jr      nc,m2aeb        ; move on if a +3-specific error
m2ae8   ROM3    RAMRST          ; else call ROM 3 error handler
m2aeb   dec     a
        ld      (iy+$00),a      ; save code in ERR_NR
m2aef   ld      hl,(CH_ADD)     ; get address at which error occurred
        ld      (X_PTR),hl      ; save it
        ROM3    o16C5           ; clear calculator stack
        ret                     ; exit to error address

; Subroutine to test the BREAK key
; Terminates with error L - BREAK into program if so

m2af9   ld      a,$7f
        in      a,($fe)
        rra
        ret     c               ; exit if SPACE not pressed
        ld      a,$fe
        in      a,($fe)
        rra
        ret     c               ; or if CAPS not pressed
        call    m2ada
        defb    $14             ; error L

; Subroutine to execute routine at HL, returning to m3a1b in order to
; return control to ROM 3
; It is provided to allow serial input into 48K BASIC, but looks buggy
      IF garry
m2b09   rst     $18
        cp      $23
        jr      z, m2b14
        call    m10b1
        jp      m1266
m2b14   call    m2b35
        ld      b, 0
m2b19   ROM2    IDE_STREAM_PTR
        push    de
        push    hl
        pop     bc
        ROM3    o2D2B
        pop     bc
        ROM3    o2D2B
        ld      de, m2b56
        ld      bc, 10
        call    m14f0
        ROM3    o2AFF
        ret
m2b35   rst     $20
        ROM3    o1C82
        rst     $18
        cp      ','
        jp      nz, m22c3
        rst     $20
        ROM3    o1C1F
        bit     6, (iy+$01)
        jp      z, m22c3
        pop     hl
        call    m10b1
        push    hl
        ROM3    o1E94
        ROM3    o1601
        ret
m2b56   defb    $ef, $34, $40, $41, $00, $00, $04, $0f, $38, $c9
      ELSE
m2b09   ei
        ex      af,af'
        ld      de,m3a1b
        push    de              ; stack return address to paging routine
        res     3,(iy+$02)      ; set "mode unchanged"
        push    hl
        ld      hl,(ERR_SP)
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=current error return address
        and     a
        ld      hl,$107f        ; test against ROM 3 editing error address
        sbc     hl,de
m2b20   jr      nz,m2b5a        ; move on if not
m2b22   pop     hl
        ld      sp,(ERR_SP)
        pop     de              ; drop two addresses from error return stack
        pop     de
        ld      (ERR_SP),de
m2b2d   push    hl              ; save routine address
        ld      de,m2b33        ; address to return to here
        push    de
m2b32   jp      (hl)            ; execute routine
m2b33   jr      c,m2b3e         ; if no error, move on
        jr      z,m2b3b         ; if no character, move on
m2b37   call    m2ada
        defb    7               ; error 8 ???
m2b3b   pop     hl
m2b3c   jr      m2b2d           ; call the routine again
m2b3e   cp      $0d
        jr      z,m2b50         ; if character was CR, move on
        ld      hl,(RETADDR)
        push    hl
        ROM3    o0F85           ; else add a character to current input line
        pop     hl
        ld      (RETADDR),hl
        pop     hl
        jr      m2b2d           ; loop back to get another character
m2b50   pop     hl              ; discard routine address
        ld      a,(BANKM)
        or      $10             ; select ROM 3
        push    af
        jp      m3a1b           ; go to exit
m2b5a   pop     hl
        ld      de,m2b60        ; address to return to here
        push    de
        jp      (hl)            ; execute routine
m2b60   ret     c               ; exit if no errors
        ret     z
        jr      m2b37           ; else go to act on them
      ENDIF

; Subroutine to page in normal memory (page 0) and swap SP with OLDSP

m2b64   ex      af,af'          ; save AF
        ld      a,$10
        di
        call    m2b7e           ; page in page 0
        pop     af              ; AF=return address
        ld      (TARGET),hl     ; save HL
        ld      hl,(OLDSP)
        ld      (OLDSP),sp
        ld      sp,hl           ; SP now swapped with OLDSP
        ei
        ld      hl,(TARGET)     ; restore HL
        push    af              ; restack return address
        ex      af,af'          ; restore AF
        ret

; Subroutine to page in a RAM/ROM/screen combination (in A)

m2b7e   push    bc
        ld      bc,$7ffd
        out     (c),a           ; page it in
        ld      (BANKM),a
        pop     bc
        ret

; Subroutine to page in DOS workspace (page 7) and swap SP with OLDSP

m2b89   ex      af,af'          ; save AF
        di
        pop     af              ; AF=return address
        ld      (TARGET),hl     ; save HL
        ld      hl,(OLDSP)
        ld      (OLDSP),sp
        ld      sp,hl           ; SP swapped with OLDSP
        ld      hl,(TARGET)     ; restore HL
        push    af              ; push back return address
        ld      a,$17
        call    m2b7e           ; page in page 7
        ei
        ex      af,af'          ; restore AF
        ret

; Subroutine to copy a file
; Enter with A=destination flag
; A=$00 - file
;  =$e0 - printer
;  =$aa - screen
; Z flag set if A=$00
; C flag reset if copying TO SPECTRUM FORMAT

m2ba3   call    m2b89           ; page in DOS workspace
        ld      (dst_dev),a     ; save destination flag
        push    af
        jr      z,m2bb2         ; move on if copying to a file
        cp      $e0             ; copy to LPRINT?
        ld      a,$03           ; use stream 3
        jr      z,m2bb4
m2bb2   ld      a,$02           ; use stream 2
m2bb4   call    m2b64           ; page in normal memory
        ROM3    o1601           ; open channel to stream
        call    m2b89           ; page in DOS workspace
        pop     af              ; restore destination flag
        jr      z,m2c1e         ; move on if copying to another file
        ld      hl,tmp_fspec    ; stored filename address
        ld      bc,$0001        ; use file number 0,exclusive-read
        ld      de,$0001        ; open action - error if doesn't exist
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error opening
m2bd7   ld      b,$00           ; file 0
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_BYTE_READ   ; read a byte
        call    m32ee           ; restore TSTACK
        jr      c,m2bed         ; move on if no error
        cp      $19
        jp      nz,m3219        ; move on if not end-of-file error
        jr      m2c0a           ; end of file, so move on to close file
m2bed   ld      a,(dst_dev)     ; check destination flag
        cp      $aa
        ld      a,c             ; A=byte from file
        jr      nz,m2bff        ; move on unless copying to screen
        cp      $0d
        jr      z,m2bff         ; okay to output CRs
        cp      $20
        jr      nc,m2bff
        ld      a,$20           ; but replace other control chars with spaces
m2bff   call    m2b64           ; page in normal memory
        ROM3    o0010           ; output byte
m2c05   call    m2b89           ; page in DOS workspace
        jr      m2bd7           ; back for more
m2c0a   ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error closing
        call    m2b64           ; page in normal memory
        ret                     ; done

; This part of the copy routine copies a file to another file

m2c1e   push    af              ; save destination flag
        ld      hl,tmp_fspec
        ld      (dst_add),hl    ; store address of destination filespec
        ld      de,dst_file
        call    m3109           ; copy filespec, error if too long
        push    hl              ; save address of source filespec
        ld      a,$ff
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_DRIVE   ; set default drive
        call    m32ee           ; restore TSTACK
        ld      (dst_drv),a     ; use default drive for destination
        ld      (src_drv),a     ; use default drive for source
        ld      hl,dst_file
        call    m30f0           ; is destination drive specified?
        jr      nz,m2c4d        ; move on if not
        ld      de,dst_drv
        call    m30e3           ; place drive letter at dst_drv
m2c4d   pop     hl              ; restore address of source filespec
        pop     af              ; restore destination flag
        jp      nc,m3123        ; move on if copying TO SPECTRUM FORMAT
        ld      (src_add),hl    ; save address of source filespec
        ld      de,src_file
        call    m3109           ; copy filespec, error if too long
        ld      hl,src_file
        call    m30f0           ; is source drive specified?
        jr      nz,m2c69        ; move on if not
        ld      de,src_drv
        call    m30e3           ; place drive letter at src_drv
m2c69   ld      (SCR_CT),a      ; zeroise scroll count
        ld      a,$0d
        rst     $10             ; output CR
        xor     a
        ld      (wild),a        ; clear "wild" flag
        ld      (copied),a      ; zero # files copied
        ld      (dst_dev),a     ; destination is a file
        ld      hl,dst_file
        call    m30b6           ; check if destination wild
        ld      a,(wild)
        or      a
        jr      z,m2c8c
        call    m2b64           ; if so, page in normal memory
        call    m2ada           ; and cause error "destination cannot be wild"
        defb    $49
m2c8c   ld      hl,m3283
        ld      de,tmp_file
        ld      bc,$000e
        ldir                    ; copy temporary filename
        ld      hl,src_file
        call    m30b6           ; check if source wild
        ld      a,(wild)
        or      a
        jr      nz,m2ca9        ; move on if so
        call    m2d58           ; copy a single file
        jp      m2d26           ; finish up
m2ca9   ld      hl,(dst_add)    ; get address of dest filespec
        call    m30f0           ; get past drive
        ld      a,$ff
        cp      (hl)
        jr      z,m2cbb         ; move on if just drive
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $4a             ; else error "destination must be drive"
m2cbb   ld      hl,wld_next
        xor     a
        ld      b,$0d
m2cc1   ld      (hl),a          ; zeroise directory entry 1
        inc     hl
        djnz    m2cc1
m2cc5   ld      hl,wld_next
        ld      de,cat_spec
        ld      bc,$000d
        ldir                    ; and zeroise directory entry 0
        ld      hl,(src_add)
        ld      bc,$0200        ; 1 entry required, include system files
        ld      de,cat_spec
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CATALOG     ; get next filename
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      hl,dst_dev
        ld      a,(hl)
        or      a
        jr      nz,m2cf7        ; move on if not copying first file
        inc     a
        ld      (hl),a          ; set "first file copied" flag
        ld      a,$17
        dec     b
        jp      z,m3219         ; cause error "File not found" if none
        inc     b
m2cf7   dec     b               ; B=0 if no more matches
        jr      z,m2d26         ; move to finish if done
        ld      hl,src_file
        call    m30f0           ; get past drive of source
        ex      de,hl
        ld      hl,wld_next     ; address of found entry
        ld      b,$08
        call    m30d9           ; copy filename part into source
        ld      hl,wld_next+8   ; get to extension of found entry
        ld      a,'.'
        ld      (de),a          ; insert "."
        inc     de
        ld      b,$03
        call    m30d9           ; copy extension part into source
        ld      a,$ff
        ld      (de),a          ; insert terminator
        ld      hl,dst_file
        call    m30f0           ; get past drive name in dest
        ld      (hl),$ff        ; insert terminator
        call    m2d58           ; copy a file
        jp      m2cc5           ; loop back for more

; Copy file routines - end part

m2d26   ld      hl,tmp_file
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_DELETE      ; delete temp file
        call    m32ee           ; restore TSTACK
        ld      a,(copied)
        dec     a               ; A=# files copied-1
        ld      hl,m3291        ; "1 file copied" message
        jr      z,m2d4c         ; move on if 1
        inc     a
        ld      l,a
        ld      h,$00           ; HL=# files copied
        ld      a,$0d
        rst     $10             ; output CR
        ld      e,' '
        call    m0800           ; output #
        ld      hl,m32a5        ; "files copied" message
m2d4c   call    m3268           ; output message
        ld      a,$17
        ld      (SCR_CT),a      ; set scroll count
        call    m2b64           ; page in normal memory
        ret                     ; done!

; Subroutine to copy a single file

m2d58   ld      hl,dst_file     ; dest filespec
        ld      de,src_file     ; source filespec
m2d5e   ld      a,(de)
        cp      (hl)            ; compare filespecs
        jr      nz,m2d72        ; move on if different
        ld      a,$ff
        cp      (hl)
        jr      nz,m2d6e
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $30             ; error if filespecs the same
m2d6e   inc     hl              ; increment pointers
        inc     de
        jr      m2d5e           ; loop back
m2d72   ld      hl,dst_file
        call    m30f0           ; move past drive specifier in dest filespec
        ld      a,(hl)
        cp      $ff
        jr      nz,m2d94        ; move on if a destination filename specified
        ld      hl,dst_file
        call    m30f0
        push    hl              ; store address after drive specifier
        ld      hl,src_file
        call    m30f0           ; get to filename of source
        pop     de
m2d8b   ld      a,(hl)
        ld      (de),a          ; copy filename to destination
        inc     a
        jr      z,m2d94         ; move on when done
        inc     de
        inc     hl
        jr      m2d8b           ; loop back
m2d94   xor     a
        ld      (copy_ram),a    ; signal "copy via M:"
        ld      a,'M'
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_FREE_SPACE  ; find free space on drive M:
        call    m32ee           ; restore TSTACK
      IF garry
        jp      nc,m2dc7
      ELSE
        jp      nc,m3219        ; move on if error
      ENDIF
        ld      a,h
        or      a
        jr      z,m2daf
        ld      hl,$003f        ; use max 63K on drive M:
m2daf   ld      a,l
        cp      $40
        jr      c,m2db7
        ld      hl,$003f        ; use max 63K on drive M:
m2db7   ld      h,l
        ld      l,$00
        add     hl,hl
        add     hl,hl
        ld      (free_m),hl     ; store free bytes on drive M:
        ld      de,$0800
        or      a
        sbc     hl,de
        jr      nc,m2dd1        ; move on if >=2K free
m2dc7   ld      a,$ff
        ld      (SCR_CT),a      ; set scroll count
        ld      a,$01
        ld      (copy_ram),a    ; signal "copy via RAM"
m2dd1   xor     a
        ld      (dst_open),a    ; signal no temporary file open
        ld      (eof),a         ; signal not EOF
        ld      hl,dst_file
        call    m30f0           ; get past drive of dest
        ld      a,(hl)
        cp      $ff
      IF garry
        jr      nz,m2e5d        ; if dest filename specified, jump on
      ELSE
        jp      nz,m2e5d        ; if dest filename specified, jump on
      ENDIF
        ld      hl,src_file
        call    m30f0           ; get past drive of source
        ld      a,(hl)
m2deb   cp      $ff
      IF garry
        jr      nz,m2e5d        ; if dest filename specified, jump on
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $30             ; error if filespecs the same
m2e5d   ld      hl,src_file     ; source name
        ld      a,$ff
        ld      (SCR_CT),a      ; set max scroll count
        push    hl
        push    hl
        call    m3268           ; display filespec
        pop     de
        ex      de,hl
        or      a
        sbc     hl,de
        ld      de,$0011
        add     hl,de
        ld      b,l             ; B=# spaces required
m2e74   push    bc
        ld      a,' '
        rst     $10             ; output a space
        pop     bc
        djnz    m2e74           ; loop back
        pop     hl
        ld      a,(dst_drv)     ; get dest drive letter
        cp      'M'
        jr      z,m2e95         ; move on if copying to M:
        ld      a,(copy_ram)
        or      a
        jr      nz,m2e95        ; or if >=2K free on M:
        ld      a,(src_drv)     ; get source drive letter
        cp      'M'
      ELSE
        jp      nz,m2e5d        ; if dest filename specified, jump on
        ld      a,(dst_drv)     ; check destination drive
        cp      'M'
        jp      z,m2e5d         ; move on if M: (will fail on attempted copy)
        ld      a,(src_drv)     ; check source drive
        cp      'M'
        jp      z,m2e5d         ; move on if M: (will fail on attempted copy)
        ld      a,'A'           ; by this stage, we must be copy A:<-->B:
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_XDPB    ; get XDPB for drive A:
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      c,0
        call    m32b6           ; save TSTACK in page 7
        ROM2    DD_LOGIN        ; login disk in drive A:
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
      IF bluerom
        call    compare         ;
      ELSE
        or      a
        ld      a,$06
      ENDIF
        jp      nz,m3219        ; cause error 6 if not a standard +3 disk
        ld      a,(src_drv)     ; get source drive letter
        ld      bc,$0001
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOSOPEN_DRIVE  ; open source drive as exclusive-read file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,(dst_drv)     ; get dest drive letter
        ld      bc,$0102
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOSOPEN_DRIVE  ; open dest drive as exclusive-write file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,$01
        ld      (dst_open),a    ; signal temporary file open
        ld      a,(copy_ram)
        or      a
        jp      z,m2f44         ; copy via M: if >=2K free on drive M:
        jp      m2ecd           ; else copy via RAM
m2e5d   ld      hl,src_file     ; source name
        ld      a,$ff
        ld      (SCR_CT),a      ; set max scroll count
        push    hl
        push    hl
        call    m3268           ; display filespec
        pop     de
        ex      de,hl
        or      a
        sbc     hl,de
        ld      de,$0011
        add     hl,de
        ld      b,l             ; B=# spaces required
m2e74   push    bc
        ld      a,' '
        rst     $10             ; output a space
        pop     bc
        djnz    m2e74           ; loop back
        pop     hl
        ld      a,(dst_drv)     ; get dest drive letter
        or      $20             ; make lowercase
        cp      'm'
        jr      z,m2e95         ; move on if copying to M:
        ld      a,(copy_ram)
        or      a
        jr      nz,m2e95        ; or if >=2K free on M:
        ld      a,(src_drv)     ; get source drive letter
        or      $20
        cp      'm'
      ENDIF
        jp      nz,m2f2d        ; if not copying from M:, move on
m2e95   ld      hl,src_file     ; source filename
        ld      bc,$0001        ; file 0,excl read
        ld      de,$0002        ; must be openable
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      hl,dst_file     ; dest filename
        push    hl
        call    m3268           ; display filename
        pop     hl
        ld      bc,$0102        ; file 1, exc write
        ld      de,$0204        ; create new file
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,$01
        ld      (dst_open),a    ; signal temporary file open

; Subroutine to copy everything from file 0 to file 1, via a 2K area
; in page 0 (bug: this should be page 7!)
      IF v41 || garry
m2ecd   ld      bc,$0007        ; file 0, page 0 (oops, should be page 7!)
      ELSE
m2ecd   ld      bc,$0000        ; file 0, page 0 (oops, should be page 7!)
      ENDIF
        ld      de,$0800        ; 2K to read
        ld      hl,tmp_buff     ; address to read
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_READ        ; read bytes
        call    m32ee           ; restore TSTACK
        jr      c,m2f08         ; move on if no error
        cp      $19
        jp      nz,m3219        ; if error not end-of-file, cause error
        ld      a,$01
        ld      (eof),a         ; signal end-of-file reached
m2eed   push    de              ; save # unread bytes
        ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file 0
        call    m32ee           ; restore TSTACK
        pop     de
        jp      nc,m3219        ; move on if error
        ld      hl,$0800
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=number of bytes read
        jr      m2f0b           ; move on
m2f08   ld      de,$0800        ; DE=2048 bytes read
m2f0b   ld      a,e
        or      d
        jr      z,m2f23         ; if no bytes read, move on
        ld      hl,tmp_buff
      IF v41 || garry
        ld      bc,$0107
      ELSE
        ld      bc,$0100
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_WRITE       ; write bytes to file 1 from page 0 (oops)
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
m2f23   ld      a,(eof)
        or      a
        jp      z,m2ecd         ; loop back if not end-of-file
        jp      m309e           ; close file 1 and exit

; Continuation of copy command, where M: is involved

m2f2d   ld      hl,src_file     ; source filename
        ld      bc,$0001        ; file 0, excl read
        ld      de,$0002        ; must be openable
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error

; Subroutine to copy everything from file 0 to file 1, via a temporary
; file in drive M:
; Each 2K is read via RAM in page 0 - this should be page 7 (oops!)

m2f44   ld      hl,tmp_file     ; temporary filename
        ld      bc,$0203        ; file 2, exclusive read-write mode
        ld      de,$0204        ; open & create actions
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open temporary file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      hl,$0000
        ld      (tmp_bytes),hl  ; zero # bytes copied to temp file
      IF v41 || garry
m2f61   ld      bc,$0007
      ELSE
m2f61   ld      bc,$0000
      ENDIF
        ld      de,$0800
        ld      hl,tmp_buff
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_READ        ; read 2K into RAM
        call    m32ee           ; restore TSTACK
        jr      c,m2f9c         ; move on if no error
        cp      $19
        jp      nz,m3219        ; cause error if it wasn't end-of-file
        ld      a,$01
        ld      (eof),a         ; signal end-of-file reached
        push    de              ; save # unread bytes
        ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file 0
        call    m32ee           ; restore TSTACK
        pop     de
        jp      nc,m3219        ; move on if error
        ld      hl,$0800
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=# bytes read
        jr      m2f9f
m2f9c   ld      de,$0800        ; DE=2048 bytes read
m2f9f   ld      a,e
        or      d
        jr      z,m2fb9         ; move on if no bytes read
        push    de
        ld      hl,tmp_buff
      IF v41 || garry
        ld      bc,$0207
      ELSE
        ld      bc,$0200
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_WRITE       ; write bytes to temporary file
        call    m32ee           ; restore TSTACK
        pop     de
        jp      nc,m3219        ; move on if error
m2fb9   ld      hl,(tmp_bytes)
        add     hl,de
        ld      (tmp_bytes),hl  ; update number of bytes copied to temp file
        ld      de,$0800
        add     hl,de
        ex      de,hl
        ld      hl,(free_m)
        ld      a,(eof)
        or      a
        jr      nz,m2fd2        ; move on if end-of-file reached
        sbc     hl,de
        jr      nc,m2f61        ; loop back if temp file can take 2K more
m2fd2   ld      a,(src_drv)
        and     $df             ; get source drive (capitalised)
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_FLUSH       ; flush for source drive
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      b,$02
        ld      hl,$0000
        ld      e,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_SET_POSITION ; get to start of temp file
        call    m32ee           ; restore TSTACK
        ld      a,(dst_open)
        or      a
        jr      nz,m301e        ; move on if dst_file contains spec of temp file
        ld      hl,dst_file
        push    hl
        call    m3268           ; else display filespec
        pop     hl
        ld      bc,$0102
        ld      de,$0204
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open file 1 in exclusive-write mode
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,$01
        ld      (dst_open),a    ; signal dest file is open
m301e   ld      hl,tmp_buff
        ld      de,$0800
      IF v41 || garry
        ld      bc,$0207
      ELSE
        ld      bc,$0200
      ENDIF
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_READ        ; read 2K from temp file
        call    m32ee           ; restore TSTACK
        ld      hl,$0800        ; HL=$0800 bytes read
        jr      c,m3042         ; move on if no error
        cp      $19
        jp      nz,m3219        ; cause non-EOF errors
        ld      hl,$0800
        or      a
        sbc     hl,de           ; HL=# bytes read
m3042   ex      de,hl
      IF v41 || garry
        ld      bc,$0107
      ELSE
        ld      bc,$0100
      ENDIF
        ld      hl,tmp_buff
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_WRITE       ; write bytes to file 1
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      hl,(tmp_bytes)
        ld      de,$0800
        or      a
        sbc     hl,de
        jr      c,m3069         ; move on if temp file empty
        ld      a,h
        or      l
        ld      (tmp_bytes),hl  ; update bytes left in temp file
        jr      nz,m301e        ; loop back to copy more
m3069   ld      b,$02
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close temp file
        call    m32ee           ; restore TSTACK
        ld      a,(dst_drv)
        and     $df             ; get dest drive (capitalised)
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_FLUSH       ; flush dest drive
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,(eof)
        or      a
        jp      z,m2f44         ; loop back if not EOF
        ld      hl,tmp_file
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_DELETE      ; delete temp file
        call    m32ee           ; restore TSTACK

; Enter here if copying via 2K area in RAM

m309e   ld      b,$01
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close file 1
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,$0d
        rst     $10             ; output CR
        ld      hl,copied
        inc     (hl)            ; increment # files copied
        ret

; Subroutine to check whether filespec at HL is wild
; Causes error if filespec longer than $11 (inc terminator)

m30b6   ld      b,$11
        ld      a,(hl)
        cp      '?'
        jr      nz,m30c4        ; move on if not ? wildcard
        push    af
        ld      a,$01
        ld      (wild),a        ; set wildcard flag
        pop     af
m30c4   cp      '*'
        jr      nz,m30cf        ; move on if not * wildcard
        push    af
        ld      a,$01
        ld      (wild),a        ; set wildcard flag
        pop     af
m30cf   inc     hl              ; increment pointer
        inc     a
        ret     z               ; exit if done
        djnz    m30b6           ; loop back
        ld      a,$14
        jp      m3219           ; cause bad filename error if too long

; Subroutine to copy up to B chars from HL to DE, stopping at first space

m30d9   ld      a,(hl)          ; get next char
        cp      ' '
        ret     z               ; exit if space
        ld      (de),a          ; copy char
        inc     hl              ; increment pointers
        inc     de
        djnz    m30d9           ; loop back
        ret

; Subroutine to get a drive letter from a filespec & place it
; in the address at DE. HL points past the colon of the filespec

m30e3   dec     hl
        dec     hl
        ld      a,(hl)          ; get character before colon
      IF garry
        and     $df             ; make lowercase
        cp      'A'
        ret     c               ; exit if < 'a'
        cp      '['
      ELSE
        or      $20             ; make lowercase
        cp      'a'
        ret     c               ; exit if < 'a'
        cp      '{'
      ENDIF
        ret     nc              ; or if > 'z'
        ld      (de),a          ; store drive letter
        ret

; Subroutine to check if filespec includes drive specification
; On entry, HL=address of filespec
; On exit, Z flag set if drive specified, and HL points to
; start of filename after colon.

m30f0   push    hl
        pop     de              ; copy address of filename to DE
        ld      a,(hl)          ; get first char
        inc     a
        jr      z,m3103         ; move to exit if end of filename
      IF garry
        ld      b,$04           ; check first 3 chars
      ELSE
        ld      b,$03           ; check first 3 chars
      ENDIF
m30f8   ld      a,(hl)
        cp      ':'             ; is char a ':' ?
        jr      z,m3107         ; move on if so
        inc     a
        jr      z,m3103         ; exit if end of filename
        inc     hl
        djnz    m30f8           ; back for more
m3103   or      $ff             ; reset Z flag - no drive specified
        ex      de,hl           ; HL=start of filename
        ret
m3107   inc     hl              ; HL=start of filename after drive spec
        ret                     ; exit with Z set

; Subroutine to copy a $ff-terminated filename from HL to DE
; If max length of $11 (inc terminator) exceeded, cause error

m3109   ld      b,$11           ; allow 17 characters in a filename
        ld      a,(hl)
        ld      (de),a          ; copy filename
        inc     hl              ; increment pointers
        inc     de
        inc     a               ; test for end of filename
        jr      z,m3119         ; exit if found
        djnz    m3109           ; loop back
        ld      a,$14
        jp      m3219           ; cause +3DOS error $14, "Bad filename"
m3119   ret


; Subroutine to clear screen and open channel to stream 2

m311a   ROM3    o0D6B           ; cls
        ld      a,$02
        ROM3    o1601           ; open channel to stream 2
        ret

; Routine to copy files to spectrum format

m3123   xor     a
        ld      (wild),a        ; no wildcard
        ld      (dst_open),a    ; dest not open file
        ld      hl,dst_file
        call    m30b6           ; is dest filespec wild?
        ld      a,(wild)
        or      a
        jr      z,m313d         ; move on if not
        call    m2b64           ; page in normal memory
        call    m2ada
        defb    $49             ; else error "destination cannot be wild"
m313d   ld      hl,dst_file
        ld      b,$12
m3142   ld      a,(hl)
        cp      '.'             ; has file got extension?
        inc     hl
        jr      z,m314b         ; move on if so
        inc     a
        jr      nz,m3142
m314b   dec     hl
        ex      de,hl
        ld      hl,m3214
        ld      bc,$0004        ; length 4 misses terminator (oops!)
        ldir                    ; copy ".HED" extension
        ld      hl,(dst_add)
        ld      bc,$0001        ; file 0, exclusive read
        ld      de,$0001
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open source file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      hl,dst_file     ; dest filename
        ld      bc,$0102        ; file 1, exclusive write
        ld      de,$0104
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_OPEN        ; open dest file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,$01
        ld      (dst_open),a    ; signal dest open
        ld      hl,$0000
        ld      (tmp_bytes),hl  ; signal 0 bytes copied
m318e   ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_BYTE_READ   ; read a byte
        call    m32ee           ; restore TSTACK
        jr      c,m31a4         ; move on if no error
        cp      $19
        jp      nz,m3219        ; cause non-EOF error
        jr      z,m31bd         ; move on
m31a4   ld      b,$01
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_BYTE_WRITE  ; write byte
        call    m32ee           ; restore TSTACK
        ld      hl,(tmp_bytes)
        inc     hl              ; update bytes copied
        ld      (tmp_bytes),hl
        jr      c,m318e         ; loop back if no error
        jp      m3219           ; cause error
m31bd   ld      b,$00
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close source file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        ld      a,(dst_drv)
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_FLUSH       ; flush dest drive
        call    m32ee           ; restore TSTACK
        ld      b,$01
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_REF_HEAD    ; point at header data for dest file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219
        ld      a,$03
        ld      (ix+$00),a      ; set CODE type
        ld      hl,(tmp_bytes)
        ld      (ix+$01),l
        ld      (ix+$02),h      ; set length
        xor     a
        ld      (ix+$03),a      ; set load address to zero
        ld      (ix+$04),a
        ld      b,$01
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; close dest file
        call    m32ee           ; restore TSTACK
        jp      nc,m3219        ; move on if error
        call    m2b64           ; page in normal memory
        ret                     ; done

m3214   defm    ".HED", $ff

; Routine to close files 0-2, delete temporary files and
; generate the +3DOS error held in A

m3219   push    af              ; save +3DOS error code
        ld      b,$03           ; three files
m321c   push    bc              ; stack counter
        dec     b               ; decrement counter
        push    bc              ; stack file number
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_CLOSE       ; try to close file B
        call    m32ee           ; restore TSTACK
        pop     bc              ; restore file number
        jr      c,m3238         ; move on if closed okay
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_ABANDON     ; else abandon it
        call    m32ee           ; restore TSTACK
m3238   pop     bc
        djnz    m321c           ; back for other files
        ld      a,$0d
        rst     $10             ; new line on screen
        ld      a,(dst_open)
        or      a
        jr      z,m3252         ; move on if no temporary file created
        ld      hl,dst_file     ; HL=address of temporary filename
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_DELETE      ; delete temporary file
        call    m32ee           ; restore TSTACK
m3252   ld      hl,tmp_file
        call    m32b6           ; save TSTACK in page 7
        ROM2    DOS_DELETE      ; delete other temporary file
        call    m32ee           ; restore TSTACK
        pop     af              ; restore +3DOS error code
        call    m2b64           ; page in normal memory
      IF v41
        ld      a,$02
        ROM3    o1601
      ENDIF
        call    m0e9a           ; cause +3DOS error
        defb    $ff

; Subroutine to display filename/message at HL

m3268   ld      a,(hl)          ; get next char
        inc     hl
        or      a
        ret     z               ; exit if null
        cp      $ff
        ret     z               ; or $ff
        and     $7f
      IF garry
        cp      ' '
        jr      c, m3268
      ENDIF
        rst     $10             ; display character
        jr      m3268           ; loop back


; Subroutine to get a key (apparently unused)

m3274   ld      hl,FLAGS
        res     5,(hl)          ; set "no key"
m3279   bit     5,(hl)
        jr      z,m3279         ; loop until key available
        res     5,(hl)          ; set "no key"
        ld      a,(LAST_K)      ; get it
        ret

; Temporary filespec, used in COPY

m3283   defm    "M:VAXNSUZ.$$$", $ff

; Files copied messages
    IF garry=0
      IF spanish
m3291   defm    $0d, "  1 fichero copiado.", $0d, $0d, 0
m32a5   defm    " ficheros copiados.", $0d, $0d, 0
      ELSE
m3291   defm    $0d, "  1 file copied.", $0d, $0d, 0
m32a5   defm    " files copied.", $0d, $0d, 0
      ENDIF
    ENDIF
; Subroutine to copy TSTACK to a temporary area in page 7, and
; reset SP to use whole of TSTACK again

m32b6   di
        ld      (tmp_hl),hl     ; save HL
        push    af
        pop     hl
        ld      (tmp_af),hl     ; save AF
        ld      (tmp_de),de     ; save DE
        ld      (tmp_bc),bc     ; save BC
        ld      hl,TSTACK
        ld      de,tmp_stack
      IF v41
        ld      bc,$0083
      ELSE
        ld      bc,$0084
      ENDIF
        lddr                    ; copy TSTACK area into page 7
        pop     bc              ; BC=return address
        ld      (tmp_sp),sp     ; save SP
        ld      hl,TSTACK
        ld      sp,hl           ; set SP back to top of TSTACK
        push    bc              ; restack return address
        ld      bc,(tmp_bc)     ; restore BC
        ld      de,(tmp_de)     ; restore DE
        ld      hl,(tmp_af)
        push    hl
        pop     af              ; restore AF
        ld      hl,(tmp_hl)     ; restore HL
        ei
        ret

; Subroutine to restore TSTACK from where it's been saved in a temporary
; area in page 7

m32ee   di
        ld      (tmp_hl),hl     ; save HL
        push    af
        pop     hl
        ld      (tmp_af),hl     ; save AF
        ld      (tmp_de),de     ; save DE
        ld      (tmp_bc),bc     ; save BC
        pop     hl
        ld      (tmp_ret),hl    ; save return address
        ld      hl,tmp_stack
        ld      de,TSTACK
      IF v41
        ld      bc,$0083
      ELSE
        ld      bc,$0084
      ENDIF
        lddr                    ; restore TSTACK from saved location
        ld      hl,(tmp_sp)
        ld      sp,hl           ; restore SP
        ld      hl,(tmp_ret)
        push    hl              ; restack return address
        ld      bc,(tmp_bc)     ; restore BC
        ld      de,(tmp_de)     ; restore DE
        ld      hl,(tmp_af)
        push    hl
        pop     af              ; restore AF
        ld      hl,(tmp_hl)     ; restore HL
        ei
        ret

; The COPY EXP command

m3328   xor     a
        call    m2b89           ; page in DOS workspace
        ld      (tmp_buff+5),a  ; flag "normal copy exp"
        call    m2b64           ; page in normal memory
        ROM3    o0020           ; get next character
        cp      $dd
        jr      nz,x34be        ; move on if not INVERSE
        ld      a,$fc
        call    m2b89           ; page in DOS workspace
        ld      (tmp_buff+5),a  ; flag "inverse copy exp"
        call    m2b64           ; page in normal memory
        ROM3    o0020           ; get to next char
x34be IF v41
        cp      $dc
        jr      nz,m3347
        ld      hl,FLAGS
        bit     7,(hl)
        jr      z,x34d9
        ld      hl,$5800
        ld      bc,$0300
x34cf   ld      a,(hl)
        or      $40
        ld      (hl),a
        inc     hl
        dec     bc
        ld      a,b
        or      c
        jr      nz,x34cf
x34d9   ROM3    o0020           ; get to next char
      ENDIF
m3347   call    m10b1           ; check for end-of-statement
        ld      a,(BANK678)
        ld      bc,$1ffd
        set     4,a             ; set strobe high
        di
        ld      (BANK678),a
        out     (c),a           ; output strobe
        ei
        call    m2b89           ; page in DOS workspace
        di
        ld      a,$1b           ; set DUMPLF/216" linespacing
        call    m33b9
        ld      a,'3'
        call    m33b9
        ld      hl,DUMPLF
        ld      a,(hl)
        call    m33b9
        ld      hl,$401f        ; address of top right corner of display
        ld      e,$20           ; number of chars per line
m3373   push    hl
        ld      d,$01           ; start with bit 0 pixel
m3376   push    de
        push    hl
        ld      hl,m34bf
        call    m33c5           ; output raster line header
        pop     hl
        pop     de
        push    hl
m3381   call    m33d1           ; output raster data for next two pixels
        ld      a,h
        and     $07
        inc     h               ; get to next pixel line down
        cp      $07
        jr      nz,m3381        ; loop back if still in same character line
        ld      a,h
        sub     $08             ; back to top line of a character
        ld      h,a
        ld      a,l
        add     a,$20           ; move to next character line down
        ld      l,a
        jr      nc,m3381        ; loop back if same screen third
        ld      a,h
        add     a,$08           ; increment screen third
        ld      h,a
        cp      $58
        jr      nz,m3381        ; loop back if all thirds not done
        pop     hl              ; restore top of screen address
        sla     d
        sla     d               ; shift left two pixels
        jr      nc,m3376        ; loop back if within same char
        pop     hl              ; restore top of screen address
        dec     hl              ; previous character
        dec     e
        jr      nz,m3373        ; loop back if not finished
        ld      a,$1b           ; reset printer
        call    m33b9
        ld      a,'@'
        call    m33b9
        ei
        call    m2b64           ; page in normal memory
        ret                     ; done

; Subroutine to page in normal memory, output a character to the
; printer, and page back DOS workspace

m33b9   ei
        call    m2b64           ; page in normal memory
        call    m2051           ; output char to printer
        call    m2b89           ; page in DOS workspace
        di
        ret

; Subroutine to output a $ff-terminated string to the printer

m33c5   ld      a,(hl)          ; get next char
        cp      $ff
        ret     z               ; exit if $ff
        push    hl
        call    m33b9           ; output char
        pop     hl
        inc     hl
        jr      m33c5           ; loop back

; Subroutine to output 4 raster bytes for the next 2 pixels

m33d1   push    af              ; save registers
        push    hl
        push    de
        push    hl
        call    m3402           ; E=attribute for address in HL
        pop     hl
        call    m3412           ; clear 4-byte buffer
        call    m343f           ; copy appropriate pattern for pixel to buffer
        call    m341f           ; shift pattern left 3 bits
        sla     d               ; shift pixel number
        call    m343f           ; merge in pattern for next pixel
        call    m3432           ; shift patterns left 2 bits
        ld      b,$04           ; get ready to output 4 raster bytes
        ld      hl,tmp_buff
m33ef   ld      a,(hl)          ; get pattern
        push    bc
        push    hl
        ld      hl,tmp_buff+5
        xor     (hl)            ; invert if required
        call    m33b9           ; output byte
        pop     hl
        pop     bc
        inc     hl
        djnz    m33ef           ; loop back
        pop     de
        pop     hl
        pop     af
        ret

; Subroutine to get attribute byte in E for screen address in HL

m3402   push    af
        ld      a,h
        and     $18
        srl     a
        srl     a
        srl     a
        or      $58             ; address attribs
        ld      h,a
        ld      e,(hl)          ; get attrib
        pop     af
        ret

; Subroutine to clear a 4-byte area at tmp_buff

m3412   push    hl
        ld      hl,tmp_buff
        ld      b,$04
m3418   ld      (hl),$00        ; clear the buffer
        inc     hl
        djnz    m3418
        pop     hl
        ret

; Subroutine to shift patterns in buffer left 3 bits

m341f   push    hl
        push    bc
        ld      hl,tmp_buff
        ld      b,$04
m3426   sla     (hl)            ; shift left
        sla     (hl)
        sla     (hl)
        inc     hl
        djnz    m3426
        pop     bc
        pop     hl
        ret

; Subroutine to shift patterns in buffer left 2 bits

m3432   ld      hl,tmp_buff
        ld      b,$04
m3437   sla     (hl)            ; shift left
        sla     (hl)
        inc     hl
        djnz    m3437
        ret

; Subroutine to merge required pattern for pixel into buffer at tmp_buff

m343f   push    de              ; save registers
        push    hl
        ld      a,d
        and     (hl)            ; mask required pixel
        ld      a,e             ; A=attribute
        jr      nz,m344c        ; move on if need ink
        srl     a               ; shift paper colour to ink position
        srl     a
        srl     a
m344c   and     $07             ; mask off ink/paper colour as required
        bit     6,e             ; check BRIGHT
        jr      z,m3454
        or      $08             ; add 8 if bright
m3454   ld      hl,m346f        ; address of colour offsets table
        ld      d,$00
        ld      e,a
        add     hl,de
        ld      e,(hl)          ; DE=offset into pattern table
        ld      hl,m347f
        add     hl,de           ; HL=required pattern address
        ld      b,$04
        ld      de,tmp_buff
m3465   ld      a,(de)
        or      (hl)
        ld      (de),a          ; merge pattern into buffer
        inc     hl
        inc     de
        djnz    m3465
        pop     hl              ; restore registers
        pop     de
        ret

; Table of offsets into following pattern table

m346f   defb    $00,$04,$08,$0c
        defb    $10,$14,$18,$1c
        defb    $20,$24,$28,$2c
        defb    $30,$34,$38,$3c

; Pattern table for expanded copy

m347f   defb    $07,$07,$07,$07 ; black
        defb    $07,$05,$07,$07 ; blue
        defb    $03,$07,$06,$07 ; red
        defb    $07,$03,$06,$03 ; magenta
        defb    $06,$03,$06,$03 ; green
        defb    $06,$05,$02,$05 ; cyan
        defb    $02,$05,$02,$05 ; yellow
        defb    $01,$06,$03,$04 ; white
        defb    $07,$07,$07,$07 ; black
        defb    $05,$02,$03,$04 ; bright blue
        defb    $06,$01,$02,$01 ; bright red
        defb    $01,$04,$02,$04 ; bright magenta
        defb    $04,$00,$04,$01 ; bright green
        defb    $01,$00,$04,$00 ; bright cyan
        defb    $00,$02,$00,$00 ; bright yellow
        defb    $00,$00,$00,$00 ; bright white

; Raster line header for expanded copy

m34bf   defb    $0d,$0a         ; CRLF
        defb    $1b,'L',$00,$03 ; 768 bytes in 120dpi mode
        defb    $ff

; CAT "T:" routine

m34c6   ld      bc,$0011
        ROM3    o0030           ; make space for tape header
        push    de
        pop     ix              ; IX=address of space
m34cf   ld      a,$0d
        ROM3    o0010           ; output CR
m34d4   ld      a,$7f
        in      a,($fe)
        rra
        jr      c,m34e3         ; move on if BREAK not pressed
        ld      a,$fe
        in      a,($fe)
        rra
        jr      c,m34e3         ; move on if BREAK not pressed
        ret                     ; done
m34e3   ld      a,$00
        ld      de,$0011
        scf
        push    ix
        ROM3    o0556           ; read a header
        pop     ix
        jr      nc,m34d4        ; loop back if failed
        push    ix
        ld      a,'"'
        ROM3    o0010           ; output quote
        ld      b,$0a           ; name length 10
m34fb   ld      a,(ix+$01)
        ROM3    o0010           ; output next byte
        inc     ix
        djnz    m34fb           ; loop back
        pop     ix
        ld      hl,m35a1
        call    m3591           ; output quote and space
        ld      a,(ix+$00)      ; get file type
        cp      $00
        jr      nz,m3537        ; move on if not program
        ld      a,(ix+$0e)
        cp      $80
        jr      z,m352f         ; move on if no auto-run line number
        ld      hl,m35be
        call    m3591           ; display "LINE" message
        ld      c,(ix+$0d)
        ld      b,(ix+$0e)
        call    m359a           ; output line number
        ld      a,' '
        ROM3    o0010           ; output space
m352f   ld      hl,m35a4
        call    m3591           ; output "BASIC" message
        jr      m34cf           ; loop back
m3537   cp      $01
        jr      nz,m3554        ; move on if not number array
        ld      hl,m35ad
        call    m3591           ; output "DATA" message
        ld      a,(ix+$0e)
        and     $7f
        or      $40
        ROM3    o0010           ; output variable name
        ld      hl,m35b9+1
        call    m3591           ; output "()" message
        jp      m34cf           ; loop back
m3554   cp      $02
        jr      nz,m3571        ; move on if not character array
        ld      hl,m35ad
        call    m3591           ; output "DATA" message
        ld      a,(ix+$0e)
        and     $7f
        or      $40
        ROM3    o0010           ; output variable name
        ld      hl,m35b9
        call    m3591           ; output "$()" message
        jp      m34cf           ; loop back
m3571   ld      hl,m35b3
        call    m3591           ; output "CODE" message
        ld      c,(ix+$0d)
        ld      b,(ix+$0e)
        call    m359a           ; output load address
        ld      a,','
        ROM3    o0010           ; output comma
        ld      c,(ix+$0b)
        ld      b,(ix+$0c)
        call    m359a           ; output length
        jp      m34cf           ; loop back

; Subroutine to output a null-terminated string

m3591   ld      a,(hl)          ; get next char
        or      a
        ret     z               ; exit if null
        ROM3    o0010           ; output char
        inc     hl
        jr      m3591           ; loop back

; Subroutine to output number in BC

m359a   ROM3    o2D2B           ; stack number on calculator
        ROM3    o2DE3           ; output number
        ret

; Messages for tape catalogs

m35a1   defm    $22, " ", $00
m35a4   defm    "(BASIC) ", 0
m35ad   defm    "DATA ", 0
m35b3   defm    "CODE ", 0
m35b9   defm    "$() ", 0
m35be   defm    "LINE ", 0

  IF garry
m35d0   ROM3    o2BF1
        push    bc
        push    de
        ROM3    o1E94
        pop     de
        pop     bc
        ROM2    IDE_STREAM_OPEN
m35d3   jp      nc, m0edb
        ret
m35d7   ROM3    o1E94
        ROM2    IDE_STREAM_CLOSE
        jr      m35d3
m35da   rst     $18
        cp      '#'
        jr      z, m35f0
        ROM3    o1C82
        call    m10b1
        ROM3    o1E67
        ret
m35f0   call    m111c
        call    m10b1
        ld      de, m3f5c
        ld      bc, 13
        call    m14f0
        ROM3    o1E94
        ROM3    o1601
        ROM3    o2DA2
        push    bc
        ROM3    o2DA2
        push    bc
        pop     hl
        pop     de
        ld      b, 1
        ROM2    IDE_STREAM_PTR
        ret
      IF spanish
m36b0   defm    "Unidades fisicas: ", 0
m36b1   defm    " disq., ", 0
        IF mmcdata||mmcen
m36b2     defm    " MMCUnidades logicas: ", 0
        ELSE
m36b2     defm    " IDEUnidades logicas: ", 0
        ENDIF
m36bd   defm    "Formatear disco duro, seguro (S/N)?", 0
m36dc   defm    "Borrar particion, seguro (S/N)?", 0
m36fb   defm    "PARTICION INVALID", 'A'+$80
m370c   defm    "YA HAY PARTICIO", 'N'+$80
m3724   defm    "SIN IMPLEMENTA", 'R'+$80
m3733   defm    "PARTICION ABIERT", 'A'+$80
m3741   defm    "PARTICION FUERA DE RANG", 'O'+$80
m3759   defm    "NO ES PARTICION SWA", 'P'+$80
m376d   defm    "UNIDAD YA MAPEAD", 'A'+$80
m3781   defm    "FUERA DE XDPB", 'S'+$80   ; errata: XDPB en lugar de XBPD
m378d   defm    "NO HAY PARTICION SWA", 'P'+$80
m379e   defm    "DISPOSITIVO INVALID", 'O'+$80
      ELSE
m36b0   defm    "Physical drives: ", 0
m36b1   defm    " floppy, ", 0
        IF mmcdata||mmcen
m36b2     defm    " MMCLogical drives: ", 0
        ELSE
m36b2     defm    " IDELogical drives: ", 0
        ENDIF
m36bd   defm    "Really format hard disk (Y/N)?", 0
m36dc   defm    "Really delete partition (Y/N)?", 0
m36fb   defm    "Invalid partitio", 'n'+$80
m370c   defm    "Partition already exist", 's'+$80
m3724   defm    "Not implemente", 'd'+$80
m3733   defm    "Partition ope", 'n'+$80
m3741   defm    "Out of partition handle", 's'+$80
m3759   defm    "Not a swap partitio", 'n'+$80
m376d   defm    "Drive already mappe", 'd'+$80
m3781   defm    "Out of XDPB", 's'+$80
m378d   defm    "No swap partitio", 'n'+$80
m379e   defm    "Invalid devic", 'e'+$80
      ENDIF
m37dd   call    m24b5
        ld      hl, FLAGS
        res     5, (hl)
m37e5   bit     5, (hl)
        jr      z, m37e5
        res     5, (hl)
        ld      a, (LAST_K)
        and     $df
        cp      'N'
        jr      z, m37f8
      IF spanish
        cp      'S'
      ELSE
        cp      'Y'
      ENDIF
        jr      nz, m37e5
m37f8   push    af
        ROM3    o0D6E
        pop     af
        ret
m37fe   ROM3    o0D6E
        ld      hl, m36bd
        call    m37dd
        push    af
        ld      bc, 0
        ld      a, (FLAGS3)
        bit     6, a
        jr      z, m3815
        ROM3    o1E99
m3815   push    bc
        ROM3    o1E99
        push    bc
        ROM3    o1E94
        ld      c, a
        pop     hl
        pop     de
        pop     af
        cp      'N'
        ret     z
m3824   push    hl
        push    bc
        push    de
        ld      b, 7
        ld      hl, $ed11
        call    m2b89
        call    m32b6
        ROM2    IDE_IDENTIFY

      IF ide8
        cp      $42
        scf
        ccf
        jp      nz,m395a

      ELSE
        jp      nc, m395a
      ENDIF

        ld      ix, $ed11

      IF ide8
        ld      h, (ix+$03)
        ld      l, (ix+$06)
        ld      e, (ix+$01)
        inc     ixh
        ld      d, (ix+$00)

      ELSE
        ld      h, (ix+$06)
        ld      l, (ix+$0c)
        ld      e, (ix+$02)
        ld      d, (ix+$03)
      ENDIF

        call    m32ee
        call    m2b64
        ex      (sp), hl
        and     a
        sbc     hl, de
        jp      nc, m38c7
        add     hl, de
        ld      a, h
        or      l
        jr      z, m3862
        ex      de, hl
        pop     hl
        set     7, h
        jr      m3863
m3862   pop     hl
m3863   pop     bc
        ld      a, c
        pop     bc
        push    de
        pop     ix
        call    m2b89
        call    m32b6
        ROM2    IDE_FORMAT
        call    m32ee
        call    m2b64
        ret     c
m387b   call    m0ecb
        rst     $38
m3880   rst     $18
        cp      $e4
        jr      z, m388e
        cp      $b9
        jr      z, m388e
        call    m10b1
        jp      m2280
m388e   ROM3    o2D28
        rst     $20
        ROM3    o1C8C
        rst     $18
        cp      ','
        jp      nz, m1125
m3899   rst     $20
        ROM3    o1C82
        call    m10b1
        ROM3    o1E99
        push    bc
        call    m3965
        jp      nz, m398a
        push    de
        ROM3    o1E94
        pop     de
        pop     hl
        cp      $b9
        ld      a, 2
        ld      bc, 17
        jr      z, m38ba
        ld      a, 3
        ld      bc, 17
m38ba   call    m2b89
        ld      ($efa8), a
        push    hl
        and     a
        sbc     hl, bc
        pop     hl
        jr      c, m38ce
m38c7   call    m2b64
        call    m2ada
        ld      a, (bc)
m38ce   ld      a, h
        or      l
        jr      z, m38c7
        push    de
        push    hl
        ld      hl, m3d8b
        ld      de, $efb8
        ld      bc, $1d
        ldir
        pop     hl
        push    hl
        ld      d, l
        ld      e, 0
        ld      a, l
        cp      5
        jr      c, m3903
        cp      9
        jr      c, m38fa
        srl     d
        rr      e
        ld      bc, $3f06
        ld      h, 3
        ld      a, $c0
        jr      m390c
m38fa   ld      bc, $1f05
        ld      h, 1
        ld      a, $f0
        jr      m390c
m3903   sla     d
        ld      bc, $0f04
        ld      h, 0
        ld      a, $ff
m390c   ld      ($efba), bc
        ld      ($efc1), a
        ld      a, h
        ld      ($efbc), a
        dec     de
        ld      b, l
        xor     a
m391a   add     a, $10
        djnz    m391a
        and     a
        jr      nz, m3925
        dec     a
        ld      de, $07f7
m3925   ld      ($efca), a
        ld      ($efbd), de
        pop     hl
        add     hl, hl
        add     hl, hl
        add     hl, hl
        dec     hl
        ld      ($efb0), hl
        ld      a, $ff
        ld      ($efaf), a
        pop     af
        push    af
        ld      hl, $ef98
        call    m32b6
        ROM2    IDE_PARTITION_NEW
        call    m32ee
        jr      nc, m395d
        pop     af
        ld      l, $e5
        ld      ix, $001f
        call    m32b6
        ROM2    IDE_PARTITION_INIT
m395a   call    m32ee
m395d   call    m2b64
        ret     c
        call    m0ecb
        rst     $38
m3965   ROM3    o2BF1
        ld      a, b
        or      c
        jr      nz, m3970
        call    m2ada
        inc     l
m3970   inc     de
        ld      a, (de)
        dec     de
        cp      '>'
        ld      a, 0
        jr      nz, m398e
m3979   ld      a, (de)
        inc     de
        inc     de
        dec     bc
        dec     bc
        sub     '0'
        jr      z, m398e
        cp      1
        jr      z, m398e
        ld      d, a
        cp      5
        ret     c
m398a   call    m2ada
        ld      e, c
m398e   push    af
        ld      b, 0
        ld      a, c
        cp      $11
        jr      c, m3998
        ld      a, $10
m3998   ex      de, hl
        ld      de, $ef98
        call    m3f63
        di
        ld      a, (BANKM)
        or      7
        ld      bc, $7ffd
        out     (c), a
        ex      de, hl
        ld      d, $10
m39ad   ld      (hl), $20
        inc     hl
        dec     d
        jr      nz, m39ad
        ld      a, (BANKM)
        out     (c), a
        ei
        pop     de
        ret
m39bb   rst     $18
        cp      $eb
        jp      z, m3df2
        cp      $bf
        jr      z, m39dc
        cp      $df
        jr      z, m3a1f
        cp      $c4
        jr      z, m3a3d
        cp      $cc
        jp      nz, m1125
        rst     $20
        ROM3    o1C8C
        call    m10b1
        jp      m04e5
m39dc   rst     $20
        ROM3    o1C8C
        call    m3a81
        call    m10b1
        call    m3965
        ld      a, d
        push    af
        jr      nz, m3a03
        ld      hl, $ef98
        call    m2b89
        call    m32b6
        ROM2    IDE_PARTITION_FIND
        call    m32ee
        call    m2b64
        jr      nc, m3a1b
m3a03   push    bc
        call    m3a8e
        pop     bc
        pop     af
        call    m2b89
        call    m32b6
        ROM2    IDE_DOS_MAP
        call    m32ee
        call    m2b64
        ret     c
m3a1b   call    m0ecb
        rst     $38
m3a1f   rst     $20
        call    m3a81
        call    m10b1
        call    m3a8e
        call    m2b89
        call    m32b6
        ROM2    IDE_DOS_UNMAP
        call    m32ee
        call    m2b64
        jr      nc, m3a1b
        ret
m3a3d   rst     $20
        call    m10b1
        ld      hl, m36dc
        call    m37dd
        push    af
        call    m3965
        jp      nz, m398a
        pop     af
        cp      'N'
        ret     z
        ld      a, d
        push    af
        ld      hl, $ef98
        call    m2b89
        call    m32b6
        ROM2    IDE_PARTITION_FIND
        call    m32ee
        call    m2b64
        jr      nc, m3a7d
        pop     af
        call    m2b89
        call    m32b6
        ROM2    IDE_PARTITION_ERASE
        call    m32ee
        call    m2b64
        ret     c
m3a7d   call    m0ecb
        rst     $38
m3a81   rst     $18
        ld      hl, FLAGS3
        res     6, (hl)
        cp      $b5
        ret     nz
        set     6, (hl)
        rst     $20
        ret
m3a8e   ROM3    o2BF1
        dec     bc
        dec     bc
        ld      a, b
        or      c
        jr      nz, m3aab
        inc     de
        ld      a, (de)
        cp      ':'
        jr      nz, m3aab
        dec     de
        ld      a, (de)
        and     $df
        cp      'A'
        jr      c, m3aab
        cp      'Q'
        jr      nc, m3aab
        ld      l, a
        ret
m3aab   call    m2ada
        ld      c, (hl)
m3aaf   rst     $18
        cp      $ab
        ld      bc, $1ff
        jr      z, m3b08
        cp      $d9
        ld      bc, $0107
        jr      z, m3b08
        cp      $da
        ld      bc, $0407
        jr      z, m3b08
        cp      $db
        ld      bc, $0801
        jr      z, m3b08
        cp      $dc
        ld      bc, $0701
        jr      z, m3b08
        cp      $0d
        jr      z, m3adb
        cp      ':'
        jr      nz, m3ae1
m3adb   call    m10b1
        jp      m1465
m3ae1   ROM3    o1C8C
        call    m10b1
        ROM3    o2BF1
        ex      de, hl
        ld      de, tmp_file
        call    m3f63
        call    m2b89
        ld      a, $ff
        ld      (de), a
        
; #####################################################################################################################
        if zx_tap
            call    is_tap
        else
            ld      hl, tmp_file
        endif
; #####################################################################################################################

        call    m32b6
        ROM2    IDE_SNAPLOAD
        call    m32ee
        jp      m3d21
m3b08   push    bc
        rst     $20
        ROM3    o1C82
        call    m3a81
        pop     bc
        call    m10b1
        push    bc
        ROM3    o1E94
        pop     bc
        ld      d, a
        ld      a, c
        cp      d
        jr      nc, m3b20
        call    m2ada
        inc     de
m3b20   dec     b
        jr      z, m3b29
        rlc     d
        rlc     c
        jr      m3b20
m3b29   call    m2b89
        ld      a, c
        cpl
        ld      c, a
        ld      a, (ed_ATTR_T)
        and     c
        or      d
        ld      (ed_ATTR_T), a
        ld      (ed_ATTR_P), a
        call    m2b64
        ld      hl, FLAGS3
        bit     6, (hl)
        ret     z
        ld      h, a
        xor     a
        jp      m3e5c
m3b48   cp      $ad
        jr      z, m3b64
        cp      $b5
        jp      z, m3da8
        call    m2ada
        dec     bc
m3b50   cp      $b9
        jp      z, m062b
        cp      $b5
        jp      z, m3da8
        cp      $ad
        jp      nz, m05f8
m3b64   rst     $20
        cp      $b9
        jr      nz, m3b6f
        rst     $20
        ld      hl, FLAGS3
        set     6, (hl)
m3b6f   call    m10b1
        call    m2b89
        ld      b, 2
m3b77   push    bc
        ld      a, 2
        sub     b
        ld      de, 0
        push    de
        push    af
        ld      hl, m3d48
        call    m07d7
        pop     af
        push    af
        ld      c, a
        add     a, $30
        call    m07cf
        ld      b, 7
        ld      hl, $ed11
        call    m32b6
        ROM2    IDE_IDENTIFY
        call    m32ee
        
      IF ide8
        cp      $42
        scf
        ccf
        jr      nz, m3c06

      ELSE
        jr      nc, m3c06
      ENDIF

        ld      ix, $ed11
        ld      hl, m3d77
        call    m07d7
        
      IF ide8
        ld      l, (ix+$01)
        inc     ixh
        ld      h, (ix+$00)
        dec     ixh
        ld      e, $ff
        call    m07df
        ld      a, '/'
        call    m07cf
        ld      h, 0
        ld      l, (ix+$03)
        ld      e, $ff
        call    m07df
        ld      a, '/'
        call    m07cf
        ld      h, 0
        ld      l, (ix+$06)

      ELSE
        ld      l, (ix+$02)
        ld      h, (ix+$03)
        ld      e, $ff
        call    m07df
        ld      a, '/'
        call    m07cf
        ld      h, 0
        ld      l, (ix+$06)
        ld      e, $ff
        call    m07df
        ld      a, '/'
        call    m07cf
        ld      h, 0
        ld      l, (ix+$0c)
      ENDIF

        ld      e, $ff
        call    m07df
        ld      a, ')'
        call    m07cf
        ld      a, 13
        call    m07cf
m3bdd   ld      bc, 0
m3be0   pop     af
        push    af
        ld      hl, $ef98
        call    m32b6
        ROM2    IDE_PARTITION_READ
        call    m32ee
        jp      nc, m3d15
        ld      ix, $ef98
        ld      a, (ix+$10)
        cp      0
        jr      nz, m3c0e
        pop     af
        pop     de
        inc     de
        push    de
        push    af
        jp      m3cf9
m3c06   ld      hl, m3d7a
        call    m07d7
        jr      m3bdd
m3c0e   push    bc
        ld      hl, $ef98
        ld      e, $10
m3c14   ld      a, (hl)
        inc     hl
        and     a
        jr      nz, m3c1b
        ld      a, $7e
m3c1b   call    m07cf
        dec     e
        jr      nz, m3c14
        ld      a, $20
        call    m07cf
        ld      l, (ix+$18)
        ld      h, (ix+$19)
        ld      e, (ix+$1a)
        ld      a, e
        or      h
        jr      nz, m3c46
        ld      h, l
        ld      l, (ix+$17)
        inc     hl
        srl     h
        rr      l
        ld      e, $20
        call    m07df
        ld      hl, m3d2b
        jr      m3c63
m3c46   xor     a
        srl     e
        rr      h
        rr      l
        rra
        srl     e
        rr      h
        rr      l
        rra
        srl     e
        rr      h
        rr      l
        ld      e, $20
        call    m07df
        ld      hl, m3d27
m3c63   call    m07d7
        ld      a, (ix+$10)
        cp      1
        ld      hl, m005e
        jr      z, m3c8f
        cp      2
        ld      hl, m3d52
        jr      z, m3c8f
        cp      3
        ld      hl, m3d57

      IF !ide8
        jr      z, m3c8f
        cp      4
        ld      hl, m3c7d
        jr      z, m3c8f
        cp      5
        ld      hl, m3c81
        jr      z, m3c8f
        cp      15
        ld      hl, m3c8e
        jr      z, m3c8f
        cp      $10
        ld      hl, m3c94
        jr      z, m3c8f
        cp      $20
        ld      hl, m3c9a
      ENDIF

        jr      z, m3c8f
        cp      $fe
        ld      hl, m3d5d
        jr      z, m3c8f
        cp      $ff
        ld      hl, m3d63
        jr      z, m3c8f

      IF !ide8
        and     $f0
        cp      $30
        ld      hl, m3c9f
        jr      z, m3c8f
        cp      $40
        ld      hl, m3ca8
        jr      z, m3c8f
      ENDIF

        ld      hl, m3d68
m3c8f   call    m07d7
        ld      a, (ix+$10)
        cp      3
        jr      nz, m3ca7
        ld      a, (ix+$3c)
        and     a
        jr      z, m3ca7
        call    m07cf
        ld      a, ':'
        call    m07cf
m3ca7   ld      a, 13
        call    m07cf
        ld      hl, FLAGS3
        bit     6, (hl)
        jr      z, m3cf8
        ld      hl, m0056
        call    m07d7
        ld      l, (ix+$11)
        ld      h, (ix+$12)
        ld      e, $ff
        call    m07df
        ld      a, ','
        call    m07cf
        ld      l, (ix+$13)
        ld      h, 0
        ld      e, $ff
        call    m07df
        ld      hl, m3d70
        call    m07d7
        ld      l, (ix+$14)
        ld      h, (ix+$15)
        ld      e, $ff
        call    m07df
        ld      a, ','
        call    m07cf
        ld      l, (ix+$16)
        ld      h, 0
        ld      e, $ff
        call    m07df
        ld      a, 13
        call    m07cf
m3cf8   pop     bc
m3cf9   inc     bc
        ld      a, b
        or      c
        jp      nz, m3be0
m3cff   pop     af
        pop     hl
        ld      e, $ff
        call    m07df
        ld      hl, m3d2e
        call    m07d7
m3d0c   pop     bc
        dec     b
        jp      nz, m3b77
        call    m2b64
        ret
m3d15   cp      $38
        jr      z, m3cff
        cp      $16
        jr      nz, m3d21
        pop     af
        pop     hl
        jr      m3d0c
m3d21   call    m2b64
        jp      m387b
m3d27   defm    "Mb ", 0
m3d2b   defm    "K ", 0
      IF spanish
m3d2e   defm    " particiones libres", 13, 13, 0
        IF mmcdata||mmcen
m3d48     defm    "Unidad MMC ", 0
        ELSE
m3d48     defm    "Unidad IDE ", 0
        ENDIF
m3d52   defm    "swap", 0
m3d57   defm    "datos ", 0
m3d5d   defm    "*MAL*", 0
m3d63   defm    "LIBRES", 0
m3d68   defm    "?????", 0
m3d70   defm    " Fin:", 0
m3d77   defm    " (", 0
m3d7a   defm    " (no detectada)", 13, 0
m3c7d   defm    "CPM Fis.", 0
m3c81   defm    "Boot HW", 0
m3c8e   defm    "Video", 0
m3c94   defm    "FAT16", 0
m3c9a   defm    "UZIX", 0
m3c9f   defm    "Disk Img", 0
m3ca8   defm    "CPM Img", 0
      ELSE
m3d2e   defm    " free partition entries", 13, 13, 0
        IF mmcdata||mmcen
m3d48     defm    "MMC unit", 0
        ELSE
m3d48     defm    "IDE unit", 0
        ENDIF
m3d52   defm    "swap", 0
m3d57   defm    "data ", 0
m3d5d   defm    "*BAD*", 0
m3d63   defm    "FREE", 0
m3d68   defm    "unknown", 0
m3d70   defm    " End: ", 0
m3d77   defm    " (", 0
m3d7a   defm    " (not detected)", 13, 0
m3c7d   defm    "CPM Phys", 0
m3c81   defm    "Boot HW", 0
m3c8e   defm    "Movie", 0
m3c94   defm    "FAT16", 0
m3c9a   defm    "UZIX", 0
m3c9f   defm    "Disk Img", 0
m3ca8   defm    "CPM Img", 0
      ENDIF
m3d8b   defb    0, 2, 0, 0, 0, 0, 0, $ff, 1, 0, 0, 0, $80, 0
        defb    0, 2, 3, 0, 0, $80, 0, 0, 2, 0, 0, 0, 0, 0, 0
m3da8   rst     $20
        call    m10b1
        call    m2b89
        ld      b, $10
        ld      l, 'A'
m3db3   push    bc
        push    hl
        ld      bc, $ef98
        call    m32b6
        ROM2    IDE_DOS_MAPPING
        call    m32ee
        jp      nc, m3d21
        jr      z, m3de9
        pop     hl
        push    hl
        ld      a, l
        call    m07cf
        ld      a, ':'
        call    m07cf
        ld      a, ' '
        call    m07cf
        ld      hl, $ef98
        ld      b, $12
m3ddd   ld      a, (hl)
        call    m07cf
        inc     hl
        djnz    m3ddd
        ld      a, 13
        call    m07cf
m3de9   pop     hl
        pop     bc
        inc     l
        djnz    m3db3
        call    m2b64
        ret
m3df2   rst     $20
        ROM3    o1C8C
        call    m10b1
        ROM3    o2BF1
        ld      b, 0
        ld      a, c
        and     a
        jr      nz, m3e06
        call    m2ada
        inc     l
m3e06   cp      $10
        jr      c, m3e0c
        ld      c, $10
m3e0c   push    bc
        ex      de, hl
        ld      de, tmp_file
        call    m3f63
        call    m3965
        ld      a, d
        jp      nz, m398a
        push    af
        ld      hl, $ef98
        call    m2b89
        call    m32b6
        ROM2    IDE_PARTITION_FIND
        call    m32ee
        call    m2b64
        jr      nc, m3e58
        pop     af
        pop     de
        call    m2b89
        ld      hl, tmp_file
        add     hl, de
        ld      d, a
        ld      a, $11
        sub     e
m3e3f   ld      (hl), $20
        inc     hl
        dec     a
        jr      nz, m3e3f
        ld      a, d
        ld      hl, tmp_file
        call    m32b6
        ROM2    IDE_PARTITION_RENAME
        call    m32ee
        call    m2b64
        ret     c
m3e58   call    m0ecb
        rst     $38
m3e5c   ld      b, a
        ld      c, a
        ld      l, 8
        call    m2b89
        call    m32b6
        ROM2    IDE_PARTITION_SETINFO
        ld      a, (ATTR_P)
        ld      h, a
        ld      l, 9
        xor     a
        ld      b, a
        ld      c, a
        ROM2    IDE_PARTITION_SETINFO
        call    m32ee
        call    m2b64
        ret
m3f5c   defb    $ef, $01, $c1, $02, $34, $40, $41, $00, $00, $32, $e1, $38, $c9


; ##############################################    IS_TAP subroutine    ##############################################
      if zx_tap
is_tap:     
        xor     a
        ld      (tapeloader_stat1), a
        dec     de          ;veo si termina en .tap
        ld      a, (de)
        and     $df
        cp      'P'
        jr      nz, notap

        dec     de
        ld      a, (de)
        and     $df
        cp      'A'
        jr      nz, notap
        
        dec     de
        ld      a, (de)
        and     $df
        cp      'T'
        jr      nz, notap

        dec     de
        ld      a, (de)
        cp      '.'
        jr      nz, notap
        
        ld      bc, $0000
        ld      (save_POS_FILE+0), bc
        ld      (save_POS_FILE+2), bc
        
        ld      b, $06
        ROM2    DOS_ABANDON
        
        ld      bc, $0601            ; abro el archivo lectura exc. con handle: 10
        ld      a, c
        ld      (tapeloader_stat1), a    ; 1=en pag 7 me indicarÂ  que estoy cargando desde cinta
        ld      de, $0002        ; error si no existe + puntero en 0
        ld      hl, tmp_file
        ROM2    DOS_OPEN            ; open file

        jr      c,  ok_opentap        ; salto adelante si todo Ok

        call    m2b64               ; page in normal memory
        call    m0e9a               ; cause DOS error
        defb    $ff

ok_opentap: 
        ld      a, (LODDRV)
        ld      (tapeloader_stat2), a
        ld      a, 'T'
        ld      (LODDRV), a     ; cambio a T: el "drive" por defecto

        call    m32ee           ; esta es la forma de retornar
        call    m2b64           ; al basic
        ret

notap:      
        ld      hl, tmp_file        ; trato de continuar como si "aqui no paso nada"
        ret
      endif

; #####################################################################################################################

  ELSE
; The "COPY RANDOMIZE" command
; This is a silly command

m35c4   ld      c,$40           ; loop timing values
m35c6   ld      b,$00
m35c8   ld      a,$fe
        in      a,($fe)
        bit     3,a
        jr      nz,m35dc        ; move on if "C" not pressed
        ld      a,$bf
        in      a,($fe)
        bit     3,a
        jr      nz,m35dc        ; move on if "J" not pressed
        bit     1,a             ; move on if "L" not pressed
        jr      z,m35e5         ; go to silly routine if "CJL" held
m35dc   djnz    m35c8           ; loop back
        dec     c
        jr      nz,m35c6        ; loop back
        call    m2ada
        defb    $0b             ; nonsense in BASIC error
m35e5
      IF v41 || spanish
        ld      ix,$2000
      ENDIF
        xor     a
        out     ($fe),a         ; black border
        ld      hl,$5800
        ld      de,$5801
        ld      bc,$02ff
        ld      (hl),$00
        ldir                    ; black screen
        ld      hl,$4000
        ld      de,$4001
        ld      bc,$17ff
        ld      (hl),$ff
        ldir                    ; fill screen with ink
        ld      c,$07           ; base ink colour
m3604   ld      a,c
        and     $07
        jr      nz,m360c
        inc     c               ; increment base ink colour
        jr      m3604
m360c   ld      d,$58           ; high byte of start of attribs
        ld      hl,m3631        ; table of attrib offsets
m3611   ld      e,(hl)
        push    af
      IF v41 || spanish
        ld      a,$fb
        in      a,($fe)
        rra
        jr      c,x37c5
        pop     af
        ld      hl,$5800
        ld      de,$5801
        ld      bc,$02ff
        ld      (hl),$38
        ldir
        call    m2ada
        rst     $38
x37c5   ld      a,$ef
        in      a,($fe)
        rra
        jr      c,x37ce
        inc     ix
x37ce   ld      a,$df
        in      a,($fe)
        rra
        jr      c,m3613
        dec     ix
      ENDIF
m3613   ld      a,e
        or      a
        jr      nz,m3624        ; if not end of third, move on
        inc     d               ; get to next third
        ld      a,d
        cp      $5b
        jr      nz,m3621        ; move on if still in attribs area
        pop     af
        inc     c               ; increment base ink colour
      IF v41 || spanish
        push    af
        push    bc
        push    ix
        pop     bc
x37e8   dec     bc
        ld      a,b
        or      c
        jr      nz,x37e8
        pop     bc
        pop     af
      ENDIF
        jr      m3604           ; loop back
m3621   pop     af
        jr      m362e           ; go to loop back for another offset
m3624   pop     af
        and     $07
        or      a
        jr      nz,m362c        ; is ink colour 0 or 8?
        ld      a,$07           ; set to white if so
m362c   ld      (de),a          ; set attribute
        dec     a               ; decrement ink colour
m362e   inc     hl              ; increment table pointer
        jr      m3611           ; loop back

; The table of attribute positions for the COPY RANDOMIZE routine

m3631   defb    $21,$41,$61,$81
        defb    $a1,$c1,$e1,$82
        defb    $83,$84,$25,$45
        defb    $65,$85,$a5,$c5
        defb    $e5,$27,$47,$67
        defb    $87,$a7,$c7,$e7
        defb    $28,$29,$2a,$2b
        defb    $88,$89,$8a,$e8
        defb    $e9,$ea,$eb,$2d
        defb    $4d,$6d,$8d,$ad
        defb    $cd,$ed,$ee,$ef
        defb    $f0,$f1,$33,$53
        defb    $73,$93,$b3,$d3
        defb    $f3,$f4,$f5
        defb    $f6,$f7,$59,$79
        defb    $99,$b9,$d9,$3a
        defb    $3b,$3c,$3d,$fa
        defb    $fb,$fc,$fd,$5e
        defb    $7e,$9e,$be,$de
        defb    $00              ; end of first screen third
        defb    $21,$22,$23,$24
        defb    $25,$43,$63,$83
        defb    $a3,$c3,$e3,$27
        defb    $47,$67,$87,$a7
        defb    $c7,$e7,$88,$89
        defb    $8a,$2b,$4b,$6b
        defb    $8b,$ab,$cb,$eb
        defb    $2d,$4d,$6d,$8d
        defb    $ad,$cd,$ed,$2e
        defb    $2f,$30,$31,$8e
        defb    $8f,$90,$ee,$ef
        defb    $f0,$f1,$33,$53
        defb    $73,$93,$b3,$d3
        defb    $f3,$34,$35
        defb    $36,$94,$95,$96
        defb    $57,$77,$b5,$d6
        defb    $f7,$39,$59,$79
        defb    $99,$b9,$d9,$f9
        defb    $3a,$3b,$3c,$3d
        defb    $9a,$9b,$9c,$fa
        defb    $fb,$fc,$fd,$00 ; end of second screen third
        defb    $20,$40,$60,$80
        defb    $a0,$c0,$e0,$22
        defb    $24,$44,$64,$84
        defb    $a4,$c4,$e4,$45
        defb    $66,$47,$28,$48
        defb    $68,$88,$a8,$c8
        defb    $e8,$4c,$6c,$8c
        defb    $ac,$cc,$ec,$2d
        defb    $2e,$2f,$8d,$8e
        defb    $8f,$50,$70,$90
        defb    $b0,$d0,$f0,$94
        defb    $95,$96,$97,$98
        defb    $56,$76,$b6,$d6
        defb    $5a,$3b,$3c,$3d
        defb    $5e,$7e,$9d,$9c
        defb    $be,$de,$fd,$fc
        defb    $fb,$da,$00     ; end of table

m3713   defs    $19
    IF v41
      IF spanish
m372c   defs    $00bf
      ELSE
m372c   defs    $0104
      ENDIF
    ELSE
      IF spanish
m372c   defs    $0250
      ELSE
m372c   defs    $02d4
      ENDIF
    ENDIF

; The printer input (m3a00) and output (m3a05) routines
; This is a copy of a routine in ROM 3 which switches in this ROM,
; at which point it takes over

m3a00   ld      hl,m3d03        ; printer input routine
        jr      m3a08
m3a05   ld      hl,m3d06        ; printer output routine
m3a08   ex      af,af'
        ld      bc,$1ffd
        ld      a,(BANK678)
        push    af
        and     $fb             ; select ROM 1
        di
        ld      (BANK678),a
        out     (c),a
        jp      m3d00           ; this ROM takes over at this point
m3a1b   ex      af,af'
        pop     af
        ld      bc,$1ffd
        di
        ld      (BANK678),a     ; previous value
        out     (c),a           ; at this point, control passes back to ROM 3
        ei
        ex      af,af'
        ret

        defs    $02d7

m3d00   jp      m2b09           ; call the required routine
m3d03   jp      m1e70           ; jump to input routine
m3d06   jp      m1f6e           ; jump to output routine
  ENDIF

; ###########################################   BLUEROM subroutines  ##################################################
      IF bluerom
newfill                         ; 0x3900 in bluerom
        ld      hl,tmp_buff+$23 ; end of scratch area
        ld      b,$09
fill_loop:
        ld      (hl),$02
        dec     hl
        push    bc
        push    hl
        ld      hl,fill_ret
        ld      c,b
        ld      b,$00
        add     hl,bc
        ld      b,(hl)
        pop     hl
        ld      (hl),b
        pop     bc
        dec     hl
        ld      (hl),$00
        dec     hl
        ld      (hl),d
        dec     hl
        djnz    fill_loop
fill_ret: ret
        ld      bc,0x0704
        ld      (bc),a
        dec     b
        ex      af,af'
        inc     bc
        ld      b,0x09
/**************************************************************************************
    THESE OTHER SUBROUTINES, FOUND IN THE BLUEROM, COULD BE ADDED AS WELL
***************************************************************************************
pixel_st                ; called at 0x3927 in bluerom
        ld      a,0xbf
        sub     b
        ld      b,a
        and     a
        rra
        scf
        rra
        and     a
        rra
        xor     b
        and     0xf8
        xor     b
        ld      h,a
        ld      a,c
        rlca
        rlca
        rlca
        xor     b
        and     0xc7
        xor     b
        rlca
        rlca
        ld      l,a
        ld      a,c
        and     0x07
        ret

copy    ld      a,(0xc005) ; 0x3945 in bluerom
        jr      sig
        ld      a,(0xc004)     ; 0x394a in bluerom
sig     or      0x20
        ret
**************************************************************************/

compare cp      0x00    ; 0x3950 in bluerom
        ret     z
        cp      0x03
        ld      a,0x06
        ret
      ENDIF
; #####################################################################################################################

      defs 0x0 + (0x3e80-$), $ff

; Subroutine to call a subroutine in ROM 0
; The subroutine address is inline after the call to this routine
;        org     $3e80
m3e80   ld      (OLDHL),hl      ; save HL in OLDHL
        ld      (OLDBC),bc      ; save BC in OLDBC
        push    af
        pop     hl
        ld      (OLDAF),hl      ; save AF in OLDAF
        ex      (sp),hl         ; HL=address of inline address
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline ROM 0 address
        inc     hl
        ex      (sp),hl         ; stack return address
        push    bc
        pop     hl              ; HL=routine address in ROM 0
        ld      a,(BANKM)
        and     $ef
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 0

; The rest of the routine continues at $3ea2 in ROM 0
; The following is a continuation of a mirrored routine in ROM 0 for
; calling this ROM

m3ea2   ei
        ld      bc,$3eb5
        push    bc              ; stack return add to swap back ROMs
        push    hl              ; stack routine address
        ld      hl,(OLDAF)
        push    hl
        pop     af              ; restore AF
        ld      bc,(OLDBC)      ; restore BC
        ld      hl,(OLDHL)      ; restore HL
        ret                     ; execute routine in this ROM

; This part is the routine which returns control to ROM 0

m3eb5   push    af              ; save AF & BC
        push    bc
        ld      a,(BANKM)
        and     $ef
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page back ROM 0

; The rest of the routine continues at $3ec5 in ROM 0
; The following is a continuation of a mirrored routine in ROM 0 for
; returning to this ROM

m3ec5   ei
        pop     bc              ; restore registers
        pop     af
        ret                     ; return

    IF garry
      IF spanish
m3291   defm    $0d, "  1 fichero copiado.", $0d, $0d, 0
m32a5   defm    " ficheros copiados.", $0d, $0d, 0
        defs    9
      ELSE
m3291   defm    $0d, "  1 file copied.", $0d, $0d, 0
m32a5   defm    " files copied.", $0d, $0d, 0
        defs    18
      ENDIF
    ELSE
        defs    $37
    ENDIF
; Subroutine to call a subroutine in ROM 2
; The subroutine address is inline after the call to this routine
; This routine is duplicated in ROMs 0 & 2, so that when we start switching
; (first to ROM 0, then to ROM 2) there is no problem.

m3f00   ld      (OLDHL),hl      ; save HL,BC and AF
        ld      (OLDBC),bc
        push    af
        pop     hl
        ld      (OLDAF),hl
        ex      (sp),hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address
        inc     hl
        ex      (sp),hl         ; restack updated return address
      IF garry
        ld      hl, m3f42
        push    hl
      ENDIF
        push    bc
        pop     hl              ; HL=address to call in ROM
        ld      a,(BANKM)
        and     $ef
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 0
        ld      a,(BANK678)
        or      $04
        ld      (BANK678),a
m3f2a   ld      bc,$1ffd
        out     (c),a           ; page in ROM 2
        ei
      IF garry=0
        ld      bc,m3f42
        push    bc              ; stack routine address to return to ROM 1
      ENDIF
        push    hl              ; stack routine address to call in ROM 2
        ld      hl,(OLDAF)      ; restore registers
        push    hl
        pop     af
        ld      bc,(OLDBC)
        ld      hl,(OLDHL)
        ret                     ; exit to routine

; This part of the routine returns control to ROM 1

m3f42   push    bc              ; save registers
        push    af
        ld      a,(BANK678)
        and     $fb
        di
        ld      (BANK678),a
        ld      bc,$1ffd
        out     (c),a           ; page in ROM 0
        ld      a,(BANKM)
        or      $10
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 1
        ei
        pop     af              ; restore registers
        pop     bc
        ret                     ; done!

; Subroutine to copy a block of memory from HL in page 0 to
; DE in page 7 (length BC bytes)

m3f63   di                      ; ensure interrupts disabled
        exx
        ld      bc,$7ffd        ; BC'=paging port
        exx
m3f69   exx
        ld      a,$10
        out     (c),a           ; page in page 0
        exx
        ld      a,(hl)
        ex      af,af'          ; get A'=byte from page 0
        exx
        ld      a,$17
        out     (c),a           ; page in page 7
        exx
        ex      af,af'
        ld      (de),a          ; store byte from page 0 in page 7
        inc     hl              ; increment addresses
        inc     de
        dec     bc              ; decrement counter
        ld      a,b
        or      c
        jr      nz,m3f69        ; loop back for more
        ld      a,(BANKM)
        ld      bc,$7ffd
        out     (c),a           ; page in previous memory
        ei                      ; enable interrupts
        ret

; Subroutine to copy a block of memory from HL in page 7 to
; DE in page 0 (length BC bytes)

m3f8a   di
        exx
        ld      bc,$7ffd        ; BC'=paging port
        exx
m3f90   exx
        ld      a,$17
        out     (c),a           ; page in page 7
        exx
        ld      a,(hl)
        ex      af,af'          ; A'=byte from page 7
        exx
        ld      a,$10
        out     (c),a           ; page in page 0
        exx
        ex      af,af'
        ld      (de),a          ; store byte in page 0
        inc     hl              ; increment addresses
        inc     de
        dec     bc              ; decrement pointers
        ld      a,b
        or      c
        jr      nz,m3f90        ; loop back for more
        ld      a,(BANKM)
        ld      bc,$7ffd
        out     (c),a           ; page in previous memory
        ei                      ; enable interrupts
        ret
  IF garry
      IF spanish
m07c9   defm    "K LIBRES", 13, 0
m07d1   defm    "NINGUN FICHERO ENCONTRADO", 13, 0
merase  defm    "]Borrar ", 0
myn     defm    " (S/N)?", 0
m296e   defm    "ERROR DE DATO", 'S'+$80
      ELSE
m07c9   defm    "K free", 13, 0
m07d1   defm    "No files found", 13, 0
merase  defm    "Erase ", 0
myn     defm    " ? (Y/N)", 0
        defs    28
      ENDIF
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff
  ELSE
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff
    IF v41
      IF spanish
        defb    $8e
      ELSE
        defb    $12
      ENDIF
    ELSE
      IF spanish
        defb    $3c
      ELSE
        defb    $72
      ENDIF
    ENDIF
  ENDIF

; ----------------------------------------------------------------------------------------------------

; ============================
; PLAY command data structures
; ============================
;
; During execution of the PLAY command, an area of memory $3c bytes long plus
; $37 bytes per string is reserved. IY is used to point to the "overhead" area,
; and IX points to the data for the string currently being considered.
; A maximum of 8 strings are allowed.
;
;
; Overhead Area: IY+n
; -------------------
;
; Offset  Length  Description
; ------  ------  -----------
; +00     10      Address of data area for each string
; +10     1       String presence flags (bit reset if string in use)
; +11     10      Note length of current note for each string
; +21     1       String counter
; +22     1       String presence flags, shifted with string counter
; +23     2       Address of pointer to string data area
; +25     2       Shortest current note length (=length to play)
; +27     2       Tempo value
; +29     1       Waveform number for volume effects
; +2a     1       Notes changed flag
; +2b     0d      FP routine used to calculate tempo value
; +38     4       Unused
;
;
; String Data Areas: IX+n
; -----------------------
;
; Offset  Length  Description
; ------  ------  -----------
; +00     1       Current semitone number
; +01     1       $ff, or MIDI channel 0-15
; +02     1       String number 0-7
; +03     1       Base semitone number (12*octave)
; +04     1       Volume level (bit 4 set=use volume effect)
; +05     1       Note length
; +06     2       String interpretation pointer
; +08     2       String end+1
; +0a     1       Infinite repeat flag
; +0b     1       Open bracket depth
; +0c     2       String start
; +0e     8       Opening bracket addresses (max depth 4)
; +16     1       Close bracket depth
; +17     0a      Close bracket addresses (max depth 5)
; +21     1       # tied notes
; +22     16      Note lengths for tied notes (max 11)

; *************************************************
; *** SPECTRUM +3 ROM 2 DISASSEMBLY (+3DOS ROM) ***
; *************************************************

; The Spectrum ROMs are copyright Amstrad, who have kindly given permission
; to reverse engineer and publish Spectrum ROM disassemblies.


; =====
; NOTES
; =====

; ------------------------
; Disassembly Contributors
; ------------------------
; Garry Lancaster
; John Elliott
;
; The ROM disassembly was created with the aid of dZ80 V1.10, and incorporates work from
; "The canonical list of +3 oddities" by Ian Collier.

; -----------------
; Assembler Details
; -----------------

; This file can be assembled to produce a binary image of the ROM
; with Interlogic's Z80ASM assembler (available for Z88, QL, DOS and Linux).
; Note that the defs directive is used and this causes a block of $00 bytes to be created.

;**************************************************

        org     $0000

      IF garry
n0000   jr      n0000
        jp      n22c5x
        jp      n196a
n0008   defm    "PLUS3DOS"
n0010   defb    $2f, $58, $32, $9a, $2f, $9e, $34, $e3
        defb    $80, $01, $c0, $05, $c4, $09, $c8, $0d
        defb    $61, $0f, $cc, $14, $51, $00, $13, $16
        defb    $24, $17, $56, $19, $10, $13, $14, $ed
        defb    $79, $01, $06, $7f, $3e, $c3, $fb, $c9
      ELSE
n0000   defs    8
n0008   defm    "PLUS3DOS"
n0010   defs    40
      ENDIF

; The maskable interrupt routine

n0038   push    af
        push    hl
        ld      hl,(FRAMES)
        inc     hl              ; increment FRAMES
        ld      (FRAMES),hl
        ld      a,h
        or      l
        jr      nz,n0048
        inc     (iy+$40)        ; increment high byte of FRAMES
n0048   push    bc
        push    de
        call    n2358           ; scan the keyboard
        call    n0068           ; test for disk motor timeout
        pop     de
        pop     bc
        pop     hl
        pop     af
        ei
        ret

      IF garry
        jp      n3a24           ; IDE_STREAM_OPEN
        jp      n3cc9           ; IDE_STREAM_CLOSE
        jp      n3d5f           ; IDE_STREAM_IN
        jp      n3d55           ; IDE_STREAM_OUT
        jp      n3d64           ; IDE_STREAM_PTR
        nop
      ELSE
        defs    16
      ENDIF

; The Non-maskable interrupt

n0066   retn                    ; do nothing

; The disk motor timeout subroutine

n0068   ld      bc,$7ffd
        ld      a,(BANKM)
        or      $07
        out     (c),a           ; page in page 7
        ld      a,(timeout)
        or      a
        jr      z,n0095         ; exit if motor already off
        ld      a,(FRAMES)
        bit     0,a
        jr      nz,n0095        ; only decrement count every other frame
        ld      a,(timeout)
        dec     a               ; decrement timeout count
        ld      (timeout),a
        jr      nz,n0095        ; exit if not yet zero
        ld      bc,$1ffd
        ld      a,(BANK678)
        and     $f7
        ld      (BANK678),a
        out     (c),a           ; turn motor off
n0095   ld      bc,$7ffd
        ld      a,(BANKM)
        out     (c),a           ; restore memory configuration
        ret

      IF garry
        defb    0, 0
        jp      n2820           ; IDE_VERSION
        jp      n275b           ; IDE_INTERFACE
        jp      n2845           ; IDE_INIT
        jp      n282a           ; IDE_DRIVE
        jp      n2524           ; IDE_SECTOR_READ
        jp      n2529           ; IDE_SECTOR_WRITE
        jp      n2a0f           ; IDE_FORMAT
        jp      n2bd6           ; IDE_PARTITION_FIND
        jp      n2df0           ; IDE_PARTITION_NEW
        jp      n2d19           ; IDE_PARTITION_INIT
        jp      n2f94           ; IDE_PARTITION_ERASE
        jp      n2c1d           ; IDE_PARTITION_RENAME
        jp      n2b77           ; IDE_PARTITION_READ
        jp      n2ba0           ; IDE_PARTITION_WRITE
        jp      n2c49           ; IDE_PARTITION_WINFO
        jp      n2ca2           ; IDE_PARTITION_OPEN
        jp      n2ce9           ; IDE_PARTITION_CLOSE
        jp      n3080           ; IDE_PARTITION_GETINFO
        jp      n3084           ; IDE_PARTITION_SETINFO
        jp      n317e           ; IDE_SWAP_OPEN
        jp      n2ce9           ; IDE_SWAP_CLOSE
        jp      n3124           ; IDE_SWAP_OUT
        jp      n3107           ; IDE_SWAP_IN
        jp      n3141           ; IDE_SWAP_EX
        jp      n30b0           ; IDE_SWAP_POS
        jp      n30bc           ; IDE_SWAP_MOVE
        jp      n31d4           ; IDE_SWAP_RESIZE
        jp      n321a           ; IDE_DOS_MAP
        jp      n3363           ; IDE_DOS_UNMAP
        jp      n33c0           ; IDE_DOS_MAPPING
        jp      n349f           ; IDE_DOS_UNPERMANENT
        jp      n3524           ; IDE_SNAPLOAD
      ELSE
        defs    98
      ENDIF

; The DOS routines jump block

n0100   jp      n019f           ; DOS_INITIALISE
n0103   jp      n01cd           ; DOS_VERSION
n0106   jp      n062d           ; DOS_OPEN
n0109   jp      n0740           ; DOS_CLOSE
n010c   jp      n0761           ; DOS_ABANDON
n010f   jp      n08b1           ; DOS_REF_HEAD
n0112   jp      n10ea           ; DOS_READ
n0115   jp      n11fe           ; DOS_WRITE
n0118   jp      n11a8           ; DOS_BYTE_READ
n011b   jp      n1298           ; DOS_BYTE_WRITE
n011e   jp      n0a19           ; DOS_CATALOG
n0121   jp      n08f2           ; DOS_FREE_SPACE
n0124   jp      n0924           ; DOS_DELETE
n0127   jp      n096f           ; DOS_RENAME
n012a   jp      n1ace           ; DOS_BOOT
n012d   jp      n090f           ; DOS_SET_DRIVE
n0130   jp      n08fc           ; DOS_SET_USER
n0133   jp      n1070           ; DOS_GET_POSITION
n0136   jp      n108c           ; DOS_SET_POSITION
n0139   jp      n1079           ; DOS_GET_EOF
n013c   jp      n01d8           ; DOS_GET_1346
n013f   jp      n01de           ; DOS_SET_1346
n0142   jp      n05c2           ; DOS_FLUSH
n0145   jp      n08c3           ; DOS_SET_ACCESS
n0148   jp      n0959           ; DOS_SET_ATTRIBUTES
n014b   jp      n0706           ; DOS_OPEN_DRIVE
n014e   jp      n02e8           ; DOS_SET_MESSAGE
n0151   jp      n1847           ; DOS_REF_XDPB
n0154   jp      n1943           ; DOS_MAP_B
n0157   jp      n1f27           ; DD_INTERFACE
n015a   jp      n1f32           ; DD_INIT
n015d   jp      n1f47           ; DD_SETUP
n0160   jp      n1e7c           ; DD_SET_RETRY
n0163   jp      n1bff           ; DD_READ_SECTOR
n0166   jp      n1c0d           ; DD_WRITE_SECTOR
n0169   jp      n1c16           ; DD_CHECK_SECTOR
n016c   jp      n1c24           ; DD_FORMAT
n016f   jp      n1c36           ; DD_READ_ID
n0172   jp      n1e65           ; DD_TEST_UNSUITABLE
n0175   jp      n1c80           ; DD_LOGIN
n0178   jp      n1cdb           ; DD_SEL_FORMAT
n017b   jp      n1edd           ; DD_ASK_1
n017e   jp      n1ee9           ; DD_DRIVE_STATUS
n0181   jp      n1e75           ; DD_EQUIPMENT
n0184   jp      n1bda           ; DD_ENCODE
n0187   jp      n1cee           ; DD_L_XDPB
n018a   jp      n1d30           ; DD_L_DPB
n018d   jp      n1f76           ; DD_L_SEEK
n0190   jp      n20c3           ; DD_L_READ
n0193   jp      n20cc           ; DD_L_WRITE
n0196   jp      n212b           ; DD_L_ON_MOTOR
n0199   jp      n2150           ; DD_L_T_OFF_MOTOR
n019c   jp      n2164           ; DD_L_OFF_MOTOR
      IF garry
        jp      n39bd           ; IDE_ACCESS_DATA
        jp      n2475           ; IDE_IDENTIFY
        jp      n29d8           ; IDE_PARTITIONS
n019f   ld      a, ($df9d)      ; DOS_INITIALISE
        push    af
      ELSE
n019f
      ENDIF

; DOS_INITIALISE
        ld      hl,pg_buffer
        ld      de,pg_buffer+1
        ld      bc,$09ff
        ld      (hl),$00
        ldir                    ; clear DOS workspace variables
        call    n1f27           ; DD_INTERFACE
      IF garry
        jr      nc,n01bc        ; move on if no interface
      ELSE
        ld      hl,$0080        ; max RAMdisk, zero cache
        ld      d,h
        ld      e,h
        jr      nc,n01c2        ; move on if no interface
      ENDIF
        call    n1f32           ; DD_INIT
        call    n17d0           ; initialise A: & B: extended XDPBs
n01bc   ld      hl, $0878       ; $78 RAMdisk buffers, $08 cache buffers
        ld      de, $0008
n01c2   push    de
        call    n1820           ; initialise RAMdisk
        pop     de
        call    n1539           ; setup cache
      IF garry
        call    n0500
        pop     af
        ld      ($df9d), a
        jp      n2845
      ELSE
        jp      n0500           ; set default drive and exit
      ENDIF


; DOS_VERSION

n01cd   xor     a
    IF garry
        ld      b, 1
        sub     b
        ld      a, 0
        ld      b,a
        ld      c,a             ; A=BC=0
        ld      de,$0101        ; DE=version info
    ELSE
        ld      b,a
        ld      c,a             ; A=BC=0
      IF spanish
        ld      de,$0101        ; DE=version info
      ELSE
        ld      de,$0100        ; DE=version info
      ENDIF
    ENDIF
      IF spanish
        ld      hl,$0070        ; HL=?
      ELSE
        ld      hl,$0069        ; HL=?
      ENDIF
        scf                     ; signal success
        ret

; DOS_GET_1346

n01d8   call    n1a48           ; get RAMdisk info
        jp      n1530           ; get cache info & exit

; DOS_SET_1346

n01de   push    de              ; save new cache info
        ex      de,hl           ; HL=new RAMdisk info
        call    n1a48           ; get HL=old RAMdisk info
        or      a
        sbc     hl,de           ; set Z if no change in RAMdisk
        ex      de,hl
        scf                     ; set success flag
        call    nz,n1a52        ; change RAMdisk if necessary
        pop     de              ; restore new cache info
        ret     nc              ; exit if error changing RAMdisk
        ex      de,hl
        call    n1530           ; get old cache info
        ex      de,hl
        or      a
        sbc     hl,de           ; set Z if no change in cache
        add     hl,de
        scf
        call    nz,n1535        ; change cache if necessary
        ret

; Subroutine to copy BC bytes from HL to DE within page A, then page
; back original page

n01fb   inc     c
        dec     c
        jr      nz,n0202
        inc     b
        dec     b
        ret     z               ; exit if no bytes to copy
n0202   call    n0207           ; page in A
        ldir                    ; copy bytes, then following routine pages
                                ; back original bank & exits

; Subroutine to page in bank A (gives A=previous bank)

n0207   push    hl
        push    bc
        ld      b,a
        ld      hl,BANKM
        ld      a,(hl)
        and     $07
        push    af              ; stack previous bank
      IF garry
        ld      a, (hl)
        and     $f8
        or      b
        ld      bc, $7ffd
        ld      (hl), a
        out     (c), a
      ELSE
        cp      b
        jr      z,n0227         ; exit if no change
        ld      a,(hl)
        and     $f8
        or      b               ; new value
        ld      b,a
        ld      a,r             ; interrupt status to P/V
        ld      a,b
        ld      bc,$7ffd
        di
        ld      (hl),a
        out     (c),a           ; page in new bank
        jp      po,n0227
        ei                      ; restore interrupts if necessary
      ENDIF
n0227   pop     af              ; restore previous bank
        pop     bc
        pop     hl
        ret

; Subroutine to find address of buffer A in 1346 area
; On exit, HL=address, A=bank

n022b   add     a,a             ; A=offset/256
        ld      l,a
        or      $c0
        ld      h,a             ; H=high byte
        ld      a,l
        ld      l,$00           ; L=start of buffer
        rlca
        rlca
        rlca
        and     $06             ; A=bank 0,2,4 or 6
        cp      $04
        ret     nc              ; exit if 4 or 6
        inc     a               ; else use 1 or 3
        ret

; Subroutine to copy IX bytes from HL in page C to DE in page B

n023d   ld      a,c
        cp      b
        jr      nz,n0247        ; move on if pages different
        push    ix
        pop     bc
        jp      n01fb           ; else just copy within page (now in A)
n0247   push    bc
        call    n02c4           ; get #bytes to move if page C below $c000
        call    n01fb           ; move them
        pop     bc
        push    bc
        ld      a,b             ; get #bytes to move if page B below $c000
        ex      de,hl           ; opposite direction
        call    n02c4           ; calculate number
        ex      de,hl
        call    n01fb           ; move them
        push    ix
        pop     bc
        ld      a,b
        or      c
        pop     bc
        ret     z               ; exit if all moved
        ld      a,r             ; get interrupt status
        di                      ; disable interrupts
        push    af
        or      a
        call    n0273           ; save $20 bytes at $bfe0
        call    n0288           ; copy bytes via buffer at $bfe0
        scf
        call    n0273           ; restore $20 bytes at $bfe0
        pop     af
        ret     po
        ei                      ; restore interrupts if necessary
        ret

; Subroutine to copy $20 bytes from pg_buffer to $bfe0 (or vice-versa if carry
; set)

n0273   push    hl
        push    de
        push    bc
        ld      bc,$0020
        ld      de,pg_buffer
        ld      hl,$bfe0
        jr      nc,n0282
        ex      de,hl           ; exchange if required
n0282   ldir                    ; copy bytes
        pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to copy IX bytes from HL in page C to DE in page B, using
; a $20-byte buffer at $bfe0

n0288   push    ix
        ex      (sp),hl
        ld      a,h
        or      a
        jr      nz,n0294        ; move on if >=$100 bytes left
        ld      a,l
        cp      $20
        jr      c,n0296         ; move up to $20 bytes at a time
n0294   ld      a,$20
n0296   push    bc              ; save page numbers
        ld      c,a
        ld      b,$00
        or      a
        sbc     hl,bc           ; reduce #bytes left to copy
        pop     bc              ; restore page numbers
        ex      (sp),hl
        pop     ix
        or      a
        ret     z               ; exit if no more bytes to copy
        push    de
        push    bc
        push    af
        ld      b,a
        ld      a,c
        ld      c,b
        ld      b,$00           ; A=page to copy from, BC=#bytes
        ld      de,$bfe0
        call    n01fb           ; copy bytes to $bfe0
        pop     af
        pop     bc
        pop     de
        push    hl
        push    bc
        ld      c,a
        ld      a,b
        ld      b,$00           ; A=page to copy to, BC=#bytes
        ld      hl,$bfe0
        call    n01fb           ; copy bytes from $bfe0
        pop     bc
        pop     hl
        jr      n0288           ; loop back until copied all

; Subroutine to calculate BC=#bytes that can be moved to DE
; If DE is in the top segment, no bytes can be moved
; IX initially contains total #bytes to move, and on exit contains #bytes
; that will be left after this move

n02c4   push    hl
        ld      bc,$0000        ; move zero bytes if dest in top segment
        ld      hl,$c000
        or      a
        sbc     hl,de
        jr      c,n02e6         ; exit if destination in top segment
        jr      z,n02e6
        push    ix
        pop     bc              ; BC=#bytes
        or      a
        sbc     hl,bc
        add     hl,bc
        jr      nc,n02dd        ; move on if space for all bytes
        ld      b,h             ; else use space available
        ld      c,l
n02dd   push    ix
        pop     hl
        or      a
        sbc     hl,bc
        push    hl
        pop     ix              ; IX=bytes left to move after this
n02e6   pop     hl
        ret

; DOS_SET_MESSAGE

n02e8   or      a
        jr      nz,n02ee
        ld      hl,$0000        ; use $0000 to disable
n02ee   ld      de,(rt_alert)   ; get old routine address
        ld      (rt_alert),hl   ; set new routine address
        ex      de,hl
        ret

; Subroutine to do an ALERT message for error A on drive C

n02f7   ld      b,a
        ld      hl,(rt_alert)
        ld      a,h
        or      l
        ld      a,b
        jr      nz,n0302        ; if ALERT routine exists, go to do it
        inc     l               ; otherwise exit with HL=1
        ret
    IF garry
n0302   push    bc
        ld      hl, n03ae
        ld      (al_resp), hl
        call    n033a
        pop     bc
        push    bc
        call    n0332
        pop     bc
        sub     $01
        ccf
        ld      a,b
        ret        
    ELSE
      IF spanish
n0302   push    bc              ; save drive
        call    n033a
        pop     bc
        push    bc
        call    n0332
        pop     bc
        sub     $01
        ccf
        ld      a,b
        ret
      ELSE
n0302   push    bc              ; save drive
        call    n033a           ; generate error message
        push    hl              ; save address
        ld      de,al_resp
        push    de
        ld      hl,n04cc
        ld      bc,$0007
        ldir                    ; copy response key list
        pop     de
        pop     hl
        push    de
        call    n0332           ; call the ALERT routine
        pop     de
        ld      hl,n04d3        ; address of reply value string
        ld      b,a
n031e   ld      a,(de)
        cp      $ff
        jr      z,n032b         ; move on if end of reply string
        cp      b
        ld      a,(hl)          ; get reply value
        jr      z,n032c         ; move on if match
        inc     de
        inc     hl
        jr      n031e           ; loop back
n032b   xor     a               ; use "Cancel"
n032c   sub     $01             ; carry set for "Cancel", Z set for "Retry"
        ccf                     ; invert carry
        pop     bc              ; restore drive
        ld      a,b             ; restore error
        ret
      ENDIF
    ENDIF
; Subroutine to call ALERT subroutine with error message in HL

n0332   push    hl
        ld      hl,(rt_alert)
        ex      (sp),hl
        ret

; Subroutine to generate change disk message

n0338   ld      a,$0a           ; message 10

; Subroutine to generate recoverable error message A, returns address in HL
      IF garry
        ld      hl, l03cd
        ld      (al_resp), hl
      ENDIF
      IF garry=0 && spanish
n033a   ld      ix,al_resp      ; address to place message
      ELSE
n033a   ld      ix,al_resp+7    ; address to place message
      ENDIF
        push    ix
        call    n0349           ; generate it
        ld      (ix+$00),$ff    ; add a terminator
        pop     hl              ; restore address
        ret

; Subroutine to put recoverable error message address for error A at IX

n0349   and     $7f             ; mask off bit 7
      IF garry
        ld      hl, (al_resp)
      ELSE
        ld      hl,n03ae        ; address of message 0
      ENDIF
        ld      b,a
        inc     b
        jr      n0357           ; go to find address
n0352   ld      a,(hl)
        inc     hl
        inc     a
        jr      nz,n0352        ; skip next message
n0357   djnz    n0352           ; back until at correct message
n0359   ld      a,(hl)          ; get next char
        inc     hl
        cp      $ff
        ret     z               ; exit if end of message
        push    hl
        call    n0365           ; process next char
        pop     hl
        jr      n0359           ; back for more chars

; Subroutine to process a character in the error message generator

n0365   or      a
        jp      p,n03a8         ; move on if standard ASCII value
        cp      $fe
        jr      z,n03a7         ; go to insert drive letter
        cp      $fd
        jr      z,n0378         ; go to insert track number
        cp      $fc
      IF garry
        jr      z, $0394
        cp      $fb
        jr      z, n037d
        cp      $fa
        jr      nz, $033c
        ld      (ix), $10
        inc     ix
        ld      a, (BORDCR)
        and     7
        jr      n03a8
n037d   ld      (ix), $10
        inc     ix
        ld      a, (BORDCR)
        and     $38
        cp      $20
        jr      nc, nn390
        ld      a, 5
        jr      nn392
nn390   ld      a, 2
nn392   jr      n03a8
      ELSE
        jr      nz,n0349        ; if not sector, go to include submessage
      ENDIF
        ld      a,e             ; sector=E
        jr      n0379
n0378   ld      a,d             ; track=D
n0379   push    de
        push    bc
        ld      l,a
        ld      h,$00
        ld      d,h
        ld      bc,$ff9c
        call    n0392           ; generate 100s digit
        ld      bc,$fff6
        call    n0392           ; generate 10s digit
        ld      a,l
        add     a,'0'
        pop     bc
        pop     de
        jr      n03a8           ; insert units digit
n0392   ld      a,$ff
n0394   push    hl
        inc     a
        add     hl,bc
        jr      nc,n039d
        ex      (sp),hl
        pop     hl
        jr      n0394           ; loop back until value in A
n039d   pop     hl
        or      a
        jr      z,n03a3         ; move on if zero
        ld      d,'0'
n03a3   add     a,d             ; form character
        ret     z               ; exit if none
        jr      n03a8
n03a7   ld      a,c             ; drive=C
n03a8   ld      (ix+$00),a      ; add character to message
        inc     ix
        ret

; Recoverable error message table

n03ae   defm    $8b, "not ready", $8f, $ff
        defm    $8c, "write protected", $8f, $ff
        defm    $8d, "seek fail", $8f, $ff
        defm    $8e, "data error", $8f, $ff
        defm    $8e, "no data", $8f, $ff
        defm    $8e, "missing address mark", $8f, $ff
        defm    $8b, "bad format", $8f, $ff
        defm    $8e, "unknown error", $8f, $ff
        defm    $8c, "changed, please replace", $8f, $ff
        defm    $8c, "unsuitable", $8f, $ff
        defm    "Please put the disk for ", $fe, ": into the drive then press "
        defm    "any key", $ff
        defm    "Drive ", $fe, ": ", $ff
        defm    $8b, "disk ", $ff
        defm    $8b, "track ", $fd, ", ", $ff
        defm    $8d, "sector ", $fc, ", ", $ff
        defm    " - Retry, Ignore or Cancel? ", $ff
      IF garry=0 && spanish=0
n04cc   defm    "rRiIcC", $ff
n04d3   defb    1,1,2,2,0,0
      ENDIF

; Subroutine to shift DE right A times

n04d9   or      a
        ret     z               ; exit if A=0
n04db   srl     d               ; shift right
        rr      e
        dec     a
        jr      nz,n04db        ; back for more
        ret

; Subroutine to shift DE left A times

n04e3   or      a
        ret     z               ; exit if A=0
        ex      de,hl
n04e6   add     hl,hl           ; shift left
        dec     a
        jr      nz,n04e6        ; back for more
        ex      de,hl
        ret

; Subroutine to call routine address in HL

n04ec   jp      (hl)

; Subroutine to convert lowercase drive letters to uppercase

n04ed   cp      'a'
n04ef   ret     c
        cp      'z'+1
        ret     nc
        add     a,$e0           ; if lowercase, convert to uppercase
        ret

    IF garry=0
      IF spanish
        defs    56
      ELSE
        defs    10
      ENDIF
    ENDIF

; Sets default drive to first found with XDPB
; If none, A: is set as default

n0500   ld      bc,$1041        ; 16 drives, A: to P:
n0503   ld      a,c
      IF garry
        call    n184d
        ld      a, c
        jr      c, n0517
        inc     c               ; increment drive letter
        djnz    n0503           ; back for more
        ld      a,'A'
n0517   ld      (def_drv),a     ; set default drive A:
        ld      (LODDRV), a
        ld      (SAVDRV), a
      ELSE
        ld      (def_drv),a     ; set drive as default
        call    n184d           ; get XDPB for drive
        ret     c               ; exit if XDPB available
        inc     c               ; increment drive letter
        djnz    n0503           ; back for more
        ld      a,'A'
        ld      (def_drv),a     ; set default drive A:
      ENDIF
        ret

; Subroutine to get FCB for file B & test if open for reading

n0514   call    n0525           ; get FCB & test if open
        ret     nc              ; exit if error
        rra                     ; test if open for read
        ld      a,$1d           ; error "file not open"
        ret

; Subroutine to get FCB for file B & test if open for writing

n051c   call    n0525           ; get FCB & test if open
        ret     nc              ; exit if error
        rra
        rra                     ; test if open for write
        ld      a,$1d           ; error "file not open"
        ret

; Subroutine to get FCB for file B & test if open

n0525   call    n054b           ; get FCB & access mode
        ret     nc              ; exit if error
        rlca
        rra                     ; bit 7 to carry
        ret     c               ; return with success if open
        ld      a,$1d           ; file not open error
        ret

; Subroutine to clear FCB for closed file B
; *BUG* Clears one byte too many; this can result in user area for the
; next FCB being erroneously set to 0

n052f   call    n054b           ; get FCB & access mode
        ret     nc              ; exit if error
        rla
        ccf                     ; inverted bit 7 to carry
        ld      a,$1d           ; file not open
        ret     nc              ; return with error if open
        push    hl              ; save registers
        push    de
        push    bc
        ld      h,b
        ld      l,c
        ld      (hl),$00
        ld      d,b
        ld      e,c
        inc     de
      IF garry
        ld      bc, $0037
      ELSE
        ld      bc,$0038        ; *BUG* should be $0037
      ENDIF
        ldir                    ; clear FCB
        pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to get FCB (in BC) of file B. Returns access mode/flags in A.

n054b   push    hl              ; save registers
        push    de
        ld      a,b             ; get file number
        cp      $10
        ld      a,$15
        jr      nc,n0566        ; if >$0f, exit with bad parameter error
        ld      hl,fcbs-$0038
        ld      de,$0038
        inc     b
n055b   add     hl,de
        djnz    n055b
        ld      b,h
        ld      c,l             ; BC=address of FCB
        ld      hl,$0020
        add     hl,bc
        ld      a,(hl)          ; get access mode
        scf                     ; success
n0566   pop     de              ; restore registers
        pop     hl
        ret


; Subroutine to check if file in BC is opened by any other FCB

n0569   ld      hl,$0020
        add     hl,bc
        ld      e,(hl)          ; save access mode
        ld      (hl),$00        ; signal "not opened"
        push    hl
        push    de
        call    n0579           ; check if file opened in any other FCB
        pop     de
        pop     hl
        ld      (hl),e          ; restore access mode
        ret

; Subroutine to check if file in BC can be opened in required access mode

n0579   ld      hl,fcbs
        ld      e,$12           ; 18 files to check
n057e   push    hl
        push    bc
        ld      bc,$0020
        add     hl,bc
        ld      d,(hl)          ; D=file access mode
        inc     hl
        ld      a,(hl)          ; A=file drive
        pop     bc
        pop     hl
        bit     7,d
        jr      z,n05b7         ; move on if file not open
        push    hl
        ld      hl,$0021
        add     hl,bc
        cp      (hl)
        pop     hl
        jr      nz,n05b7        ; move on if different drive
        ld      a,(bc)
        cp      $22             ; check if current file is open drive
        jr      z,n05a3
        ld      a,(hl)
        cp      $22             ; or file we are checking
        call    nz,n0d8a        ; if not, check if files are the same
        jr      nz,n05b7        ; if not, move on
n05a3   push    hl
        ld      hl,$0020
        add     hl,bc
        ld      a,(hl)          ; get access mode of current file
        rrca
        rrca
        and     $03
        ld      h,a             ; H=1 if open shared
        ld      a,d
        and     $03
        or      h
        xor     h               ; Z set if legal access
        ld      a,$1e           ; access denied error
        pop     hl
        ret     nz
n05b7   push    de
        ld      de,$0038
        add     hl,de
        pop     de
        dec     e
        jr      nz,n057e        ; loop back to test more FCBs
        scf
        ret

; DOS_FLUSH

n05c2   call    n04ed           ; make drive uppercase
        call    n0c27           ; ensure disk logged in
        ret     nc              ; exit if error
n05c9   push    bc
        ld      bc,fcbs         ; first FCB
        ld      e,$12           ; 18 files
n05cf   ld      hl,$0020
        add     hl,bc
        bit     7,(hl)
        jr      z,n05e4         ; skip if file not open
        inc     hl
        ld      a,(hl)
        cp      (ix+$1c)        ; is it on same drive?
        scf
        push    de
        call    z,n074c         ; ensure file header & directory up to date
        pop     de
        jr      nc,n05ee        ; exit if error
n05e4   ld      hl,$0038
        add     hl,bc
        ld      b,h
        ld      c,l             ; get to next FCB
        dec     e
        jr      nz,n05cf        ; back for more
        scf                     ; success
n05ee   pop     bc
        ret

; Subroutine to get sector HL to buffer, ensuring all FCBs on same
; drive referencing this sector are up to date
; On entry, D=drive, HL=abs logical sector of a buffer

n05f0   ld      bc,fcbs         ; first FCB
        ld      e,$12           ; check 18 FCBs (16 user+2 system)
n05f5   push    hl
        push    de
        ld      a,d             ; A=drive
        ex      de,hl
      IF garry
        ld      hl,$0021
        add     hl,bc
      ELSE
        ld      hl,$0020
        add     hl,bc
        bit     7,(hl)          ; is file open?
        jr      z,n061f         ; move on if not
        inc     hl
      ENDIF
        cp      (hl)            ; is drive the same?
        jr      nz,n061f        ; move on if not
        inc     hl
        bit     3,(hl)          ; is a sector number in +$2b?
        jr      z,n061f         ; move on if not
        ld      hl,$002b
        add     hl,bc
        ld      a,e
        cp      (hl)            ; check low byte of absolute sector
        jr      nz,n061f        ; move on if different
        inc     hl
        ld      a,d
        cp      (hl)            ; check high byte of absolute sector
        jr      nz,n061f        ; move on if different
        call    n0c20           ; ensure correct disk logged in
        call    c,n132a         ; if no error, get sector to buffer
        jr      nc,n0626
n061f   ld      hl,$0038
        add     hl,bc
        ld      b,h             ; BC=next FCB
        ld      c,l
        scf                     ; success
n0626   pop     de
        pop     hl
        ret     nc              ; exit if error
        dec     e
        jr      nz,n05f5        ; loop back for more FCBs
        ret

; DOS_OPEN

n062d   push    de
        push    bc
        call    n052f           ; clear FCB for file B (& ensure closed)
        call    c,n0adf         ; parse filename to FCB,disallowing wildcards
        call    c,n0c20         ; ensure correct disk logged in
        pop     hl
        pop     de
        ret     nc              ; exit if error
        push    de
        ld      a,l
        ld      hl,$0020
        add     hl,bc
        ld      (hl),a          ; set access mode
        call    n0579           ; ensure file can be opened in this mode
        ld      hl,n0d8a
        call    c,n0dae         ; find first extent of file
        pop     de
        ret     nc              ; exit if error
        jr      nz,n067f        ; move on if not found
        ld      a,e             ; check open action
        or      a
        ld      a,$18
        ret     z               ; "file exists" error for open action 0
        dec     e
        jr      nz,n065f        ; move on for actions 2-4
        call    n06c4           ; find first entry (open action 1)
        call    c,n0801         ; open file, reading any header
        jr      n069b           ; mark file as open & exit
n065f   dec     e
        jr      nz,n066a        ; move on for actions 3 & 4
        call    n06c4           ; find first entry (open action 2)
        call    c,n0859         ; open file, skipping any header
        jr      n069b           ; mark file as open & exit
n066a   push    de
        dec     e
        jr      nz,n0676        ; move on for action 4
        call    n06e0           ; for open action 3, erase any existing .BAK
        call    c,n0983         ; and rename file to .BAK
        jr      n067d           ; go to follow create action
n0676   or      a
        ld      a,$15           ; bad parameter if not action 4
        dec     e
        call    z,n092e         ; for action 4, erase file then do create
n067d   pop     de
        ret     nc              ; exit if error
n067f   ld      a,d
        or      a
        ld      a,$17
        ret     z               ; error "file not found" for create action 0
        dec     d
        jr      nz,n068f        ; move on for create action 2
        call    n06a9           ; for action 1, create an entry
        call    c,n07dc         ; and add a header
        jr      n0696
n068f   or      a
        ld      a,$15           ; "bad parameter" for create actions > 2
        dec     d
        call    z,n06a9         ; for action 2, just create an entry
n0696   ret     nc              ; exit if error
        xor     a               ; A=0 if file was created
        scf
        jr      n069d
n069b   ret     nc              ; exit if error
        sbc     a,a             ; A=$ff if file was opened
n069d   push    af
        ld      hl,$0020
        add     hl,bc
        set     7,(hl)          ; mark FCB as containing an open file
        inc     (ix+$21)        ; increment # open files on drive
        pop     af
        ret

; Subroutine to set up clean directory entry for new file

n06a9   ld      hl,$0020
        add     hl,bc
        ld      a,(hl)
        rra
        rra                     ; check bit 1 of FCB flags
        ld      a,$1e           ; "access denied" error
        call    c,n18f3         ; check disk can be written to
        ld      hl,$0000
        call    c,n0cbe         ; set up clean extent
        ret     nc              ; exit if error
        ld      hl,$0022
        add     hl,bc
        set     0,(hl)          ; signal "directory valid"
        scf
        ret

; Subroutine to find entry for required extent of file

n06c4   call    n0d4a           ; find directory entry of required extent
        jr      nc,n06d8        ; move on if not found
        ld      hl,$0020
        add     hl,bc
        bit     1,(hl)
        scf
        ret     z               ; exit with success if new entry not needed
        call    n0ebe           ; check file can be written to
        call    c,n18f3         ; check disk can be written to
        ret
n06d8   cp      $19             ; error "end of file"
        scf
        ccf
        ret     nz              ; exit unless finding first extent
        ld      a,$17           ; error "file not found"
        ret

; Subroutine to erase any .BAK file existing for file in current FCB

n06e0   push    bc
        ld      h,b
        ld      l,c
        ld      de,sysfcb0
        ld      bc,$0038
        ldir                    ; copy FCB to SYSFCB0
        pop     bc
        ld      a,'B'
        ld      (sysfcb0+9),a
        ld      hl,$4b41
        ld      (sysfcb0+$0a),hl ; set extension in SYSFCB0 to "BAK"
        push    bc
        ld      bc,sysfcb0
        call    n092e           ; erase any existing .BAK file
        pop     bc
        ret     c               ; exit if success
        cp      $17
        scf
        ret     z               ; or with success if error was "file not found"
        or      a
        ret

; DOS_OPEN_DRIVE

n0706   call    n04ed           ; make drive letter uppercase
        ld      d,a             ; save letter
        ld      e,c             ; & access mode
        call    n052f           ; clear FCB for file B (ensure closed)
        ret     nc              ; exit if error
        ld      a,$22
        ld      (bc),a          ; "open drive"
        ld      hl,$0020
        add     hl,bc
        ld      (hl),e          ; access mode
        inc     hl
        ld      (hl),d          ; drive letter
        ld      a,d
        call    n184d           ; get XDPB for drive
        call    c,n0579         ; check can open in required access mode
        ret     nc              ; exit if error
        ld      e,(ix+$05)
        ld      d,(ix+$06)
        inc     de
        ld      a,(ix+$02)
      IF garry
        sub     2
        call    nz, n04e3
      ELSE
        call    n04e3
      ENDIF
        call    n19c0
        sla     e
        rl      d               ; DE="file" length (high bytes)
        ld      hl,$0024
        add     hl,bc
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; set file length
        scf
        jp      n069d           ; set file open & exit

; DOS_CLOSE

n0740   call    n0525           ; get FCB & see if open
        call    c,n0c20         ; ensure correct disk logged in
        call    c,n074c         ; ensure file header & directory up-to-date
        ret     nc              ; exit if error
        jr      n077f           ; go to abandon FCB

; Subroutine to ensure file's +3DOS header & directory entry are up-to-date

n074c   ld      hl,$0020
        add     hl,bc
        bit     1,(hl)
        scf
        ret     z               ; exit with success if file not in write mode
        call    n0797           ; update any +3DOS header with file length
        call    c,n132a         ; get sector to buffer
        call    c,n1719         ; write all changed data on this disk
        call    c,n0cca         ; ensure directory up to date for this file
        ret

; DOS_ABANDON

n0761   call    n0525           ; get FCB & see if open
        call    c,n0c20         ; ensure correct disk logged in
        ret     nc              ; exit if error
        ld      hl,$0020
        add     hl,bc
        bit     1,(hl)
        jr      z,n077f         ; move on if not open in write mode
        inc     hl
        inc     hl
        bit     1,(hl)
        jr      z,n077c         ; move on if new directory entry not needed
        call    n1038           ; clear flag & increment free entries
        call    n0f40           ; deallocate blocks in FCB
n077c   call    n16c6           ; move all inuse BCBs for file to free list
n077f   ld      hl,$0020
        add     hl,bc
        ld      (hl),$00        ; signal "file not open"
        dec     (ix+$21)        ; decrement files open on disk
        call    z,n189d         ; low-level logout disk if none left
        scf                     ; success
        ret

; +3DOS file header signature (issue 1)

n078d   defm    "PLUS3DOS", $1a, $01


; Subroutine to update any +3DOS file header with filelength if necessary
; File position is unaffected

n0797   ld      hl,$0022
        add     hl,bc
        bit     6,(hl)
        scf
        ret     z               ; exit with success if file has no header
        call    n1074           ; get DEHL=file position
        push    hl
        push    de
        call    n07af           ; update header with filelength
        pop     de
        pop     hl
        push    af
        call    n1090           ; restore file position
        pop     af
        ret

; Subroutine to update +3DOS file header with filelength & +3 BASIC header
; Leaves filepointer positioned after header

n07af   ld      hl,$000b
        ld      e,h
        call    n1090           ; set file position to header file length
        ld      hl,$0023
        add     hl,bc
        ld      e,$03
        call    n07d2           ; copy filelength from FCB to file header
        ret     nc              ; exit if error
        xor     a
        call    n12a5           ; MSB of filelength is zero
        ret     nc              ; exit if error
        ld      hl,$0030
        add     hl,bc
        ld      e,$08
        call    n07d2           ; copy +3 BASIC header data from FCB to file
        ret     nc              ; exit if error
        jp      n12e6           ; update header checksum & exit

; Subroutine to copy E bytes from HL into file at current filepointer

n07d2   ld      a,(hl)          ; get next byte
        inc     hl
        call    n12a5           ; copy byte into file
        ret     nc              ; exit if error
        dec     e
        jr      nz,n07d2        ; back for more
        ret

; Subroutine to create a header for a newly-created file

n07dc   ld      e,$0a
        ld      hl,n078d        ; header signature
        call    n07d2           ; copy header signature into file
        ret     nc
        ld      a,$00
        call    n12a5           ; version 0
        ret     nc
        ld      e,$74
n07ed   xor     a
        call    n12a5           ; fill rest of header with nulls
        ret     nc
        dec     e
        jr      nz,n07ed
        call    n12e6           ; set checksum & place filepointer after it
        ret     nc
n07f9   ld      hl,$0022
        add     hl,bc
        set     6,(hl)          ; set "file has header" flag
        scf
        ret

; Subroutine to open file & read any header

n0801   call    n12de           ; check if valid header checksum
        jr      nc,n084d        ; move on if error
        jr      nz,n0852        ; if not, move on (no header)
        ld      e,$0a           ; header signature length
        ld      hl,n078d        ; header signature
n080d   call    n11cb           ; get byte from file
        jr      nc,n084d        ; move on if error
        cp      (hl)
        inc     hl
        jr      nz,n0852        ; move on if doesn't match header signature
        dec     e
        jr      nz,n080d        ; back for more chars
        call    n11cb           ; get version
        jr      nc,n084d        ; move on if error
        cp      $01
        jr      nc,n0852        ; no header if higher version than 0
        ld      hl,$0023
        add     hl,bc
        ld      e,$03
n0828   call    n11cb
        ret     nc
        ld      (hl),a          ; copy filelength from header
        inc     hl
        dec     e
        jr      nz,n0828
        call    n11cb           ; skip high byte of length
        ret     nc
        ld      hl,$0030
        add     hl,bc
        ld      e,$08
n083b   call    n11cb
        ret     nc
        ld      (hl),a          ; copy +3 BASIC data from header
        inc     hl
        dec     e
        jr      nz,n083b
        ld      hl,$0080
        ld      e,h
        call    n1090           ; set filepointer past header record
        jr      n07f9           ; exit, setting "file has header" flag
n084d   cp      $19
        scf
        ccf
        ret     nz              ; error unless "end of file"
n0852   ld      hl,$0000
        ld      e,l
        call    n1090           ; set filepointer to start of file
n0859   ld      hl,$0000
      IF garry
        ld      (filerecs),hl
      ELSE
        ld      (filerecs+1),hl
      ENDIF
        xor     a
        ld      (filerecs+2),a
        ld      hl,n088d
        call    n0dae           ; get last record+1 in file
        ret     nc
        ld      de,(filerecs+1)
        ld      hl,(filerecs-1)
        ld      l,$00           ; DEHL=2*filelength
        srl     d
        rr      e
        rr      h
        rr      l               ; DEHL=filelength
        ld      a,d
        or      a
        ld      a,$22           ; "file too big" error if >8M
        ret     nz
        push    hl
        ld      hl,$0025
        add     hl,bc
        ld      (hl),e          ; store filelength in FCB
        pop     de
        dec     hl
        ld      (hl),d
        dec     hl
        ld      (hl),e
        scf
        ret

; Subroutine to update largest rec# with one from current extent if larger

n088d   call    n0d8a
        ret     nz              ; exit if filenames don't match
        push    bc
        ld      b,h
        ld      c,l
        call    n14c2           ; get ADE=last record number+1
        ld      b,a
        ex      de,hl           ; test against largest found so far
        ld      hl,(filerecs)
        or      a
        sbc     hl,de
        ld      a,(filerecs+2)
        sbc     a,b
        jr      nc,n08ad        ; move on unless larger
        ld      (filerecs),de
        ld      a,b
        ld      (filerecs+2),a  ; set size from current extent
n08ad   pop     bc
        scf
        sbc     a,a             ; success
        ret

; DOS_REF_HEAD

n08b1   call    n0525           ; get FCB & check file is open
        ret     nc              ; exit if not
        ld      ix,$0030
        add     ix,bc           ; IX points to header data
        ld      hl,$0022
        add     hl,bc
        bit     6,(hl)          ; does file have header?
        scf                     ; success
        ret

; DOS_SET_ACCESS

n08c3   ld      e,c             ; E=required access mode
        push    de
        call    n0525           ; get FCB & current access mode
        call    c,n0c20         ; if ok, ensure correct disk logged in
        call    c,n074c         ; ensure file header & directory up-to-date
        pop     de
        ret     nc              ; exit if error
        ld      hl,$0020
        add     hl,bc
        ld      d,(hl)          ; get old access mode
        ld      (hl),e          ; store new (as closed)
        push    hl
        push    de
        call    n0579           ; check if can open in this mode
        pop     de
        pop     hl
        jr      nc,n08ef        ; if not, go to restore old mode & exit
        bit     1,e
        jr      z,n08eb         ; move on if not opening for write
        call    n0ebe           ; check file can be written to
        call    c,n18f3         ; check disk can be written to
        jr      nc,n08ef        ; exit, restoring mode, if error
n08eb   set     7,(hl)          ; set file open
        scf                     ; success
        ret
n08ef   ld      (hl),d          ; restore old mode
        or      a
        ret

; DOS_FREE_SPACE

n08f2   call    n04ed           ; make drive letter uppercase
        call    n0c27           ; ensure allocation bitmap up-to-date
        ret     nc              ; exit if error
        jp      n0fa9           ; move on to calculate free space

; DOS_SET_USER

n08fc   cp      $ff
        jr      z,n090a         ; move on to return current default user area
        cp      $10             ; check in range 0-15
        ld      b,a
        ld      a,$15
        ret     nc              ; error 21 - bad parameter if not
        ld      a,b
        ld      (def_user),a    ; set default user area
n090a   ld      a,(def_user)    ; get default user area
        scf                     ; success
        ret

; DOS_SET_DRIVE

n090f   call    n04ed           ; make letter uppercase
        cp      $ff
        jr      z,n091f         ; move on if current default drive required
        ld      b,a
        call    n184d           ; check drive has an XDPB
        ret     nc              ; exit with error if not
        ld      a,b
        ld      (def_drv),a     ; set default drive
n091f   ld      a,(def_drv)     ; get default drive
        scf                     ; success
        ret

; DOS_DELETE

n0924   ld      bc,sysfcb0
        call    n0af5           ; parse filespec, allowing wildcards
        call    c,n0c20         ; ensure correct disk logged in
        ret     nc
n092e   call    n0569           ; check no source files open by any FCBs
        call    c,n18f3         ; check disk can be written to
        ret     nc              ; exit if error
        ld      hl,n093b        ; routine to delete extents
        jp      n09ad

; Subroutine to delete any directory entry matching one in FCB

n093b   call    n0d84
        ret     nz              ; exit if entry doesn't match
        call    n0ebe
        ret     nc              ; or if file read-only
        push    hl
        push    de
        xor     a
        call    n0f43           ; deallocate blocks in entry
        pop     de
        pop     hl
        ld      (hl),$e5        ; set "deleted" mark in FCB
        call    n0e34           ; copy "direntry" to directory entry DE
        ret     nc
        call    n1040           ; increment #free entries
        sbc     a,a
        ld      (extchg),a      ; set "success" flag
        ret

; DOS_SET_ATTRIBUTES

n0959   ld      (att_clr),de    ; store attribs to set/clear
        ld      bc,sysfcb0
        call    n0af5           ; parse filespec, allowing wildcards
        call    c,n0c20         ; ensure correct disk logged in
        call    c,n18f3         ; check disk can be written to
        ret     nc              ; exit if error
        ld      hl,n09bf        ; routine to change attributes
        jr      n09a7

; DOS_RENAME

n096f   push    de
        ld      bc,sysfcb1
        call    n0adf           ; parse source filespec, ensuring no wildcards
        call    c,n0c20         ; ensure correct disk logged in
        pop     hl
        push    bc
        ld      bc,sysfcb0
        call    c,n0adf         ; parse dest filespec, ensuring no wildcards
        pop     bc
        ret     nc              ; exit if error
n0983   ld      hl,$0021
        add     hl,bc
        ld      a,(sysfcb0+$21)
        xor     (hl)            ; check drives are the same
        ld      a,$1f
        ret     nz              ; error "cannot rename between drives"
        call    n18f3           ; check disk can be written to
        push    bc
        ld      bc,sysfcb0
        call    c,n0569         ; check dest file not open by any FCB
        ld      hl,n0d84
        call    c,n0dae         ; check if dest file exists in directory
        pop     bc
        ret     nc              ; exit if error
        ccf
        ld      a,$18
        ret     z               ; file already exists error
        ld      hl,n09f4        ; rename routine
n09a7   push    hl
        call    n0569           ; check source file not open by any FCB
        pop     hl
        ret     nc              ; exit if error
n09ad   xor     a
        ld      (extchg),a      ; set "no extents changed"
        call    n0dae           ; rename/delete all extents of file
        ret     nc
        ld      a,(extchg)
        or      a               ; check if any extents changed
        ld      a,$17           ; file not found error
        call    nz,n1719
        ret

; Subroutine to change attributes for directory entries matching
; filespec

n09bf   call    n0d84
        ret     nz              ; exit if no match
        push    bc
        ld      a,(att_set)     ; get attribs to set
        ld      c,$ff           ; set mask
        push    hl
        call    n09d8           ; set them
        pop     hl
        ld      a,(att_clr)     ; get attribs to clear
        inc     c               ; clear mask
        call    n09d8           ; clear them
        pop     bc
        jr      n0a10           ; go to update directory entry

; Subroutine to set/clear attributes. HL points to directory entry, A
; contains attributes to set/clear & C contains set/clear mask

n09d8   rla                     ; discard bit 7
        ld      b,$04
        inc     hl
        call    n09e5           ; bits 6->3 on first four chars of filename
        inc     hl
        inc     hl
        inc     hl
        inc     hl
        ld      b,$03           ; bits 2->0 on extension
n09e5   rla
        jr      nc,n09f0        ; move on if attribute not to be affected
        res     7,(hl)          ; reset it
        inc     c
        dec     c
        jr      z,n09f0
        set     7,(hl)          ; set it if mask=$ff
n09f0   inc     hl
        djnz    n09e5           ; back for more
        ret

; Subroutine to rename any directory entry matching filename in SYSFCB1
; to name in SYSFCB0

n09f4   call    n0d84
        ret     nz              ; exit if names don't match
        call    n0ebe
        ret     nc              ; exit if file readonly
        push    de
        ex      de,hl
        ld      hl,sysfcb0
        ld      a,(de)
        and     $10             ; also rename password control entries
        or      (hl)
        ld      (de),a
        inc     de
        inc     hl
        push    bc
        ld      bc,$000b
        ldir                    ; copy new filename to direntry
        pop     bc
        pop     de
n0a10   call    n0e34           ; copy "direntry" to directory entry DE
        ret     nc
        sbc     a,a
        ld      (extchg),a      ; if no error, set successful rename flag
        ret

; DOS_CATALOG

n0a19   ld      (cat_buff),de   ; store buffer address
        ld      (cat_filt),bc   ; store filter & buffer size
        ld      a,$01
        ld      (cat_ents),a    ; store "1 entry completed"
        ld      bc,sysfcb0
        call    n0af5           ; parse filespec to SYSFCB0, wildcards allowed
        call    c,n0c20         ; ensure correct disk logged in
        call    c,n05c9         ; flush drive
        ld      hl,n0a3d
        call    c,n0dae         ; generate catalog
        ld      bc,(cat_size)   ; get B=#completed entries
        ret

; Subroutine to add directory entry to catalog if suitable

n0a3d   push    bc
        call    n0a45           ; process the entry
        pop     bc
        scf
        sbc     a,a             ; set A=$ff, set carry for success
        ret

; Subroutine to process a directory entry & add to catalog if suitable

n0a45   call    n0d8a
        ret     nz              ; exit if doesn't match filespec
        ld      a,(cat_filt)
        rra
        jr      c,n0a58         ; move on if we should include system files
        push    hl
        ld      bc,$000a
        add     hl,bc
        bit     7,(hl)
        pop     hl
        ret     nz              ; exit if system file
n0a58   ld      de,(cat_buff)
        call    n0ac9           ; is it alphabetically less than preloaded?
        ret     nc              ; exit if so
        ld      bc,(cat_size)   ; C=buffer size, B=#completed entries
n0a64   push    hl
        ld      hl,$000d
        add     hl,de           ; get to next entry in buffer
        ex      de,hl
        pop     hl
        dec     c               ; decrement buffer size
        djnz    n0a71           ; move on if more entries to check
        ret     z               ; exit if no space left in buffer
        jr      n0aa1           ; else move to add
n0a71   call    n0ac9           ; does filespec match next buffer entry?
        jr      c,n0a64         ; loop back if alphabetically greater
        jr      z,n0ab9         ; move on if the same
        push    hl
        push    de
        ld      hl,(cat_size)
        ld      h,$00
        dec     hl              ; HL=#catalog buffer entries-1
        ld      b,h
        ld      c,l
        add     hl,hl
        add     hl,bc
        add     hl,hl
        add     hl,hl
        add     hl,bc           ; HL=13*(#catalog buffer entries-1)
        ld      bc,(cat_buff)
        add     hl,bc           ; HL=address of last entry in catalog buffer
        ld      a,l
        sub     e
        ld      c,a
        ld      a,h
        sbc     a,d
        ld      b,a             ; BC=distance between last & current entries
        dec     hl
        ld      de,$000d
        ex      de,hl
        add     hl,de
        ex      de,hl           ; DE=address of end of catalog buffer
        ld      a,b
        or      c
        jr      z,n0a9f
        lddr                    ; shift catalog entries down one (may lose one)
n0a9f   pop     de
        pop     hl
n0aa1   push    hl
        push    de
        inc     hl
        ld      bc,$000b
        ldir                    ; copy entry into buffer
        xor     a
        ld      (de),a
        inc     de
        ld      (de),a          ; set zero size
        ld      hl,(cat_size)
        ld      a,h
        cp      l
        adc     a,$00
        ld      (cat_ents),a    ; increment # completed entries (max=bufsize)
        pop     de
        pop     hl
n0ab9   call    n0f75           ; calculate extent size in K
        ex      de,hl
        ld      bc,$000b
        add     hl,bc
        ld      a,(hl)
        add     a,e             ; add extent size into directory entry size
        ld      (hl),a
        inc     hl
        ld      a,(hl)
        adc     a,d
        ld      (hl),a
        ret

; Subroutine to compare filenames at DE & HL (ignoring attributes)
; and setting Z if they match. Carry set if filename at HL > one at DE

n0ac9   push    hl
        push    de
        push    bc
        ld      b,$0b           ; 11 chars to check
        inc     hl
n0acf   ld      a,(hl)
        add     a,a
        ld      c,a
        ld      a,(de)
        add     a,a
        cp      c               ; compare chars without attribute bits
        jr      nz,n0adb        ; if different, exit
        inc     de
        inc     hl
        djnz    n0acf           ; back for more
n0adb   pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to parse filespec at HL into FCB at BC, giving
; error if filespec illegal or contains wildcards

n0adf   call    n0b3f           ; parse filespec
        ret     nc              ; exit if error
        ld      hl,$0001
        add     hl,bc
        ld      e,$0b
n0ae9   ld      a,(hl)
        inc     hl
        cp      '?'             ; check for wildcard characters
        ld      a,$14
        ret     z               ; exit with "bad filename" if found
        dec     e
        jr      nz,n0ae9        ; back for more
        scf
        ret

; Subroutine to parse filespecs, allowing wildcards

n0af5   jp      n0b3f           ; jump to the routine

; Subroutine to set user area & drive letter specified in filename
; Should exit with HL pointing to ":"
; On exit, carry reset if neither found

n0af8   call    n0b02           ; set user area if specified
        jr      nc,n0b21
        call    n0b21           ; set drive letter if specified
        scf
        ret

; Subroutine to check if chars at HL are a user area
; If so, exits with user area set, carry set & HL pointing after user area
; in filename

n0b02   call    n0b38           ; check if char is digit
        ret     nc              ; exit if not
        ld      e,a             ; save digit
        call    n0bd3           ; get next char
        call    c,n0b38         ; check if its a digit
        jr      nc,n0b1b        ; if not, use single digit
        ld      d,a             ; save ls digit
        ld      a,e
        add     a,a
        ld      e,a
        add     a,a
        add     a,a
        add     a,e
        add     a,d
        ld      e,a             ; E=user area
        call    n0bd3           ; get next char
n0b1b   ld      a,e
        cp      $10
        ret     nc              ; exit if invalid user area
        ld      (bc),a          ; save user area in FCB
        ret

; Subroutine to check if char at HL is a drive letter
; If so, exits with drive letter set, carry set & HL pointing after drive
; letter in filename

n0b21   call    n0bc9           ; get next char
        ret     nc              ; exit if none
        cp      'A'
        ccf
        ret     nc              ; or if <"A"
        cp      'Q'
        ret     nc              ; or if >"P"
        push    hl
        ld      hl,$0021
        add     hl,bc
        ld      (hl),a          ; save as drive letter in FCB
        pop     hl
        call    n0bd3           ; get next char
        scf
        ret

; Subroutine to test if A is a digit ('0'-'9')
; If so, exits with carry set & A=value

n0b38   sub     '0'
        ccf                     ; error if <"0"
        ret     nc
        cp      $0a             ; set carry if user area
        ret

; Subroutine to parse filename at HL to FCB in BC (preserved)
; Carry reset & error $14 if illegal filespec

n0b3f   push    bc
        call    n0b47           ; parse filename
        pop     bc
        ld      a,$14           ; error "bad filename"
        ret

; Subroutine to parse filename at HL to FCB in BC (not preserved)
; Exits with carry set if legal filespec

n0b47   push    hl
        ld      hl,$0021
        add     hl,bc
        ld      a,(def_drv)
        ld      (hl),a          ; set drive as default
        pop     hl
        ld      a,(def_user)
        ld      (bc),a          ; set user area as default
        call    n0bc9           ; get next filename char
        jr      nc,n0b7a        ; move on if none
        ld      e,a             ; save char
        push    hl
n0b5c   cp      ':'
        scf
        jr      z,n0b66         ; if drive/user spec found, move on
        call    n0bd3           ; get next char
        jr      c,n0b5c         ; back if found
n0b66   pop     hl
        ld      a,e             ; A=last drive/user char
        jr      nc,n0b80        ; but skip if no drive/user spec
        call    n0af8           ; set user area and/or drive in FCB
        ret     nc              ; exit if not found
        call    n0bc9           ; get char
        ret     nc
        xor     ':'
        ret     nz              ; exit if not ":"
        call    n0bc5           ; get char after ":"
        jr      c,n0b80
n0b7a   inc     bc              ; if no filename, point to start
        ld      e,$0b           ; with 11 chars to blank
        scf
        jr      n0bbc
n0b80   inc     bc              ; move to filename in FCB
        cp      '.'
        ret     z               ; exit if first char is "."
        ld      e,$08
        call    n0b96           ; get up to 8 filename chars
        ccf
        ld      e,$03           ; and up to 3 extension chars
        jr      nc,n0bb3
        xor     '.'
        ret     nz              ; exit if no extension
        call    n0bc5           ; skip "." and get next char
        jr      nc,n0bb3        ; move on if none
n0b96   push    hl
        cp      ' '
        ld      hl,n0bef
        call    nc,n0be5        ; check if char legal
        pop     hl
        jr      c,n0bb3         ; if not, fill rest with spaces
        dec     e
        ret     m               ; exit with error if filename too long
        cp      '*'
        call    z,n0bbc         ; fill rest with ? if "*" wildcard
        ld      (bc),a          ; else, store character
        inc     bc
        call    n0bd3           ; get next
        jr      nz,n0b96        ; loop back if more
        call    c,n0bc5         ; skip any spaces
n0bb3   push    af
        ld      a,' '
        call    n0bbe           ; fill rest with spaces
        pop     af
        ccf                     ; set carry (success)
        ret

; Subroutine to fill E+1 chars in filename with "?" wildcard chars
; Or enter at n0bbe to fill with char in A

n0bbc   ld      a,'?'
n0bbe   inc     e
n0bbf   dec     e
        ret     z               ; exit if done
        ld      (bc),a          ; fill
        inc     bc
        jr      n0bbf

; Subroutine to skip char in filename & get next one

n0bc5   call    n0bd3           ; get next char
        ret     nc              ; exit if end

; Subroutine to get next filename char in A, Z set if end-of-filename

n0bc9   call    n0bd8           ; check for end of filename
n0bcc   ret     nz              ; exit if not
        call    n0bd3           ; check if ended by space or $ff
        jr      c,n0bcc         ; skip until $ff encountered
        ret

; Subroutine to get next filename char (exits with C reset
; if already end of filename)

n0bd3   ld      a,(hl)
        cp      $ff
        ret     z               ; exit if end of filename
        inc     hl              ; next character

; Subroutine to get current filename char as uppercase in A,
; checking for end of filename ($ff or space), setting Z if so

n0bd8   ld      a,(hl)          ; get next char
        cp      $ff
        ret     z               ; exit if end of filename
        and     $7f             ; mask to ASCII code
        call    n04ed           ; convert to uppercase
        cp      ' '             ; space?
        scf                     ; set "not $ff"
        ret

; Subroutine to check for illegal chars in filenames
; On entry, A=char & on exit carry & Z set if illegal

n0be5   cp      (hl)            ; test against next illegal char
        scf
        ret     z               ; exit if illegal
        inc     hl              ; get to next char in list
        bit     7,(hl)
        jr      z,n0be5         ; move back for more
        or      a               ; clear carry & reset Z (character legal)
        ret

; List of illegal chars in filenames

n0bef   defm    "!&()+,-./:;<=>[\\]|", $80
      IF garry=0
        defs    30
      ENDIF

; Subroutine to ensure disk for FCB in BC is logged in, if
; necessary building checksum vector, allocation bitmap & directory
; entry information for a drive

n0c20   push    hl
        ld      hl,$0021
        add     hl,bc
        ld      a,(hl)          ; get drive from FCB
        pop     hl
n0c27   call    n1871           ; possibly re-log drive
        ret     nc              ; exit if error
        bit     0,(ix+$1b)
        scf
        ret     nz              ; exit if disk logged in
        push    hl
        push    de
        push    bc
        call    n0ecc           ; initialise allocation bitmap
        set     1,(ix+$1b)      ; set "collecting sector checksums"
        xor     a
        ld      (ix+$22),a
        ld      (ix+$23),a      ; set no free directory entries
        call    n0c74           ; copy last dir entry number to ext XDPB info
        ld      bc,$0000
        ld      hl,n0c61
        call    n0dae           ; generate allocation bitmap & get free entries
        ld      (ix+$24),c
        ld      (ix+$25),b      ; set last used directory entry number
        pop     bc
        pop     de
        pop     hl
        ret     nc              ; exit if error
        set     0,(ix+$1b)      ; drive logged in
        res     1,(ix+$1b)      ; just check sector checksums
        ret

; Subroutine to process a directory entry, either incrementing the number
; of free entries, or updating the allocation bitmap for the files blocks

n0c61   call    n0c67
        scf                     ; success
        sbc     a,a             ; A=$ff
        ret
n0c67   ld      a,(hl)
        cp      $e5             ; is entry unused?
        jp      z,n1040         ; if so, inc #free directory entries & exit
        ld      b,d             ; BC=directory entry number
        ld      c,e
        ld      a,$ff           ; add to allocation bitmap
        jp      n0f43           ; add entry's blocks into bitmap

; Subroutine to copy last directory entry number to extended XDPB info

n0c74   ld      a,(ix+$07)
        ld      (ix+$24),a
        ld      a,(ix+$08)
        ld      (ix+$25),a
        ret

; Subroutine to find extent HL for current file

n0c81   call    n0d19           ; is correct extent in FCB?
        ret     c               ; exit if so
        push    hl
        call    n0cca           ; ensure directory up to date for this file
        pop     hl
        ret     nc              ; exit if error
n0c8b   ex      de,hl
        ld      hl,$000c
        add     hl,bc
        ld      (hl),d          ; store low 5 bits of extent counter in FCB
        inc     hl
        inc     hl
        ld      (hl),e          ; store high 8 bits of extent counter in FCB
        ld      e,$11
        xor     a
n0c97   inc     hl
        ld      (hl),a          ; clear allocation list & records in extent
        dec     e
        jr      nz,n0c97
        call    n0d4a           ; find entry
        ret     c               ; exit if success
        ld      hl,$0022
        add     hl,bc
        set     2,(hl)          ; signal "new extent required"
        or      a
        ret

; Subroutine to get new extent for file if required

n0ca8   call    n0d19           ; check if correct extent in FCB
        jr      nc,n0cb8        ; move on if not
        ld      hl,$0022
        add     hl,bc
        bit     2,(hl)
        jp      nz,n0fd6        ; move on if new extent required
        scf                     ; else success
        ret
n0cb8   push    hl
        call    n0cca           ; ensure directory up to date for this file
        pop     hl
        ret     nc
n0cbe   call    n0c8b           ; set up FCB with clean extent
        ret     c
        cp      $19             ; error "end of file"
        scf
        ccf
        ret     nz              ; exit with error except new extent required
        jp      n0fd6           ; get new directory entry

; Subroutine to ensure directory is up-to-date for current file

n0cca   ld      hl,$0022
        add     hl,bc
        ld      a,(hl)          ; get FCB flags
        and     $03
        scf
        ret     z               ; exit with success if directory up to date
        cp      $02
        jp      z,n1038         ; move on if new entry flag set but not needed
        and     $02
        jr      nz,n0ce9        ; move on if need new entry
        ld      hl,n0d60
        call    n0dae           ; search directory for correct extent
        ret     nc              ; exit if error
        ld      a,$20           ; extent missing error
        ccf
        ret     nz              ; exit with error if extent not found
        jr      n0cff           ; update directory from FCB & exit
n0ce9   call    n0ff6           ; get new directory entry number (DE)
        ret     nc              ; exit if error
        push    hl
        push    de
        push    bc
        call    n1049           ; check if datestamps in use
        jr      nz,n0cfc        ; move on if not
        ld      b,$0a
n0cf7   ld      (hl),$00        ; else zeroise date stamp
        inc     hl
        djnz    n0cf7
n0cfc   pop     bc
        pop     de
        pop     hl

; Subroutine to update directory with current FCB info

n0cff   push    de
        push    bc
        ex      de,hl
        ld      h,b
        ld      l,c
        ld      bc,$0020
        ldir                    ; copy directory entry from FCB to "direntry"
        pop     bc
        pop     de
        call    n0e34           ; copy "direntry" to directory entry DE
        call    c,n1719         ; write all changed buffers back on this disk
        ld      hl,$0022
        add     hl,bc
        res     0,(hl)          ; flag "directory up to date"
        scf
        ret

; Subroutine to check if correct extent for record is in FCB
; On entry, DE=record number
; On exit, carry set if record is within this extent
      IF garry=0
n0d19
      ENDIF
n0d19x  push    bc
        ld      a,(ix+$04)      ; A=EXM extent mask
        cpl
        and     $1f
        ld      b,a             ; B=low 5 bits of extent mask (inverted)
        ld      a,d
        rra
        rra
        rra
        rra
        and     $0f
        ld      l,a             ; L=high 8 bits of required extent counter
        ld      a,e
        add     a,a
        ld      a,d
        adc     a,a
        and     b
        ld      h,a             ; H=low 5 bits of required extent counter
        ld      a,b
        pop     bc
      IF garry
        ret
n0d19   call    n0d19x
      ENDIF
        push    hl
        push    de
        push    bc
        ex      de,hl
        ld      hl,$000e
        add     hl,bc
        ld      b,a
        ld      a,(hl)          ; A=high 8 bits of extent counter from FCB
        xor     e
        jr      nz,n0d46        ; if not same, exit
        dec     hl
        dec     hl
        ld      a,(hl)          ; A=low 5 bits of extent counter from FCB
        xor     d
        and     b
        jr      nz,n0d46        ; if not same, exit
        scf                     ; signal "correct extent"
n0d46   pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to find directory entry with filename & extent counter in FCB

n0d4a   ld      hl,n0d60
        call    n0dae           ; find entry with correct extent counter
        ret     nc              ; exit if error
        ccf
        ld      a,$19
        ret     nz              ; error "end of file" if not found
        push    bc
        ld      d,b
        ld      e,c
        ld      bc,$0020
        ldir                    ; copy entry into FCB
        pop     bc
        scf
        ret

; Subroutine to check if directory entry found (HL) matches one in FCB
; FCB can contain wildcards & $ff for extent bytes (match any extent)
; Z set if match found

n0d60   push    hl
        push    de
        push    bc
        ld      a,(bc)
        xor     (hl)            ; check user area
        call    z,n0d97         ; and filename
        jr      nz,n0d82        ; move on if no match
        ld      a,(de)          ; get EX
        inc     a
        jr      z,n0d78         ; move on if don't care about extent
        ld      a,(ix+$04)
        cpl
        ld      b,a             ; B=inverse EXM
        ld      a,(de)
        xor     (hl)
        and     b
        jr      nz,n0d82        ; move on if wrong extent
n0d78   inc     de
        inc     hl
        inc     de
        inc     hl
        ld      a,(de)          ; get S2
        cp      $ff
        jr      z,n0d82         ; move on if don't care about extent
        xor     (hl)
n0d82   jr      n0d92           ; exit with Z set if match

; Subroutine to check if current file (BC) and file HL are the same
; Enter at n0d84 if user area flag $20 should be ignored, or at
; n0d8a if user areas must exactly match. Z set if match.

n0d84   ld      a,(bc)
        xor     (hl)
        and     $ef             ; mask off user area flag $20
        jr      n0d8c
n0d8a   ld      a,(bc)
        xor     (hl)            ; check if user areas match
n0d8c   push    hl
        push    de
        push    bc
        call    z,n0d97         ; check if filenames match
n0d92   pop     bc
        pop     de
        pop     hl
        scf
        ret

; Subroutine to check if filename in directory entry at HL matches one
; in FCB at BC (may contain ? wildcards). Z set if match.
; On exit, HL points to directory entry after filename & DE points to
; FCB after filename (or at failed chars)

n0d97   push    bc
        ld      d,b
        ld      e,c
        inc     de              ; DE points to FCB's name
        inc     hl              ; HL points to directory entry's name
        ld      b,$0b           ; 11 bytes to check
n0d9e   ld      a,(de)          ; get next char from FCB
        cp      '?'
        jr      z,n0da8         ; ? matches anything
        xor     (hl)            ; compare chars
        and     $7f             ; mask off attributes
        jr      nz,n0dac        ; move on if no match
n0da8   inc     de
        inc     hl
        djnz    n0d9e           ; loop back for more chars
n0dac   pop     bc
        ret

; Subroutine to call subroutine HL with every directory entry in turn
; The subroutine it calls should set Z if it doesn't require any more
; entries. On exit, this routine leaves address of last-accessed entry
; in HL.

n0dae   ld      (rt_dirent),hl  ; store subroutine address
        call    n1653           ; free buffers referencing directory sectors
        ld      de,$0000        ; DE=first directory entry
        push    af
n0db8   ld      a,e
        and     $0f
        jr      nz,n0dc3        ; only get a sector every 16th entry
        pop     af
        call    n0dff           ; get sector & get/set checksum
        ret     nc              ; exit if error
        push    af
n0dc3   pop     af
        push    af
        push    hl
        push    ix
        push    de
        push    bc
        ld      c,a
        ld      b,$07
        ld      a,e
        call    n0e6a           ; calc offset of entry in sector
        call    n023d           ; copy entry to page 7
        pop     bc
        pop     de
        pop     ix
        push    de
        call    n0ded           ; call subroutine rt_dirent
        pop     de
        pop     hl
        jr      nc,n0de7        ; move on if error
        jr      z,n0de7         ; or if done
        call    n0df5           ; increment dir entry number
        jr      nc,n0db8        ; loop back if more
n0de7   ld      hl,direntry     ; HL points to last entry obtained
        inc     sp
        inc     sp              ; drop original AF from stack
        ret

; Subroutine to call the subroutine whose address is at rt_dirent.
; It enters with HL=address of directory entry (direntry)

n0ded   ld      hl,(rt_dirent)
        push    hl              ; stack routine address
        ld      hl,direntry     ; address of directory entry
        ret                     ; "return" to call routine


; Subroutine to increment DE (current directory entry)
; On exit, carry is set if no more entries

n0df5   inc     de              ; increment
        ld      a,(ix+$24)
        sub     e
        ld      a,(ix+$25)
        sbc     a,d             ; test against last
        ret

; Subroutine to get sector for directory entry DE, and get/set checksum
; On exit, AHL=sector buffer address. Error if checksums didn't match

n0dff   push    bc
        push    de
      IF garry
        ld      a, 4
      ELSE
        ld      a, 2
      ENDIF
        call    n04d9           ; DE=logical usable record number
        call    n19c0           ; DE=absolute logical sector number
n0e09   call    n15f4           ; get AHL=page & address of buffer
        jr      nc,n0e31        ; exit if error
        ld      b,a             ; save buffer details
        push    hl
        call    n0e7d           ; get sector checksum & address to place
        jr      c,n0e2d         ; skip reserved sectors
        bit     1,(ix+$1b)
        jr      z,n0e1c         ; move on if just checking
        ld      (hl),a          ; save checksum
n0e1c   cp      (hl)            ; set Z if checksum matches
        scf                     ; set success
        jr      z,n0e2d         ; if checksums match, exit
        call    n166c           ; free buffers referencing unchanged sectors
        ld      a,$08
        call    n1a34           ; recoverable error 8 - disk changed
        jr      nz,n0e2d        ; exit if didn't recover
        pop     hl
        jr      n0e09           ; else loop back to retry
n0e2d   pop     hl              ; restore buffer address to AHL
        jr      nc,n0e31        ; but don't overwrite an error code
        ld      a,b
n0e31   pop     de
        pop     bc
        ret

; Subroutine to copy "direntry" to directory entry (DE), marking
; buffer as changed & updating checksum

n0e34   push    hl
        push    de
        push    bc
        ld      c,e             ; save low byte of directory entry number
      IF garry
        ld      a, 4
      ELSE
        ld      a, 2
      ENDIF
        call    n04d9           ; DE=directory record number
        call    n19c0           ; get DE=absolute logical sector
        push    bc
        ld      bc,$0001        ; dummy FCB address
        call    n1624           ; get buffer to AHL, and flag changed
        pop     bc
        jr      nc,n0e66        ; exit if error
        ld      b,a             ; save buffer page
        push    ix
        push    hl
        push    de
        push    bc
        ld      a,c
        call    n0e6a           ; get address of directory entry
        ex      de,hl
        ld      c,$07
        call    n023d           ; copy "direntry" into directory
        pop     bc
        pop     de
        pop     hl
        pop     ix
        call    n0e7d           ; calculate sector checksum
        jr      c,n0e66
        ld      (hl),a          ; update checksum vector
        scf
n0e66   pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to calculate an offset into a sector buffer for a
; directory entry
; On entry, A=lowbyte of entry number, HL=buffer address
; On exit, DE=direntry, HL=entry address, IX=$20

n0e6a   and     $0f             ; 16 entries per sector
        jr      z,n0e75
        ld      de,$0020
n0e71   add     hl,de
        dec     a
        jr      nz,n0e71
n0e75   ld      de,direntry
        ld      ix,$0020
        ret

; Subroutine to find address of sector DE (abs log) within checksum table
; (returned in HL) returning sector checksum in B
; On entry, BHL=sector buffer address

n0e7d   push    hl
        push    de
        ex      de,hl           ; HL=abs logical sector
        ld      e,(ix+$0b)
        ld      a,(ix+$0c)
        and     $7f
        ld      d,a             ; DE=#directory records
      IF garry
        ld      a, 2
        call    n04d9
      ENDIF
        call    n19c0           ; DE=first non-directory sector
        sbc     hl,de           ; test logical sector
        ccf
        pop     de
        pop     hl
        ret     c               ; exit if not after directory
        push    bc
        ld      a,b
        call    n0207           ; page in bank containing buffer
        push    af
        xor     a
        ld      bc,$0002
n0e9c   add     a,(hl)          ; A=8-bit checksum of sector
        inc     hl
        djnz    n0e9c
        dec     c
        jr      nz,n0e9c
        ld      b,a             ; save checksum
        pop     af
        call    n0207           ; page back original bank
        ld      l,(ix+$26)
        ld      h,(ix+$27)      ; HL=address of checksum table
        add     hl,de           ;    +abs logical sector
        push    de
        ld      de,$0000
        call    n19c0           ; DE=first non-reserved sector
        or      a
        sbc     hl,de           ; HL=address of sector checksum
        pop     de
        ld      a,b
        or      a
        pop     bc              ; restore checksum
        ret

; Subroutine to check if file (HL=FCB) is read-only, giving error if so

n0ebe   push    de
        ex      de,hl
        ld      hl,$0009
        add     hl,de
        ld      a,(hl)          ; get read-only bit
        add     a,a             ; move to carry
        ex      de,hl
        pop     de
        ccf                     ; carry is inverse of read-only bit
        ld      a,$1c           ; "read-only file" error
        ret

; Subroutine to initialise the allocation bitmap of a drive with the
; directory bitmaps

n0ecc   call    n0fc9           ; get HL=allocation bitmap, DE=last block #
        ld      a,$03
        call    n04d9
        inc     de              ; DE=(last block #)/8+1
        push    hl
n0ed6   ld      (hl),$00        ; zero allocation for 8 blocks
        inc     hl
        dec     de
        ld      a,d
        or      e
        jr      nz,n0ed6        ; loop back for more
        pop     hl
        ld      a,(ix+$09)      ; store directory bitmaps
        ld      (hl),a
        inc     hl
        ld      a,(ix+$0a)
        ld      (hl),a
        ret


; Subroutine to allocate/deallocate a block
; On entry, DE=block number and C=$00 to remove block from allocation bitmap
; or $ff to add block to allocation bitmap

n0ee9   push    bc
        push    hl
        push    de
        ld      a,$03
        call    n04d9           ; DE=block/8
        push    de
        call    n0fc9           ; get HL=address of allocation bitmap
        pop     de
        add     hl,de           ; HL points to correct allocation byte
        pop     de
        ld      a,e
        and     $07
        ld      b,a             ; B=bit within byte
        ld      a,$01
        inc     b
n0eff   rrca
        djnz    n0eff
        ld      b,a             ; B=bitmask
        and     c
        ld      c,a             ; C=bit if allocating, 0 if deallocating
        ld      a,b
        cpl
        and     (hl)
        or      c
        ld      (hl),a          ; update bit in allocation bitmap
        pop     hl
        pop     bc
        ret

; Subroutine to allocate a new block for a file (returned in DE)

n0f0d   push    hl
        push    bc
        call    n0fc9           ; get HL=allocation bitmap & DE=last block
n0f12   ld      bc,$0880        ; bit counter & mask
n0f15   ld      a,(hl)          ; get byte from allocation bitmap
        and     c
        jr      z,n0f27         ; move on if found free block
        rrc     c               ; shift bit mask
        ld      a,d
        or      e
        ld      a,$1a
        jr      z,n0f3d         ; move on if no blocks left
        dec     de
        djnz    n0f15           ; loop back for more blocks in allocation byte
        inc     hl
        jr      n0f12           ; back for more allocation bytes
n0f27   ld      a,(hl)
        or      c
        ld      (hl),a          ; allocate this block
        ld      a,(ix+$05)
        sub     e
        ld      e,a
        ld      a,(ix+$06)
        sbc     a,d
        ld      d,a             ; calculate DE=allocated block
        pop     bc
        push    bc
        ld      hl,$0022
        add     hl,bc
        set     0,(hl)          ; signal directory contains valid FCB data
        scf
n0f3d   pop     bc
        pop     hl
        ret

; Subroutine to deallocate all blocks in current FCB

n0f40   ld      h,b             ; HL=FCB address
        ld      l,c
        xor     a               ; deallocate

; Subroutine to add/remove all the blocks in a directory entry to
; the allocation bitmap
; On entry, HL=address of directory entry, A=$ff to add or $00 to remove

n0f43   push    bc              ; save BC
        ld      c,a             ; C=allocate/deallocate flag
        ld      a,$0f
        cp      (hl)
        jr      c,n0f72         ; exit if not a file entry
        ld      de,$0010
        add     hl,de           ; HL points to allocation list
        ld      b,$10           ; 16 allocation entries to consider
        inc     b
        jr      n0f70           ; go to start loop
n0f53   ld      e,(hl)          ; E=next allocation entry
        inc     hl
        ld      a,(ix+$06)      ; more than 256 blocks on disk?
        or      a
        ld      d,a             ; DE=block number if 8-bit block numbers
        jr      z,n0f5f
        dec     b
        ld      d,(hl)          ; DE=16-bit block number
        inc     hl
n0f5f   ld      a,d
        or      e
        jr      z,n0f70         ; move on if allocation entry null
        push    hl
        ld      a,(ix+$05)
        sub     e
        ld      a,(ix+$06)
        sbc     a,d             ; test against last block number
        call    nc,n0ee9        ; if in range, allocate/deallocate block
        pop     hl
n0f70   djnz    n0f53           ; loop back
n0f72   pop     bc
        scf
        ret

; Subroutine to calculate extent size in K (to HL)

n0f75   push    de
        ex      de,hl
        ld      a,(de)
        cp      $10             ; test user area
        ld      hl,$0000        ; zero blocks so far
        jr      nc,n0f99        ; skip calculation if password entry
        ld      hl,$0010
        add     hl,de           ; point to allocation list
        ld      de,$1000        ; D=#bytes to test,E=#blocks found
n0f86   ld      a,(ix+$06)
        or      a               ; more than 255 blocks?
        ld      a,(hl)          ; get block number
        inc     hl
        jr      z,n0f91         ; if not move on
        or      (hl)            ; else incorporate 2nd byte
        dec     d               ; and move over
        inc     hl
n0f91   or      a
        jr      z,n0f95
        inc     e               ; increment #blocks if not null
n0f95   dec     d
        jr      nz,n0f86        ; loop back for rest of allocation list
        ex      de,hl           ; HL=#blocks, to be converted to K next
n0f99   pop     de

; Subroutine to convert HL=blocks to K

n0f9a   ld      a,(ix+$02)      ; get block size
        dec     a
        dec     a
n0f9f   dec     a
        jr      z,n0fa5         ; move on when HL=size in K
        add     hl,hl           ; double it
        jr      n0f9f           ; loop back
n0fa5   ld      a,h
        or      l               ; set Z if HL=0
        scf                     ; success
        ret

; Subroutine to calculate HL=free space (in K) on current drive

n0fa9   ld      hl,$0000        ; 0 free blocks so far
        push    hl              ; stack it
        call    n0fc9           ; HL=alloc bitmap, DE=last block number
n0fb0   ld      bc,$0880        ; bit count & mask
n0fb3   ld      a,(hl)
        and     c               ; check if block free
        jr      nz,n0fba
        ex      (sp),hl
        inc     hl              ; increment #free if so
        ex      (sp),hl
n0fba   rrc     c               ; shift bit mask
        ld      a,d
        or      e
        jr      z,n0fc6         ; move on if no more blocks
        dec     de
        djnz    n0fb3           ; loop back for rest of allocation byte
        inc     hl
        jr      n0fb0           ; loop back
n0fc6   pop     hl              ; HL=#free blocks
        jr      n0f9a           ; convert blocks to K & exit

; Subroutine to get HL=allocation bitmap & DE=last block number from XDPB

n0fc9   ld      l,(ix+$28)
        ld      h,(ix+$29)      ; HL=add of allocation bitmap
        ld      e,(ix+$05)
        ld      d,(ix+$06)      ; DE=last block number
        ret

; Subroutine to check if new directory entry available

n0fd6   ld      a,(ix+$22)
        or      (ix+$23)
        ld      a,$1b
        ret     z               ; error "directory full" if no new entries
        ld      hl,$0022
        add     hl,bc
        set     1,(hl)          ; new directory entry needed
        res     2,(hl)          ; extent now created
        ld      a,(ix+$22)
        sub     $01             ; decrement #free directory entries
        ld      (ix+$22),a
        jr      nc,n0ff4
        dec     (ix+$23)
n0ff4   scf
        ret

; Subroutine to get a new directory entry (DE)

n0ff6   push    bc
        ld      c,(ix+$24)
        ld      b,(ix+$25)      ; BC=last used directory entry number
        call    n0c74           ; set last used=last entry
        ld      hl,n1033
        call    n0dae           ; find first unused entry
        jr      nc,n1031        ; exit if error
        ex      (sp),hl
        push    hl
        push    de
        push    af
        ld      de,$0022
        add     hl,de
        res     1,(hl)          ; reset "new directory entry" flag
        pop     af
        pop     de
        pop     hl
        ex      (sp),hl
        jr      nz,n102b        ; if no free entry found, cause error
        ex      de,hl
        or      a
        sbc     hl,bc
        add     hl,bc
        ex      de,hl
        jr      c,n1022         ; move on if entry lower than last used
        ld      b,d
        ld      c,e             ; else last used=this entry
n1022   ld      (ix+$24),c
        ld      (ix+$25),b      ; set last used entry
        scf                     ; success
        jr      n1031
n102b   call    n1040           ; re-increment free directory entries
        ld      a,$20           ; "extent missing" error
        or      a
n1031   pop     bc
        ret

; Subroutine to check if directory entry at HL is free

n1033   ld      a,(hl)
        xor     $e5             ; set Z if free
        scf                     ; success
        ret

; Subroutine to clear new entry flag & increment # free entries

n1038   push    hl
        ld      hl,$0022
        add     hl,bc
        res     1,(hl)          ; we don't need a new entry
        pop     hl
n1040   scf                     ; success
        inc     (ix+$22)        ; increment # free directory entries
        ret     nz
        inc     (ix+$23)
        ret

; Subroutine to check for datestamps, and if present to exit with Z set
; and HL pointing to address to place datestamp for entry DE

; *BUG* This routine assumes that on entry, HL contains the address of a
; directory entry within a record, and tries to access the last entry in
; the record. However, HL points to a copy of the entry at "direntry",
; so the routine checks for a datestamp at $dfc2 (unused), $dfe2 (byte 2 of
; BCB 0) or $e002 (byte 1 of BCB 3).
; Luckily, none of these locations can ever hold a datestamp identifier,
; so the effect of the bug is that datestamps are always ignored.

n1049   ld      a,e
        and     $03
        cpl
        add     a,$04
        jr      z,n1058
        ld      bc,$0020
n1054   add     hl,bc           ; generate HL=address of last entry in record
        dec     a
        jr      nz,n1054
n1058   ld      a,(hl)
        cp      $21             ; check if datestamp entry
        ret     nz              ; exit if not
        ld      a,e
        and     $03
        jr      z,n1068
        ld      bc,$000a
n1064   add     hl,bc           ; generate address of datestamp for entry
        dec     a
        jr      nz,n1064
n1068   inc     hl
        ret

      IF garry=0
        defs    6
      ENDIF

; DOS_GET_POSITION

n1070   call    n0525           ; get FCB
        ret     nc              ; exit if error
n1074   ld      hl,$0026        ; offset for file position
        jr      n1080           ; move on

; DOS_GET_EOF

n1079   call    n0525           ; get FCB
        ret     nc              ; exit if error
        ld      hl,$0023        ; offset for EOF
n1080   add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      a,(hl)
        ex      de,hl
        ld      e,a
        ld      d,$00           ; DEHL=file position/EOF
        scf                     ; success
        ret

; DOS_SET_POSITION

n108c   call    n0525           ; get FCB
        ret     nc              ; exit if error
n1090   ld      a,l
        ld      d,e
        ld      e,h             ; DEA=new filepos
        ld      hl,$0026
        add     hl,bc           ; HL=add of filepos in FCB
        jr      n10ad           ; move on

; Subroutine to increment filepointer by 1 (l09d), $80 (n1099) or A (n109f)
; If this caused the filepointer to cross a record boundary, bit 5 of
; the FCB flags byte is reset

n1099   ld      a,$80
        jr      n109f
n109d   ld      a,$01
n109f   ld      hl,$0026
        add     hl,bc           ; HL=add of filepos in FCB
        add     a,(hl)          ; add in A
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        jr      nc,n10ab
        inc     de
n10ab   dec     hl              ; move HL back to start of filepos
        dec     hl
n10ad   push    hl              ; save registers
        push    af
        xor     (hl)
        jp      m,n10bd         ; move on if record changed
        inc     hl
        ld      a,(hl)
        cp      e
        jr      nz,n10bd
        inc     hl
        ld      a,(hl)
        cp      d
        jr      z,n10c3         ; skip next bit if record unchanged
n10bd   ld      hl,$0022
        add     hl,bc
        res     5,(hl)          ; flag "record changed"
n10c3   pop     af
        pop     hl
        ld      (hl),a
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; set new filepointer
        scf                     ; success
        ret

; Subroutine to ensure filelength is at least as large as current filepointer

n10cc   push    bc
        push    af
        ld      hl,$0022
        add     hl,bc
        ex      de,hl           ; DE points to filelength-1
        ld      hl,$0025
        add     hl,bc           ; HL points to filepointer-1
        ld      b,$03
        or      a
n10da   inc     de
        inc     hl
        ld      a,(de)
        sbc     a,(hl)          ; compare filepointer with filelength
        djnz    n10da
        jr      nc,n10e7        ; exit if filepointer within current file
        ld      bc,$0003
        lddr                    ; make filelength=filepointer
n10e7   pop     af
        pop     bc
        ret

; DOS_READ
      IF garry
n10d9   call    n11cb
        ret     nc
        push    de
        ld      e, a
        ld      a, (rw_page)
        ld      hl, (rw_add)
        call    n0207
        ld      (hl), e
        call    n0207
        inc     hl
        ld      (rw_add), hl
        pop     de
        ld      a, d
        or      e
        dec     de
        scf
        ret

n10f6   push    de
        call    n137d
        pop     de
        ret     nc
        push    de
        call    n1099
        ld      hl, $002d
        add     hl, bc
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     hl
        push    bc
        ld      c, (hl)
        ld      a, (rw_page)
        ld      b, a
        ld      hl, (rw_add)
        ex      de, hl
        ld      ix, $0080
        call    n023d
        pop     bc
        ld      (rw_add), de
        pop     de
        ld      hl, $ff81
        add     hl, de
        ex      de, hl
        ld      a, d
        or      e
        dec     de
        scf
        ret
      ELSE
n10ea   ld      a,c
        ld      (rw_page),a     ; save page & address to read to
        ld      (rw_add),hl
        call    n0514           ; test if file B open for reading
        ret     nc              ; exit if not
        add     hl,de           ; calculate final address
        push    hl
        call    n1107           ; do the read
        pop     hl
        ret     c               ; exit if successful
        push    af
        ld      de,(rw_add)     ; get current address
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=unread bytes
        pop     af
        ret 

; Subroutine to read DE bytes from file

n1107   push    bc
        push    de
        ld      hl,$0023
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      b,(hl)          ; get BDE=file length
        inc     hl
        ld      a,e
        scf
        sbc     a,(hl)
        ld      e,a
        inc     hl
        ld      a,d
        sbc     a,(hl)
        ld      d,a
        inc     hl
        ld      a,b
        sbc     a,(hl)
        ex      de,hl           ; AHL=filelength available to read
        pop     de
        pop     bc
        jr      c,n1130         ; exit if none
        dec     de              ; DE=#bytes to read-1
        sbc     hl,de
        add     hl,de
        sbc     a,$00
        jr      nc,n1134        ; if enough bytes in file, move on
        ex      de,hl
        call    n1134           ; else read what's available
        ret     nc              ; exit if error
n1130   ld      a,$19           ; "end of file" error
        or      a
        ret
n1134   ld      hl,$0026
        add     hl,bc
        ld      a,(hl)
        and     $7f
        jr      z,n1144         ; move on if filepointer on record boundary
        call    n1158           ; read byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n1134           ; loop back
n1144   ld      hl,$ff81
        add     hl,de
        jr      nc,n1151        ; move on if don't need any more full records
        call    n1175           ; read a record
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n1144           ; loop back
n1151   call    n1158           ; read byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n1151           ; loop back

; Subroutine to read a byte from the file to correct address
; On exit, Z set if finished

n1158   call    n11cb           ; read a byte
        ret     nc              ; exit if error
        push    de
        ld      e,a
        ld      a,(rw_page)
        ld      hl,(rw_add)
        call    n0207           ; page in bank
        ld      (hl),e          ; store byte
        call    n0207           ; page back original bank
        inc     hl
        ld      (rw_add),hl     ; update address to read to
        pop     de
        ld      a,d
        or      e               ; set Z if finished
        dec     de              ; decrement #bytes to read
        scf                     ; success
        ret

; Subroutine to read a record from the file to correct address
; On exit, Z set if finished

n1175   push    de
        call    n137d           ; get record to buffer & update FCB
        pop     de
        ret     nc              ; exit if error
        push    de
        call    n1099           ; increment filepointer by $80
        ld      hl,$002d
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=address of record
        inc     hl
        push    bc
        ld      c,(hl)          ; C=page of buffer
        ld      a,(rw_page)
        ld      b,a
        ld      hl,(rw_add)
        ex      de,hl
        ld      ix,$0080
        call    n023d           ; copy record from buffer
        pop     bc
        ld      (rw_add),de     ; update address to read to
        pop     de
        ld      hl,$ff81
        add     hl,de
        ex      de,hl           ; subtract $7f from bytes to read
        ld      a,d
        or      e               ; set Z if done
        dec     de              ; subtract further byte
        scf                     ; success
        ret
      ENDIF

; DOS_BYTE_READ

n11a8   call    n0514           ; get FCB & test if open for reading
        ret     nc              ; exit if error
        ld      hl,$0026
        add     hl,bc
        ex      de,hl           ; DE=filepointer address
        ld      hl,$0023
        add     hl,bc           ; HL=filelength address
        push    bc
        ld      b,$03
        or      a
n11b9   ld      a,(de)          ; test filepointer (carry must be set
        sbc     a,(hl)          ; if pointer within file)
        inc     de
        inc     hl
        djnz    n11b9
        pop     bc
        ld      a,$19           ; error "end of file"
        call    c,n11cb         ; get a byte if within file
        ret     nc              ; exit if error
        ld      c,a             ; C=byte read
        cp      $1a             ; set Z if soft-EOF
        scf                     ; success
        ret

; Subroutine to read a byte (A) from the file

n11cb   push    hl
        push    de
        ld      hl,$0022
        add     hl,bc
        bit     5,(hl)          ; has record been changed?
        jr      nz,n11da
        call    n137d           ; if so, get new record details into FCB
        jr      nc,n11fb        ; exit if error
n11da   ld      hl,$0026
        add     hl,bc
        ld      a,(hl)          ; low byte of filepointer
        and     $7f             ; offset into record
        ld      hl,$002d
        add     hl,bc
        add     a,(hl)
        ld      e,a
        inc     hl
        adc     a,(hl)
        sub     e
        ld      d,a             ; DE=address of byte in buffer
        inc     hl
        ld      a,(hl)          ; A=bank of buffer
        ex      de,hl
        call    n0207           ; page in buffer bank
        ld      d,(hl)          ; get byte
        call    n0207           ; page back original bank
        push    de
        call    n109d           ; increment filepointer
        pop     af              ; A=byte
        scf                     ; success
n11fb   pop     de
        pop     hl
        ret

; DOS_WRITE

n11fe   ld      a,c
        ld      (rw_page),a     ; store bank & address to write from
        ld      (rw_add),hl
        call    n051c           ; test file B open for writing
        ret     nc              ; exit if error
        add     hl,de           ; calculate final address
        push    hl
        call    n121e           ; do the write
        call    n10cc           ; ensure filelength includes filepointer
        pop     hl
        ret     c               ; exit if successful
        push    af
        ld      de,(rw_add)
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=bytes unwritten
        pop     af
        ret

; Subroutine to write DE bytes to file

n121e   dec     de
n121f   ld      hl,$0026
        add     hl,bc
        ld      a,(hl)
        and     $7f
        jr      z,n122f         ; move on if filepointer on record boundary
        call    n1243           ; write a byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n121f           ; loop back
n122f   ld      hl,$ff81
        add     hl,de
        jr      nc,n123c        ; move on if don't need to write full record
        call    n1261           ; write a record
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n122f           ; loop back
n123c   call    n1243           ; write a byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n123c           ; loop back

; Subroutine to write a byte to file

n1243   ld      a,(rw_page)     ; get bank & address
        ld      hl,(rw_add)
        call    n0207           ; page in bank
        ld      l,(hl)          ; get byte
        call    n0207           ; page back original bank
        ld      a,l
        call    n12a5           ; write the byte
        ret     nc              ; exit if error
        ld      hl,(rw_add)
        inc     hl
        ld      (rw_add),hl     ; update address to write from
        ld      a,d
        or      e               ; test if finished
        dec     de              ; decrement bytes to write
        scf
        ret

; Subroutine to write a record to file

n1261   push    de
        call    n134e           ; get record to buffer at AHL
        pop     de
        ret     nc              ; exit if error
        ld      hl,$0022
        add     hl,bc
        set     4,(hl)          ; signal "current record changed"
        push    de
        call    n1099           ; increment filepointer by $80
        ld      hl,$002d
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        push    bc
        ld      b,(hl)          ; get B=bank, DE=address of buffer
        ld      a,(rw_page)
        ld      c,a
        ld      hl,(rw_add)
        ld      ix,$0080
        call    n023d           ; copy record to buffer
        pop     bc
        ld      (rw_add),hl     ; update address to write from
        pop     de
        ld      hl,$ff81
        add     hl,de
        ex      de,hl           ; subtract $7f from bytes to read
        ld      a,d
        or      e               ; set Z if finished
        dec     de              ; subtract further byte
        scf
        ret

; DOS_BYTE_WRITE

n1298   ld      e,c
        call    n051c           ; check file open for writing
        ret     nc              ; exit if not
        ld      a,e
        call    n12a5           ; write byte A at filepointer
        call    c,n10cc         ; ensure filelength includes filepointer
        ret

; Subroutine to place byte A in file at current filepointer, and increment
; filepointer

n12a5   push    hl
        push    de
        ld      e,a             ; save byte in E
        ld      hl,$0022
        add     hl,bc
        bit     5,(hl)
        jr      nz,n12b9        ; move on if FCB contains valid record details
        push    hl
        push    de
        call    n134e           ; get record to buffer
        pop     de
        pop     hl
        jr      nc,n12db        ; exit if error
n12b9   set     4,(hl)          ; signal "record changed"
        ld      hl,$0026
        add     hl,bc
        ld      a,(hl)
        and     $7f             ; A=offset into current record
        ld      hl,$002d
        add     hl,bc
        push    de
        add     a,(hl)
        ld      e,a
        inc     hl
        adc     a,(hl)
        sub     e
        ld      d,a             ; DE=address in file
        inc     hl
        ld      a,(hl)          ; A=bank of file
        ex      de,hl
        pop     de
        call    n0207           ; page in file bank
        ld      (hl),e          ; store byte at filepointer
        call    n0207           ; page back original bank
        call    n109d           ; increment filepointer
n12db   pop     de
        pop     hl
        ret

; Subroutine to test if file has valid header checksum (Z set if so)

n12de   call    n12f7           ; get stored & calculated checksum
        ret     nc              ; exit if error
        ld      a,d
        cp      e               ; set Z if they match
        scf                     ; success
        ret

; Subroutine to update checksum in file header & set filepointer after it

n12e6   call    n12f7           ; get header checksums
        ret     nc              ; exit if error
        call    n0207           ; page in bank file bank
        ld      (hl),e          ; store calculated header checksum
        call    n0207           ; page back original bank
        call    n1099           ; increment filepointer past header
        jp      n10cc           ; ensure filelength includes filepointer

; Subroutine to get stored header checksum (D) & calculated checksum (E)

n12f7   ld      hl,$0000
        ld      e,h
        call    n1090           ; set position to file start
        ld      hl,$0022
        add     hl,bc
        bit     5,(hl)
        jr      nz,n130a        ; move on if valid record details in FCB
        call    n137d           ; get record to buffer and update FCB
        ret     nc              ; exit if error
n130a   ld      hl,$002d
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=address of file start
        inc     hl
        ld      a,(hl)          ; A=bank of file
        ex      de,hl
        push    af
        call    n0207           ; page in file bank
        push    af
        xor     a               ; zero checksum
        ld      e,$7f
n131c   add     a,(hl)          ; form checksum
        inc     hl
        dec     e
        jr      nz,n131c        ; back for more bytes in header
        ld      e,a             ; E=calculated checksum
        ld      d,(hl)          ; D=checksum stored in file header
        pop     af
        call    n0207           ; page back original bank
        pop     af
        scf
        ret

; Subroutine to get sector in FCB to a buffer

n132a   push    hl
        ld      hl,$0022
        add     hl,bc           ; HL points to flags of FCB
        bit     3,(hl)
        jr      z,n1347         ; move on if sector already in buffer
        bit     4,(hl)
        jr      z,n1347         ; or if current record not changed
        push    hl
        push    de
        ld      hl,$002b
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=logical sector
        call    n1624           ; get AHL=buffer address (flag changed)
        pop     de
        pop     hl
        jr      nc,n134c        ; move on if error
n1347   ld      a,(hl)
        and     $c7             ; reset bits 3,4 & 5
        ld      (hl),a
        scf                     ; success
n134c   pop     hl
        ret

; Subroutine to get abs logical sector (DE) & record address (AHL)
; for record (DE) in current file, creating new record if required

n134e   ld      a,(bc)
        cp      $22             ; test for "drive open as file"
        ld      hl,n135b        ; routine to use for normal file
        jr      nz,n1388
        ld      hl,n14eb        ; routine to use for drive
        jr      n1388

; Subroutine to find abs log sector (DE) and record address (AHL)
; for possibly new record DE in current file

n135b   push    de
        call    n0ca8           ; get new extent if required
        pop     de
        call    c,n13f0         ; get record address & sector number
        ret     nc              ; exit if error
        push    hl
        push    de
        push    af
        call    n13d2           ; get DE=record number from FCB
        call    n14b0           ; check in current extent
        call    nc,n1493        ; if so, set FCBs extent counter & #records
        pop     af
        pop     de
        pop     hl
        ret

; Subroutine to get the abs log sector (DE) and address (AHL) of
; record DE in the current file

n1374   push    de
        call    n0c81           ; find extent HL for file
        pop     de
        call    c,n1423         ; if found, get address of record
        ret

; Subroutine to get the current record into a buffer and update the FCB
; with its details

n137d   ld      a,(bc)
        cp      $22             ; test for "drive open as file"
        ld      hl,n1374        ; routine to use for normal file
        jr      nz,n1388
        ld      hl,n14eb        ; routine to use for drive
n1388   call    n13dc           ; DE=record number for filepointer
        ret     nc              ; exit if file too big
        push    hl
        ld      hl,$0022
        add     hl,bc
        bit     3,(hl)
        pop     hl
        jr      z,n13a2         ; move on if no sector currently in buffer
        push    hl
        ex      de,hl
        call    n13d2           ; get record number from FCB
        ex      de,hl
        or      a
        sbc     hl,de
        pop     hl
        jr      z,n13c8         ; move on if record numbers match
n13a2   call    n0c20           ; ensure correct disk logged in
        call    c,n132a         ; get sector in FCB to buffer
        ret     nc              ; exit if error
        push    hl
        ld      hl,$0029
        add     hl,bc
        ld      (hl),e
        inc     hl
        ld      (hl),d
        pop     hl
        call    n13d2           ; DE=record number required
        call    n04ec           ; call routine in HL
        ret     nc              ; exit if error
        push    hl
        ld      hl,$002b
        add     hl,bc
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store abs logical sector number
        pop     de
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d          ; store add of record
        inc     hl
        ld      (hl),a          ; store bank for buffer
n13c8   ld      hl,$0022
        add     hl,bc
        ld      a,(hl)
        or      $28             ; set bit 3 (valid sector) & bit 5
        ld      (hl),a          ; (valid filepointer)
        scf
        ret

; Subroutine to get DE=record number from FCB

n13d2   push    hl
        ld      hl,$0029
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        pop     hl
        ret

; Subroutine to get DE=record number for filepointer

n13dc   push    hl
        ld      hl,$0026
        add     hl,bc           ; HL points to filepointer
        ld      a,(hl)
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl           ; HLA=filepointer
        add     a,a
        adc     hl,hl           ; double filepointer
        ex      de,hl           ; DE=record number
        ccf                     ; successful if no carry
        ld      a,$22           ; error "file too big"
        pop     hl
        ret

; Subroutine to get record address (AHL) and sector (DE) for record DE,
; creating new record if required

n13f0   push    de
        call    n1459           ; get block & offset
        ex      de,hl
        ex      (sp),hl
        ex      de,hl
        jr      c,n140a         ; move on if not end-of-file
        call    n0f0d           ; allocate a new block
        jr      nc,n1413        ; move on if error
        ld      (hl),e          ; insert block in allocation list
        ld      a,(ix+$06)
        or      a
        jr      z,n1407
        inc     hl
        ld      (hl),d
n1407   ex      de,hl           ; HL=block number
        jr      n1411
n140a   ld      a,e
        and     $03
        scf
        call    z,n14b0         ; if first record in a sector, check in extent
n1411   sbc     a,a             ; Z set if record newly created
        scf
n1413   pop     de
        call    c,n143c         ; get abs logical sector & offset
        push    hl
        call    c,n141d         ; get sector to buffer
        jr      n1435           ; exit, getting required record to AHL

; Subroutine to get sector DE to a buffer, don't bother reading in if
; newly created record (Z set)

n141d   jp      z,n160c         ; if created, don't read sector
        jp      n15f4           ; get sector, reading if necessary

; Subroutine to find abs log sector (DE) and record address (AHL)
; for record DE in current file

n1423   push    de
        call    n1459           ; get block & offset
        ex      de,hl
        ex      (sp),hl
        ex      de,hl
        call    c,n14b0         ; check record is in this extent
        pop     de
        call    c,n143c         ; calculate sector & offset
n1431   push    hl              ; stack offset into sector
        call    c,n15f4         ; get AHL=address of sector DE
n1435   ex      de,hl
        ex      (sp),hl         ; stack sector, restore offset
        push    af
        add     hl,de           ; now AHL=address of record
        pop     af
        pop     de              ; restore sector
        ret

; Subroutine to calculate abs logical sector (DE) and offset (HL) from
; block number (HL) offset into block (DE)

n143c   push    bc
        push    af
        ex      de,hl
        ld      a,(ix+$02)
      IF garry
        sub     2
        call    nz, n04e3
      ELSE
        call    n04e3
      ENDIF
        call    n19c0           ; DE=abs logical sector of block start
        ex      de,hl
        ld      b,d             ; save high byte of offset
        ld      a,d
        and     $01
        ld      d,a
        ex      de,hl           ; HL=offset into sector
        xor     b
        rrca                    ; A=#sectors offset
        add     a,e
        ld      e,a
        adc     a,d
        sub     e
        ld      d,a             ; DE=abs logical sector
        pop     af
        pop     bc
        ret

; Subroutine to calculate block number (HL) and offset (DE) of record
; DE in file, assuming correct extent is in FCB

n1459   push    bc
        ld      h,b             ; HL=FCB
        ld      l,c
        ld      a,(ix+$03)
        and     e               ; A=record within block
        rra
        ld      b,a
        ld      a,$00
        rra
        ld      c,a             ; BC=byte offset within block
        ld      a,(ix+$02)
        call    n04d9
        ld      d,$00           ; DE=block number (low byte)
        ld      a,(ix+$06)
        or      a
        ld      a,e
        jr      z,n1480         ; move on if <256 blocks on disk with A=block
        and     $07
        add     a,a
        add     a,$11
        ld      e,a
        add     hl,de           ; for 256+ blocks, each uses 2 bytes in list
        ld      d,(hl)          ; D=high byte of actual block number
        dec     hl              ; HL points to low byte
        jr      n1486
n1480   and     $0f
        add     a,$10
        ld      e,a
        add     hl,de           ; for <256 blocks, each uses 1 byte in list
n1486   ld      e,(hl)          ; now, DE=block number on disk
        ld      a,d
        or      e
        ld      a,$19
        jr      z,n148f         ; if 0, exit with "end of file" error
        ex      de,hl           ; HL=block number
        scf                     ; success
n148f   ld      d,b
        ld      e,c
        pop     bc
        ret

; Subroutine to set extent counter & number of records in extent

n1493   push    hl
        ld      a,e
        and     $7f
        inc     a
        ld      hl,$000f
        add     hl,bc
        ld      (hl),a          ; set number of records in extent
        ld      a,e
        rla
        ld      a,d
        rla
        and     $1f
        dec     hl
        dec     hl
        dec     hl
        ld      (hl),a          ; set extent counter (low 5 bits)
        ld      hl,$0022
        add     hl,bc
        set     0,(hl)          ; directory contains valid copy of FCB data
        scf
        pop     hl
        ret

; Subroutine to check record number DE is in the current extent

n14b0   push    de
        push    hl
        call    n14c2           ; find last record number in extent
        or      a
        ld      a,$22
        jr      nz,n14bf        ; "file too big" error
        ex      de,hl
        sbc     hl,de           ; check record is in this extent
        ld      a,$19           ; "end of file" error if not
n14bf   pop     hl
        pop     de
        ret

; Subroutine to calculate ADE=last record in extent+1

n14c2   push    de
        ld      hl,$000c
        add     hl,bc
        ld      d,(hl)
        ld      e,$00
        srl     d
        rr      e
        inc     hl
        inc     hl
        inc     hl
        ld      a,(hl)
        or      a
        jp      p,n14d8
        ld      a,$80
n14d8   add     a,e
        ld      e,a
        adc     a,d
        sub     e
        dec     hl
        ld      l,(hl)
        ld      h,$00
        add     hl,hl
        add     hl,hl
        add     hl,hl
        add     hl,hl
        add     a,l
        ld      d,a
        adc     a,h
        sub     d               ; A=#records in this extent
        ex      de,hl           ; DE=last record in extent+1
        pop     de
        ret

; Subroutine to find abs log sector (DE) and record address (AHL)
; for record DE in current file (which is an open drive)

n14eb   ld      a,e
        and     $03
        ld      h,a
        ld      l,$00
        srl     h
        rr      l               ; HL=offset of record into sector
        ld      a,$02
        call    n04d9           ; DE=absolute logical sector
        push    hl
        push    de
        ex      de,hl
        ld      a,(ix+$02)
        ld      e,(ix+$05)
        ld      d,(ix+$06)
        inc     de
      IF garry
        sub     2
        call    nz, n04e3
      ELSE
        call    n04e3
      ENDIF
        call    n19c0           ; DE=max sector on disk
        or      a
        sbc     hl,de           ; no carry (error) if sector > max
        pop     de
        pop     hl
        ld      a,$19           ; error "end of file"
        jp      n1431           ; go to get sector & calculate address

      IF garry=0
        defs    25
      ENDIF

; Subroutine to get D=first buffer for cache, E=number of cache buffers

n1530   ld      de,(cachenum)   ; get the values
        ret

; Subroutine to set cache to D=first buffer, E=# buffers

n1535   call    n1706           ; clear current cache
        ret     nc              ; exit if error
n1539   ld      hl,$0000
        ld      (bcb_inuse),hl  ; clear last in-use BCB address
        ld      (bcb_free),hl   ; clear last free BCB address
        ld      h,d
        ld      (cachenum),hl   ; set first buffer=D, no buffers yet
        ld      ix,bcbs         ; address for first BCB
        ld      b,$10           ; max 16 buffers required
        ld      a,$07
        ld      hl,cache7       ; first buffer in bank 7
        jr      n1561           ; move on
n1553   ld      a,e
        or      a
        scf                     ; exit if created all required BCBs
        ret     z
        ld      hl,cachenum
        inc     (hl)            ; increment # buffers
        ld      a,d
        inc     d               ; increment buffer number
        dec     e               ; decrement buffers left to create
        call    n022b           ; get address & bank of buffer D
n1561   ld      (ix+$08),l
        ld      (ix+$09),h      ; store buffer address
        ld      (ix+$0a),a      ; and bank
        ld      hl,(bcb_free)
        ld      (ix+$00),l
        ld      (ix+$01),h      ; store add of previous BCB
        ld      (bcb_free),ix   ; current BCB is now last
        ex      de,hl
        ld      de,$000b
        add     ix,de           ; address of next BCB
        ex      de,hl
        djnz    n1553           ; back for more
        scf                     ; success
        ret

; Subroutine to find BCB (address in DE) of buffer holding log sector in BC
; on current drive

n1582   ld      de,bcb_inuse    ; last in-use buffer address
n1585   ex      de,hl
        call    n179b           ; get next in-use BCB
        ccf
        ld      a,$21
        ret     z               ; fail with error "uncached" if none
        push    hl
        ld      hl,$0005
        add     hl,de
        ld      a,(hl)
        cp      (ix+$1c)        ; is buffer from current drive?
        jr      nz,n15a0        ; move on if not
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      h,(hl)          ; HL=abs logical sector in buffer
        ld      l,a
        or      a
        sbc     hl,bc
n15a0   pop     hl
        jr      nz,n1585        ; loop back if not required buffer
        scf                     ; success
        ret

; Subroutine to get a buffer for logical sector BC
; On exit, DE=BCB

n15a5   call    n1798           ; get last free BCB
        jr      nz,n15c4        ; move on if got one
        ld      de,bcb_inuse    ; address of in-use BCB chain
n15ad   ex      de,hl
        call    n179b           ; get next in-use BCB
        ccf
        ld      a,$21
        ret     z               ; "uncached" error if no more inuse BCBs
        call    n17a3           ; is this last BCB in chain?
        jr      nz,n15ad        ; loop back if not
        call    n15db           ; get sector for BCB to memory
        call    n16ec           ; write back data from this buffer if required
        ret     nc              ; exit if error
        call    n17aa           ; move BCB to the free chain
n15c4   push    hl
        ld      hl,$0002
        add     hl,de
        xor     a
        ld      (hl),a          ; no data changed
        inc     hl
        ld      (hl),a
        inc     hl
        ld      (hl),a          ; no file owner
        inc     hl
        ld      a,(ix+$1c)
        ld      (hl),a          ; drive
        inc     hl
        ld      (hl),c
        inc     hl
        ld      (hl),b          ; absolute logical sector
        pop     hl
        scf                     ; success
        ret

; Subroutine to get sector for BCB into memory

n15db   push    ix
        push    hl
        push    de
        push    bc
        ld      hl,$0005
        add     hl,de
        ld      a,(hl)
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        ex      de,hl
        ld      d,a             ; D=drive letter, HL=abs logical sector
        call    n05f0           ; get sector to buffer, updating FCBs
        pop     bc
        pop     de
        pop     hl
        pop     ix
        ret

; Subroutine to return page (A) & address (HL) for absolute logical sector DE
; reading to a new buffer if necessary

n15f4   bit     3,(ix+$1b)
        jp      nz,n1ab6        ; move on if RAMdisk
        push    de
        push    bc
        ld      b,d
        ld      c,e             ; BC=abs logical sector
        call    n1582           ; check if sector held in a buffer
        jr      c,n160a         ; move on if so
        call    n15a5           ; get a new buffer for it
        call    c,n1778         ; if no error, read the sector to the buffer
n160a   jr      n161d           ; move on

; Subroutine to return page (A) & address (HL) for absolute logical sector DE
; creating a new buffer if necessary (but not reading sector from disk)

n160c   bit     3,(ix+$1b)
        jp      nz,n1ab6        ; move on if RAMdisk
        push    de
        push    bc
        ld      b,d
        ld      c,e             ; BC=abs logical sector
        call    n1582           ; check if sector held in a buffer
        call    nc,n15a5        ; get a new buffer if not
n161d   push    af
        call    c,n17b2         ; if no error, move BCB to top of in-use chain
        pop     af
        jr      n1643           ; go to return buffer address as AHL

; Subroutine to get page (A) and address (HL) of buffer for files
; current logical sector, & flag as changed

n1624   bit     3,(ix+$1b)
        jp      nz,n1ab6        ; move on if RAMdisk
        push    de
        push    bc
        push    bc
        ld      b,d
        ld      c,e
        call    n1582           ; find buffer holding logical sector
        pop     bc
        jr      nc,n1643        ; move on if error
        push    hl
        ld      hl,$0002
        add     hl,de
        set     0,(hl)          ; flag "data changed"
        inc     hl
        ld      (hl),c
        inc     hl
        ld      (hl),b          ; store FCB address of file using buffer
        pop     hl
        scf                     ; successful so far
n1643   jr      nc,n1650        ; move on if error
        ld      hl,$0008
        add     hl,de
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      a,(hl)          ; A=buffer bank
        ex      de,hl           ; HL=buffer address
        scf                     ; success
n1650   pop     bc
        pop     de
        ret

; Subroutine to free all buffers referencing unchanged sectors on drive
; Enter at n166c, or n1653 to free only buffers referencing directory sectors

n1653   call    n18ab           ; has drive been recently accessed?
        ret     c               ; exit if so
        push    hl
        push    de
        push    bc
        ld      e,(ix+$07)
        ld      d,(ix+$08)
        inc     de              ; DE=#directory entries
      IF garry
        ld      a, 4
      ELSE
        ld      a, 2
      ENDIF
        call    n04d9           ; DE=#directory records (32 bytes per entry)
        call    n19c0
        dec     de              ; DE=last absolute directory sector
        jr      n1672
n166c   push    hl
        push    de
        push    bc
        ld      de,$ffff        ; max abs sector number
n1672   ld      b,d
        ld      c,e             ; BC=absolute sector number
        ld      de,bcb_inuse    ; DE=last inuse buffer address
n1677   ex      de,hl
n1678   call    n179b           ; get next inuse buffer
        jr      z,n16e8         ; move on if no more in-use buffers
        push    hl
        ld      hl,$0005
        add     hl,de
        ld      a,(hl)
        cp      (ix+$1c)
        jr      nz,n16a4        ; move on if buffer isn't on same drive
        inc     hl
        ld      a,c
        sub     (hl)
        inc     hl
        ld      a,b
        sbc     a,(hl)
        jr      c,n16a4         ; move on if larger sector than required
        call    n15db           ; get sector for BCB into memory
        dec     hl
        dec     hl
        dec     hl
        dec     hl
        dec     hl
        bit     0,(hl)
        jr      nz,n16a4        ; move on if buffer contains changed data
        pop     hl
        push    hl
        call    n17aa           ; else move buffer to free chain
        pop     hl
        jr      n1678           ; back for more
n16a4   pop     hl
        jr      n1677           ; back for more

; Subroutine to move all in-use BCBs for current drive to the free list

n16a7   push    hl
        push    de
        push    bc
        ld      de,bcb_inuse    ; last in-use BCB address
n16ad   ex      de,hl
n16ae   call    n179b           ; get next BCB
        jr      z,n16e8         ; exit if no more
        push    hl
        ld      hl,$0005
        add     hl,de
        ld      a,(hl)
        pop     hl
        cp      (ix+$1c)
        jr      nz,n16ad        ; move on if buffer not for current drive
        push    hl
        call    n17aa           ; move BCB from in-use chain to free chain
        pop     hl
        jr      n16ae           ; loop back for more

; Subroutine to move all in-use BCBs for current file to the free list

n16c6   push    hl
        push    de
        push    bc
        ld      de,bcb_inuse    ; last in-use BCB address
n16cc   ex      de,hl
n16cd   call    n179b           ; get next BCB
        jr      z,n16e8         ; exit if no more
        push    hl
        ld      hl,$0003
        add     hl,de
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a             ; HL=FCB of file for current buffer
        or      a
        sbc     hl,bc
        pop     hl
        jr      nz,n16cc        ; loop back if not current file
        push    hl
        call    n17aa           ; move BCB from in-use chain to free chain
        pop     hl
        jr      n16cd           ; loop back
n16e8   pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to release in-use cache buffer (address in DE)

n16ec   push    ix
        push    hl
        ld      hl,$0002
        add     hl,de
        bit     0,(hl)          ; test flags
        scf
        jr      z,n1702         ; exit if no changed data in buffer
        inc     hl
        inc     hl
        inc     hl
        ld      a,(hl)          ; A=drive letter for buffer
        call    n184d           ; get IX=XDPB
        call    n1719           ; write data back for all changed buffers
n1702   pop     hl              ;  on this disk
        pop     ix
        ret

; Subroutine to clear current cache

n1706   push    hl
        push    de
        ld      de,bcb_inuse    ; last in-use BCB address
n170b   ex      de,hl
        call    n179b           ; get address of previous in-use BCB
        jr      z,n1716         ; exit if none
        call    n16ec           ; release cache buffer
        jr      c,n170b         ; loop back if no error
n1716   pop     de
        pop     hl
        ret

; Subroutine to write data back to disk
; On entry, DE=BCB and IX=XDPB
; The routine writes all changed sectors for the disk back in order
; (smallest absolute logical sector first)

n1719   push    hl
        push    de
        push    bc
n171c   ld      de,bcb_inuse
        ld      bc,$ffff        ; max absolute logical sector number
        call    n173a           ; get a smaller one
        jr      z,n1736         ; exit if none left
n1727   push    de
        call    n173a           ; get a smaller one
        jr      z,n1730         ; move on if smallest found
        pop     af
        jr      n1727           ; loop back
n1730   pop     de
        call    n1762           ; write buffer to disk
        jr      c,n171c         ; loop back if no error
n1736   pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to find BCB on same drive with smaller logical sector number
; than BC. On entry DE contains address of current BCB.
; On exit, Z set if no BCB with smaller logical sector number found.

n173a   ex      de,hl
        call    n179b           ; get address of previous BCB
        ret     z               ; exit if none with Z set
        ld      hl,$0002
        add     hl,de
        bit     0,(hl)
        jr      z,n173a         ; loop back if no data to write
        inc     hl
        inc     hl
        inc     hl
        ld      a,(hl)          ; get drive letter for this buffer
        cp      (ix+$1c)        ; same as buffer we're freeing?
        jr      nz,n173a        ; back if not
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a             ; HL=absolute logical sector
        or      a
        sbc     hl,bc
        add     hl,bc
        jr      z,n175d         ; if same, move on
        jr      nc,n173a        ; if larger, loop back
n175d   ld      b,h             ; BC=smaller absolute logical sector
        ld      c,l
        scf
        sbc     a,a             ; exit with Z reset
        ret

; Subroutine to write buffer (DE=BCB) to disk

n1762   push    de
        call    n1785           ; get buffer & sector details
        call    n1a13           ; write the sector
        pop     de
        ret     nc              ; exit if error
        ld      hl,$0002
        add     hl,de
        res     0,(hl)          ; signal "buffer doesnt contain unwritten data"
        inc     hl
        xor     a
        ld      (hl),a
        inc     hl
        ld      (hl),a          ; set null FCB using this buffer
        scf                     ; success
        ret

; Subroutine to read buffer (DE=BCB) from disk

n1778   push    hl
        push    de
        push    bc
        call    n1785           ; get buffer & sector details
        call    n1a0a           ; read the sector
        pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to get buffer bank (B), address (HL), logical track (D) and
; logical sector (E), given BCB address in DE

n1785   ld      hl,$000a
        add     hl,de
        ld      b,(hl)          ; B=buffer bank
        dec     hl
        ld      d,(hl)
        dec     hl
        ld      e,(hl)
        push    de              ; stack buffer address
        dec     hl
        ld      d,(hl)
        dec     hl
        ld      e,(hl)          ; DE=absolute logical sector number
        call    n19df           ; get D=logical track, E=logical sector
        pop     hl              ; HL=buffer address
        ret

; Subroutine to get address of last free/in-use BCB (Z set if none)
; Enter at n179b with HL=bcb_inuse for last in-use BCB

n1798   ld      hl,bcb_free     ; address of last free BCB
n179b   ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=BCB address
        dec     hl
        ld      a,d
        or      e               ; set Z if null
        scf                     ; success
        ret

; Subroutine to check if current BCB is last in chain
; Exits with Z set if so

n17a3   ex      de,hl
        ld      a,(hl)
        inc     hl
        or      (hl)
        dec     hl
        ex      de,hl
        ret

; Subroutine to move a BCB from the free chain to the in-use chain (n17b2)
; or vice-versa (n17aa)
; If the BCB is already in the chain its being moved to, this has the effect
; of moving it to the top of the chain
; On entry, HL is address of pointer to this BCB and DE holds address of BCB
; On exit, HL is address of start of other chain, and DE is unchanged

n17aa   call    n17c3           ; remove current BCB from chain
        ld      hl,bcb_free
        jr      n17b8           ; go to insert into free chain
n17b2   call    n17c3           ; remove current BCB from chain
        ld      hl,bcb_inuse    ; address of in-use chain
n17b8   ld      a,(hl)          ; store start of chain into current BCB
        ld      (de),a
        inc     hl
        inc     de
        ld      a,(hl)
        ld      (de),a
        dec     de
        ld      (hl),d          ; store address of current BCB at list address
        dec     hl
        ld      (hl),e
        ret

; Subroutine to transfer a word value from DE to HL
; On exit, DE is unchanged, but HL is incremented

n17c3   ld      a,(de)
        ld      (hl),a
        inc     hl
        inc     de
        ld      a,(de)
        ld      (hl),a
        dec     de
        ret

      IF garry=0
        defs    5
      ENDIF

; Subroutine to setup extended XDPB info for drives A: and B:

n17d0   ld      a,'A'
        ld      (unit0),a       ; unit 0 is drive A:
        ld      hl,n17f6
        ld      de,xdpb_a+$1b
        ld      bc,$0015
        ldir                    ; copy extended XDPB info for A:
        ld      hl,xdpb_a
        ld      (xdpb_ptrs),hl  ; set pointer to A:'s XDPB
        ld      hl,n180b
        ld      de,xdpb_b+$1b
        ld      bc,$0015
        ldir                    ; copy extended XDPB info for B:
      IF garry
        ld      hl, xdpb_b
        ld      ($e2a2), hl
        ld      c, 1            ; B: should be unit 1 or disabled
        call    n1943
        call    n1edd
        ret     nc
        ld      a, 3
        ld      l, $42
        jp      n321a
      ELSE
        ld      c,$01           ; B: should be unit 1 or disabled
        jp      n1943           ; exit via DOS_MAP_B
      ENDIF

; The extended XDPB info for drive A:

n17f6   defb    $04,'A',$00     ; flags,drive,unit
        defb    $00,$00,$00,$00 ; last access,filesopen
        defw    $0000,$0000     ; #free direntries,last used
        defw    chksm_a,alloc_a ; checksum vector,alloc bitmap
        defw    n1988           ; login disk
        defw    n197c           ; read sector
        defw    n1982           ; write sector

; The extended XDPB info for drive B:

n180b   defb    $04,'B',$01     ; flags,drive,unit
        defb    $00,$00,$00,$00 ; last access,filesopen
        defw    $0000,$0000     ; #free direntries,lastused
        defw    chksm_b,alloc_b ; checksum vector,alloc bitmap
        defw    n1988           ; login disk
        defw    n197c           ; read sector
        defw    n1982           ; write sector

; Subroutine to initialise RAMdisk

n1820   push    hl
        ld      hl,n1830
        ld      de,xdpb_m+$1b
        ld      bc,$0015
        ldir                    ; copy extended XDPB info for M:
      IF garry
        ld      hl, xdpb_m
        ld      ($e2b8), hl
      ENDIF
        pop     hl
        jp      n1a5d           ; setup RAMdisk & exit

; The extended XDPB info for drive M:

n1830   defb    $08,'M',$ff     ; flags,drive,unit
        defb    $00,$00,$00,$00 ; last access,filesopen
        defw    $0000,$0000     ; #free direntries,lastused
        defw    $0000,alloc_m   ; no checksum;alloc bitmap
        defw    n1845           ; login disk
        defw    n1845           ; read sector
        defw    n1845           ; write sector

; Dummy low-level routines for RAMdisk

n1845   scf                     ; success
        ret

; DOS_REF_XDPB

n1847   call    n04ed           ; ensure drive letter uppercase
        ld      hl,xdpb_ptrs
n184d   sub     'A'
        jr      c,n186d         ; error if <A
        cp      $10
        jr      nc,n186d        ; error if >P
        push    hl
        add     a,a
        add     a,xdpb_ptrs and $ff
        ld      l,a
        adc     a,xdpb_ptrs/$100
        sub     l
        ld      h,a             ; HL=xdpb_ptrs+2*drive
        ld      a,(hl)
        inc     hl
        ld      h,(hl)          ; get address of XDPB for drive (or 0)
        ld      l,a
        push    hl
        pop     ix              ; IX points to XDPB
        ld      a,h
        or      l
        add     a,$ff           ; set carry unless no XDPB (success)
        pop     hl              ; restore HL
        ld      a,$16           ; error 22 - drive not found if error
        ret
n186d   ld      a,$15           ; error 21 - bad parameter
        or      a
        ret

; Subroutine to possibly logout drive & low-level login another disk

n1871   call    n184d           ; get XDPB for drive
        ret     nc              ; exit if none
        push    hl
        push    de
        push    bc
        call    n188f           ; possibly logout disk
        bit     0,(ix+$1b)
        scf
        call    z,n1887         ; if disk logged out, try to log another in
        pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to low-level login a disk

n1887   ld      a,(ix+$1a)      ; get freeze flag
        rla
        ret     c               ; exit if auto-detect not required
        jp      n19fe           ; do a low-level login & exit

; Subroutine to log out a disk if no files open & not recently accessed

n188f   bit     0,(ix+$1b)
        ret     z               ; exit if drive not logged in
        ld      a,(ix+$21)
        or      a
        ret     nz              ; exit if files open on drive
        call    n18ab
        ret     c               ; exit if accessed within last 2secs, or fixed

; Subroutine to low-level log out a disk (IX=XDPB)

n189d   ld      a,(ix+$21)      ; # files open on drive
        or      a
        ld      a,$24           ; drive in use error if so
        ret     nz
        res     0,(ix+$1b)      ; flag drive logged out
        jp      n16a7           ; move all BCBs for this drive to free list

; Subroutine to see if drive has been accessed within last 2secs
; If so (or if fixed drive), carry is set

n18ab   bit     7,(ix+$0c)
        scf
        ret     nz              ; exit if drive is fixed
        push    hl
        push    de
        push    bc
        ld      a,r             ; get interrupt status
        di
        ld      a,(FRAMES)      ; get HLA=FRAMES
        ld      hl,(FRAMES+1)
        jp      po,n18c1
        ei                      ; re-enable interrupts if necessary
n18c1   ld      b,a             ; HLB=current FRAMES
        ld      a,(ix+$1e)
        ld      e,(ix+$1f)
        ld      d,(ix+$20)      ; DEA=last access FRAMES
        add     a,$64
        jr      nc,n18d0
        inc     de              ; DEA=last access FRAMES + 2secs
n18d0   ld      c,a
        ld      a,b
        sub     c
        sbc     hl,de
        push    af              ; save carry (set if accessed within last 2s)
        ld      hl,FRAMES
        ld      a,r             ; get interrupt status
        di
        ld      a,(hl)
        ld      (ix+$1e),a      ; update last access time to current FRAMES
        inc     hl
        ld      a,(hl)
        ld      (ix+$1f),a
        inc     hl
        ld      a,(hl)
        ld      (ix+$20),a
        jp      po,n18ee
        ei                      ; re-enable interrupts if necessary
n18ee   pop     af
        pop     bc
        pop     de
        pop     hl
        ret                     ; done

; Subroutine to call n18fd, preserving BC/DE/HL

n18f3   push    hl
        push    de
        push    bc
        call    n18fd
        pop     bc
        pop     de
        pop     hl
        ret

; Subroutine to check disk can be written to

n18fd   bit     2,(ix+$1b)
        scf
        ret     z               ; exit with success if not floppy drive
        call    n1918           ; change disk if necessary
        call    n1e65           ; DD_TEST_UNSUITABLE
        ret     nc              ; exit if error
        call    n1ee9           ; DD_DRIVE_STATUS
        ld      c,a
        and     $20
        ret     z               ; exit if not present
        bit     6,c
        ld      a,$01
        ret     nz              ; error if disk write-protected
        scf                     ; success
        ret

; Subroutine to check whether "change disk" routine should be called

      IF garry=0
n1918   push    hl
        ld      c, (ix+$1d)
        ld      a,c
        or      a
        jr      nz, n1935       ; exit if drive not mapped to unit 0
        ld      hl, unit0
        ld      a, (ix+$1c)
        cp      (hl)
        jr      z, n1935        ; exit if unit 0 is currently mapped to drive
        ld      (hl), a         ; change unit 0 mapping to this drive
        push    ix
        push    de
        push    bc
        call    n1937           ; ask user to change disk
        pop     bc
        pop     de
        pop     ix
n1935   pop     hl
        ret

; Change disk subroutine

n1937   push    af
        ld      c,a
        call    n0338           ; generate change disk message
        pop     af
        push    hl
        ld      hl,(rt_chgdsk)
        ex      (sp),hl         ; stack change disk routine address
        ret                     ; exit to routine

; DOS_MAP_B

n1943   ld      a,'B'
        call    n184d           ; get XDPB of drive B:
        ccf
        call    nc,n189d        ; logout drive at low-level
        ret     nc              ; exit if error
        ld      a,c
        or      a
        jr      z,n1954
        ld      hl,$0000        ; no change-disk routine if B: is unit 1
n1954   ld      de,(rt_chgdsk)  ; get old routine address
        ld      (rt_chgdsk),hl  ; store new routine address
        ld      hl,$0000
        ld      (xdpb_ptrs+2),hl ; clear XDPB pointer for B:
        ld      ix,xdpb_b       ; IX=XDPB for B:
        ld      (ix+$1d),c      ; set unit number
        call    n1f27           ; DD_INTERFACE
        jr      nc,n1979        ; move on if no interface
        ld      a,c
        or      a
        scf
        call    nz,n1edd        ; for unit 1 only, test if present
        jr      nc,n1979        ; if not, no drive B:
        ld      (xdpb_ptrs+2),ix ; set pointer to B:'s XDPB
n1979   scf
        ex      de,hl
        ret                     ; exit with HL=old change-disk routine

; Low-level read sector subroutine for drives A: & B:

n197c   call    n1918           ; check if disk change required
        jp      n1bff           ; DD_READ_SECTOR

; Low-level write sector subroutine for drives A: & B:

n1982   call    n1918           ; check if disk change required
        jp      n1c0d           ; DD_WRITE_SECTOR

; Low-level login disk subroutine for drives A: & B:

n1988   call    n1918           ; check if disk change required
        call    n1c80           ; DD_LOGIN
        ret     nc              ; exit if error
        ld      a,(ix+$0f)
        xor     $02
        ld      a,$06           ; "unrecognised disk format"
        ret     nz              ; error if sectorsize <> 512
        rr      d
        rr      e
        ld      hl,$ffd2
        add     hl,de
        ccf
        ret     nc              ; error if alloc vector size/2 >$2d
        ld      e,(ix+$0b)
        ld      a,(ix+$0c)
        and     $7f
        ld      d,a
        ld      hl,$ffbf
        add     hl,de
        ccf
        ret     c               ; success if chksum size <= $40
        ld      (ix+$0b),$40
        ld      a,(ix+$0c)
        and     $80
        or      $00
        ld      (ix+$0c),a      ; else set chksum size to $40
        scf
        ret
      ENDIF

; Subroutine to convert logical usable record number (in DE) to
; absolute logical sector number by allowing for reserved tracks

n19c0   push    hl
        push    bc
        ld      c,(ix+$0d)
        ld      b,(ix+$0e)      ; BC=# reserved tracks
        ex      de,hl
        ld      e,(ix+$00)
        ld      d,(ix+$01)      ; DE=# records per track
      IF garry
        ld      a, 2
        call    n04d9
      ENDIF
        jr      n19d3
n19d1   add     hl,de
        dec     bc
n19d3   ld      a,b
        or      c
        jr      nz,n19d1
        ex      de,hl           ; DE=origHL+#reserved records
        pop     bc
        pop     hl
      IF garry
        ret
      ELSE
        ld      a,$02
        jp      n04d9           ; DE=absolute logical sector
      ENDIF

; Subroutine to find logical track (D) & sector (E) from absolute logical
; sector number (DE). IX=XDPB for disk

n19df   push    hl
        push    bc
        ex      de,hl
      IF garry
        ld      e,(ix+$00)
        ld      d,(ix+$01)      ; DE=records per track
        ld      a, 2
        call    n04d9
      ELSE
        add     hl,hl
        add     hl,hl           ; HL=absolute logical record number
        ld      e,(ix+$00)
        ld      d,(ix+$01)      ; DE=records per track
      ENDIF
        ld      bc,$ffff        ; BC=logical track counter
        or      a
n19ee   inc     bc
        sbc     hl,de
        jr      nc,n19ee        ; loop until found correct track in BC
        add     hl,de
        ex      de,hl           ; DE=logical record number
      IF garry=0
        ld      a,$02
        call    n04d9           ; DE=logical sector number on track
      ENDIF
        ld      d,c             ; D=logical track, E=logical sector
        pop     bc
        pop     hl
        ret

; Subroutine to login a disk at low-level

n19fe   push    hl
        ld      l,(ix+$2a)
        ld      h,(ix+$2b)      ; HL=routine address to login a disk
        ld      de,$0000        ; track 0, sector 0
        jr      n1a1a           ; move on to perform operation

; Subroutine to read a sector at BHL on logical track D, logical sector E

n1a0a   push    hl
        ld      l,(ix+$2c)
        ld      h,(ix+$2d)      ; HL=routine address to read a sector
        jr      n1a1a           ; move on to perform operation

; Subroutine to write a sector at BHL on logical track D, logical sector E

n1a13   push    hl
        ld      l,(ix+$2e)
        ld      h,(ix+$2f)      ; HL=routine address to write a sector
n1a1a   ld      (rt_temp),hl    ; store ready to call
        pop     hl
n1a1e   push    hl
        push    de
        push    bc
        call    n1a2e           ; call routine to write a sector
        pop     bc
        pop     de
        pop     hl
        ret     c               ; exit if no error
        call    n1a34           ; retry message
        jr      z,n1a1e         ; loop back to retry
        ret                     ; exit

; Subroutine to call address at rt_temp

n1a2e   push    hl              ; save HL
        ld      hl,(rt_temp)    ; stack routine address
        ex      (sp),hl         ; stack address & restore HL
        ret                     ; return to call routine

      IF garry
n1909   jp      (hl)
n1918   push    hl
        ld      c,(ix+$1d)
        ld      a,c
        or      a
        jr      nz,n1935        ; exit if drive not mapped to unit 0
        ld      hl,unit0
        ld      a,(ix+$1c)
        cp      (hl)
        jr      z,n1935         ; exit if unit 0 is currently mapped to drive
        ld      (hl),a          ; change unit 0 mapping to this drive
        push    ix
        push    de
        push    bc
        call    n1937           ; ask user to change disk
        pop     bc
        pop     de
        pop     ix
n1935   pop     hl
        ret

; Change disk subroutine

n1937   push    af
        ld      c,a
        call    n0338           ; generate change disk message
        pop     af
        push    hl
        ld      hl,(rt_chgdsk)
        ex      (sp),hl         ; stack change disk routine address
        ret                     ; exit to routine

; DOS_MAP_B
n1943   ld      ix, xdpb_b
        call    n189d
        ret     nc              ; exit if error
        ld      a,c
        or      a
        jr      z,n1954
        ld      hl,$0000        ; no change-disk routine if B: is unit 1
n1954   ld      de,(rt_chgdsk)  ; get old routine address
        ld      (rt_chgdsk),hl  ; store new routine address
        ld      ix,xdpb_b       ; IX=XDPB for B:
        ld      (ix+$1d),c      ; set unit number
        call    n1f27           ; DD_INTERFACE
        jr      nc,n1979        ; move on if no interface
        ld      a,c
        or      a
        scf
        call    nz,n1edd        ; for unit 1 only, test if present
        jr      c,n1979         ; if not, no drive B:
        ld      (ix+$1d), 0
n1979   scf
        ex      de,hl
        ret                     ; exit with HL=old change-disk routine

; DD_SET_RETRY
n1e7c   ld      (retry_cnt),a   ; set it
        ret
n196a   ld      a, 10
        or      a
        jp      n22c7
        defs    12

; Low-level read sector subroutine for drives A: & B:

n197c   call    n1918           ; check if disk change required
        jp      n1bff           ; DD_READ_SECTOR

; Low-level write sector subroutine for drives A: & B:

n1982   call    n1918           ; check if disk change required
        jp      n1c0d           ; DD_WRITE_SECTOR

; Low-level login disk subroutine for drives A: & B:

n1988   call    n1918           ; check if disk change required
        call    n1c80           ; DD_LOGIN
        ret     nc              ; exit if error
        ld      a,(ix+$0f)
        xor     $02
        ld      a,$06           ; "unrecognised disk format"
        ret     nz              ; error if sectorsize <> 512
        rr      d
        rr      e
        ld      hl,$ffd2
        add     hl,de
        ccf
        ret     nc              ; error if alloc vector size/2 >$2d
        ld      e,(ix+$0b)
        ld      a,(ix+$0c)
        and     $7f
        ld      d,a
        ld      hl,$ffbf
        add     hl,de
        ccf
        ret     c               ; success if chksum size <= $40
        ld      (ix+$0b),$40
        ld      a,(ix+$0c)
        and     $80
        or      $00
        ld      (ix+$0c),a      ; else set chksum size to $40
        scf
        ret

n10ea   ld      a,c
        ld      (rw_page),a     ; save page & address to read to
        ld      (rw_add),hl
        call    n0514           ; test if file B open for reading
        ret     nc              ; exit if not
        add     hl,de           ; calculate final address
        push    hl
        call    n1107           ; do the read
        pop     hl
        ret     c               ; exit if successful
        push    af
        ld      de,(rw_add)     ; get current address
        or      a
        sbc     hl,de
        ex      de,hl           ; DE=unread bytes
        pop     af
        ret 

; Subroutine to read DE bytes from file

n1107   push    bc
        push    de
        ld      hl,$0023
        add     hl,bc
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      b,(hl)          ; get BDE=file length
        inc     hl
        ld      a,e
        scf
        sbc     a,(hl)
        ld      e,a
        inc     hl
        ld      a,d
        sbc     a,(hl)
        ld      d,a
        inc     hl
        ld      a,b
        sbc     a,(hl)
        ex      de,hl           ; AHL=filelength available to read
        pop     de
        pop     bc
        jr      c,n1130         ; exit if none
        dec     de              ; DE=#bytes to read-1
        sbc     hl,de
        add     hl,de
        sbc     a,$00
        jr      nc,n1134        ; if enough bytes in file, move on
        ex      de,hl
        call    n1134           ; else read what's available
        ret     nc              ; exit if error
n1130   ld      a,$19           ; "end of file" error
        or      a
        ret
n1134   inc     de
        ld      a, d
        and     $fe
        jr      z, n1a65
        push    bc
        push    de
        xor     a
        ld      hl, $f516
        call    n3879
        pop     de
        pop     bc
        jr      nc, n1a65
        ld      ix, $f518
        push    de
        ld      hl, $0026
        add     hl, bc
        ld      a, (hl)
        add     a, e
        ld      (hl), a
        inc     hl
        ld      a, (hl)
        adc     a, d
        ld      (hl), a
        inc     hl
        ld      a, (hl)
        adc     a, 0
        ld      (hl), a
        ld      hl, $0022
        add     hl, bc
        res     5, (hl)
        ld      l, (ix-$02)
        ld      h, (ix-$01)
        call    n2558
        call    n25c2
        ld      hl, (rw_add)
        jr      n1a4c
n1a49   call    n2558        
n1a4c   ld      a, (rw_page)
        call    n0207
        ex      (sp), hl
        and     a
        sbc     hl, de
        jr      c, n1a8b
        ex      (sp), hl
        call    n25ab
        ex      (sp), hl
        ld      a, h
        or      l
        ex      (sp), hl
        jr      nz, n1a49
        pop     de
        jr      n1a98
n1a65   dec     de
        ld      hl,$0026
        add     hl,bc
        ld      a,(hl)
        and     $7f
        jr      z,n1144         ; move on if filepointer on record boundary
        call    n10d9           ; read byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jp      n1134           ; loop back
n1144   ld      hl,$ff81
        add     hl,de
        jr      nc,n1151        ; move on if don't need any more full records
        call    n10f6           ; read a record
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n1144           ; loop back
n1151   call    n10d9           ; read byte
        ret     nc              ; exit if error
        ret     z               ; exit if finished
        jr      n1151           ; loop back
n1a8b   add     hl, de
        ex      de, hl
        and     a
        sbc     hl, de
        ex      (sp), hl
        call    n25ab
        pop     de
        call    n26e5
n1a98   call    n26d7
        ld      (rw_add), hl
        scf
        ret
      ENDIF

; Subroutine to do an ALERT message for error A (IX=XDPB)

n1a34   push    ix
        push    hl
        push    de
        push    bc
        call    n2164           ; turn off motor
        ld      c,(ix+$1c)      ; C=drive
        call    n02f7           ; run the ALERT routine
        pop     bc
        pop     de
        pop     hl
        pop     ix
        ret

; Subroutine to get H=first RAMdisk buffer, L=number of RAMdisk buffers

n1a48   ld      a,(spec_m+5)
        ld      h,a             ; H=first buffer
        ld      a,(spec_m+2)    ; A=last buffer+1
        sub     h
        ld      l,a             ; L=# buffers
        ret

n1a52
      IF garry
n1abe   ld      ix, xdpb_m
        ld      a, (ix+$1c)
        and     a
        jr      z, n1acc
        call    n189d
        ret     nc
n1acc
      ELSE
; Subroutine to change the RAMdisk to first buffer=H, number of buffers=L

        ld      a,'M'
        call    n184d           ; get XDPB of drive M:
        jr      nc,n1a5d        ; move on if doesn't exist
        call    n189d           ; log drive M: out
        ret     nc              ; exit if error
      ENDIF
n1a5d   push    hl
        ld      hl,n1aae
        ld      de,spec_m
        ld      bc,$0008
        ldir                    ; copy initial disk spec for M:
        pop     de
      IF garry
        ld      a,e
        cp      $04
        jr      c, n1b14
      ELSE
        ld      hl,$0000
        ld      (xdpb_ptrs+$18),hl ; set M:s XDPB to null
        ld      a,e
        cp      $04
        ret     c               ; exit with M: disabled if <2K allowed
      ENDIF
        add     a,d
        ld      (spec_m+2),a    ; #tracks=size+offset (=last buffer+1)
        ld      a,d
        ld      (spec_m+5),a    ; #reserved tracks (=first buffer)
n1a7c   ld      a,d
        push    de
        call    n022b           ; get address of buffer
        call    n0207           ; page in the bank
        ld      d,h
        ld      e,l
        inc     de
        ld      (hl),$e5
        ld      bc,$01ff
        ldir                    ; fill buffer with $e5 filler bytes
        call    n0207           ; repage previous bank
        pop     de
        inc     d               ; next buffer
        dec     e
        jr      nz,n1a7c        ; back for rest
        ld      ix,xdpb_m
        ld      hl,spec_m       ; disk spec for M:
        call    n1d30           ; initialise DPB
        ld      (ix+$0b),$00
        ld      (ix+$0c),$80    ; M: is permanent (fixed)
      IF garry
        scf                     ; success
        ret
n1b14   ld      a, (ix+$1c)
        ld      (ix+$1c), 0
        call    n04ed
        sub     $41
        ret     c
        ld      e, a
        ld      d, 0
        ld      hl, $e2a0
        add     hl, de
        add     hl, de
        ld      (hl), 0
        inc     hl
        ld      (hl), 0
        scf
        ret
      ELSE
        ld      (xdpb_ptrs+$18),ix ; set pointer to XDPB for M:
        scf                     ; success
        ret
      ENDIF

; Disk spec for RAMdisk

n1aae   defb    $00,$00,$00,$01
        defb    $02,$00,$03,$00

; Subroutine to get page (A) and address (HL) of RAMdisk logical sector
; for current file

n1ab6   push    de
        call    n19df           ; get logical track & sector
        ld      a,e
        or      a
        jr      nz,n1ac9        ; RAMdisk has 1sec/trk, so error if not 0
        ld      a,d
        ld      hl,spec_m+2
        cp      (hl)
        jr      nc,n1ac9        ; error if track out of range
        call    n022b           ; convert track=buffer# to address & bank
        scf
n1ac9   pop     de
        ret     c
        ld      a,$02           ; seek fail error
        ret

; DOS_BOOT

n1ace   ld      a,'A'
        call    n1871           ; login a disk
        call    c,n189d         ; log back out if no error
        ld      de,$0000        ; logical sector 0
        call    c,n15f4         ; get sector to memory at AHL if no error
        ret     nc              ; exit if error
        ld      c,a             ; save bank
        push    hl
        call    n0207           ; page bank in
        push    af              ; save old bank
        xor     a
        ld      b,a
        ld      e,$02
n1ae7   add     a,(hl)          ; form checksum of all bytes in sector
        inc     hl
        djnz    n1ae7
        dec     e
        jr      nz,n1ae7
        ld      e,a
        pop     af
        call    n0207           ; page back original bank
        pop     hl
        ld      a,e
        xor     $03             ; checksum must be 3
        ld      a,$23
        ret     nz              ; if not, exit with "disk not bootable" error
        di                      ; disable interrupts
        ld      b,$03
        ld      de,$fe00
        ld      ix,$0200
        call    n023d           ; copy bootsector to $fe00 in bank 3
        ld      a,$03
        call    n0207           ; page in bank 3
        ld      hl,n1b22
        ld      de,$fdfb
        ld      bc,$0005
        ldir                    ; copy routine to bank 3
        ld      bc,$1ffd
        ld      a,$07
        ld      sp,$fe00
        jp      $fdfb           ; jump to following routine in bank 3
n1b22   out     (c),a           ; page in RAM 4,7,6,3; keep disk motor on
        jp      $fe10           ; jump to boot routine

      IF garry=0
        defs    9
      ENDIF

; ********************** LOW-LEVEL ROUTINES *********************


; Subroutine to setup parameter block for format

n1b30   ld      a,(ix+$19)
        and     $40             ; A=modulation mode
        or      $0d             ; format command
        call    n1b9c           ; set up parameter block as for read/write etc
        ld      l,(ix+$0f)
        ld      h,(ix+$13)
        ld      (ddl_parms+8),hl ; store sector size & #sectors per track
        ld      h,e
        ld      l,(ix+$18)
        ld      (ddl_parms+$0a),hl ; store format gap length & filler byte
        ld      a,$06
        ld      (ddl_parms+5),a ; store # of command bytes
        ret

; Setup parameter block for sector check

n1b50   ld      a,(ix+$19)      ; flags
        or      $11             ; scan equal command
        call    n1b69           ; set up parameter block
        ld      (hl),$01        ; store data length 1
        ret

; Setup parameter block for sector read

n1b5b   ld      a,(ix+$19)      ; flags
        or      $06             ; read data command
        jr      n1b69           ; set up parameter block

; Setup parameter block for sector read

n1b62   ld      a,(ix+$19)      ; flags
        and     $c0             ; mask off deleted address mark bit
        or      $05             ; write data command

; Subroutine to setup parameter block for low-level read/writes

n1b69   call    n1b9c           ; setup basic parameter block data
        ld      a,e
        add     a,(ix+$14)
        ld      e,a             ; E=physical sector number
        push    de              ; save physical track & sector numbers
        ld      hl,(rt_encode)
        ld      a,h
        or      l
        call    nz,n1909        ; call encode routine if required
        ld      a,e
        ld      (ddl_parms+$0a),a ; store 1st sector ID
        ld      l,(ix+$0f)
        ld      h,e
        ld      (ddl_parms+$0b),hl ; store sector size & last(=1st) sector ID
        ld      a,(ix+$17)
        ld      (ddl_parms+$0d),a ; store gap length
        ld      h,b
        ld      l,d
        ld      (ddl_parms+8),hl ; store track & side numbers
        ld      a,$09
        ld      (ddl_parms+5),a       ; store # command bytes
        ld      hl,ddl_parms+$0e
        ld      (hl),$ff        ; store dummy data length
        pop     de
        ret

; Subroutine to setup some of the parameter block for sector read/writes
; (except # command bytes & additional command bytes)

n1b9c   ld      (ddl_parms+1),hl ; store buffer address
        ld      l,a
        ld      a,b
        ld      (ddl_parms),a   ; store buffer page
        call    n1bb5           ; C=physical side & unit byte
        ld      h,c
        ld      (ddl_parms+6),hl ; store command & unit byte
        ld      l,(ix+$15)
        ld      h,(ix+$16)
        ld      (ddl_parms+3),hl ; store sector size as # bytes to transfer
        ret

; Subroutine to return physical side (B) and track (D) given logical track (D)
; Physical side is also ORed with unit number in C

n1bb5   ld      a,(ix+$11)
        and     $7f             ; A=sidedness
        ld      b,$00           ; side 0
        ret     z               ; exit if single-sided (physical=logical)
        dec     a
        jr      nz,n1bc8        ; move on if double-sided: successive sides
        ld      a,d
        rra                     ; for alternate sides, halve track
        ld      d,a
        ld      a,b
        rla                     ; with side=remainder
        ld      b,a
        jr      n1bd4           ; move on to OR into unit number
n1bc8   ld      a,d
        sub     (ix+$12)        ; subtract # tracks
        jr      c,n1bd4         ; if < # tracks, physical=logical so move on
        sub     (ix+$12)        ; on successive side, tracks count back down
        cpl
        ld      d,a
        inc     b               ; and use side 1
n1bd4   ld      a,b
        add     a,a
        add     a,a
        or      c
        ld      c,a             ; update unit number with side bit
        ret

; DD_ENCODE

n1bda   or      a
        jr      nz,n1be0        ; move on if routine supplied
        ld      hl,$0000        ; disable
n1be0   ld      de,(rt_encode)  ; get old encode routine address
        ld      (rt_encode),hl  ; store new encode routine address
        ex      de,hl           ; HL=old routine
        ret

; Subroutine to read A bytes from a sector

n1be9   push    af
        call    n1b5b           ; setup parameter block for sector read
        pop     af
        ld      l,a
        ld      h,$00
        ld      (ddl_parms+3),hl ; store #bytes required from sector
        ld      hl,n1bf9        ; the operation to try
        jr      n1c4f           ; go to try it
n1bf9   ld      hl,ddl_parms    ; address of parameter block
        jp      n20ba           ; read bytes and exit

; DD_READ_SECTOR

n1bff   call    n1b5b           ; set up parameter block
        ld      hl,n1c07        ; the operation to try
        jr      n1c4f           ; go to try it
n1c07   ld      hl,ddl_parms    ; address of parameter block
        jp      n20c3           ; do a DD_L_READ

; DD_WRITE_SECTOR

n1c0d   call    n1e65           ; test if suitable XDPB
        ret     nc              ; exit if error
        call    n1b62           ; set up parameter block
        jr      n1c2b           ; move on

; DD_CHECK_SECTOR

n1c16   call    n1b50           ; set up parameter block
        call    n1c2b           ; scan the data
        ret     nc              ; exit if error
        ld      a,(fdc_res+3)   ; get ST2
        cp      $08             ; set Z if scan was equal
        scf                     ; success
        ret

; DD_FORMAT

n1c24   call    n1e65           ; test if suitable XDPB
        ret     nc              ; exit if not
        call    n1b30           ; setup parameter block
n1c2b   ld      hl,n1c30        ; the operation to try
        jr      n1c4f           ; go to try it
n1c30   ld      hl,ddl_parms    ; address of parameter block
        jp      n20cc           ; do a DD_L_WRITE

; DD_READ_ID

n1c36   call    n1c41           ; read a sector ID
        ld      hl,fdc_res      ; get results buffer address
        ret     nc              ; exit if error
        ld      a,(fdc_res+6)   ; get sector number
        ret

; Subroutine to read a sector ID

n1c41   call    n1bb5           ; convert logical track to physical
        ld      hl,n1c49        ; the operation to try
        jr      n1c4f           ; go to do it
n1c49   ld      a,(ix+$19)      ; get modulation mode
        jp      n2103           ; read sector ID & exit

; Routine to turn on motor, try an operation in HL on track D multiple
; times & then start the motor off timeout

n1c4f   call    n212b           ; turn on motor
        call    n1e80           ; try the operation multiple times
        jp      n2150           ; start motor off timeout & exit


; Tables of specifications for disk types 0-3
; Format as on p215 of +3 Manual

; Type 0 - Spectrum +3 format

n1c58   defb    $00,$00,$28,$09
        defb    $02,$01,$03,$02
        defb    $2a,$52

; Type 1 - CPC system format

        defb    $01,$00,$28,$09
        defb    $02,$02,$03,$02
        defb    $2a,$52

; Type 2 - CPC data format

        defb    $02,$00,$28,$09
        defb    $02,$00,$03,$02
        defb    $2a,$52

; Type 3 - PCW format

        defb    $03,$81,$50,$09
        defb    $02,$01,$04,$04
        defb    $2a,$52

; DD_LOGIN

n1c80   xor     a
        call    n1cdb           ; get IX=XDPB of +3 format disk
        ld      d,$00
        push    bc
        call    c,n1c36         ; if no error, read a sector ID on track 0
        pop     bc
        ret     nc              ; exit if error
        and     $c0
        ld      e,$01           ; CPC system format if IDs ~$40
        cp      $40
        jr      z,n1c99
        inc     e               ; CPC data format if IDs ~$c0
        cp      $c0
        jr      nz,n1c9f        ; otherwise, +3 or PCW format
n1c99   ld      a,e
        call    n1cdb           ; get IX=XDPB of CPC format disks
        jr      n1cd3           ; move on
n1c9f   push    bc
        ld      hl,ddl_parms+$0f ; buffer for disk spec
        ld      de,$0000        ; track 0, sector 0
        ld      b,$07           ; use page 7
        ld      a,$0a           ; 10 bytes required (disk spec)
        push    hl
        call    n1be9           ; read disk spec from boot sector
        pop     hl
        pop     bc
        jr      c,n1cba         ; move on if no error
        cp      $08
        scf
        ccf
        ret     nz              ; exit with errors except disk changed
        ld      a,$06           ; substitute "unrecognised disk format"
        ret
n1cba   push    bc
        ld      d,h
        ld      e,l
        ld      c,(hl)
        ld      b,$0a           ; check 10 bytes of specifier
n1cc0   ld      a,(de)
        inc     de
        cp      c
        jr      nz,n1cca        ; if any differ, use this as disk spec
        djnz    n1cc0
        ld      hl,n1c58        ; use +3 format if all bytes the same
n1cca   pop     bc
        ld      a,(hl)
        cp      $04             ; test format type
        ld      a,$06           ; signal unrecognised disk format
        call    c,n1cee         ; initialise XDPB if no error
n1cd3   push    hl
        push    bc
        call    c,n1dee         ; if no errors, update drive equipment &
        pop     bc              ; check suitable for disk
        pop     hl
        ret

; DD_SEL_FORMAT

n1cdb   ld      e,a
        cp      $04             ; test format type
        ld      a,$06
        ret     nc              ; error 6 if not type 0-3
        ld      a,e
        add     a,a
        ld      e,a             ; E=2*type
        add     a,a
        add     a,a
        add     a,e             ; A=10*type
        adc     a,n1c58 and $ff
        ld      l,a
        adc     a,n1c58/$100
        sub     l
        ld      h,a             ; HL=address of info for type

; DD_L_XDPB
; Enter at this point to initialise an XDPB (HL=disk spec)

n1cee   push    hl              ; save info address
        push    bc
        ld      a,(hl)          ; get format type
        ld      b,$41           ; first sector number for CPC system
        dec     a
        jr      z,n1cfd
        ld      b,$c1           ; first sector number for CPC data
        dec     a
        jr      z,n1cfd
        ld      b,$01           ; first sector number for +3/PCW
n1cfd   ld      (ix+$14),b      ; set first sector number
        inc     hl
        ld      a,(hl)
        ld      (ix+$11),a      ; set sidedness & single/double track
        inc     hl
        ld      a,(hl)
        ld      (ix+$12),a      ; set # tracks
        inc     hl
        ld      a,(hl)
        ld      (ix+$13),a      ; set # sectors
        inc     hl
        ld      b,(hl)          ; B=sector size (0..2)
        inc     hl
        inc     hl
        inc     hl
        inc     hl
        ld      a,(hl)
        ld      (ix+$17),a      ; set gap length (r/w)
        inc     hl
        ld      a,(hl)
        ld      (ix+$18),a      ; set gap length (format)
        ld      hl,$0080
        call    n1efd           ; HL=128x2^B
        ld      (ix+$15),l
        ld      (ix+$16),h      ; set sector size (bytes)
        ld      (ix+$19),$60    ; set multitrack,modulation flags
        pop     bc              ; restore registers
        pop     hl

; DD_L_DPB
; Enter at this point to initialise a DPB (HL=disk spec)
; On exit, DE=ALS, HL=HASH and A=format type

n1d30   push    bc              ; save registers
        push    hl
        ex      de,hl
        ld      hl,$0004
        add     hl,de
        ld      a,(hl)
        ld      (ix+$0f),a      ; set PSH=log2(sectorsize/128)
        push    af
        call    n1ef3
        ld      (ix+$10),a      ; set PHM=(sectorsize/128)-1
        dec     hl
        ld      l,(hl)
        ld      h,$00
        pop     bc
        call    n1efd           ; HL=(#sectors)x(records per sector)
        ld      (ix+$00),l
        ld      (ix+$01),h      ; set SPT (records per track)
        ld      hl,$0006
        add     hl,de
        ld      a,(hl)
        ld      (ix+$02),a      ; set BSH=log2(blocksize/128)
        ld      c,a             ; save it
        push    hl
        call    n1ef3
        ld      (ix+$03),a      ; set BLM=(blocksize/128)-1
        dec     hl
        ld      e,(hl)
        ld      (ix+$0d),e      ; set OFF (#reserved tracks)
        ld      (ix+$0e),$00
        dec     hl
        dec     hl
        ld      b,(hl)          ; B=#sectors
        dec     hl
        ld      d,(hl)          ; D=#tracks
        dec     hl
        ld      a,(hl)          ; A=sidedness
        ld      l,d
        ld      h,$00           ; HL=tracks per side
        ld      d,h             ; DE=reserved tracks
        and     $7f
        jr      z,n1d79
        add     hl,hl           ; HL=total tracks on disk
n1d79   sbc     hl,de
        ex      de,hl           ; DE=total tracks-reserved tracks
        ld      hl,$0000
n1d7f   add     hl,de
        djnz    n1d7f           ; HL=total non-reserved sectors
        ld      a,c
        sub     (ix+$0f)
        ld      b,a
        call    n1f04           ; HL=total non-reserved blocks
        dec     hl
        ld      (ix+$05),l
        ld      (ix+$06),h      ; set DSM (last block number)
        ld      b,$03
        ld      a,h
        or      a
        jr      z,n1d98
        inc     b               ; B=3, or 4 if >256 blocks
n1d98   ld      a,c             ; A=log2(blocksize/128)
        sub     b               ; A=log2(bs/2^7)-log2(2^B)=log2(bs/2^(B+7))
        call    n1ef3           ; A=(bs/2^(B+7))-1
        ld      (ix+$04),a      ; set EXM (extent mask)
        pop     de
        push    hl              ; save DSM
        ld      b,$02
        call    n1f04
        inc     hl
        inc     hl              ; HL=Floor(DSM/4)+2=ALS (allocation vector size)
        ex      (sp),hl         ; save ALS and retrieve DSM
        inc     de
        ld      a,(de)          ; A=#dir blocks
        or      a
        jr      nz,n1db7        ; move on unless need to calculate it
        add     hl,hl
        ld      a,h
        inc     a
        cp      $02
        jr      nc,n1db7
        inc     a
n1db7   ld      b,a
        ld      hl,$0000
n1dbb   scf
        rr      h
        rr      l
        djnz    n1dbb           ; HL=2^16-2^(16-#dir blocks)
        ld      (ix+$09),h      ; set AL0 directory bitmap
        ld      (ix+$0a),l      ; set AL1 directory bitmap
        ld      h,$00
        ld      l,a             ; HL=#dirblocks
        ld      b,c             ; B=log2(blocksize/128)
        inc     b
        inc     b               ; B=log2(bs/128)+log2(4)=log2(bs/32)
        call    n1efd
        push    hl
        dec     hl              ; HL=(#dirblocks*bs/32)-1=DRM
        ld      (ix+$07),l
        ld      (ix+$08),h      ; set DRM (last directory entry number)
        ld      b,$02
        call    n1f04
        inc     hl              ; HL=((DRM+1)/4)+1=CKS
        ld      (ix+$0b),l
        ld      (ix+$0c),h      ; set CKS (checksum vector size)
        pop     hl
        add     hl,hl
        add     hl,hl           ; HL=4*(DRM+1) (hash table size)
        pop     de              ; DE=ALS (2bit allocation vector size)
        pop     bc
        ld      a,(bc)          ; A=format type
        scf                     ; signal success
        pop     bc              ; restore BC
        ret

; Subroutine to update drive equipment info & check is suitable for disk

n1dee   ld      b,a
        push    de
        push    bc
        call    n1e10           ; test drive equipment, updating if necessary
        pop     bc
        pop     de
        ret     nc              ; exit if error
        ld      a,(ix+$11)
        and     $03
        jr      z,n1e02         ; move on if disk is single-sided
        bit     1,(hl)
        jr      z,n1e0c         ; error 9 if drive single-sided
n1e02   ld      a,b
        scf
        bit     7,(ix+$11)
        ret     z               ; exit with success if disk not double-track
        bit     3,(hl)
        ret     nz              ; or if drive double-track
n1e0c   ld      a,$09           ; error 9 - unsuitable media for drive
        or      a
        ret

; Subroutine to test drive equipment for sidedness and double/single track

n1e10   call    n1f6a           ; get equipment address
        ld      a,(hl)
        and     $0c             ; check if single/double track drive
        jr      z,n1e24         ; move on if not known
        ld      a,(hl)
        and     $03             ; check if single/double sided drive
        scf
        ret     nz              ; exit with success if known
        ld      a,(ix+$11)
        and     $03             ; check # sides for disk
        scf
        ret     z               ; exit with success if disk single-sided
n1e24   ld      a,(ix+$11)
        and     $03             ; check # sides for disk
        ld      d,$02           ; track 2
        jr      z,n1e39         ; move on if single-sided
        dec     a
        ld      d,$05           ; track 2 on side 1 if alternating
        jr      z,n1e39         ; move on if alternating sides
        ld      a,(ix+$12)      ;
        add     a,a
        sub     $03
        ld      d,a             ; track 2 on side 1 if successive sides
n1e39   push    hl
        call    n1c36           ; read a sector ID
        pop     hl
        ret     nc              ; exit if error
        ld      de,(fdc_res+4)  ; get E=track, D=head detected
        ld      a,(ix+$11)
        and     $03
        jr      z,n1e53         ; move on if single-sided disk
        dec     d               ; D should now be zero
        jr      z,n1e51
        set     0,(hl)          ; if not, set single-sided drive
        jr      n1e53
n1e51   set     1,(hl)          ; set double-sided drive
n1e53   ld      a,(ix+$11)
        dec     e
        dec     e
        jr      z,n1e5b         ; move on if track 2 was detected
        cpl                     ; else drive has inverse d-track bit of disk
n1e5b   rla                     ; get double-track bit
        jr      nc,n1e61
        set     3,(hl)          ; set double-track
        ret
n1e61   set     2,(hl)          ; set single-track
        scf
        ret

; DD_TEST_UNSUITABLE

n1e65   push    hl
        call    n1f6a           ; get equipment address
        bit     3,(hl)          ; test if double-track
        pop     hl
        scf
        ret     z               ; exit with okay if single-track
        ld      a,(ix+$11)
        rla                     ; set carry (okay) if disk double-track
        ld      a,$09           ; error 9 - unsuitable media
        ret

; DD_EQUIPMENT

n1e75   call    n1f6a           ; get equipment address
        ld      a,(hl)          ; get flags byte
        and     $0f             ; mask side & track info
        ret

; DD_SET_RETRY
      IF garry=0
n1e7c   ld      (retry_cnt),a   ; set it
        ret
      ENDIF

; Subroutine to try operation in HL on track D multiple times

n1e80   ld      a,(retry_cnt)
        ld      b,a             ; B=retry count
n1e84   push    bc
        call    n1eb0           ; try the operation
        pop     bc
        ret     z               ; exit for success or unrecoverable error
        cp      $04
        jr      nz,n1eac        ; move on if not "no data" error
        push    hl
        push    de
        push    bc
        ld      a,(ix+$19)      ; flags (for modulation mode)
        call    n2103           ; read a sector ID
        call    n204a           ; process results
        pop     bc
        pop     de
        pop     hl
        jr      nz,n1eac        ; move on if recoverable error
        ret     nc              ; exit if non-recoverable error
        ld      a,(fdc_res+6)   ; get sector ID found
        xor     (ix+$14)
        and     $c0             ; compare to XDPB sector ID (detect if
        ld      a,$08           ; different CPC format than expected)
        ret     nz              ; error 8 - disk changed
        rra
n1eac   djnz    n1e84           ; back for more tries
        or      a               ; exit with error 4 - no data
        ret

; Subroutine to position head on track D and call subroutine in HL,
; processing results buffer afterwards
; B contains try number

n1eb0   ld      a,b
        and     $07
        jr      z,n1ec2         ; reseek to high track every 8 tries
        and     $03
        jr      nz,n1ecc        ; recalibrate every other 8 tries
        push    hl
        call    n1f6a           ; get equipment address
        res     6,(hl)          ; signal head not positioned
        pop     hl
        jr      n1ecc
n1ec2   push    de
        ld      d,(ix+$12)
        dec     d               ; D=high track number
        call    n1f76           ; seek to it
        pop     de
        ret     nc              ; exit if error
n1ecc   call    n1f76           ; seek to track D
        ret     nc              ; exit if error
        push    hl
        push    de
        push    bc
        call    n1909           ; call routine address in HL
        pop     bc
        pop     de
        call    n204a           ; process results buffer
        pop     hl
        ret

; DD_ASK_1

n1edd   push    bc
        ld      c,$01
        call    n1ee9           ; get status of unit 1
        pop     bc
        and     $60
        ret     z               ; exit if not ready or write-protected
        scf                     ; signal "unit 1 present"
        ret

; DD_DRIVE_STATUS

n1ee9   call    n212b           ; turn on motor
        call    n2087           ; get status in A
        jp      n2150           ; start motor off timeout & exit

; Call is made here to call the address in HL
      IF garry=0
n1909   jp      (hl)
      ENDIF

; Subroutine to calculate N/128 - 1
; given A=log2 (N/128)

n1ef3   or      a
        ret     z               ; exit if zero
        ld      b,a
        ld      a,$01
n1ef8   add     a,a             ; calculate N/128
        djnz    n1ef8
        dec     a               ; decrement
        ret

; Subroutine to multiply HL by 2^B

n1efd   ld      a,b
        or      a
        ret     z               ; exit when B=0
n1f00   add     hl,hl           ; double HL
        djnz    n1f00           ; loop back
        ret

; Subroutine to divide HL by 2^B

n1f04   ld      a,b
        or      a
        ret     z               ; exit when B=0
n1f07   srl     h
        rr      l               ; halve HL
        djnz    n1f07           ; loop back
        ret

      IF garry=0
        defs    18
      ENDIF

; Default setup data, used by DD_INIT

n1f20   defb    $0a             ; motor on time
        defb    $32             ; motor off time
        defb    $af             ; write off time
        defb    $1e             ; head settle time
      IF floppy35
        defb    $04             ; step rate for 3,5" units
      ELSE
        defb    $0c             ; step rate
      ENDIF
        defb    $0f             ; head unload time
        defb    $03             ; head load time x2+1

; DD_INTERFACE

n1f27   push    bc
        ld      bc,$2ffd
        in      a,(c)           ; read FD status register ($ff if no i/f)
        add     a,$01
      IF carmel=1
        xor     a
      ELSE
        ccf                     ; carry not set if no i/f
      ENDIF
        pop     bc
        ret

; DD_INIT

n1f32   ld      hl,equipment    ; zero equipment data, timing consts and
        ld      b,$10           ; FDC results buffer
n1f37   ld      (hl),$00
        inc     hl
        djnz    n1f37
        ld      a,$0f
        ld      (retry_cnt),a   ; set retry count to $0f
        call    n2164           ; turn off motor
        ld      hl,n1f20        ; enter DD_SETUP with default setup data

; DD_SETUP

n1f47   ld      de,tm_mtron
        ld      bc,$0005
        ldir                    ; copy first 5 bytes of setup info
        ld      a,(tm_step)
        dec     a
        rlca
        rlca
        rlca
        cpl
        and     $f0
        or      (hl)
        inc     hl
        ld      h,(hl)
        ld      l,a             ; HL=setup info for FDC
        ld      a,$03           ; send setup info & exit
        call    n2114
        ld      a,l
        call    n2114
        ld      a,h
        jp      n2114

; Subroutine to convert unit/head byte (A) to equipment address (in HL)

n1f6a   ld      a,c
        and     $03
        add     a,a             ; A=2*unit
        add     a,equipment and $ff
        ld      l,a
        adc     a,equipment/$100
        sub     l
        ld      h,a             ; HL=equipment+2*unit
        ret

; DD_L_SEEK

n1f76   push    hl
        call    n1f6a           ; get equipment address
        call    n1f7f           ; do the seek
        pop     hl
        ret

; Subroutine to seek to track D on equipment HL (XDPB=IX)

n1f7f   ld      a,(retry_cnt)
        ld      b,a             ; B=# tries
n1f83   bit     6,(hl)
        jr      nz,n1f92        ; move on if head positioned
        inc     hl
        ld      (hl),$00        ; set track zero
        dec     hl
        call    n1fb7           ; seek to track zero
        jr      nc,n1fa8        ; move on if error
        set     6,(hl)          ; signal head positioned
n1f92   ld      a,d
        inc     hl
        cp      (hl)            ; compare required track to current
        dec     hl
        scf
        ret     z               ; exit with carry set if same
        or      a
        jr      nz,n1fa0
        call    n1fb7           ; recalibrate if track 0 required
        jr      n1fa3
n1fa0   call    n1fdb           ; else seek to track D
n1fa3   jr      nc,n1fad        ; move on if error
        inc     hl
        ld      (hl),d          ; store new track number
        ret                     ; done
n1fa8   push    de
        call    nz,n1fd7        ; attempt to seek to highest track
        pop     de
n1fad   res     6,(hl)          ; signal head not positioned
        ret     z               ; exit if FDC wasn't ready
        call    n206f           ; wait until ready
        djnz    n1f83           ; loop back for retries
        cp      a               ; exit with carry reset & error 2 - seek fail
        ret

; Subroutine to seek to track zero

n1fb7   call    n1fbb           ; try once
        ret     z               ; and again if unsuccessful
n1fbb   push    bc
        ld      b,(ix+$12)
        dec     b               ; B=max track
        bit     7,(ix+$11)
        jr      nz,n1fcd        ; move on unless double-track disk
        bit     3,(hl)
        jr      z,n1fcd         ; move on if single-track drive
        ld      a,b
        add     a,a
        ld      b,a             ; double max track #
n1fcd   ld      a,$07
        call    n2114           ; send recalibrate command
        ld      a,c
        and     $03
        jr      n1ffe           ; do the seek

; Subroutine to seek to track D (enter at n1fd7 for highest track)

n1fd7   ld      d,(ix+$12)
        dec     d               ; D=high track
n1fdb   push    bc
        ld      a,d
        inc     hl
        sub     (hl)            ; A=#tracks head must move
        dec     hl
        jr      nc,n1fe4
        cpl
        inc     a               ; ensure A is positive
n1fe4   ld      b,a
        ld      a,$0f
        call    n2114           ; send seek command
        ld      a,c
        call    n2114           ; send unit number
        ld      a,d             ; A=track number
        bit     7,(ix+$11)
        jr      nz,n1ffe        ; move on if double-track disk
        bit     3,(hl)
        jr      z,n1ffe         ; move on unless double-track drive
        ld      a,b
        add     a,a
        ld      b,a             ; double tracks to move
        ld      a,d
        add     a,a             ; double track number required

; Subroutine to complete a seek command. Carry set on exit if successful

n1ffe   push    hl
        call    n2114           ; send unit number
n2002   ld      a,(tm_step)
        call    n201c           ; delay for step rate time
        djnz    n2002           ; for max tracks
        ld      a,(tm_hdset)
        call    n201c           ; delay for head settle time
        ld      hl,fdc_res
        call    n2080           ; sense interrupt status
        call    n2025           ; wait until seek successfully completed
        pop     hl
        pop     bc
        ret

; Subroutine to delay for approx A milliseconds

n201c   ld      l,$dc
n201e   dec     l
        jr      nz,n201e
        dec     a
        jr      nz,n201c
        ret

; Subroutine to wait for end of seek command
; On exit, carry set if seek completed successfully
; If unsuccessful, Z set if FDC was not ready

n2025   ld      a,c             ; unit number
        or      $20             ; seek end bit
        inc     hl
        xor     (hl)            ; mask against ST0
        and     $fb             ; ignore side information
        scf
        ret     z               ; return with carry set if seek ended
        ld      a,(hl)
        and     $c0             ; test error code
        xor     $80
        jr      z,n2046         ; move on if invalid command
        ld      a,(hl)
        xor     c
        and     $03
        jr      z,n2040         ; move on if no error
        call    n2080           ; else sense interrupt status again
        jr      n2025           ; and loop back
n2040   ld      a,(hl)
        and     $08
        xor     $08             ; test not ready bit
        ret     z               ; exit with carry reset if so
n2046   ld      a,$02
        or      a
        ret                     ; else exit with Z reset

; Subroutine to process results buffer, exiting with error or carry set
; Z is set for success or write-protect/not ready error

n204a   inc     hl
        ld      a,(hl)          ; get ST0
        xor     c
        scf
        ret     z               ; exit with success if no error bits
        and     $08
        xor     $08
        ret     z               ; exit with error 0 if not ready
        inc     hl
        ld      a,(hl)          ; get ST1
        cp      $80             ; bit 7 always set on +3
        scf
        ret     z               ; exit with success if no error
        xor     $02
        ld      a,$01           ; error 1 if write-protected
        ret     z
        ld      a,$03           ; error 3 if CRC data error
        bit     5,(hl)
        ret     nz
        inc     a               ; error 4 if no data
        bit     2,(hl)
        ret     nz
        inc     a               ; error 5 if missing address mark
        bit     0,(hl)
        ret     nz
        inc     a
        inc     a               ; else error 7 (unknown error)
        ret

; Subroutine to wait until FDC ready for new command

n206f   push    hl
        push    af
        ld      hl,fdc_res
n2074   call    n2080           ; sense interrupt status
        and     $c0
        cp      $80
        jr      nz,n2074        ; wait for bit 7=1, bit 6=0
        pop     af
        pop     hl
        ret

; Subroutine to perform "sense interrupt status" command

n2080   ld      a,$08           ; Sense interrupt status command
        call    n2114           ; send it
        jr      n2093           ; get results & exit

; Subroutine to perform "get unit status" command

n2087   ld      a,$04           ; get unit status command
        call    n2114           ; send it
        ld      a,c             ; C=unit number
        call    n2114           ; send it & follow in to next routine

; Subroutine to get results string from FDC

n2090   ld      hl,fdc_res      ; HL=buffer for results
n2093   push    de
        push    bc
        ld      bc,$2ffd
        ld      d,$00           ; total bytes read
        inc     hl              ; step past length byte
        push    hl
n209c   in      a,(c)           ; get FD status register
        add     a,a
        jr      nc,n209c        ; loop back until ready
        jp      p,n20b3         ; move on if no more bytes (bit 6 reset)
        ld      b,$3f
        in      a,(c)           ; get byte
        ld      b,$2f
        ld      (hl),a          ; store in buffer
        inc     hl
        inc     d               ; increment count
        ex      (sp),hl         ; short delay
        ex      (sp),hl
        ex      (sp),hl
        ex      (sp),hl
        jr      n209c           ; back for more
n20b3   pop     hl
        ld      a,(hl)          ; A=first byte of results
        dec     hl
        ld      (hl),d          ; store results length
        pop     bc
        pop     de
        ret                     ; exit with HL=address of results

; Subroutine to read E bytes only

n20ba   call    n20de           ; output command except last byte
        call    n2185           ; read the bytes
        jp      n2090           ; get results string & exit


      IF garry=0
; DD_L_READ
n20c3
        call    n20de           ; output command except last byte
        call    n21b7           ; read the bytes
        jp      n2090           ; get results string & exit
      ENDIF

; DD_L_WRITE

n20cc   call    n20de           ; output command except last byte
        call    n21d4           ; write the bytes
        ld      a,(tm_wroff)    ; get write off time value
n20d5   dec     a
        inc     bc
        inc     bc
        inc     bc
        jr      nz,n20d5        ; write off delay
        jp      n2090           ; get results string & exit


; Subroutine to get page (D) and address (HL) of buffer for low-level
; command, and output all command bytes except last (in A)
; On entry, HL=address of parameter block

n20de   call    n206f           ; wait until ready for new command
        ld      a,(BANKM)       ; get old BANKM
        and     $f8
        or      (hl)            ; set page required
        ld      b,a
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)          ; DE=buffer address
        inc     hl
        ld      c,(hl)          ; C=# bytes to transfer (low)
        push    bc
        inc     hl
        inc     hl
        ld      b,(hl)          ; B=# command bytes
        inc     hl
        dec     b
n20f4   ld      a,(hl)          ; get next command byte
        inc     hl
        call    n2114           ; send it
        djnz    n20f4           ; back for all except last
        ld      a,(hl)
        ex      de,hl
        pop     de              ; D=page required, E=#bytes to transfer (low)
        ld      bc,$7ffd
        di                      ; turn off interrupts
        ret

; Subroutine to read a sector ID

n2103   call    n206f           ; wait for FDC ready
        and     $40             ; get modulation mode
        or      $0a             ; read sector ID command
        call    n2114           ; send command
        ld      a,c
        call    n2114           ; send unit
        jp      n2090           ; get results

; Subroutine to wait for FD ready & ouput A to data register if
; controller wants input

n2114   push    de
        push    bc
        ld      d,a
        ld      bc,$2ffd
n211a   in      a,(c)           ; get FD status register
        add     a,a
        jr      nc,n211a        ; loop back if not ready
        add     a,a
        jr      c,n2128         ; exit if controller doesn't want input
        ld      b,$3f
        out     (c),d           ; output byte to data register
        ex      (sp),hl         ; short delay
        ex      (sp),hl
n2128   pop     bc
        pop     de
        ret


; DD_L_ON_MOTOR

n212b   push    bc
        push    af
        xor     a
        ld      (timeout),a     ; zero timeout value
        ld      a,(BANK678)
        bit     3,a
        jr      nz,n214d        ; exit if motor already on
        or      $08
        call    n2173           ; set motor on
        ld      a,(tm_mtron)    ; get motor spinup timing value
n2140   push    af
        ld      bc,$3548
n2144   dec     bc              ; delay loop
        ld      a,b
        or      c
        jr      nz,n2144
        pop     af
        dec     a
        jr      nz,n2140
n214d   pop     af              ; restore registers and exit
        pop     bc
        ret

; DD_L_T_OFF_MOTOR

n2150   push    af
        xor     a
        ld      (timeout),a     ; zero timeout value
        ld      a,(BANK678)
        and     $08
        jr      z,n2162         ; go to exit if motor already off
        ld      a,(tm_mtroff)
        ld      (timeout),a     ; else set timeout value
n2162   pop     af
        ret

      IF garry
n2173   push    bc
        ld      bc, $1ffd
        ld      (BANK678), a
        out     (c), a
        pop     bc
        ret
      ELSE
; DD_L_OFF_MOTOR
n2164   push    af
        xor     a
        ld      (timeout),a     ; zero timeout value
        ld      a,(BANK678)
        and     $f7             ; get current BANK678 value & mask motor bit
        call    n2173           ; change the value to switch off motor
        pop     af
        ret

; Subroutine to set the BANK678 value to A

n2173   push    bc
        ld      b,a
        ld      a,r             ; get interrupt status
        ld      a,b
        ld      bc,$1ffd
        di
        ld      (BANK678),a
        out     (c),a           ; set the value
        pop     bc
        ret     po
        ei                      ; re-enable interrupts if necessary
        ret
      ENDIF
; Subroutine to output last command byte to FDC and read E bytes to buffer

n2185   call    n2114           ; send command
        out     (c),d           ; page in required bank
        ld      bc,$2ffd
        ld      d,$20
        jr      n219b
n2191   ld      b,$3f
        ini                     ; read a byte
        ld      b,$2f
        dec     e
        jp      z,n21ac         ; move on if got all bytes required
n219b   in      a,(c)
        jp      p,n219b         ; wait until FDC ready
        and     d
        jp      nz,n2191        ; loop back if more bytes on offer
        jr      n21ef           ; page bank 7 back and exit
n21a6   ld      b,$3f
        in      a,(c)           ; discard a byte
        ld      b,$2f
n21ac   in      a,(c)
        jp      p,n21ac         ; wait until FDC ready
        and     d
        jp      nz,n21a6        ; loop back if more bytes on offer
        jr      n21ef           ; page bank 7 back and exit

; Subroutine to output last byte of command to FDC and read bytes to buffer

n21b7   call    n2114           ; send command
        out     (c),d           ; page in required bank
        ld      bc,$2ffd
        ld      d,$20
        jr      n21c9
n21c3   ld      b,$3f
        ini                     ; read a byte
        ld      b,$2f
n21c9   in      a,(c)
        jp      p,n21c9         ; wait until FDC ready
        and     d
        jp      nz,n21c3        ; loop back if more bytes to read
        jr      n21ef           ; go to repage bank 7 & exit

; Subroutine to output last byte of command to FDC and write bytes from buffer

n21d4   call    n2114           ; send command
        out     (c),d           ; page in required bank
        ld      bc,$2ffd
        ld      d,$20
        jr      n21e6
n21e0   ld      b,$40
        outi                    ; write a byte
        ld      b,$2f
n21e6   in      a,(c)
        jp      p,n21e6         ; wait until FDC ready
        and     d
        jp      nz,n21e0        ; loop back if more bytes to write
n21ef   ld      a,(BANKM)
        ld      bc,$7ffd
        out     (c),a           ; page bank 7 back in
        ei
        ret

      IF garry=0
        defs    165
      ENDIF

; ******************** KEYBOARD SCANNING ROUTINES *****************

; These are copies of the keytables from ROM 3

; The L-mode keytable with CAPS-SHIFT

n229e   defm    "BHY65TGV"
        defm    "NJU74RFC"
        defm    "MKI83EDX"
        defm    $0e, "LO92WSZ"
        defm    " ", $0d, "P01QA"

; The extended-mode keytable (unshifted letters)

n22c5   defb    $e3,$c4,$e0,$e4
        defb    $b4,$bc,$bd,$bb
        defb    $af,$b0,$b1,$c0
        defb    $a7,$a6,$be,$ad
        defb    $b2,$ba,$e5,$a5
        defb    $c2,$e1,$b3,$b9
        defb    $c1,$b8

; The extended mode keytable (shifted letters)

n22df   defb    $7e,$dc,$da,$5c
        defb    $b7,$7b,$7d,$d8
        defb    $bf,$ae,$aa,$ab
        defb    $dd,$de,$df,$7f
        defb    $b5,$d6,$7c,$d5
        defb    $5d,$db,$b6,$d9
        defb    $5b,$d7

; The control code keytable (CAPS-SHIFTed digits)

n22f9   defb    $0c,$07,$06,$04
        defb    $05,$08,$0a,$0b
        defb    $09,$0f

; The symbol code keytable (letters with symbol shift)

n2303   defb    $e2,$2a,$3f,$cd
        defb    $c8,$cc,$cb,$5e
        defb    $ac,$2d,$2b,$3d
        defb    $2e,$2c,$3b,$22
        defb    $c7,$3c,$c3,$3e
        defb    $c5,$2f,$c9,$60
        defb    $c6,$3a

; The extended mode keytable (SYM-SHIFTed digits)

n231d   defb    $d0,$ce,$a8,$ca
        defb    $d3,$d4,$d1,$d2
        defb    $a9,$cf

    IF garry
n22c5x  xor     a
        ld      a, b
n22c7   push    hl
        ld      hl,(CURCHL)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS2)
        ex      (sp),hl
        ld      hl, $22f3
        ld      (al_resp), hl
        push    af
        call    n033a
        pop     af
        call    n3e00
        defw    $3ff7
        pop     hl
        ld      (FLAGS2),hl
        pop     hl
        ld      (FLAGS),hl
        pop     hl
        ld      (CURCHL),hl
        ret

      IF spanish
        defm    $8b, 13, $fb, "NO PREPARADA", 13
        defm    $8e, $ff, $8b, 13, $fb, "DISCO PROTEGIDO CONTRA ESCRITURA"
        defm    $8e, $ff, $8c, 13, $fb, "FALLO DE BUSQUEDA", 13
        defm    $8e, $ff, $8d, "ERROR DE DATOS", 13
        defm    $8e, $ff, $8d, "SIN DATOS", 13
        defm    $8e, $ff, $8d, "FALTA MARCA DE DIRECCIONES", 13
        defm    $8e, $ff, $8b, 13, $fb, "FORMATO INCORRECTO", 13
        defm    $8e, $ff, $8d, "ERROR DESCONOCIDO", 13
        defm    $8e, $ff, $8b, 13, $fb, "DISCO CAMBIADO; SUSTITUYALO", 13
        defm    $8e, $ff, $8b, 13, $fb, "DISCO NO ADECUADO", 13
        defm    $8e, $ff, "Introduzca el disco en la unidad para ", $fe
        defm    " y luego pulse una tecla", $ff
        defm    "UNIDAD ", $fe
        defm    ":", $ff, $8b, " PISTA ", $fd, $ff, $8c
        defm    " SECTOR ", $fc, 13, $fb, $ff, $fa
        defm    "]REINTENTAR, IGNORAR O CANCELAR?", $ff
        defs    5
      ELSE
        defm    $8b, 13, $fb, "Not ready", 13
        defm    $8e, $ff, $8b, 13, $fb, "Write protected", 13
        defm    $8e, $ff, $8c, 13, $fb, "Seek fail", 13
        defm    $8e, $ff, $8d, "Data error", 13
        defm    $8e, $ff, $8d, "No data", 13
        defm    $8e, $ff, $8d, "Missing address mark", 13
        defm    $8e, $ff, $8b, 13, $fb, "Bad format", 13
        defm    $8e, $ff, $8d, "Unknown error", 13
        defm    $8e, $ff, $8b, 13, $fb, "Disk changed, please replace", 13
        defm    $8e, $ff, $8b, 13, $fb, "Disk unsuitable", 13
        defm    $8e, $ff, "Please put the disk for ", $fe
        defm    ": into the drive then press any key", $ff
        defm    "Drive ", $fe
        defm    ":", $ff, $8b, " track ", $fd, $ff, $8c
        defm    " sector ", $fc, 13, $fb, $ff, $fa
        defm    "Retry, Ignore or Cancel?", $ff
        defs    29
      ENDIF

n2475   push    bc
        push    de
        ld      a, b
        call    n0207
        push    hl
        push    bc
        ld      d, h
        ld      e, l
        inc     de
        xor     a
        ld      (hl), a
        ld      bc, $01ff
        ldir
        pop     bc
        inc     c
        dec     c
        ld      hl, $ef98
        call    n266d
        jr      nc, n24e2
        and     a
        jr      z, n24f2
        ld      hl, ($ef9e)
        ld      a, h
        ld      h, l
        ld      l, a
        ld      a, ($efa0)
        rrca
        rrca
        adc     hl, hl
        rlca
        rlca
        adc     hl, hl
        inc     hl
        ld      bc, ($efa1)
        ld      a, c
        and     3
        rl      b
        rla
n24c7   ld      c, a
        ld      a, ($ef9d)
        and     15
        add     a, c
        inc     a
        ld      de, 0
n24d2   add     hl, hl
        ex      de, hl
        adc     hl, hl
        ex      de, hl
        dec     a
        jr      nz, n24d2
        ld      l, h
        ld      h, e
        ld      e, d
        ld      d, 0
        jr      n2500
n24e2   ld      a, 0
        jr      n251d
n24f2   ld      hl, ($efa0)
        ld      a, h
        ld      h, l
        ld      l, a
        ld      a, ($ef9f)
        and     $3f
        ld      de, 1
        add     hl, de
        adc     a, d
        add     hl, hl
        adc     a, a
        add     hl, hl
        adc     a, a
        ld      e, h
        ld      h, l
        ld      l, d
        and     a
        jr      z, n2500
        ld      e, $ff
        ld      h, e
        ld      l, e
n2500   ex      (sp), ix
        ld      (ix+$72), l
        ld      (ix+$73), h
        ld      (ix+$74), e
        ld      (ix+$78), l
        ld      (ix+$79), h
        ld      (ix+$7a), e
        ld      (ix+$6c), h
        ld      (ix+$6d), e
        ld      (ix+$02), h
        ld      (ix+$03), e
        ld      (ix+$6e), 2
        ld      (ix+$06), 2
n2510   ld      (ix+$70), $80
        ld      (ix+$0c), $80
        ex      (sp), ix
        scf
n251d   pop     hl
        push    af
        inc     h
        inc     h
        pop     af
        jr      n254e
n2524   push    bc
        set     7, b
        jr      n252c
n2529   push    bc
        res     7, b
n252c   push    de
        push    hl
        call    n25cd
        ex      (sp), ix
        jr      nc, n254c
        push    af
        ld      a, b
        and     7
        call    n0207
        bit     7, b
        jr      nz, n2548
        pop     af
        call    n2710
        jr      n254c
n2548   pop     af
        call    n26b8
n254c   pop     ix
n254e   push    af
        ld      a, 7
        call    n0207
        pop     af
        pop     de
        pop     bc
        ret
n2558   push    hl
        call    n26d7
        bit     7, (ix+$04)
        call    n27e4
n2571   jr      nc, n2578
        jr      nz, n2578
        inc     (ix)
        jr      nz, n257c
        inc     (ix+1)
        jr      nz, n257c
        jr      n257a
n2578   ld      a, (ix+$01)
        add     a, 2
        ld      (ix+$01), a
        jr      nc, n257c
n257a   inc     (ix+2)
        jr      nz, n257c
        inc     (ix+3)
n257c   ld      e, (ix)
        ld      d, (ix+1)
        ld      l, (ix+2)
        ld      h, (ix+3)
        bit     7, (ix+$04)
        ld      a, $51
        call    n2630
n257e   call    n26a6
        cp      $fe
        jr      nz, n257e
        ld      de, $0200
n2580   ld      c, mmcdata
        pop     hl
        and     a
        rl      (ix+$04)
        dec     (ix+$04)
        dec     (ix+$04)
        jr      z, n25a0
        rr      (ix+$04)
        ret
n25a0   inc     ix
        inc     ix
        inc     ix
        inc     ix
        inc     ix
        ret
n25ab   ld      c, mmcdata
        inc     e
        dec     e
        ld      b, e
        jr      z, n25b7
        inir
        inc     d
        jr      n25b9
n25b7   inir
n25b9   dec     d
        jr      nz, n25b7
        ld      e, d
        ld      a, 7
        jp      n0207
n25c2   ld      c, mmcdata
        ld      a, h
        or      l
        ret     z
        in      a, (c)
        dec     hl
        dec     de
        jr      n25c2
n25c8   dec     de
        ld      a, d
        and     e
        inc     a
        jr      nz, n25cd
        dec     bc
n25cd   xor     a
        push    bc
        push    de
        ld      l, (ix+$07)
        ld      h, (ix+$08)
        sbc     hl, de
        ld      l, (ix+$09)
        ld      h, (ix+$0a)
        ld      b, a
        sbc     hl, bc
        jr      nc, n25e9
        pop     de
        pop     bc
        ld      a, 2
        and     a
        ret
n25e9   ld      d, a
        ld      e, (ix+$02)
        ld      h, (ix+$01)
        ld      l, (ix+$03)
        rrc     l
        pop     bc
        add     hl, bc
        pop     bc
        ld      a, b
        ld      b, 0
        ex      de, hl
        adc     hl, bc
        ld      b, a
        bit     4, (ix+$10)
        call    n27f1
        jr      c, n2600
        ld      h, l
        ld      l, d
        ld      d, e
        ld      e, 0
        ex      de, hl
        add     hl, hl
        ex      de, hl
        adc     hl, hl
n2600   bit     4, (ix+$10)
        scf
        ret
n260f   push    af
        ld      a, $ff
        jr      n261d
n2614   and     a
n2616   push    af
	ifdef zc
	ld a, 1
	else
        ld      a, $fe
        endif
        jr      z, n261d
        ifdef zc
        ld a, 2
        else
        ld      a, $fd
        endif
n261d   out     (mmcen), a
        in      a, (mmcdata)
        pop     af
        ret
n2628   ld      h, 0
n262a   ld      l, 0
        ld      d, l
        ld      e, l
n2630   push    bc
        ld      b, $ff
        jr      n2638
n2637   push    bc
n2638   ld      c, a
        call    n2620
        call    n2616
        ld      a, c
        out     (mmcdata), a
        ld      a, h
        nop
        out     (mmcdata), a
        ld      a, l
        nop
        out     (mmcdata), a
        ld      a, d
        nop
        out     (mmcdata), a
        ld      a, e
        nop
        out     (mmcdata), a
        ld      a, b
        nop
        out     (mmcdata), a
        call    n2695
        pop     bc
        and     a
        ret     nz
        scf
        ret
n266d   push    bc
        push    de
        push    hl
        push    af
        call    n278c
        pop     af
        push    de
        ld      a, $49
        call    n2628
        pop     de
        pop     hl
        jr      nc, n2692
        call    n26a6
        cp      $fe
        jr      z, n2689
        and     a
        jr      n2692
n2689   ld      b, $12
        ld      c, mmcdata
n268d   ini
        jr      nz, n268d
        scf
        ld      a, d
n2692   pop     de
        pop     bc
        jr      n2620
n2695   push    bc
        ld      bc, 50
n2699   in      a, (mmcdata)
        cp      $ff
        jr      nz, n26a4
        djnz    n2699
        dec     c
        jr      nz, n2699
n26a4   pop     bc
        ret
n26a6   push    bc
        ld      b, 10
n26a9   call    n2695
        cp      $fe
        jr      z, n26b6
        cp      $ff
        jr      nz, n26b6
        djnz    n26a9
n26b6   pop     bc
        ret
n26b8   ld      a, $51
        call    n2630
n26bd   ld      a, 0
        jr      nc, n2620
        call    n26a6
        cp      $fe
        jr      z, n26ca
        and     a
        jr      n26bd
n26ca   push    ix
        pop     hl
        push    bc
        ld      bc, mmcdata
        inir
        nop
        inir
        pop     bc
n26d7   in      a, (mmcdata)
        nop
        nop
        in      a, (mmcdata)
        scf
n2620   call    n260f
n2621   push    af
        push    bc
        ld      b, 10
n2625   in      a, (mmcdata)
        djnz    n2625
        pop     bc
        pop     af
        ret
n26e5   ld      c, mmcdata
        in      a, (c)
        dec     de
        ld      a, d
        or      e
        jr      nz, n26e5
        jr      n26d7
n2710   ld      a, $58
        call    n2630
        jr      nc, n2757
        ld      a, $fe
        out     (mmcdata), a
        push    bc
        ld      bc, mmcdata
        push    hl
        push    ix
        pop     hl
        otir
        nop
        otir
        push    hl
        pop     ix
        pop     hl
        ld      a, $ff
        out     (mmcdata), a
        nop
        nop
        out     (mmcdata), a
        call    n2695
        pop     bc
        and     $1f
        cp      5
        jr      nz, n2757
        ld      a, d
        add     a, 2
        jr      nc, n2745
        inc     hl
n2745   ld      d, a
n2746   call    n2695
        cp      0
        jr      z, n2746
        call    n2620
        scf
        ret
n2757   ld      a, 0
        and     a
        call    n260f
        ret
n275b   ld      bc, $0200
n275e   ld      a, 2
        sub     b
        ld      hl, tmp_buff
        call    n266d
        jr      c, n2771
n2770   dec     c
n2771   inc     c
        djnz    n275e
        ld      a, c
        ld      ($df9d), a
        ret
n278c   push    bc
        push    af
        call    n2620
        ld      a, $40
        ld      hl, 0
        ld      d, h
        ld      e, l
        ld      b, $95
        call    n2637
        dec     a
        jr      nz, n27c0
        ld      bc, $0078
n27a8   pop     af
        push    af
        push    bc
        ld      a, $48
        ld      hl, 0
        ld      de, $01aa
        ld      b, $87
n27ad   call    n2637
        pop     bc
        bit     2, a
        ld      h, 0
        jr      nz, n27b8
        dec     a
        jr      nz, n27c2
        in      a, (mmcdata)
        ld      h, a
        nop
        in      a, (mmcdata)
        ld      l, a
        nop
        in      a, (mmcdata)
        and     $0f
        ld      d, a
        in      a, (mmcdata)
        cp      e
        jr      nz, n27c2
        dec     d
        jr      nz, n27de
        ld      h, $40
n27b8   pop     af
        push    af
        push    hl
        ld      a, $77
        call    n2628
        pop     hl
        pop     af
        push    af
        push    hl
        ld      a, $69
        call    n262a
        pop     hl
        bit     2, a
        jr      nz, n27c8
        jr      c, n27d0
        dec     a
        jr      z, n27b8
n27c0   jr      n27de
n27c2   djnz    n27a8 
        dec     c
        jr      nz, n27a8
        jr      n27de
n27c8   pop     af
        push    af
        ld      a, $41
n27ce   call    n2628
        jr      c, n27d1
        djnz    n27c8
        dec     c
        jr      nz, n27c8
        jr      n27de
n27d0   pop     af
        push    af
        call    n27e4
        jr      nc, n27de
        ld      d, a
        jr      z, n27db
n27d1   pop     af
        push    af
        ld      a, $50
        ld      de, $0200
        ld      h, e
        ld      l, e
        call    n2630
        jr      nc, n27de
n27d9   ld      d, 1
n27db   scf
        jr      n27df
n27de   and     a
n27df   pop     bc
        pop     bc
        jp      n2620
n27e4   ld      a, $7a
        call    n2628
        ret     nc
        ld      d, $c0
        in      a, (mmcdata)
        and     d
        ld      h, a
        in      a, (mmcdata)
        ld      l, a
        nop
        in      a, (mmcdata)
        ld      e, a
        nop
        in      a, (mmcdata)
        ld      a, h
        sub     d
        scf
        ret

n27f1   push    hl
        push    de
        call    n27e4
        pop     de
        pop     hl
        ret     nc
        ret     z
        and     a
        ret
n27f3   scf
        ret

n27f5   sla     e
        srl     d
        rr      e
        ld      c, 0
        push    hl
        ld      l, (ix+$17)
        ld      h, (ix+$18)
        ex      (sp), hl
        ex      (sp), ix
        call    n2524
        pop     ix
        ret
n280d   sla     e
        srl     d
        rr      e
        ld      c, 0
        push    hl
        ld      l, (ix+$17)
        ld      h, (ix+$18)
        ex      (sp), hl
        ex      (sp), ix
        call    n2529
        pop     ix
        ret
n2820   ld      de, $0106
        scf
        ret
n282a   srl     a
        ld      ix, $e883
        jr      nc, n2836
        ld      ix, $e88d
n2836   and     a
        ld      a, $16
        ret     nz
        ld      a, (ix+$00)
        or      (ix+$01)
        ld      a, $16
        ret     z
        scf
        ret
n2845   ld      hl, $e897
        ld      de, $e898
        ld      bc, $004b
        ld      (hl), 0
        ldir
        ld      hl, $e8e3
        ld      de, $e8e4
        ld      bc, $025f
        ld      (hl), 0
        ldir
        ld      hl, $e883
        ld      de, $e897
        ld      a, $a0
        call    n2945
        ld      hl, $e88d
        ld      de, $e8aa
        ld      a, $b0
        call    n2945
        ld      bc, $fefe
        in      a, (c)
        rra
        ccf
        ret     c
        xor     a
        ld      b, a
        ld      c, a
        ld      l, 8
        call    n3080
        jr      nc, n28ad
        ld      (ed_ATTR_P), a
        ld      (ed_ATTR_T), a
        ld      (ATTR_T), a
        ld      (BORDCR), a
        ld      d, a
        rra
        rra
        rra
        and     7
        out     ($fe), a
        ld      hl, $5800
        ld      bc, $0300
n28a1   ld      a, (hl)
        cp      $38
        jr      nz, n28a7
        ld      (hl), d
n28a7   inc     hl
        dec     bc
        ld      a, b
        or      c
        jr      nz, n28a1
n28ad   xor     a
        ld      b, a
        ld      c, a
        ld      l, 9
        call    n3080
        jr      nc, n28ba
        ld      (ATTR_P), a
n28ba   ld      hl, FLAGS3
        res     6, (hl)
        xor     a
        ld      b, a
        ld      c, a
        ld      hl, $ef11
        call    n2b77
        jr      nc, n28fc
        ld      hl, $ef3b
        ld      de, n2940
        ld      b, 3
n28d2   ld      a, (hl)
        and     a
        jr      z, n28e1
        push    hl
        push    de
        push    bc
        ld      a, (de)
        ld      l, a
        call    n3363
        pop     bc
        pop     de
        pop     hl
n28e1   inc     hl
        inc     de
        djnz    n28d2
        ld      hl, $ef3e
        ld      b, 3
n28ea   ld      a, (hl)
        and     a
        jr      z, n28f9
        push    hl
        push    bc
        ld      l, a
        ld      a, 5
        sub     b
        call    n321a
        pop     bc
        pop     hl
n28f9   inc     hl
        djnz    n28ea
n28fc   xor     a
n28fd   ld      bc, 0
        push    af
n2901   pop     af
        push    af
        ld      l, $1c
        call    n3080
        jr      nc, n2938
        jr      z, n2914
        ld      l, a
        pop     af
        push    af
        push    bc
        call    n321a
        pop     bc
n2914   inc     bc
        ld      a, b
        or      c
        jr      nz, n2901
n2919   pop     af
        inc     a
        cp      $02
        jr      nz, n28fd
        xor     a
        ld      b, a
        ld      c, a
        ld      l, $10
        call    n3080
        jr      nc, n2936
        jr      z, n2936
        call    n012d
        jr      nc, n2936
        ld      (LODDRV), a
        ld      (SAVDRV), a
n2936   scf
        ret

n2938   cp      $38
        jr      z, n2919
        cp      $16
        jr      z, n2919
        jr      n2914
n2940   ld      b, c
        ld      b, d
        ld      c, l
n2945   push    hl
        push    de
        ld      hl, n29b5
        ld      bc, $0010
        ldir
        ex      de, hl
        ld      (hl), a
        inc     hl
        ld      (hl), 0
        inc     hl
        ld      (hl), 0
        pop     hl
        pop     de
        push    de
        push    hl
        ld      hl, n29c0
        ld      bc, 8
        ldir
        ex      de, hl
        pop     de
        push    de
        ld      (hl), e
        inc     hl
        ld      (hl), d
        rlca
        rlca
        rlca
        rlca
        and     1
        push    af
        ld      hl, n29c8
        call    n2bd6
        pop     bc
        jr      nc, n2980
        ld      a, ($ef21)
        cp      $01
        jr      z, n299a
n2980   ld      a, b
        ex      (sp), ix
        inc     (ix+$03)
        inc     (ix+$06)
        ex      (sp), ix
        ld      hl, n29c8
        call    n2bd6
        jr      nc, n29ad
        ld      a, ($ef21)
        cp      1
        jr      nz, n29ad
n299a   ld      hl, $ef21
        pop     de
        ld      bc, $0010
        ldir    
        ld      hl, $ef31
        pop     de
        ld      bc, 8
        ldir
        ret
        
n29ad   xor     a
        pop     hl
        ld      (hl), a
        pop     hl
        ld      (hl), a
        inc     hl
        ld      (hl), a
        ret

n29b5   defb    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
n29c0   defb    1, 0, 2, 2, 4, 0, 0, 0
n29c8   defm    "PLUSIDEDOS      "
n29d8   rlca    
        rlca    
        rlca    
        rlca    
        ld      c, a
        ld      ix, $e897
        ld      b, 4
        ld      e, 0
        ld      h, e
        ld      l, e
n29e7   ld      a, (ix+$00)
        and     a
        jr      z, n2a0a
        ld      a, (ix+$10)
        and     $10
        cp      c
        jr      nz, n29fe
        ld      a, (ix+$11)
        or      (ix+$12)
        jr      z, n29fe
        inc     e
n29fe   push    de
        ld      de, $0013
        add     ix, de
        pop     de
        djnz    n29e7
        ld      a, e
        scf     
        ret     
n2a0a   push    ix
        pop     hl
        jr      n29fe
n2a0f   push    bc
        push    hl
        push    ix
        push    af
        call    n29d8
        and     a
        jr      z, n2a21
        ld      a, $3b
n2a1c   pop     bc
        pop     bc
n2a1e   pop     bc
        pop     bc
        ret     
n2a21   pop     af
        push    af
        call    n282a
        jr      c, n2a34
        ld      a, h
        or      l
        ld      a, $3c
        jr      z, n2a1c
        ld      (ix+$08), l
        ld      (ix+$09), h
n2a34   pop     af
        pop     de
        ld      (ix+$00), e
        ld      (ix+$01), d
        pop     bc
        ld      (ix+$02), b
        ld      (ix+$03), c
        ld      hl, 0
        ld      d, h
        ld      e, c
        res     7, b
n2a4a   add     hl, de
        djnz    n2a4a
        ld      (ix+$04), l
        ld      (ix+$05), h
        pop     hl
        ld      (ix+$06), l
        ld      (ix+$07), h
        push    af
        srl     h
        rr      l
        srl     h
        rr      l
        srl     h
        rr      l
        xor     a
        call    n2edb
        bit     7, (ix+$02)
        res     7, (ix+$02)
        ld      l, (ix+$08)
        ld      h, (ix+$09)
        push    hl
        ex      (sp), ix
        push    af
        ld      a, 0
        ld      (ix+$01), a
        ld      (ix+$02), a
        jr      z, n2a88
        inc     a
n2a88   ld      (ix+$03), a
        pop     af
        ex      (sp), ix
        call    nz, n2efd
        ex      (sp), ix
        ld      (ix+$00), 1
        ld      (ix+$04), e
        ld      (ix+$05), d
        ld      (ix+$06), a
        ex      (sp), ix
        ld      de, $0010
        and     a
        sbc     hl, de
        call    n2f05
        ex      (sp), ix
        pop     de
        pop     af
        push    af
        rlca
        rlca
        rlca
        rlca
        or      $a0
        ld      (ix+$10), a
        xor     a
        ld      (ix+$11), a
        ld      (ix+$12), a
        push    de
        ld      d, a
        ld      e, a
        call    n2d15
        jp      nc, n2a1e
        ld      hl, $ef11
        ld      d, h
        ld      e, l
        inc     de
        ld      bc, $003f
        ld      (hl), b
        ldir
        ld      a, $ff
        ld      ($ef21), a
        ld      e, (ix+$04)
        ld      d, (ix+$05)
        ld      a, (ix+$06)
        ex      (sp), ix
        call    n2efd
        ld      ($ef22), de
        ld      ($ef24), a
        ld      l, (ix+$00)
        ld      h, (ix+$01)
        dec     hl
        ld      ($ef25), hl
        ld      a, (ix+$02)
        dec     a
        ld      ($ef27), a
        ld      hl, $ef11
        call    n2f05
        ex      (sp), ix
        pop     de
        pop     af
        push    af
        push    de
        ld      bc, 1
        call    n2ba0
        jp      nc, n2a1e
        ld      hl, n29c8
        ld      de, $ef11
        ld      bc, $0010
        ldir
        push    ix
        pop     hl
        ld      bc, 11
        ldir
        pop     hl
        ld      de, $ef31
        ld      bc, 8
        ldir
        ex      de,hl
        ld      (hl), $38
        inc     hl
        ld      (hl), $38
        pop     af
        ld      hl, $ef11
        call    n2ba0
        ret
        
n2b3f   call    n282a
        ret     nc
        ld      l, (ix+$06)
        ld      h, (ix+$07)
        and     a
        sbc     hl, bc
        ld      a, $38
        ccf
        ret     nc
        ld      l, (ix+$08)
        ld      h, (ix+$09)
        push    hl
        pop     ix
        push    bc
        srl     b
        rr      c
        srl     b
        rr      c
        srl     b
        rr      c
        ld      d, b
        ld      e, c
        pop     bc
        ld      a, c
        and     7
        ld      c, 0
        rra
        rr      c
        rra
        rr      c
        ld      b, a
        scf
        ret

n2b77   push    bc
        push    ix
        push    hl
        call    n2b3f
        jr      nc, n2b9b
        push    bc
        ld      c, 0
        ld      b, 7
        ld      hl, $ed11
        call    n2524
        pop     bc
        jr      nc, n2b9b
        ld      hl, $ed11
        add     hl, bc
        pop     de
        ld      bc, $0040
        ldir
        scf
        jr      n2b9c
n2b9b   pop     hl
n2b9c   pop     ix
        pop     bc
        ret

n2ba0   push    bc
        push    ix
        push    hl
        call    n2b3f
        jr      nc, n2bd1
        push    de
        push    bc
        ld      c, 0
        ld      b, 7
        ld      hl, $ed11
        call    n2524
        pop     bc
        pop     de
        jr      nc, n2bd1
        ld      hl, $ed11
        add     hl, bc
        ex      de, hl
        ex      (sp), hl
        ld      bc, $0040
        ldir
        ld      c, 0
        ld      b, 7
        ld      hl, $ed11
        pop     de
        call    n2529
        jr      n2bd2

n2bd1   pop     hl
n2bd2   pop     ix
        pop     bc
        ret     

n2bd6   push    ix
        ld      bc, 0
n2bdb   push    af
        push    bc
        push    hl
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2c0b
        pop     hl
        push    hl
        ld      de, $ef11
        ld      b, $10
n2bed   ld      a, (de)
        cp      (hl)
        jr      z, n2c06
        cp      $41
        jr      c, n2bf9
        cp      $5b
        jr      c, n2c01
n2bf9   cp      $61
        jr      c, n2c11
        cp      $7b
        jr      nc, n2c11
n2c01   xor     $20
        cp      (hl)
        jr      nz, n2c11
n2c06   inc     de
        inc     hl
        djnz    n2bed
        scf
n2c0b   pop     hl
        pop     bc
n2c0d   pop     hl
        pop     ix
        ret

n2c11   pop     hl
        pop     bc
        inc     bc
        ld      a, b
        or      c
        ld      a, $38
        jr      z, n2c0d
        pop     af
        jr      n2bdb

      IF spanish
n2c1d   ld      a, $3a
        and     a
        ret
n2c49   push    hl
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2c46
        pop     af
        pop     hl
        ld      de, $ef31
        push    bc
        ld      bc, $0020
        ldir
        pop     bc
        ld      hl, $ef11
        call    n2ba0
        ret
n2c46   pop     hl
        pop     hl
        ret     
      ELSE
n2c1d   push    hl
        push    af
        push    bc
        call    n2bd6
        pop     bc
        ccf
        ld      a, $39
        jr      nc, n2c46
        pop     af
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2c46
        pop     af
        pop     hl
        ld      de, $ef11
        push    bc
        ld      bc, $0010
        ldir
        pop     bc
        ld      hl, $ef11
        call    n2ba0
        ret
n2c46   pop     hl
        pop     hl
        ret     
n2c49   push    hl
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2c66
        pop     af
        pop     hl
        ld      de, $ef31
        push    bc
        ld      bc, $0020
        ldir    
        pop     bc
        ld      hl, $ef11
        call    n2ba0
        ret     
        
n2c66   pop     hl
        pop     hl
        ret     
      ENDIF

n2c69   push    ix
        push    de
        push    hl
        add     a, a
        add     a, a
        add     a, a
        add     a, a
        ld      d, a
        ld      ix, $e897
        ld      e, 4
n2c78   ld      a, (ix+$00)
        and     a
        jr      z, n2c92
        ld      a, (ix+$10)
        and     $10
        cp      d
        jr      nz, n2c92
        ld      l, (ix+$11)
        ld      h, (ix+$12)
        sbc     hl, bc
        ld      a, $3b
        jr      z, n2c9d
n2c92   push    bc
        ld      bc, $0013
        add     ix, bc
        pop     bc
        dec     e
        jr      nz, n2c78
n2c9c   scf
n2c9d   pop     hl
        pop     de
        pop     ix
        ret
        
n2ca2   push    af
        call    n2c69
        jr      nc, n2ce7
        ld      ix, $e897
        ld      e, 4
n2cae   ld      a, (ix+$00)
        and     a
        jr      z, n2cc2
        push    bc
        ld      bc, $0013
        add     ix, bc
        pop     bc
        dec     e
        jr      nz, n2cae
        ld      a, $3c
        jr      n2ce7

n2cc2   pop     af
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2ce7
        ld      a, ($ef21)
        dec     a
        cp      $fd
        ld      a, $38
        jr      nc, n2ce7
        pop     af
        call    n2cef
        ld      hl, $ef21
        push    ix
        pop     de
        ld      bc, $0010
        ldir
        scf
        ret
        
n2ce7   pop     hl
        ret
        
n2ce9   ld      (ix+$00), 0
        scf
        ret

n2cef   push    af
        push    ix
        call    n282a
        ld      a, (ix+$02)
        and     $40
        pop     ix
        ld      (ix+$10), a
        pop     af
        and     1
        add     a, a
        add     a, a
        add     a, a
        add     a, a
        add     a, $a0
        or      (ix+$10)
        ld      (ix+$10), a
        ld      (ix+$11), c
        ld      (ix+$12), b
        ret

n2d15   push    ix
        jr      n2d39
n2d19   push    ix
        push    hl
        push    af
        call    n2c69
        jr      nc, n2d71
        pop     af
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n2d71
        pop     af
        pop     hl
        push    ix
        pop     de
        ld      ix, $ef21
        call    n2cef
        ld      a, l
n2d39   push    de
        ld      hl, $ed11
        ld      (hl), a
        ld      de, $ed12
        ld      bc, $01ff
        ldir
        pop     de
        ld      c, 0
        ld      a, d
        or      e
        jr      nz, n2d56
        ld      e, (ix+$07)
        ld      d, (ix+$08)
        ld      c, (ix+$09)
n2d56   ld      b, 7
        ld      hl, $ed11
        push    de
        call    n2529
        pop     de
        jr      nc, n2d73
        ld      a, c
        or      d
        or      e
        scf
        jr      z, n2d73
        dec     de
        ld      a, d
        and     e
        inc     a
        jr      nz, n2d56
        dec     c
        jr      n2d56
n2d71   pop     hl
        pop     hl
n2d73   pop     ix
        ret

n2d76   ld      bc, $ffff
        ld      ($ef92), bc
        ld      ($ef94), bc
        inc     bc
        ld      ($ef96), bc
n2d86   push    af
        push    de
        push    hl
        ld      hl, $ef11
        call    n2b77
        pop     hl
        pop     de
        jr      nc, n2de6
        ld      a, ($ef21)
        cp      h
        jr      nz, n2dde
        ld      a, ($ef2b)
        and     a
        jr      nz, n2dae
        ld      a, l
        push    hl
        ld      hl, ($ef28)
        sbc     hl, de
        ld      l, a
        ld      a, ($ef2a)
        sbc     a, l
        pop     hl
        jr      c, n2dde
n2dae   pop     af
        push    af
        call    n2c69
        jr      nc, n2dde
        push    de
        push    hl
        ld      de, ($ef92)
        ld      hl, ($ef28)
        and     a
        sbc     hl, de
        ld      de, ($ef94)
        ld      hl, ($ef2a)
        sbc     hl, de
        jr      nc, n2ddc
        ld      hl, ($ef28)
        ld      ($ef92), hl
        ld      hl, ($ef2a)
        ld      ($ef94), hl
        ld      ($ef96), bc
n2ddc   pop     hl
        pop     de
n2dde   inc     bc
        ld      a, b
        or      c
        jr      z, n2de6
        pop     af
        jr      n2d86

n2de6   pop     af
        ld      bc, ($ef96)
        ld      a, b
        or      c
        ret     z
        scf
        ret

n2df0   push    ix
        push    af
        push    hl
        call    n2bd6
        ld      a, $39
        ccf
        jp      nc, n2ed6
        pop     ix
        ld      e, (ix+$17)
        ld      d, (ix+$18)
        ld      l, (ix+$19)
        ld      h, $ff
        pop     af
        push    af
        call    n2d76
        ld      a, $1a
        jp      nc, n2ed7
        pop     af
        push    af
        ld      hl, $ef11
        call    n2b77
        jp      nc, n2ed7
        ld      l, (ix+$17)
        ld      h, (ix+$18)
        ld      e, (ix+$19)
        pop     af
        push    af
        push    ix
        call    n282a
        jp      nc, n2ed6
        ld      a, e
        call    n2edb
        ld      hl, ($ef22)
        add     hl, de
        ld      e, a
        ld      a, ($ef24)
        add     a, e
        cp      (ix+$02)
        jr      c, n2e48
        sub     (ix+$02)
        inc     hl
n2e48   ex      de, hl
        ld      l, a
        ld      a, ($ef27)
        cp      l
        ld      a, l
        jr      nz, n2e58
        ld      hl, ($ef25)
        sbc     hl, de
        jr      z, n2eab
n2e58   pop     hl
        ex      (sp), hl
        ld      l, a
        push    bc
        push    de
        push    hl
        ld      bc, 0
n2e61   pop     af
        push    af
        ld      hl, $ef51
        call    n2b77
        jr      nc, n2ed2
        ld      a, ($ef61)
        and     a
        jr      z, n2e78
        inc     bc
        ld      a, b
        or      c
        jr      nz, n2e61
        jr      n2ed2

n2e78   ld      a, $ff
        ld      ($ef61), a
        ld      a, ($ef27)
        ld      ($ef67), a
        ld      hl, ($ef25)
        ld      ($ef65), hl
        pop     hl
        pop     de
        push    de
        push    hl
        ld      a, l
        call    n2efd
        ld      ($ef64), a
        ld      ($ef62), de
        ld      hl, $ef51
        call    n2f05
        pop     af
        push    af
        call    n2ba0
        jr      nc, n2ed4
        pop     hl
        ld      a, l
        pop     de
        pop     bc
        ex      (sp), hl
        push    hl
n2eab   ld      ($ef27), a
        ld      ($ef25), de
        ld      hl, $ef11
        call    n2f05
        pop     de
        push    de
        push    bc
        ld      hl, $ef22
        ld      bc, $0011
        ex      de, hl
        add     hl, bc
        ex      de, hl
        ld      bc, 15
        ldir
        pop     bc
        pop     hl
        pop     af
        call    n2ba0
        pop     ix
        ret
        
n2ed2   ld      a, $1a
n2ed4   pop     hl
        pop     hl
n2ed6   pop     hl
n2ed7   pop     hl
        pop     ix
        ret

n2edb   push    bc
        scf
        ld      c, (ix+$04)
        ld      b, (ix+$05)
        ld      de, 0
        and     a
n2ee7   sbc     hl, bc
        sbc     a, 0
        inc     de
        jr      nc, n2ee7
        add     hl, bc
        dec     de
        xor     a
        ld      c, (ix+$03)
        ld      b, a
n2ef5   sbc     hl, bc
        inc     a
        jr      nc, n2ef5
        dec     a
        pop     bc
        ret

n2efd   inc     a
        cp      (ix+$02)
        ret     c
        inc     de
        xor     a
        ret
        
n2f05   push    bc
        push    de
        push    hl
        ex      (sp), ix
        ld      e, (ix+$14)
        ld      d, (ix+$15)
        ld      c, (ix+$16)
        inc     c
        ex      (sp), ix
        call    n2f64
        ex      de, hl
        ld      a, c
        ex      (sp), ix
        ld      e, (ix+$11)
        ld      d, (ix+$12)
        ld      c, (ix+$13)
        ex      (sp), ix
        call    n2f64
        and     a
        sbc     hl, de
        sbc     a, c
        ex      de, hl
        ld      c, a
        ld      b, 0
        ld      a, (ix+$03)
        push    ix
        ld      ix, 0
        ld      h, b
        ld      l, b
n2f3e   add     ix, de
        adc     hl, bc
        dec     a
        jr      nz, n2f3e
        push    ix
        pop     bc
        ld      a, b
        or      c
        jr      nz, n2f4d
        dec     hl
n2f4d   dec     bc
        pop     ix
        ex      (sp), ix
        ld      (ix+$17), c
        ld      (ix+$18), b
        ld      (ix+$19), l
        ld      (ix+$1a), h
        ex      (sp), ix
        pop     hl
        pop     de
        pop     bc
        ret

n2f64   push    af
        push    hl
        push    bc
        ld      b, (ix+$02)
        call    n2f78
        pop     bc
        ld      b, 0
        ex      de, hl
        add     hl, bc
        ex      de, hl
        adc     a, b
        ld      c, a
        pop     hl
        pop     af
        ret
        
n2f78   ex      de, hl
        xor     a
        ex      af, af'
        push    af
        xor     a
        ld      d, a
        ld      e, a
n2f7f   srl     b
        jr      nc, n2f8a
        ld      c, a
        ex      af, af'
        ex      de, hl
        add     hl, de
        ex      de, hl
        adc     a, c
        ex      af, af'
n2f8a   jr      z, n2f91
        add     hl, hl
        adc     a, a
        jp      n2f7f
n2f91   pop     af
        ex      af, af'
        ret     

n2f94   push    ix
        push    bc
        push    af
        call    n282a
        jp      nc, n3048
        pop     af
        push    af
        call    n2c69
        jp      nc, n3048
        pop     af
        push    af
        ld      hl, $ef11
        call    n2b77
        jp      nc, n3048
n2fb1   ld      bc, 0
n2fb4   pop     af
        push    af
        ld      hl, $ef51
        call    n2b77
        jp      nc, n3053
        ld      a, ($ef61)
        cp      $ff
        jp      nz, n304d
        ld      a, ($ef67)
        ld      de, ($ef65)
        call    n2efd
        ld      l, a
        ld      a, ($ef24)
        sub     l
        jr      nz, n2fdf
        ld      hl, ($ef22)
        sbc     hl, de
        jr      z, n2ff9
n2fdf   ld      a, ($ef27)
        ld      de, ($ef25)
        call    n2efd
        ld      l, a
        ld      a, ($ef64)
        sub     l
        jr      nz, n304d
        ld      hl, ($ef62)
        sbc     hl, de
        jr      z, n3007
        jr      n304d

n2ff9   ld      a, ($ef27)
        ld      ($ef67), a
        ld      hl, ($ef25)
        ld      ($ef65), hl
        jr      n3013

n3007   ld      a, ($ef24)
        ld      ($ef64), a
        ld      hl, ($ef22)
        ld      ($ef62), hl
n3013   ld      hl, $ef51
        call    n2f05
        pop     af
        push    af
        call    n2ba0
        jr      nc, n3048
        pop     af
        pop     de
        push    bc
        push    af
        push    de
        ld      b, $40
        ld      hl, $ef11
n302a   ld      (hl), 0
        inc     hl
        djnz    n302a
        pop     bc
        pop     af
        push    af
        ld      hl, $ef11
        call    n2ba0
        jr      nc, n3048
        ld      hl, $ef51
        ld      de, $ef11
        ld      bc, $0040
        ldir
        jp      n2fb1
n3048   pop     bc
        pop     bc
        pop     ix
        ret

n304d   inc     bc
        ld      a, b
        or      c
        jp      nz, n2fb4
n3053   ld      a, $ff
        ld      ($ef21), a
        ld      hl, $ef11
        ld      b, $10
n305d   ld      (hl), 0
        inc     hl
        djnz    n305d
        ld      hl, $ef11
        pop     af
        pop     bc
        call    n2ba0
        pop     ix
        ret     

n3080   call    n306d
        ret     nc
        ld      a, (hl)
        and     a
        scf
        ret

n3084   push    af
        call    n306d
        jr      nc, n3060
        ld      (hl), a
        pop     af
        ld      hl, $ef11
        call    n2ba0
        ret
n3060   pop     hl
        ret

n306d   push    hl
        ld      hl, $ef11
        call    n2b77
        pop     hl
        ret     nc
        ld      a, l
        and     $1f
        ld      l, a
        ld      a, h
        ld      h, 0
        ld      de, $ef31
        add     hl, de
        scf
        ret

n30a5   ld      a, (ix+$00)
        cp      2
        scf
        ret     z
        ld      a, $3d
        and     a
        ret

n30b0   call    n30a5
        ret     nc
        ld      c, (ix+$0c)
        ld      b, (ix+$0d)
        scf     
        ret     
        
n30bc   call    n30a5
        ret     nc
        push    hl
        ld      l, (ix+$0e)
        ld      h, (ix+$0f)
        and     a
        sbc     hl, bc
        pop     hl
        ccf
        ld      a, $15
        ret     nc
        ld      (ix+$0c), c
        ld      (ix+$0d), b
        scf
        ret
        
n30d7   call    n30a5
        ret     nc
        ld      a,b
        push    af
        push    hl
        ld      e, (ix+$0c)
        ld      d, (ix+$0d)
        ld      l, (ix+$0e)
        ld      h, (ix+$0f)
        and     a
        sbc     hl, de
        jr      nc, n30f2
        ld      de, 0
n30f2   push    de
        ld      b, (ix+$0b)
        call    n2f78
        ld      c, a
        pop     hl
        inc     hl
        ld      (ix+$0c), l
        ld      (ix+$0d), h
        pop     hl
        pop     af
        ld      b, a
        scf
        ret

n3107   call    n30d7
        ret     nc
        ld      a, (ix+$0b)
n310e   push    af
        push    de
        call    n2524
        pop     de
        jr      nc, n3122
        inc     de
        ld      a, d
        or      e
        jr      nz, n311c
        inc     c
n311c   pop     af
        dec     a
        jr      nz, n310e
        scf
        ret
n3122   pop     de
        ret     
        
n3124   call    n30d7
        ret     nc
        ld      a, (ix+$0b)
n312b   push    af
        push    de
        call    n2529
        pop     de
        jr      nc, n313f
        inc     de
        ld      a, d
        or      e
        jr      nz, n3139
        inc     c
n3139   pop     af
        dec     a
        jr      nz, n312b
        scf
        ret
n313f   pop     de
        ret     
        
n3141   call    n30d7
        ret     nc
        ld      a, (ix+$0b)
n3148   push    af
        push    bc
        push    de
        push    hl
        ld      hl, $ed11
        ld      b, 7
        call    n2524
        pop     hl
        pop     de
        pop     bc
        jr      nc, n317c
        push    de
        push    hl
        call    n2529
        pop     hl
        pop     de
        jr      nc, n317c
        push    bc
        push    de
        ld      de, $ed11
        ld      bc, $0200
        ex      de, hl
        ldir
        ex      de, hl
        pop     de
        pop     bc
        inc     de
        ld      a, d
        or      e
        jr      nz, n3176
        inc     c
n3176   pop     af
        dec     a
        jr      nz, n3148
        scf
        ret
n317c   pop     de
        ret     
        
n317e   push    af
        push    bc
        call    n31ba
        ld      h, 2
        push    de
        push    hl
        ld      a, 0
        call    n2d76
        pop     hl
        pop     de
        ld      a, 0
        jr      c, n319c
        inc     a
        call    n2d76
        ld      a, $40
        jr      nc, n31b7
        ld      a, 1
n319c   call    n2ca2
        jr      nc, n31b7
n31a1   pop     bc
        ld      (ix+$0e), c
        ld      (ix+$0f), b
        pop     af
        ld      (ix+$0b), a
        ld      (ix+$0c), 0
        ld      (ix+$0d), 0
        scf
        ret
n31b6   pop     bc
n31b7   pop     bc
        pop     bc
        ret     

n31ba   ld      hl, 0
        ld      e, a
        dec     e
        ld      d, a
        dec     a
        cp      $20
        ld      a, $15
        jr      nc, n31b6
        ld      a, h
n31c8   add     hl, bc
        adc     a, 0
        dec     d
        jr      nz, n31c8
        add     hl, de
        adc     a, 0
        ex      de, hl
        ld      l, a
        ret

n31d4   ld      d, a
        call    n30a5
        ret     nc
        ld      a, d
        push    af
        push    bc
        call    n31ba
        ld      a, (ix+$09)
        cp      l
        jr      c, n31f5
        jr      nz, n31a1
        ld      a, (ix+$08)
        cp      d
        jr      c, n31f5
        jr      nz, n31a1
        ld      a, (ix+$07)
        cp      e
        jr      nc, n31a1
n31f5   pop     bc
        pop     bc
        ld      a, $15
        and     a
        ret

n31fb   ld      a, l
        ld      ($ef91), a
        sub     $41
        jr      c, n3216
        cp      $10
        jr      nc, n3216
        ld      l, a
        ld      h, 0
        add     hl, hl
        ld      de, $e2a1
        add     hl, de
        ld      d, (hl)
        dec     hl
        ld      e, (hl)
        ld      a, d
        or      e
        scf
        ret
        
n3216   and     a
        ld      a, $15
        ret     

n321a   cp      2
        jp      nc, n32e8
        push    ix
        push    af
        push    bc
        push    hl
        ld      hl, $e8e3
        ld      b, 2
        ld      de, $0130
n322c   ld      a, (hl)
        inc     hl
        or      (hl)
        dec     hl
        jr      z, n323e
        add     hl, de
        djnz    n322c
        ld      a, $3f
        and     a
n3238   pop     de
        pop     de
        pop     de
        pop     ix
        ret

n323e   ex      (sp),hl
        call    n31fb
        jr      nc, n3238
        ld      a, $3e
        ccf
        jr      nz, n3238
        pop     de
        pop     bc
        pop     af
        push    hl
        push    af
        push    de
        ld      hl, $ef11
        call    n2b77
        jr      nc, n3238
        ld      a, ($ef21)
        cp      3
        jr      z, n3263
        and     a
        ld      a, $38
        jr      n3238
n3263   ld      hl, $ef31
        pop     de
        pop     af
        push    de
        push    bc
        push    af
        ld      bc, $001c
        ldir    
        ex      de, hl
        ld      a, ($ef91)
        ld      (hl), a
        inc     hl
        pop     af
        push    af
        rlca
        rlca
        rlca
        rlca
        or      $a0
        ld      (hl), a
        inc     hl
        ld      b, 10
n3282   ld      (hl), 0
        inc     hl
        djnz    n3282
        ld      de, 8
        ex      de, hl
        add     hl, de
        ex      de, hl
        ld      (hl), e
        inc     hl
        ld      (hl), d
        inc     hl
        ld      (hl), n27f3 & 255
        inc     hl
        ld      (hl), n27f3 >> 8
        inc     hl
        ld      (hl), n27f5 & 255
        inc     hl
        ld      (hl), n27f5 >> 8
        inc     hl
        ld      (hl), n280d & 255
        inc     hl
        ld      (hl), n280d >> 8
        pop     af
        pop     bc
        push    bc
        push    af
        call    n2ca2
        jr      nc, n32dc
        pop     af
        pop     bc
        pop     hl
        push    hl
        ld      de, $0017
        add     hl, de
        push    ix
        pop     de
        ld      (hl), e
        inc     hl
        ld      (hl), d
        pop     de
        pop     hl
        ld      (hl), e
        inc     hl
        ld      (hl), d
        pop     ix
        ld      hl, $5b66
        bit     6, (hl)
        scf
        ret     z
        push    af
        push    bc
        ld      a, ($ef91)
        ld      l, a
        call    n349f
        ld      a, ($ef91)
        ld      h, a
        ld      l, $1c
        pop     bc
        pop     af
        call    n3084
        ret
        
n32dc   pop     hl
        pop     hl
        pop     hl
        ld      (hl), 0
        inc     hl
        ld      (hl), 0
        pop     de
        pop     ix
        ret
        
n32e8   push    hl
        sub     2
        ld      e, a
        ld      d, 0
        cp      2
        jr      z, n32f9
        jr      nc, n335f
        call    n0157
        jr      nc, n335f
n32f9   ld      h, d
        ld      l, e
        push    de
        add     hl, hl
        add     hl, de
        add     hl, hl
        ld      de, n3462
        add     hl, de
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        ld      hl, $e2a0
        ld      e, $10
n330b   ld      a, (hl)
        inc     hl
        cp      c
        jr      nz, n3316
        ld      a, (hl)
        cp      b
        ld      a, $3b
        jr      z, n335c
n3316   inc     hl
        dec     e
        jr      nz, n330b
        pop     de
        pop     hl
        push    de
        call    n31fb
        pop     de
        ret     nc
        ld      a, $3e
        ccf
        ret     nz
        ld      (hl), c
        inc     hl
        ld      (hl), b
        ld      hl, $001c
        add     hl, bc
        ld      a, ($e3ea)
        and     a
        jr      nz, n333d
        ld      a, e
        and     a
        jr      nz, n333d
        ld      a, ($ef91)
        ld      ($e3ea), a
n333d   ld      a, ($ef91)
        ld      (hl), a
        ld      hl, $5b66
        bit     6, (hl)
        scf
        ret     z
        push    af
        push    de
        ld      l, a
        call    n349f
        pop     de
        pop     af
        ld      hl, 13
        add     hl, de
        ld      h, a
        xor     a
        ld      b, a
        ld      c, a
        call    n3084
        ret
n335c   pop     hl
        pop     hl
        ret     

n335f   ld      a, $41
        pop     hl
        ret     

n3363   call    n31fb
        ret     nc
        push    ix
        jr      z, n33ae
        push    de
        pop     ix
        call    n189d
        jr      nc, n33bd
        xor     a
        ld      (hl), a
        inc     hl
        ld      (hl), a
        ex      de, hl
        ld      a, (ix+$1b)
        and     $0c
        jr      nz, n3382
        ld      (hl), a
        inc     hl
        ld      (hl), a
n3382   ld      a, ($e3ea)
        cp      (ix+$1c)
        jr      nz, n338e
        xor     a
        ld      ($e3ea), a
n338e   ld      (ix+$1c), 0
        ld      e, (ix+$2a)
        ld      d, (ix+$2b)
        ld      hl, n27f3
        and     a
        sbc     hl, de
        jr      nz, n33ae
        ld      e, (ix+$17)
        ld      d, (ix+$18)
        push    de
        pop     ix
        call    n2ce9
        jr      nc, n33bd
n33ae   ld      hl, $5b66
        bit     6, (hl)
        scf
        jr      z, n33bd
        ld      a, ($ef91)
        ld      l, a
        call    n349f
n33bd   pop     ix
        ret

n33c0   push    bc
        ld      a, $20
        ld      e, $12
n33c5   ld      (bc), a
        inc     bc
        dec     e
        jr      nz, n33c5
        call    n31fb
        ex      de, hl
        pop     bc
        ret     nc
        ret     z
        push    ix
        push    bc
        push    hl
        pop     ix
        ld      e, (ix+$2a)
        ld      d, (ix+$2b)
        ld      hl, n27f3
        and     a
        sbc     hl, de
        jr      nz, n342b
        ld      e, (ix+$17)
        ld      d, (ix+$18)
        push    de
        pop     ix
        ld      a, (ix+$10)
        rra
        rra
        rra
        rra
        and     1
        ld      c, (ix+$11)
        ld      b, (ix+$12)
        push    bc
        push    af
        ld      hl, $ef11
        call    n2b77
        jr      nc, n3425
        pop     af
        pop     bc
        pop     de
        push    bc
        push    af
        add     a, $30
        ld      (de), a
        inc     de
        ld      a, $3e
        ld      (de), a
        inc     de
        ld      hl, $ef11
        ld      bc, $0010
        ldir    
        xor     a
        sbc     a, 1
        pop     bc
        ld      a, b
        pop     bc
        pop     ix
        ret
n3425   pop     de
        pop     de
n3427   pop     de
        pop     ix
        ret

n342b   push    ix
        pop     de
        ld      ix, n3462
        ld      a, 3
n3434   ld      l, (ix+$00)
        ld      h, (ix+$01)
        and     a
        sbc     hl, de
        jr      z, n344b
        ld      bc, 6
        add     ix, bc
        dec     a
        jr      nz, n3434
        ld      a, $41
        jr      n3427

n344b   ld      l, (ix+$02)
        ld      h, (ix+$03)
        pop     de
        ld      c, (ix+$04)
        ld      b, 0
        ldir
        xor     a
        sbc     a, 1
        ld      a, (ix+$05)
        pop     ix
        ret

      IF spanish
n3462   defb    $c0, $e2,  $74, $34,  $0e, $02
        defb    $2d, $e3,  $82, $34,  $0e, $03
        defb    $9a, $e3,  $90, $34,  $0b, $04
n3474   defm    "2>Disquetera 0"
n3485   defm    "3>Disquetera 1"
n3496   defm    "4>Disco RAM"
        defs    4
      ELSE
n3462   defb    $c0, $e2,  $74, $34,  $11, $02
        defb    $2d, $e3,  $85, $34,  $11, $03
        defb    $9a, $e3,  $96, $34,  $09, $04
n3474   defm    "2>Floppy device 0"
n3485   defm    "3>Floppy device 1"
n3496   defm    "4>RAMdisk"
      ENDIF

n349f   push    hl
        xor     a
        ld      b, a
        ld      c, a
        ld      hl, $ef11
        call    n2b77
        pop     de
        jr      nc, n34de
        ld      hl, $ef3b
        ld      a, e
        cp      $41
        jr      nz, n34b6
        ld      (hl), 1
n34b6   inc     hl
        cp      $42
        jr      nz, n34bd
        ld      (hl), 1
n34bd   inc     hl
        cp      $4d
        jr      nz, n34c4
        ld      (hl), 1
n34c4   ld      hl, $ef3e
        ld      b, 3
n34c9   ld      a, (hl)
        cp      e
        jr      nz, n34cf
        ld      (hl), 0
n34cf   inc     hl
        djnz    n34c9
        xor     a
        ld      b, a
        ld      c, a
        push    de
        ld      hl, $ef11
        call    n2ba0
        pop     de
        ret     nc
n34de   xor     a
n34df   ld      bc, 0
        push    af
n34e3   pop     af
        push    af
        push    de
        ld      hl, $ef11
        call    n2b77
        pop     de
        jr      nc, n3519
        ld      a, ($ef21)
        cp      3
        jr      nz, n350c
        ld      a, ($ef4d)
        cp      e
        jr      nz, n350c
        xor     a
        ld      ($ef4d), a
        pop     af
        push    af
        push    de
        ld      hl, $ef11
        call    n2ba0
        pop     de
        jr      nc, n3519
n350c   inc     bc
        ld      a, b
        or      c
        jr      nz, n34e3
n3511   pop     af
        inc     a
        cp      2
        jr      nz, n34df
        scf
        ret

n3519   cp      $38
        jr      z, n3511
        cp      $16
        jr      z, n3511
        pop     de
        and     a
        ret
        
n3524   ld      d, h
        ld      e, l
n3526   ld      a, (de)
        inc     de
        cp      $ff
        jr      nz, n3526
        dec     de
        dec     de
        ld      a, (de)
        ld      ($401d),a
        ld      bc, 1
        ld      d, b
        ld      e, 1
        call    n0106
        ret     nc
        ld      hl, $5000
        ld      de, $001e
        ld      b, d
        ld      c, 7
        call    n0112
        ret     nc
        ld      b, 0
        call    n0133
        push    de
        push    hl
        ld      b, 0
        call    n0139
        pop     bc
        and     a
        sbc     hl, bc
        pop     bc
        ld      a, e
        sbc     a, c
        ld      bc, 1
        add     hl, bc
        adc     a, b
        ex      de, hl
        ld      ($4015), a
        push    af
        call    n0514
        pop     af
        ld      hl, $506b
        call    n3879
        ret     nc
        ld      ($503f), hl
        ld      b, 0
        call    n0109
        di      
        ld      sp, $5067
        ld      ix, $506d
        ld      l, (ix-$02)
        ld      h, (ix-$01)
        call    n2558
        call    n25c2
        exx     
        ld      hl, $401d
        bit     6, (hl)
        jp      z, n3614
        ld      a, ($501a)
        out     ($fe), a
        ld      a, ($5013)
        and     4
        ld      ($5013), a
        ld      a, ($4015)
        and     a
        ld      hl, $0010
        exx     
        ld      iyl, 0
        ld      l, 3
        jp      z, n363f
        call    n3765
        ld      sp, $4047
        call    n381c
        call    n3868
        ld      l, a
        call    n3868
        ld      h, a
        ld      ($4027), hl
        ld      a, $c3
        ld      ($4026), a
        call    n3868
        ld      ($401d), a
        and     7
        jr      z, n35eb
        exx
        ld      hl, $c000
        ld      e, a
n35db   xor     a
        call    n37d0
        ld      d, (hl)
        ld      a, e
        call    n37d0
        ld      (hl), d
        inc     hl
        bit     7, h
        jr      nz, n35db
        exx
n35eb   call    n3868
        xor     a
n35ef   cp      2
        jr      z, n360d
        cp      5
        jr      z, n360d
        ld      hl, ($401d)
        ld      h, a
        ld      a, l
        and     7
        cp      h
        ld      a, h
        jr      z, n360d
        call    n37d0
        push    af
        ld      hl, $c000
        call    n381c
        pop     af
n360d   inc     a
        cp      8
        jr      c, n35ef
        jr      n3648

n3614   ld      hl, $500c
        ld      a, (hl)
        cp      $ff
        jr      nz, n361f
        ld      a, 1
        ld      (hl), a
n361f   rra
        out     ($fe), a
        dec     hl
        ld      a, (hl)
        res     7, a
        jr      nc, n362a
        set     7, a
n362a   ld      (hl), a
        inc     hl
        ld      a, (hl)
        and     $20
        ld      iyl, a
        ld      hl, n37d8
        exx
        ld      hl, ($5006)
        ld      a, h
        or      l
        jp      z, n3684
        ld      l, 0
n363f   call    n3765
        ld      sp, $4047
        call    n381c
n3648   call    n26e5
        im      0
        ld      a, ($4010)
        and     3
        jr      z, n365b
        im      1
        dec     a
        jr      z, n365b
        im      2
n365b   ld      sp, $4000
        pop     hl
        pop     de
        pop     bc
        exx
        pop     af
        ex      af, af'
        pop     hl
        pop     de
        pop     iy
        pop     ix
        pop     bc
        ld      a, b
        sub     9
        rla
        rl      b
        rra
        ld      r, a
        pop     af
        ld      i, a
        ld      sp, ($4016)
        ld      bc, $1ffd
        ld      a, ($4015)
        jp      $4018

n3684   call    n3868
        ld      l, a
        call    n3868
        and     a
        jp      nz, n3728
        call    n3868
        ld      ($5006), a
        call    n3868
        ld      ($5007), a
        call    n3868
        ld      h, a
        call    n3868
        ld      ($5069), a
        call    n3868
        call    n3868
        call    n3868
        push    af
        exx     
        ld      de, $0010
n36b3   exx     
        call    n3868
        exx     
        ld      bc, $fffd
        out     (c), d
        ld      b, $bf
        out     (c), a
        inc     d
        dec     e
        jr      nz, n36b3
        ld      b, $ff
        pop     af
        out     (c), a
        exx
        ld      a, l
        sub     $17
        jr      nz, n36d8
        ld      a, h
        cp      3
        jr      c, n36e6
        inc     h
        jr      n36e6

n36d8   cp      $20
n36da   push    af
        call    n3868
        ld      l, a
        pop     af
        dec     a
        jr      nz, n36da
        ld      a, l
        jr      nc, n36e8

n36e6   ld      a, 4
n36e8   ld      ($506a), a
        ld      a, h
        cp      4
        jp      nc, n3729
        xor     a
        call    n37d0
        ld      h, 3
        and     a
n36f8   push    hl
        call    n385d
        ld      hl, $8000
        ld      iyh, $c0
        cp      4
        jr      z, n371e
        ld      h, $c0
        ld      iyh, 0
        cp      5
        jr      z, n371e
        cp      8
        jr      nz, n3728
        call    n3770
        pop     af
        ld      sp, $4047
        push    af
        ld      iyh, $80
n371e   call    n381c
        pop     hl
        dec     h
        jr      nz, n36f8
        jp      n3648
n3728   rst     0
n3729   ld      h, 8
        and     a
n372c   push    hl
        call    n385d
        sub     3
        jr      c, n3728
        cp      8
        jr      nc, n3728
        ld      hl, $c000
        call    n37d0
        cp      5
        jr      nz, n3758
        call    n3770
        pop     af
        ld      sp, $4047
        push    af
        ld      a, ($5069)
        ld      ($401d), a
        ld      a, ($506a)
        ld      ($4015), a
        set     7, h
n3758   ld      iyh, 0
        call    n381c
        pop     hl
        dec     h
        jr      nz, n372c
        jp      n3648

n3765   xor     a
        call    n37d0
        call    n3772
        ld      iyh, 0
        ret

n3770   ld      l, 0
n3772   ld      h, $40
        ld      iyh, $48
        call    n381c
        exx
        push    hl
        ld      hl, ($503f)
        dec     ix
        push    ix
        pop     de
        and     a
        sbc     hl, de
        ld      b, h
        ld      c, l
        ld      hl, $4047
        push    hl
        pop     ix
        inc     ix
        ex      de, hl
        ldir
        pop     hl
        ld      d, 0
        call    n37b2
        ld      d, $50
        call    n37b2
        ld      hl, $401d
        ld      (hl), $10
        ld      l, $15
        ld      (hl), 4
        exx
        ld      a, ($4014)
        and     a
        ret     nz
        ld      ($4025), a
        ret

n37b2   ld      b, $40
n37b4   ld      e, (hl)
        inc     hl
        bit     7, e
        ret     nz
        ld      a, (hl)
        and     $3f
        ld      c, a
        ld      a, (hl)
        rlca
        rlca
        and     3
        inc     hl
        push    hl
        ld      l, a
        inc     l
n37c6   ld      a, (de)
        inc     e
        ld      (bc), a
        inc     c
        dec     l
        jr      nz, n37c6
        pop     hl
        jr      n37b4

n37d0   push    bc
        ld      bc, $7ffd
        out     (c), a
        pop     bc
        ret
        
n37d8   defb    $2f, $58, $32, $9a, $2f, $9e, $34, $a3
        defb    $35, $26, $80, $0a, $13, $0b, $11, $17
        defb    $cc, $04, $48, $0d, $4a, $02, $61, $08
        defb    $56, $01, $12, $00, $24, $16, $06, $15
        defb    $07, $13, $40, $11, $42, $0f, $44, $06
        defb    $67, $1d, $10, $1b, $14, $80

n3806   ld      a,d
        or      e
        call    z, n3871
        dec     de
        in      a, (c)
        ld      (hl), a
        inc     l
        jp      nz, n3806
        inc     h
        ld      a, h
        and     $f8
        cp      iyh
        jr      nz, n3806
        ret

n381c   ld      a, iyl
        and     a
        jr      z, n3806
n3821   ld      a, d
        or      e
        call    z, n3871
        dec     de
        in      a, (c)
        cp      $ed
        jr      z, n383b
n382d   ld      (hl), a
        inc     l
        jp      nz, n3821
        inc     h
n3833   ld      a, h
        and     $f8
        cp      iyh
        jr      nz, n3821
        ret
        
n383b   call    n3868
        cp      $ed
        jr      nz, n3853
        call    n3868
        push    af
        call    n3868
        pop     bc
n384a   ld      (hl), a
        inc     hl
        djnz    n384a
        ld      bc, mmcdata
        jr      n3833
n3853   ld      (hl), $ed
        inc     l
        jr      nz, n382d
        inc     h
        jr      nz, n382d
        scf
        ret

n385d   call    nc, n3868
        ld      l, a
        call    n3868
        and     l
        inc     a
        ld      iyl, a
n3868   ld      a, d
        or      e
        call    z, n3871
        dec     de
        in      a, (c)
        ret

n3871   ld      a, (ix+$04)
        inc     a
        call    nz, n2558
        ret

n3879   push    de
        push    af
        ld      ($f514), hl
        ld      hl, $0020
        add     hl, bc
        ld      a, (hl)
        and     3
        dec     a
        ld      a, $1d
        jr      nz, n38a7
        inc     hl
        ld      a, (hl)
        call    n1847
        jr      nc, n38a7
        ld      a, (ix+$06)
        and     a
        jr      z, n38a4
        ld      l, (ix+$2c)
        ld      h, (ix+$2d)
        ld      de, n27f5
        sbc     hl, de
        jr      z, n38aa
n38a4   ld      a, $1d
        and     a
n38a7   pop     de
        pop     de
        ret
        
n38aa   call    n1074
        push    ix
        ld      ix, ($f514)
        ld      (ix+$00), l
        ld      a, h
        and     1
        ld      (ix+$01), a
        ld      l, h
        ld      h, e
        srl     h
        rr      l
        ld      e, (ix+$00)
        ld      d, (ix+$01)
        inc     ix
        inc     ix
        ld      ($f514), ix
        pop     ix
        pop     af
        ex      (sp), hl
        push    hl
        ld      hl, $0200
        and     a
        sbc     hl, de
        ex      de, hl
        pop     hl
        and     a
        sbc     hl, de
        sbc     a, 0
        ld      e, a
        ld      a, h
        and     1
        or      l
        ld      l, h
        ld      h, e
        ld      de, 1
        jr      z, n38ef
        inc     de
n38ef   srl     h
        rr      l
        add     hl, de
        ld      ($f511), hl
        pop     de
        ld      a, (ix+$03)
        srl     a
        srl     a
        and     e
        ld      ($f513), a
        ld      a, (ix+$02)
        sub     2
        call    nz, n04d9
n390b   push    de
        ld      a, (ix+$02)
        call    n04e3
        call    n0d19x
        ex      de, hl
        ld      hl, $000c
        add     hl, bc
        cpl
        and     (hl)
        or      d
        ld      (hl), a
        inc     hl
        inc     hl
        ld      (hl), e
        call    n0d4a
        pop     de
        ret     nc
        ld      a, e
        and     7
        add     a, a
        add     a, $10
        ld      l, a
        ld      h, 0
        add     hl, bc
n3930   push    de
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     hl
        push    hl
        push    bc
        ld      a, (ix+$02)
        sub     2
        push    af
        call    nz, n04e3
        ld      c, 0
        ld      a, ($f513)
        add     a, e
        ld      e, a
        ld      a, d
        adc     a, c
        ld      d, a
        push    ix
        ld      l, (ix+$17)
        ld      h, (ix+$18)
        push    hl
        pop     ix
        call    n25c8
        pop     ix
        jr      nc, n39b1
        ld      b, h
        ld      c, l
        ld      hl, ($f514)
        ld      (hl), e
        inc     hl
        ld      (hl), d
        inc     hl
        ld      (hl), c
        inc     hl
        ld      (hl), b
        inc     hl
        pop     bc
        ex      af, af'
        push    af
        ex      af, af'
        push    af
        ld      a, ($f513)
        ld      c, a
        ld      a, 1
n3974   add     a, a
        djnz    n3974
        sub     c
        ld      b, 0
        ld      c, a
        push    hl
        ld      hl, ($f511)
        ld      a, l
        and     a
        sbc     hl, bc
        jr      nc, n3987
        ld      c, a
        xor     a
n3987   ld      ($f511), hl
        pop     hl
        ex      af, af'
        pop     af
        jr      z, n3991
        set     7, c
n3991   pop     af
        ex      af, af'
        ld      (hl), c
        inc     hl
        ld      ($f514), hl
        pop     bc
        scf
        jr      z, n39b3
        pop     hl
        pop     de
        xor     a
        ld      ($f513), a
        inc     de
        push    hl
        and     a
        sbc     hl, bc
        ld      a, l
        pop     hl
        cp      $20
        jp      c, n3930
        jp      n390b
n39b1   pop     bc
        pop     bc
n39b3   inc     hl
        inc     hl
        inc     hl
        inc     hl
        ld      (hl), $ff
        inc     hl
        pop     bc
        pop     bc
        ret
        
n39bd   ld      a, $3a
        and     a
        ret     
        
n39c1   add     a, 3
        cp      $13
        jr      nc, n39d6
        rlca    
        ld      hl, $5c10
        ld      c, a
        ld      b, 0
        add     hl, bc
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        dec     hl
        scf
        ret

n39d5   pop     bc
n39d6   ld      a, $17
        and     a
        ret

n39da   inc     hl
        inc     hl
n39dc   ld      a, (hl)
        inc     hl
        and     a
        ret     z
        cp      c
        jr      nz, n39da
        scf
        ret

n39e5   push    hl
        call    n39f6
        jr      nc, n39f4
        ex      de, hl
        ex      (sp), hl
        and     a
        sbc     hl, de
        ccf
        pop     hl
        ex      de, hl
        ret
        
n39f4   pop     hl
        ret

n39f6   ld      a, b
        or      c
        ret     z
        ld      a, (de)
        cp      $2c
        scf
        ccf
        ret     nz
        inc     de
        dec     bc
n3a01   ld      hl, 0
n3a04   ld      a, b
        or      c
        scf
        ret     z
        ld      a, (de)
        cp      $20
        jr      z, n3a20
        sub     $30
        ret     c
        cp      $0a
        ccf
        ret     c
n3a14   push    de
        add     hl, hl
        ld      d, h
        ld      e, l
        add     hl, hl
        add     hl, hl
        add     hl, de
        ld      d, 0
        ld      e, a
        add     hl, de
        pop     de
n3a20   inc     de
        dec     bc
        jr      n3a04

n3a24   push    bc
        call    n39c1
        jr      nc, n39d5
        ld      a, b
        or      c
        jr      z, n3a44
        push    hl
        ld      hl, ($5c4f)
        add     hl, bc
        inc     hl
        inc     hl
        inc     hl
        ld      a, (hl)
        pop     hl
        cp      $4b
        jr      z, n3a44
        cp      $53
        jr      z, n3a44
        cp      $50
        jr      nz, n39d5
n3a44   pop     bc
        push    hl
        ld      hl, n3a84
        ld      a, b
        or      c
        jr      z, n3a7f
        dec     bc
        ld      a, b
        or      c
        inc     bc
        ld      a, (de)
        jr      z, n3a65
        ld      hl, n3a9c
        inc     de
        ld      a, (de)
        dec     de
        cp      $3e
        ld      a, $49
        jr      nz, n3a65
        ld      a, (de)
        inc     de
        inc     de
        dec     bc
        dec     bc
n3a65   and     $df
        push    bc
        ld      c, a
        call    n39dc
        pop     bc
        jr      nc, n3a7f
        ld      a, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, a
        call    n3a7e
        pop     hl
        jr      nc, n3a80
        ld      (hl), e
        inc     hl
        ld      (hl), d
        scf
        ret

n3a7e   jp      (hl)

n3a7f   pop     bc
n3a80   ld      a, $0e
        and     a
        ret

n3a84   defb    $4b, $8e, $3a, $53, $92, $3a, $50, $96
        defb    $3a, $00, $1e, $01, $18, $06, $1e, $06
        defb    $18, $02, $1e, $10, $16, $00, $37, $c9
n3a9c   defb    $49, $bd, $3a, $4f, $b6, $3a, $55, $af
        defb    $3a, $4d, $41, $3b, $56, $7c, $3b, $57, $bc, $3b, $00

n3aaf   ld      hl, $0202
        ld      a, 3
        jr      n3ac2

n3ab6   ld      hl, $0204
        ld      a, 2
        jr      n3ac2

n3abd   ld      hl, $0002
        ld      a, 1
n3ac2   push    af
        push    hl
        ld      hl, $c022
        ld      a, b
        and     a
        jr      nz, n3ad1
        ld      a, c
        ld      b, c
        cp      $12
        jr      c, n3ad3
n3ad1   ld      b, $11
n3ad3   ex      de, hl
n3ad4   ld      a, (hl)
        inc     hl
        call    n3d8e
        ld      (de), a
        inc     de
        call    n3d6a
        djnz    n3ad4
        call    n3d8e
        ld      a, $ff
        ld      (de), a
        call    n3d6a
        ld      b, 2
n3aeb   push    bc
        call    n3d8e
        call    n3da8
        call    n052f
        call    n3de4
        call    n3d6a
        pop     bc
        jr      c, n3b07
        inc     b
        ld      a, b
        cp      $10
        jr      c, n3aeb
        pop     hl
        pop     hl
        ret

n3b07   ld      hl, $c022
        pop     de
        pop     af
        ld      c, a
        push    bc
        call    n3d8e
        call    n3da8
        call    n0106
        call    n3de4
        call    n3d6a
        pop     bc
        ret     nc
        push    bc
        ld      hl, n3b34
        ld      bc, 14
        ld      de, 13
        call    n3c99
        ld      bc, 13
        add     hl, bc
        pop     bc
        ld      (hl), b
        scf
        ret

n3b34   defb    $00, $5b, $00, $5b, $46, $e0, $3e, $73
        defb    $3e, $4e, $3e, $0e, $00

n3b41   call    n3a01
        push    hl
        call    n39f6
        pop     de
        ret     nc
        ld      a, b
        or      c
        ret     nz
        ld      a, h
        or      l
        ret     z
        push    de
        push    hl
        ld      hl, n3b6f
n3b55   ld      bc, $0013
        ld      de, $000d
        call    n3c99
        ld      bc, $000d
        add     hl, bc
        pop     bc
        ld      (hl), c
        inc     hl
        ld      (hl), b
        inc     hl
        inc     hl
        inc     hl
        pop     bc
        ld      (hl), c
        inc     hl
        ld      (hl), b
        scf
        ret

n3b6f   defb    $00, $5b, $00, $5b, $4d, $1c, $03, $21
        defb    $03, $26, $03, $13, $00

n3b7c   ld      a, b
        and     a
        ret     nz
        ld      a, c
        and     a
        ret     z
        ld      a, (de)
        inc     de
        dec     c
        ret     z
        and     $df
        cp      $41
        ccf
        ret     nc
        cp      $5b
        ret     nc
        ld      l, a
        ld      a, (de)
        cp      $24
        scf
        ccf
        ret     nz
        dec     c
        ret     nz
        set     7, l
        push    hl
        ld      hl, n3baf
        ld      bc, $0010
        ld      de, $000d
        call    n3c99
        ld      bc, $000d
        add     hl, bc
        pop     bc
        ld      (hl), c
        scf
        ret

n3baf   defb    $00, $5b, $00, $5b, $56, $ef, $39, $d7
        defb    $39, $fb, $39, $10, $00

n3bbc   call    n3a01
        ld      a, h
        and     a
        ret     nz
        ld      a, l
        cp      $18
        ret     nc
        push    hl
        ld      hl, $001f
        call    n39e5
        jp      nc, n3c7e
        ld      a, l
        pop     hl
        ld      h, a
        push    hl
        ld      a, $18
        sub     l
        ld      l, a
        ld      h, 0
        call    n39e5
        jp      nc, n3c7e
        ex      (sp), hl
        push    hl
        ld      a, $20
        sub     h
        ld      l, a
        ld      h, 0
        call    n39e5
        ld      a, l
        pop     hl
        ex      (sp), hl
        ld      h, a
        push    hl
        call    n39f6
        ld      a, 8
        jr      nc, n3c0d
        ld      a, h
        and     a
        jp      nz, n3c7d
        ld      a, l
        cp      3
        ccf
        jr      nc, n3c7d
        cp      9
        jr      nc, n3c7d
        push    af
        call    n39f6
        jr      c, n3c20
        pop     af
n3c0d   push    af
        ld      hl, n3c80
        sub     3
        jr      z, n3c1a
n3c15   inc     hl
        inc     hl
        dec     a
        jr      nz, n3c15
n3c1a   ld      a, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, a
        jr      n3c26

n3c20   ld      a, h
        and     $c0
        jr      z, n3c7c
        dec     h
n3c26   ld      a, b
        or      c
        jr      nz, n3c7c
        push    hl
        ld      hl, n3c8c
        ld      bc, $004d
        ld      de, $000d
        call    n3c99
        ld      bc, $0015
        add     hl, bc
        pop     bc
        ld      (hl), b
        dec     hl
        ld      (hl), c
        dec     hl
        pop     af
        ld      (hl), a
        dec     hl
        pop     bc
        ex      de, hl
        ex      (sp), hl
        ex      de, hl
        push    af
        ld      a, e
        add     a, a
        add     a, a
        add     a, a
        ld      (hl), a
        dec     hl
        ld      (hl), d
        dec     hl
        ld      a, c
        add     a, e
        dec     a
        ld      (hl), a
        dec     hl
        ld      a, b
        add     a, d
        dec     a
        ld      (hl), a
        dec     hl
        ld      (hl), e
        dec     hl
        ld      (hl), d
        ld      e,b
        ld      d, 0
        ex      de, hl
        add     hl, hl
        add     hl, hl
        add     hl, hl
        pop     af
        ld      c, a
        ld      b, 0
        xor     a
n3c69   sbc     hl, bc
        inc     a
        jr      nc, n3c69
        dec     a
        ld      hl, $000b
        add     hl, de
        ld      (hl), a
        inc     hl
        ld      a, ($5c8d)
        ld      (hl), a
        pop     de
        scf
        ret

n3c7c   pop     hl
n3c7d   pop     hl
n3c7e   pop     hl
        ret

n3c80   defb    $62, $2b, $62, $2b, $7b, $2b, $7b, $2b
        defb    $3e, $2b, $1f, $2b
n3c8c   defb    $00, $5b, $00, $5b, $57, $d0, $27, $9c
        defb    $39, $9c, $39, $4d, $00

n3c99   push    hl
        push    de
        push    bc
        ld      hl, ($5c53)
        dec     hl
        push    hl
        exx
        call    n3e00
        xor     a
        ccf
        pop     de
        pop     hl
        pop     bc
        and     a
        sbc     hl, bc
        ex      (sp), hl
        push    de
        ldir    
        pop     hl
        pop     bc
n3cb3   ld      a, b
        or      c
        jr      z, n3cbd
        xor     a
        ld      (de), a
        inc     de
        dec     bc
        jr      n3cb3

n3cbd   push    hl
        ld      de, ($5c4f)
        and     a
        sbc     hl, de
        inc     hl
        ex      de, hl
        pop     hl
        ret     

n3cc9   call    n39c1
        ret     nc
        ld      a, b
        or      c
        scf     
        ret     z
        push    hl
        ld      hl, ($5c4f)
        add     hl, bc
        inc     hl
        inc     hl
        inc     hl
        ld      c, (hl)
        ex      de, hl
        ld      hl, n3d06
        call    n39dc
        jp      nc, n39d6
        ld      a, (hl)
        inc     hl
        ld      h, (hl)
        ld      l, a
        call    n3a7e
        pop     hl
        ld      a, $12
        ret     nc
        ld      bc, 0
        ld      de, $a3e2
        ex      de, hl
        add     hl, de
        jr      c, n3d00
        ld      bc, n3d2a
        add     hl, bc
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
n3d00   ex      de, hl
        ld      (hl), c
        inc     hl
        ld      (hl), b
        scf     
        ret     

n3d06   defb    $4b, $04, $3d, $53, $04, $3d, $50, $04
        defb    $3d, $46, $2a, $3d, $4d, $41, $3d, $56
        defb    $41, $3d, $57, $41, $3d, $00, $01, $00
        defb    $06, $00, $0B, $00, $01, $00, $01, $00
        defb    $06, $00, $10, $00

n3d2a   ld      hl, 9
        add     hl, de
        ld      b, (hl)
        push    de
        call    n3d8e
        call    n3da8
        call    n0109
        call    n3de4
        call    n3d6a
        pop     de
        ret     nc
        ld      hl, 7
        add     hl, de
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        dec     de
        dec     de
        dec     de
        dec     de
        ex      de, hl
        exx     
        call    n3e00
        ld      (hl), a
        ccf     
        scf     
        ret     

n3d55   exx     
        ld      de,$0000
n3d59   call    n3e00
        dec     l
        add     hl,sp
        ret     
        
n3d5f   ld      de, 2
        jr      n3d59

n3d64   exx     
        ld      de, 4
        jr      n3d59

n3d6a   ex      af,af'
        xor     a
        di      
        call    n3d83
        pop     af
        ld      ($5b58), hl
        ld      hl, ($5b6a)
        ld      ($5b6a), sp
        ld      sp, hl
        ei      
        ld      hl, ($5b58)
        push    af
        ex      af, af'
        ret     
        
n3d83   push    bc
        ld      bc, $7ffd
        out     (c), a
        ld      ($5b5c), a
        pop     bc
        ret     

n3d8e   ex      af, af'
        di      
        pop     af
        ld      ($5b58), hl
        ld      hl, ($5b6a)
        ld      ($5b6a), sp
        ld      sp, hl
        ld      hl, ($5b58)
        push    af
        ld      a, 7
        call    n3d83
        ei      
        ex      af,af'
        ret     

n3da8   call    n3dd2
        ld      hl, $5bff
        ld      de, $e7ff
        ld      bc, $0084
        lddr    
        pop     bc
        ld      ($e602), sp
        ld      hl, $5bff
        ld      sp, hl
        push    bc
n3dc0   ld      bc, ($e60c)
        ld      de, ($e60a)
        ld      hl, ($e606)
        push    hl
        pop     af
        ld      hl, ($e608)
        ei      
        ret     

n3dd2   di      
        ld      ($e608), hl
        push    af
        pop     hl
        ld      ($e606), hl
        ld      ($e60a), de
        ld      ($e60c), bc
        ret     
        
n3de4   call    n3dd2
        pop     hl
        ld      ($e604), hl
        ld      hl, $e7ff
        ld      de, $5bff
        ld      bc, $0084
        lddr    
        ld      hl, ($e602)
        ld      sp, hl
        ld      hl, ($e604)
        push    hl
        jr      n3dc0

n3e00   ld      ($5b52), hl
        push    af
        pop     hl
        ld      ($5b56), hl
        ex      (sp), hl
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ex      (sp), hl
        push    bc
        pop     hl
        ld      a, ($5b67)
        ld      bc, $1ffd
        res     2, a
        di      
        ld      ($5b67), a
        out     (c), a
        ei      
        ld      bc, n3e2d
        push    bc
        push    hl
        ld      hl, ($5b56)
        push    hl
        pop     af
        ld      hl, ($5b52)
        ret     

n3e2d   push    bc
        push    af
        ld      a,($5b67)
        ld      bc,$1ffd
        set     2,a
        di      
        ld      ($5b67),a
        out     (c),a
        ei      
        pop     af
        pop     bc
        ret     
    ENDIF

; This is a copy of the "keyboard scanning" subroutine from
; $028e in ROM 3

n2327   ld      l,$2f
        ld      de,$ffff
        ld      bc,$fefe
n232f   in      a,(c)
        cpl
        and     $1f
        jr      z,n2344
        ld      h,a
        ld      a,l
n2338   inc     d
        ret     nz
n233a   sub     $08
        srl     h
        jr      nc,n233a
        ld      d,e
        ld      e,a
        jr      nz,n2338
n2344   dec     l
        rlc     b
        jr      c,n232f
        ld      a,d
        inc     a
        ret     z
        cp      $28
        ret     z
        cp      $19
        ret     z
        ld      a,e
        ld      e,d
        ld      d,a
        cp      $18
        ret

; This is a copy of the "keyboard" subroutines from $02bf in ROM 3

n2358   call    n2327
        ret     nz
        ld      hl,KSTATE
n235f   bit     7,(hl)
        jr      nz,n236a
        inc     hl
        dec     (hl)
        dec     hl
        jr      nz,n236a
        ld      (hl),$ff
n236a   ld      a,l
        ld      hl,KSTATE+$04
        cp      l
        jr      nz,n235f
        call    n23b7
        ret     nc
        ld      hl,KSTATE
        cp      (hl)
        jr      z,n23a9
        ex      de,hl
        ld      hl,KSTATE+$04
        cp      (hl)
        jr      z,n23a9
        bit     7,(hl)
        jr      nz,n238a
        ex      de,hl
        bit     7,(hl)
        ret     z
n238a   ld      e,a
        ld      (hl),a
        inc     hl
        ld      (hl),$05
        inc     hl
        ld      a,(REPDEL)
        ld      (hl),a
        inc     hl
        ld      c,(iy+$07)
        ld      d,(iy+$01)
        push    hl
        call    n23cc
        pop     hl
        ld      (hl),a
n23a1   ld      (LAST_K),a
        set     5,(iy+$01)
        ret
n23a9   inc     hl
        ld      (hl),$05
        inc     hl
        dec     (hl)
        ret     nz
        ld      a,(REPPER)
        ld      (hl),a
        inc     hl
        ld      a,(hl)
        jr      n23a1

; This is a copy of the "K-Test" subroutine from $031e in ROM 3

n23b7   ld      b,d
        ld      d,$00
        ld      a,e
        cp      $27
        ret     nc
        cp      $18
        jr      nz,n23c5
        bit     7,b
        ret     nz
n23c5   ld      hl,n229e        ; the main keytable
        add     hl,de
        ld      a,(hl)
        scf
        ret

  IF garry
; DD_L_OFF_MOTOR
n2164   push    af
        xor     a
        ld      ($e600), a
        ld      a, ($5b67)
        and     $f7
        call    n2173
        pop     af
        ret

; DD_L_READ
n20c3   call    n20de
        call    n21b7
        jp      n2090
        nop
        nop
  ELSE
n23cc   ld      a,e
        cp      $3a
        jr      c,n2400
        dec     c
        jp      m,n23e8
        jr      z,n23da
        add     a,$4f
        ret
n23da   ld      hl,n22c5-'A'
        inc     b
        jr      z,n23e3
        ld      hl,n22df-'A'
n23e3   ld      d,$00
        add     hl,de
        ld      a,(hl)
        ret
n23e8   ld      hl,n2303-'A'
        bit     0,b
        jr      z,n23e3
        bit     3,d
        jr      z,n23fd
        bit     3,(iy+$30)
        ret     nz
        inc     b
        ret     nz
        add     a,$20
        ret
n23fd   add     a,$a5
        ret
n2400   cp      $30
        ret     c
        dec     c
        jp      m,n2436
        jr      nz,n2422
        ld      hl,n231d-'0'
        bit     5,b
        jr      z,n23e3
        cp      $38
        jr      nc,n241b
        sub     $20
        inc     b
        ret     z
        add     a,$08
        ret
n241b   sub     $36
        inc     b
        ret     z
        add     a,$fe
        ret
n2422   ld      hl,n22f9-'0'
        cp      $39
        jr      z,n23e3
        cp      $30
        jr      z,n23e3
        and     $07
        add     a,$80
        inc     b
        ret     z
        xor     $0f
        ret
n2436   inc     b
        ret     z
        bit     5,b
        ld      hl,n22f9-'0'
        jr      nz,n23e3
        sub     $10
        cp      $22
        jr      z,n244b
        cp      $20
        ret     nz
        ld      a,$5f
        ret
n244b   ld      a,$40
        ret

    IF v41
n244e   push    hl
        ld      hl,(CURCHL)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS2)
        ex      (sp),hl
        xor     a
      IF spanish
        ld      h,b
        ld      l,c
      ENDIF
        call    n3e00
        defw    $3ff0
        pop     hl
        ld      (FLAGS2),hl
        pop     hl
        ld      (FLAGS),hl
        pop     hl
        ld      (CURCHL),hl
        ret
n2455   push    hl
        ld      hl,(CURCHL)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS)
        ex      (sp),hl
        push    hl
        ld      hl,(FLAGS2)
        ex      (sp),hl
        or      a
        call    n3e00
        defw    $3ff0
        pop     hl
        ld      (FLAGS2),hl
        pop     hl
        ld      (FLAGS),hl
        pop     hl
        ld      (CURCHL),hl
        ret
    ELSE
n244e   xor     a               ; we need a response
      IF spanish
        ld      h,b
        ld      l,c
      ENDIF
; These routines display error messages (in RAM at HL) using ROM 0.
; The first requires a response (DE=list of possible keys on entry)

        call    n3e00
        defw    $3ff0           ; display message
        ret
n2455   or      a               ; no response required
        call    n3e00
        defw    $3ff0           ; display message
        ret
    ENDIF

; ******************* SELF-TEST PROGRAM SECTION START *******************
; This routine is copied to RAM at $6000 and executed there with ROM 1
; paged in. A total of $C00 bytes is copied from here ($245c-$305b).
    IF v41
      IF spanish
        define  stst    $6000-$2494
      ELSE
        define  stst    $6000-$2492
      ENDIF
        define  offs    $13
    ELSE
      IF spanish
        define  stst    $6000-$245e
      ELSE
        define  stst    $6000-$245c
      ENDIF
        define  offs    $00
    ENDIF

n6000   call    n683a+stst      ; page ROM 1/bank 0
        ROM3    o0D6B           ; cls
        ld      a,$02
        ROM3    o1601           ; open stream 2
        call    n6038+stst      ; do the tests
        push    af
        ld      hl,n6544+stst   ; pass message
        jr      c,n601c         ; move on if no error
        cp      $ff             ; was error "no interface"?
        call    nz,n6588+stst   ; if not, display error
        ld      hl,n6561+stst   ; fail message
n601c   call    n65a4+stst      ; display pass/fail message
        ld      a,$0d
        call    n6391+stst      ; display repeat/quit message
        pop     hl
n6025   push    hl
        call    n67f9+stst      ; get key
        pop     hl
        and     $df             ; capitalise
        cp      'R'
        jp      z,n6000+stst    ; re-start
        cp      'Q'
        jr      nz,n6025        ; don't exit unless "Q"
        push    hl
        pop     af
        ret                     ; finished!

; Subroutine to perform the tests

n6038   ld      a,$01
        call    n6391+stst      ; display signon message
        call    n6817+stst      ; page ROM 2/bank 7
        call    DOS_INITIALISE
        call    n683a+stst      ; page ROM 1/bank 0
        ret     nc              ; exit if error
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_INTERFACE
        call    n683a+stst      ; page ROM 1/bank 0
        jr      c,n605b         ; move on if interface found
        ld      a,$03
        call    n6391+stst      ; "no interface" message
        xor     a
        ld      a,$ff
        ret                     ; exit
n605b   xor     a
        ld      ($6aa4-offs),a  ; set unit 0
        ld      a,$02
        call    n6391+stst      ; display "found drives" message
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_ASK_1
        call    n683a+stst      ; page ROM 1/bank 0
        ld      a,'A'
        jr      nc,n6079        ; if only one drive, move on
        ld      a,'&'           ; else output "&B"
        rst     $10
        ld      a,'B'
        rst     $10
        ld      a,'B'
n6079   ld      ($6aa3-offs),a  ; store max drive to test
        ld      a,$0d
        rst     $10             ; CR
        ld      ix,$6a61-offs
        ld      a,$00           ; initialise a standard XDPB
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_SEL_FORMAT
        call    n683a+stst      ; page ROM 1/bank 0
        ret     nc              ; exit if error
        call    n60a1+stst      ; test unit 0
        ret     nc              ; exit if error
        ld      a,$01
        ld      ($6aa4-offs),a  ; set unit 1
        ld      a,($6aa3-offs)
        cp      'B'
        call    z,n60a1+stst    ; if B: present, test it
        ret

; Subroutine to test unit at $6aa4

n60a1   ld      a,$04
        call    n6391+stst      ; display "testing drive" message
        ld      a,($6aa4-offs)
        add     a,'A'
        rst     $10             ; output drive letter
        ld      a,$0d
        rst     $10             ; CR
        call    n636a+stst      ; get drive status
        jr      z,n60be         ; move on if no disk
        ld      a,$06
        call    n6391+stst      ; display "remove disk" message
n60b9   call    n636a+stst      ; get drive status
        jr      nz,n60b9        ; loop while disk present
n60be   ld      a,$05
        call    n6391+stst      ; display "insert side 1" message
n60c3   call    n636a+stst      ; get drive status
        jr      z,n60c3         ; loop until disk present
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_INIT
        call    n683a+stst      ; page ROM 1/bank 0

      IF v41=0
        ld      d,$00
        call    n62a8+stst      ; format track 0
        ret     nc
        call    n61f5+stst      ; spin speed test
        ret     nc
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_INIT
        call    n683a+stst      ; page ROM 1/bank 0
      ENDIF

        ld      a,$0e
        call    n6391+stst      ; display "formatting tracks" message
        ld      a,$e5
        ld      ($6860-offs),a  ; use $e5 as filler
        ld      d,$13
        call    n62a8+stst      ; format track $13
        ret     nc
        ld      d,$00
        call    n62a8+stst      ; format track 0
        ret     nc
        ld      d,$27
        call    n62a8+stst      ; format track $27
        ret     nc
        ld      a,$aa
        ld      ($6860-offs),a  ; use $aa as filler
        ld      d,$12
        call    n62a8+stst      ; format track $12
        ret     nc
        ld      d,$01
        call    n62a8+stst      ; format track 1
        ret     nc
        ld      d,$26
        call    n62a8+stst      ; format track $26
        ret     nc
        ld      a,$e5
        ld      ($6860-offs),a  ; test $e5 filled tracks
        ld      d,$00
        call    n6269+stst      ; test track 0
        ret     nc
        ld      d,$13
        call    n6269+stst      ; test track $13
        ret     nc
        ld      d,$27
        call    n6269+stst      ; test track $27
        ret     nc
        ld      a,$aa
        ld      ($6860-offs),a  ; test $aa filled tracks
        ld      d,$01
        call    n6269+stst      ; test track 1
        ret     nc
        ld      d,$12
        call    n6269+stst      ; test track $12
        ret     nc
        ld      d,$26
        call    n6269+stst      ; test track $26
        ret     nc
        xor     a
        ld      ($6860-offs),a  ; use 0 as filler
        ld      d,$00
        call    n62a8+stst      ; format track 0
        ret     nc
        ld      d,$01
        call    n62a8+stst      ; format track 1
        ret     nc
        ld      d,$12
        call    n62a8+stst      ; format track $12
        ret     nc
        ld      d,$13
        call    n62a8+stst      ; format track $13
        ret     nc
        ld      d,$26
        call    n62a8+stst      ; format track $26
        ret     nc
        ld      d,$27
        call    n62a8+stst      ; format track $27
        ret     nc
        ld      d,$00
        call    n6269+stst      ; test track 0
        ret     nc
        ld      d,$01
        call    n6269+stst      ; test track 1
        ret     nc
        ld      d,$12
        call    n6269+stst      ; test track $12
        ret     nc
        ld      d,$13
        call    n6269+stst      ; test track $13
        ret     nc
        ld      d,$26
        call    n6269+stst      ; test track $26
        ret     nc
        ld      d,$27
        call    n6269+stst      ; test track $27
        ret     nc
        ld      a,$06
        call    n6391+stst      ; display "remove disk" message
n6196   call    n636a+stst      ; get drive status
        jr      nz,n6196        ; loop until no disk present
        ROM3    o0DAF           ; cls
        ld      a,$07
        call    n6391+stst      ; display "insert side 2" message
n61a3   call    n636a+stst      ; get drive status
        jr      z,n61a3         ; loop until disk present
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_INIT
        call    n683a+stst      ; page ROM 1/bank 0
        ld      a,($6aa4-offs)
        ld      c,a
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_DRIVE_STATUS
        call    n683a+stst      ; page ROM 1/bank 0
        and     $40
        jr      nz,n61cb        ; move on if write-protected
        ld      a,$08
        call    n6391+stst      ; display "disk not w/p" message
        xor     a               ; fail
        ld      a,$ff
        ret
n61cb   ld      a,$0a
        call    n6391+stst      ; display "checking data" message
        ld      b,$28           ; $28 tracks to check
n61d2   push    bc
        ld      a,b
        add     a,a
        add     a,a
        add     a,a
        add     a,a
        add     a,b
        ld      ($6860-offs),a  ; filler is $11*(track+1)
        dec     b
        ld      d,b             ; track number to check
        call    n6269+stst      ; check track
        pop     bc
        ret     nc              ; exit if error
        djnz    n61d2           ; back for more
        ld      a,$06
        call    n6391+stst      ; display "remove disk" message
n61ea   call    n636a+stst      ; get drive status
        jr      nz,n61ea        ; loop back until no disk
        ROM3    o0DAF           ; cls
        xor     a
        scf                     ; success
        ret

; Subroutine to test spin speed

n61f5   ld      a,$0b
        call    n6391+stst      ; display "starting spin speed test"
        call    n62de+stst      ; time a read data command
        call    n62de+stst      ; and again
        push    hl
        ld      hl,$3030
        ld      (n6522+stst),hl ; set spin speed difference 00%
        pop     hl
        push    de
        ld      ($685e-offs),hl ; save low word of time taken
      IF v41
        ld      de,$736f
      ELSE
        ld      de,$4c2d
      ENDIF
        or      a
        sbc     hl,de           ; test time taken (low word)
        ld      a,'-'           ; set spin speed +/- flag
        jr      nc,n6218
        ld      a,'+'
n6218   ld      (n6521+stst),a  ; set sign of spin speed difference
        pop     de
        ld      a,d
        push    af
        or      e               ; test time taken (high word)
        jr      z,n6227
        pop     af
        ld      a,$63           ; if not zero, spin speed out by 99%
        jp      n623f+stst
n6227   pop     af
        ld      hl,($685e-offs) ; get low word of time taken
      IF v41
        ld      de,$736f
      ELSE
        ld      de,$4c2d
      ENDIF
        jr      nc,n6231
        ex      de,hl           ; exchange if necessary
n6231   xor     a               ; zero difference percentage
        sbc     hl,de           ; get timing difference
      IF v41
        ld      de,$0127        ; DE is 1% difference
      ELSE
        ld      de,$00c3        ; DE is 1% difference
      ENDIF
n6237   or      a
        sbc     hl,de
        jr      c,n623f         ; move on when within range
        inc     a               ; increment percentage difference
        jr      n6237           ; loop back
n623f   push    af
        or      a
        jr      z,n624c         ; move on if spin speed exactly right
        ld      b,a
n6244   ld      hl,n6523+stst   ; address of %age in "spin diff" message
        call    n625e+stst      ; increment by B%
        djnz    n6244
n624c   ld      a,$0f
        call    n6391+stst      ; display "spin speed diff" message
        pop     af
        cp      $03
        ld      a,$10
        push    af
        call    nc,n6391+stst   ; if 3% out or more, "spin speed incorrect"
        pop     af
        ld      a,$ff
        ret

; Subroutine to increment %age figure (ASCII) at HL

n625e   ld      a,(hl)
        inc     a               ; increment low digit
        ld      (hl),a
        cp      $3a
        ret     nz              ; exit if in range
        ld      (hl),'0'        ; else zero
        dec     hl              ; and loop back for next higher digit
        jr      n625e

; Subroutine to test track D contains sector filled with correct filler

n6269   ld      b,$09           ; 9 sectors
        push    bc
        dec     b
        ld      a,($6aa4-offs)
        ld      e,b             ; E=sector (0 base)
        ld      c,a             ; C=unit
        ld      b,$00           ; page 0
        ld      e,$00           ; sector 0
        ld      hl,$6861-offs   ; buffer to read to
        ld      ix,$6a61-offs   ; XDPB
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_READ_SECTOR
        call    n683a+stst      ; page ROM 1/bank 0
        pop     bc
        ret     nc              ; exit if error
        push    bc
        ld      hl,$6861-offs
        ld      bc,$0200        ; $200 bytes to test
n628f   ld      a,($6860-offs)
        cp      (hl)            ; test against filler
        jr      nz,n629e        ; move on if different
        inc     hl
        dec     bc
        ld      a,b
        or      c
        jr      nz,n628f        ; loop back
        pop     bc
        scf                     ; success
        ret
n629e   pop     bc
        ld      a,$0c
        call    n6391+stst      ; display "data not read correctly" message
        xor     a
        ld      a,$ff
        ret

; Subroutine to format track D with filler byte from $6860

n62a8   ld      a,($6860-offs)
        ld      e,a             ; E=filler byte
        ld      b,$00           ; B=page 0
        ld      a,($6aa4-offs)
        ld      c,a             ; C=unit
        ld      hl,$6a7b-offs
        call    n62c6+stst      ; fill format buffer
        ld      ix,$6a61-offs   ; IX=XDPB
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_FORMAT
        call    n683a+stst      ; page ROM 1/bank 0
        ret

; Subroutine to fill format buffer at HL for track D

n62c6   push    af
        push    bc
        push    hl
        ld      b,$09           ; 9 sectors
n62cb   ld      (hl),d          ; insert track number
        inc     hl
        ld      (hl),$00        ; insert head number (0)
        inc     hl
        ld      a,$0a
        sub     b
        ld      (hl),a          ; insert sector number (1-9)
        inc     hl
        ld      (hl),$02        ; insert sector size (512 bytes)
        inc     hl
        djnz    n62cb           ; loop back
        pop     hl
        pop     bc
        pop     af
        ret

; Subroutine to turn on motor & time a read data command

n62de   call    n636a+stst      ; get drive status
        jr      z,n62de         ; loop until disk present
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_L_ON_MOTOR
        call    n683a+stst      ; page ROM 1/bank 0
        di                      ; disable interrupts for timing
        call    n62f2+stst      ; time a read data command
        ei                      ; re-enable interrupts
        ret

; Subroutine to time an impossible "read data" command

n62f2   ld      bc,$2ffd
        in      a,(c)           ; get FDC status
        bit     4,a
        jr      nz,n62f2        ; loop if busy
        ld      a,$66
        call    n6353+stst      ; send "read data" command
        ld      a,($6aa4-offs)
        call    n6353+stst      ; send unit
        xor     a
        call    n6353+stst      ; send track 0
        xor     a
        call    n6353+stst      ; send head 0
        ld      a,$fe
        call    n6353+stst      ; send sector $fe
        ld      a,$03
        call    n6353+stst      ; send 1024 bytes/sector
        ld      a,$fe
        call    n6353+stst      ; send endsector $fe
        ld      a,$2a
        call    n6353+stst      ; send gaplength $2a
        ld      a,$ff
        call    n6353+stst      ; send datalength $ff
        ld      hl,$0000        ; zero timer
        ld      de,$0000
n632d   ld      bc,$2ffd
n6330   in      a,(c)
        bit     7,a
        jr      nz,n633e        ; move on if FDC ready
        inc     hl              ; increment timer DEHL
        ld      a,h
        or      l
        jr      nz,n6330
        inc     de
        jr      n6330           ; loop back
n633e   bit     5,a
        jr      z,n6349         ; move on if not in execution phase
        ld      bc,$3ffd
        in      a,(c)           ; discard a byte
        jr      n632d           ; loop back
n6349   ld      bc,$2ffd
        in      a,(c)
        bit     7,a
        jr      z,n6349         ; loop until FDC ready
        ret

; Subroutine to output a byte (A) to FDC data register

n6353   ld      d,a             ; save byte
        ld      bc,$2ffd
n6357   in      a,(c)
        and     $e0
        cp      $80
        jr      nz,n6357        ; loop back until FDC ready for data
        ld      bc,$3ffd
        ld      a,d
        out     (c),a           ; output byte
        ex      (sp),hl         ; short delay
        ex      (sp),hl
        ex      (sp),hl
        ex      (sp),hl
        ret

; Subroutine to get bit 5 of drive status

n636a   ld      a,($6aa4-offs)  ; get unit
        ld      c,a
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_DRIVE_STATUS
        call    n683a+stst      ; page ROM 1/bank 0
        ld      bc,$4000
n637a   push    bc
        pop     bc
        dec     bc
        ld      a,b
        or      c
        jr      nz,n637a        ; delay loop
        ld      a,($6aa4-offs)
        ld      c,a
        call    n6817+stst      ; page ROM 2/bank 7
        call    DD_DRIVE_STATUS
        call    n683a+stst      ; page ROM 1/bank 0
        and     $20             ; mask bit 5
        ret

; Subroutine to set scroll count to max & display message A

n6391   push    af
        ld      a,$ff
        ld      (SCR_CT),a
        pop     af
        ld      hl,n639e+stst   ; first message
        jp      n6598+stst      ; display message A

; Message table

n639e   defm    $0d, 0
        defm    "Integral disk test  V1.5", $0d, 0
        defm    $0d, "Found Drive(s) :A", 0
        defm    "NO DISK INTERFACE !", $0d, $0d, "Test Aborted.", 0
        defm    $0d, "Testing Drive ", 0
        defm    $0d, "Insert side 1 of test disk.", $0d, 0
        defm    $0d, "Remove disk from drive", $0d, 0
        defm    $0d, "Insert side 2 of test disk.", 0
        defm    $0d, "Disk is not write-protected.", $0d, 0
        defm    $0d, "Spin test not implemented.", $0d, 0
        defm    $0d, "Checking Data.", $0d, 0
        defm    $0d, "Starting spin-speed test.", $0d, 0
        defm    $0d, "Data not read correctly.", $0d, 0
        defm    $0d, "Press R to repeat, Q to quit", $0d, 0
        defm    "Formatting tracks.", $0d, 0
        defm    "Spin speed difference "
n6521   defm    "*"
n6522   defm    "0"
n6523   defm    "0 %", $0d, 0
        defm    $0d, "Spin speed is INCORRECT !", $0d, 0
n6544   defm    $0d, "The disk drive test passed.", 0
n6561   defm    $0d, "The disk drive test failed.", 0

; Subroutine to set print position to top left - appears unused

n657e   push    af
        ld      a,$16
n6581   rst     $10
        xor     a
        rst     $10
n6584   xor     a
        rst     $10
        pop     af
        ret

; Subroutine to display error message A

n6588   ld      hl,n65b0+stst   ; error message table start
        cp      $0a
        jr      c,n6591
        sub     $0a             ; adjust error number to fit table
n6591   call    n6598+stst      ; display message
        ld      a,$0d
        rst     $10             ; CR
        ret

; Subroutine to display null-terminated message A, table start HL

n6598   ld      b,a
        inc     b               ; increment message count
        xor     a               ; find null
n659b   push    hl
        pop     de
n659d   cp      (hl)
n659e   inc     hl
        jr      nz,n659d        ; loop back until null found
        djnz    n659b           ; loop back until at start of correct message
        ex      de,hl           ; DE=message start
n65a4   ld      a,(hl)          ; get next char
        inc     hl
        or      a
        ret     z               ; exit if null
        cp      $ff
        ret     z               ; or $ff
        ROM3    o0010           ; output char
        jr      n65a4           ; loop back

; Error message table

n65b0   defm    "Drive not ready.", 0
        defm    "Disc is write protected.", 0
        defm    "Disc seek fail.", 0
        defm    "Disc CRC data error.", 0
        defm    "No data on disc.", 0
        defm    "Address mark missing.", 0
        defm    "Unrecognized disc format.", 0
        defm    "Unknown disc error. - Well done !", 0
        defm    "Disc changed while in use.", 0
        defm    "Wrong type of disc in drive.", 0
        defm    "Bad filename.", 0
        defm    "Bad parameter.", 0
        defm    "Drive not found.", 0
        defm    "File not found.", 0
        defm    "File already exists.", 0
        defm    "End of file.", 0
        defm    "Disc full.", 0
        defm    "Directory full.", 0
        defm    "Read-only file.", 0
        defm    "File not open, or wrong access.", 0
        defm    "Access denied, file in use.", 0
        defm    "Cannot rename between drives", 0
        defm    "Extent is missing.", 0
        defm    "Uncached. (software error)", 0
        defm    "File too big.", 0
        defm    "Disc not bootable", 0
        defm    "Drive was in use.", 0
        defm    "You should never see this.", 0

; Subroutine to wait for a keypress, returning in A

n67f9   ld      hl,FLAGS
        res     5,(hl)          ; set "no key"
n67fe   bit     5,(hl)
        jr      z,n67fe         ; loop back until key available
        ld      a,(LAST_K)      ; get it
        res     5,(hl)          ; set "no key"
        ret

; Subroutine to reset the computer - appears to be unused

n6808   di
        ld      bc,$1ffd
        xor     a
        out     (c),a
        ld      bc,$7ffd
        out     (c),a
        jp      $0000

; Subroutine to make sure ROM 2 & bank 7 are paged in

n6817   di
n6818   push    af
        push    bc
        push    hl
        ld      bc,$7ffd
        ld      hl,BANKM
        ld      a,(hl)
        or      $07             ; ensure ROM 0/2 & bank 7 paged
        and     $ef
n6826   ld      (hl),a
        out     (c),a
        ld      hl,BANK678
        ld      a,(hl)
        or      $04             ; ensure ROM 2 paged
        ld      (hl),a
        ld      bc,$1ffd
        out     (c),a
        pop     hl
        pop     bc
        pop     af
        ei
        ret

; Subroutine to make sure ROM 1 and bank 0 are paged in

n683a   di
        push    af
        push    bc
        push    hl
        ld      bc,$7ffd
        ld      hl,BANKM
        ld      a,(hl)
        or      $10             ; ensure ROM 1/3 & bank 0 paged
        and     $f8
        ld      (hl),a
n684a   out     (c),a
        ld      a,(BANK678)
n684f   and     $fb             ; ensure ROM 1 paged
        ld      (BANK678),a
        ld      bc,$1ffd
        out     (c),a
        pop     hl
        pop     bc
        pop     af
        ei
        ret
        nop
        nop
        push    hl
        nop
        nop

; *********************** END OF SELF-TEST PROGRAM **********************


    IF v41
      IF spanish
n2cc4   defs    4380
      ELSE
n2cc4   defs    4382
      ENDIF
    ELSE
      IF spanish
n2cc4   defs    4415
      ELSE
n2cc4   defs    4417
      ENDIF
    ENDIF

; Paging routine, for calling a routine (address inline) in ROM 0

n3e00   ld      (OLDHL),hl      ; save HL & AF
        push    af
        pop     hl
        ld      (OLDAF),hl
        ex      (sp),hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address to call
        inc     hl
        ex      (sp),hl         ; restack updated return address
        push    bc
        pop     hl              ; HL=address to call
        ld      a,(BANK678)
        ld      bc,$1ffd
        res     2,a             ; select ROM 0
        di
        ld      (BANK678),a
        out     (c),a
        ei
        ld      bc,n3e2d
        push    bc              ; stack address to return to repage ROM 2
        push    hl              ; stack address to call in ROM 0
        ld      hl,(OLDAF)      ; restore AF & HL
        push    hl
        pop     af
        ld      hl,(OLDHL)
        ret                     ; "return" to call routine
n3e2d   push    bc              ; stack registers
        push    af
        ld      a,(BANK678)
        ld      bc,$1ffd
        set     2,a             ; select ROM 2
        di
        ld      (BANK678),a
        out     (c),a
        ei
        pop     af              ; restore registers
        pop     bc
        ret                     ; done

        defs    191
  ENDIF

; This routine is a duplicate of a routine to call a ROM 2 routine
; residing in ROM 1 (another copy is in ROM 0). As soon as ROM 2 is
; paged in, it takes control.

n3f00   ld      (OLDHL),hl      ; save HL, BC and AF
        ld      (OLDBC),bc
        push    af
        pop     hl
        ld      (OLDAF),hl
        ex      (sp),hl
        ld      c,(hl)
        inc     hl
        ld      b,(hl)          ; BC=inline address
        inc     hl
        ex      (sp),hl         ; restack updated return address
      IF garry
        ld      hl, n3f42
        push    hl
      ENDIF
        push    bc
        pop     hl
        ld      a,(BANKM)
        and     $ef
        di
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 0
        ld      a,(BANK678)
        or      $04
        ld      (BANK678),a
n3f2a   ld      bc,$1ffd
        out     (c),a           ; page in ROM 2
        ei
      IF garry=0
        ld      bc,n3f42
        push    bc              ; stack routine address to return to ROM 1
      ENDIF
        push    hl              ; stack routine address to call
        ld      hl,(OLDAF)      ; restore registers
        push    hl
        pop     af
        ld      bc,(OLDBC)
        ld      hl,(OLDHL)
        ret                     ; exit to ROM 2 routine

; This part then returns control to ROM 1

n3f42   push    bc              ; save registers
        push    af
        ld      a,(BANK678)
        and     $fb
        di
        ld      (BANK678),a
        ld      bc,$1ffd
        out     (c),a           ; page in ROM 0
        ld      a,(BANKM)
        or      $10
        ld      (BANKM),a
        ld      bc,$7ffd
        out     (c),a           ; page in ROM 1
        ei
        pop     af              ; restore registers
        pop     bc
        ret                     ; done!

  IF garry
n3f63   push    bc
        push    af
        ld      a, ($5b67)
        and     $fb
        di      
        ld      ($5b67), a
        ld      bc, $1ffd
        out     (c), a
        ei      
        pop     af
        pop     bc
        ret     

n23cc
n3f77   ld      a, e
        cp      $3a
        jr      c, n3fab
        dec     c
        jp      m, n3f93
        jr      z, n3f85
        add     a, $4f
        ret     

n3f85   ld      hl,$2222
        inc     b
        jr      z, n3f8e
        ld      hl, $223c
n3f8e   ld      d, 0
        add     hl, de
        ld      a, (hl)
        ret     

n3f93   ld      hl, $2260
        bit     0, b
        jr      z, n3f8e
        bit     3, d
        jr      z, n3fa8
        bit     3, (iy+$30)
        ret     nz
        inc     b
        ret     nz
        add     a, $20
        ret     
n3fa8   add     a, $a5
        ret     
        
n3fab   cp      $30
        ret     c
        dec     c
        jp      m, n3fe1
        jr      nz, n3fcd
        ld      hl, $228b
        bit     5, b
        jr      z, n3f8e
        cp      $38
        jr      nc, n3fc6
        sub     $20
        inc     b
        ret     z
        add     a, 8
        ret     
n3fc6   sub     $36
        inc     b
        ret     z
n3fca   add     a, $fe
        ret     
        
n3fcd   ld      hl, $2267
        cp      $39
        jr      z, n3f8e
        cp      $30
        jr      z, n3f8e
        and     7
        add     a, $80
        inc     b
        ret     z
        xor     $0f
        ret     

n3fe1   inc     b
        ret     z
        bit     5, b
        ld      hl, $2267
        jr      nz, n3f8e
        sub     $10
        cp      $22
        jr      z, n3ff6
        cp      $20
        ret     nz
        ld      a, $5f
        ret     

n3ff6   ld      a,$40
        ret     
        defb    $ff, $ff, $ff, $ff, $ff, $ff, $ff
  ELSE
; Unused space
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
        defb    $ff,$ff,$ff,$ff
    IF v41
      IF spanish
        defb    $4f
      ELSE
        defb    $5c
      ENDIF
    ELSE
      IF spanish
        defb    $59
      ELSE
        defb    $66
      ENDIF
    ENDIF
  ENDIF

; ----------------------------------------------------------------------------------------------------

; ======================================
; BCB (Buffer Control Block) description
; ======================================
;
; Each buffer has a BCB consisting of $0B bytes.
; BCBs are contained in two chains: an "in-use" chain and a "free" chain.
; The most recently accessed buffers rise to the top of the in-use chain.
;
; DE contains the address of the BCB for the current buffer during
; DOS operations.
;
;
; Offset  Length  Description
; ------  ------  -----------
; +00     2       Pointer to previous BCB in chain
; +02     1       Flags:  Bit 0 set if data changed & should be written to disk
; +03     2       FCB address of file using this buffer
; +05     1       Drive letter (ASCII)
; +06     2       Absolute logical sector
; +08     2       Buffer address
; +0A     1       Buffer bank

; ----------------------------------------------------------------------------------------------------

; ====================================
; FCB (File Control Block) description
; ====================================
;
; Each file has an FCB consisting of $38 bytes. The first $20 bytes
; of this is a straight copy of the directory entry for the file.
;
; BC contains the address of the FCB for the current file during
; DOS operations.
;
;
; Offset  Length  Description
; ------  ------  -----------
; +00     1       User area
; +01     8       Filename
; +09     3       Extension
; +0C     1       Extent counter (low 5 bits)
; +0D     1       Reserved (0)
; +0E     1       Extent counter (high 8 bits)
; +0F     1       Number of records in extent (low byte)
; +10     10      Allocation list
; +20     1       Access mode (bit 7 set if file open)
; +21     1       Drive file resides on (ASCII)
; +22     1       Flags:  Bit 0 set if dir contains valid copy of FCB info
;                         Bit 1 set if new directory entry needed
;                         Bit 2 set if new extent needs to be created
;                         Bit 3 set if +2B contains valid sector number
;                         Bit 4 set if current record changed
;                         Bit 5 set if valid record details in FCB
;                         Bit 6 set if file has header
; +23     3       File length
; +26     3       Filepointer
; +29     2       Record number
; +2B     2       Absolute logical sector
; +2D     2       Address of record start
; +2F     1       Bank containing record
; +30     8       +3 BASIC header data (as on p225 of +3 manual)

; ----------------------------------------------------------------------------------------------------

; ================================================
; XDPB (eXtended Disk Parameter Block) description
; ================================================
;
; Each drive has an XDPB, largely as described in the +3 manual.
; However, +3DOS keeps extra information for each drive directly
; after its copies of the XDPBs, so we can regard these as being
; "extended" XDPBs of $30 bytes each.
;
; IX contains the address of the XDPB for the current drive during
; DOS operations.
;
;
; Offset  Length  Description
; ------  ------  -----------
; +00     2       SPT records per track
; +02     1       BSH log2 (blocksize/128)
; +03     1       BLM (blocksize/128)-1
; +04     1       EXM extent mask
; +05     2       DSM last block number
; +07     2       DRM last directory entry number
; +09     1       ALO directory bitmap
; +0A     1       AL1 directory bitmap
; +0B     2       CKS checksum vector size (bit 15=fixed drive flag)
; +0D     2       OFF reserved tracks
; +0F     1       PSH log2 (sectorsize/128)
; +10     1       PHM (sectorsize/128)-1
; +11     1       Flags:  Bit 7 set if double-track
;                         Bits 0..1=sidedness (0=single,1=alternate,2=successive)
; +12     1       tracks per side
; +13     1       sectors per track
; +14     1       1st physical sector number
; +15     2       sector size
; +17     1       gap length (r/w)
; +18     1       gap length (format)
; +19     1       Flags:  Bit 7 = multitrack
;                         Bit 6 = MFM (FM=0)
;                         Bit 5 = skip deleted address marks
; +1A     1       Freeze flag: $ff=don't auto-detect disk format
; +1B     1       Flags:  Bit 3 set for RAMdisk
;                         Bit 2 set for floppy disks
;                         Bit 1 set if getting checksums (0=checking)
;                         Bit 0 set if drive logged in
; +1C     1       Drive letter (ASCII)
; +1D     1       FD unit number (for drive B:)
; +1E     3       Last access (FRAMES)
; +21     1       # files open on drive
; +22     2       # free directory entries
; +24     2       last used directory entry number
; +26     2       address of checksum vector
; +28     2       address of allocation bitmap
; +2A     2       low-level routine to login a disk
; +2C     2       low-level routine to read a sector
; +2E     2       low-level routine to write a sector


;************************************************************************
;** An Assembly File Listing to generate a 16K ROM for the ZX Spectrum **
;************************************************************************

; -------------------------
; Last updated: 05-FEB-2012
; -------------------------

;   It is always a good idea to anchor, using ORGs, important sections such as
;   the character bitmaps so that they don't move as code is added and removed.

;   Generally most approaches try to maintain main entry points as they are
;   often used by third-party software.

        ORG     $0000

;*****************************************
;** Part 1. RESTART ROUTINES AND TABLES **
;*****************************************

; -----------
; THE 'START'
; -----------
;   At switch on, the Z80 chip is in Interrupt Mode 0.
;   The Spectrum uses Interrupt Mode 1.
;   This location can also be 'called' to reset the machine.
;   Typically with PRINT USR 0.

;; START
o0000:  DI                      ; Disable Interrupts.
        XOR     A               ; Signal coming from START.
        LD      DE,$FFFF        ; Set pointer to top of possible physical RAM.
        JP      o11CB           ; Jump forward to common code at START-NEW.

; -------------------
; THE 'ERROR' RESTART
; -------------------
;   The error pointer is made to point to the position of the error to enable
;   the editor to highlight the error position if it occurred during syntax
;   checking.  It is used at 37 places in the program.  An instruction fetch
;   on address $0008 may page in a peripheral ROM such as the Sinclair
;   Interface 1 or Disciple Disk Interface.  This was not an original design
;   concept and not all errors pass through here.

;; ERROR-1
o0008:  LD      HL,(CH_ADD)     ; Fetch the character address from CH_ADD.
        LD      (X_PTR),HL      ; Copy it to the error pointer X_PTR.
        JR      o0053           ; Forward to continue at ERROR-2.

; -----------------------------
; THE 'PRINT CHARACTER' RESTART
; -----------------------------
;   The A register holds the code of the character that is to be sent to
;   the output stream of the current channel.  The alternate register set is
;   used to output a character in the A register so there is no need to
;   preserve any of the current main registers (HL, DE, BC).
;   This restart is used 21 times.

;; PRINT-A
o0010:  JP      o15F2           ; Jump forward to continue at PRINT-A-2.

; ---

    IF spanish
      IF v41 || garry
        DEFB    $FF, $FC        ; Five unused locations.
      ELSE
        DEFB    $FF, $C0        ; Five unused locations.
      ENDIF
    ELSE
      IF v41
        DEFB    $FF, $15        ; Five unused locations.
      ELSE
        DEFB    $A7, $FF        ; Five unused locations.
      ENDIF
    ENDIF
        DEFB    $FF, $FF, $FF   ;

; -------------------------------
; THE 'COLLECT CHARACTER' RESTART
; -------------------------------
;   The contents of the location currently addressed by CH_ADD are fetched.
;   A return is made if the value represents a character that has
;   relevance to the BASIC parser. Otherwise CH_ADD is incremented and the
;   tests repeated. CH_ADD will be addressing somewhere -
;   1) in the BASIC program area during line execution.
;   2) in workspace if evaluating, for example, a string expression.
;   3) in the edit buffer if parsing a direct command or a new BASIC line.
;   4) in workspace if accepting input but not that from INPUT LINE.

;; GET-CHAR
o0018:  LD      HL,(CH_ADD)     ; fetch the address from CH_ADD.
        LD      A,(HL)          ; use it to pick up current character.

;; TEST-CHAR
o001C:  CALL    o007D           ; routine SKIP-OVER tests if the character is
                                ; relevant.
        RET     NC              ; Return if it is significant.

; ------------------------------------
; THE 'COLLECT NEXT CHARACTER' RESTART
; ------------------------------------
;   As the BASIC commands and expressions are interpreted, this routine is
;   called repeatedly to step along the line.  It is used 83 times.

;; NEXT-CHAR
o0020:  CALL    o0074           ; routine CH-ADD+1 fetches the next immediate
                                ; character.
        JR      o001C           ; jump back to TEST-CHAR until a valid
                                ; character is found.

; ---

        DEFB    $FF, $FF, $FF   ; unused

; -----------------------
; THE 'CALCULATE' RESTART
; -----------------------
;   This restart enters the Spectrum's internal, floating-point, stack-based,
;   FORTH-like language.
;   It is further used recursively from within the calculator.
;   It is used on 77 occasions.

;; FP-CALC
o0028:  JP      o335B           ; jump forward to the CALCULATE routine.

; ---

        DEFB    $FF, $FF, $FF   ; spare - note that on the ZX81, space being a
        DEFB    $FF, $FF        ; little cramped, these same locations were
                                ; used for the five-byte end-calc literal.

; ------------------------------
; THE 'CREATE BC SPACES' RESTART
; ------------------------------
;   This restart is used on only 12 occasions to create BC spaces
;   between workspace and the calculator stack.

;; BC-SPACES
o0030:  PUSH    BC              ; Save number of spaces.
        LD      HL,($5C61)      ; Fetch WORKSP.
        PUSH    HL              ; Save address of workspace.
        JP      o169E           ; Jump forward to continuation code RESERVE.

; --------------------------------
; THE 'MASKABLE INTERRUPT' ROUTINE
; --------------------------------
;   This routine increments the Spectrum's three-byte FRAMES counter fifty
;   times a second (sixty times a second in the USA ).
;   Both this routine and the called KEYBOARD subroutine use the IY register
;   to access system variables and flags so a user-written program must
;   disable interrupts to make use of the IY register.

;; MASK-INT
o0038:  PUSH    AF              ; Save the registers that will be used but not
        PUSH    HL              ; the IY register unfortunately.
        LD      HL,($5C78)      ; Fetch the first two bytes at FRAMES1.
        INC     HL              ; Increment lowest two bytes of counter.
        LD      ($5C78),HL      ; Place back in FRAMES1.
        LD      A,H             ; Test if the result was zero.
        OR      L               ;
        JR      NZ,o0048        ; Forward, if not, to KEY-INT

        INC     (IY+$40)        ; otherwise increment FRAMES3 the third byte.

;   Now save the rest of the main registers and read and decode the keyboard.

;; KEY-INT
o0048:  PUSH    BC              ; Save the other main registers.
        PUSH    DE              ;

        CALL    o386E           ; Routine KEYBOARD executes a stage in the
                                ; process of reading a key-press.
        POP     DE              ;
        POP     BC              ; Restore registers.

        POP     HL              ;
        POP     AF              ;

        EI                      ; Enable Interrupts.
        RET                     ; Return.

; ---------------------
; THE 'ERROR-2' ROUTINE
; ---------------------
;   A continuation of the code at 0008.
;   The error code is stored and after clearing down stacks, an indirect jump
;   is made to MAIN-4, etc. to handle the error.

;; ERROR-2
o0053:  POP     HL              ; drop the return address - the location
                                ; after the RST 08H instruction.
        LD      L,(HL)          ; fetch the error code that follows.
                                ; (nice to see this instruction used.)

;   Note. this entry point is used when out of memory at REPORT-4.
;   The L register has been loaded with the report code but X-PTR is not
;   updated.

;; ERROR-3
o0055:  LD      (IY+$00),L      ; Store it in the system variable ERR_NR.
        LD      SP,(ERR_SP)     ; ERR_SP points to an error handler on the
                                ; machine stack. There may be a hierarchy
                                ; of routines.
                                ; To MAIN-4 initially at base.
                                ; or REPORT-G on line entry.
                                ; or  ED-ERROR when editing.
                                ; or   ED-FULL during ed-enter.
                                ; or  IN-VAR-1 during runtime input etc.

        JP      o16C5           ; Jump to SET-STK to clear the calculator stack
                                ; and reset MEM to usual place in the systems
                                ; variables area and then indirectly to MAIN-4,
                                ; etc.

; ------------------------------------
; THE 'NON-MASKABLE INTERRUPT' ROUTINE
; ------------------------------------
;
;   There is no NMI switch on the standard Spectrum or its peripherals.
;   When the NMI line is held low, then no matter what the Z80 was doing at
;   the time, it will now execute the code at 66 Hex.
;   This Interrupt Service Routine will jump to location zero if the contents
;   of the system variable NMIADD are zero or return if the location holds a
;   non-zero address.   So attaching a simple switch to the NMI as in the book
;   "Spectrum Hardware Manual" causes a reset.  The logic was obviously
;   intended to work the other way.  Sinclair Research said that, since they
;   had never advertised the NMI, they had no plans to fix the error "until
;   the opportunity arose".
;
;   Note. The location NMIADD was, in fact, later used by Sinclair Research
;   to enhance the text channel on the ZX Interface 1.
;   On later Amstrad-made Spectrums, and the Brazilian Spectrum, the logic of
;   this routine was indeed reversed but not as at first intended.
;
;   It can be deduced by looking elsewhere in this ROM that the NMIADD system
;   variable pointed to o121C and that this enabled a Warm Restart to be
;   performed at any time, even while playing machine code games, or while
;   another Spectrum has been allowed to gain control of this one.
;
;   Software houses would have been able to protect their games from attack by
;   placing two zeros in the NMIADD system variable.

;; RESET
o005F:  DEFB    $FF, $FF, $FF   ; Unused locations
        DEFB    $FF, $FF, $FF   ; before the fixed-position
        DEFB    $FF             ; NMI routine.
      IF pokemon&&!zx_tap
        push    af
        ld      a, ($5c8f)
        cp      $39
        jp      nz, poke
        ld      a, 0
      ELSE
o0066:  PUSH    AF              ; save the
        PUSH    HL              ; registers.
        LD      HL,($5CB0)      ; fetch the system variable NMIADD.
        LD      A,H             ; test address
        OR      L               ; for zero.
        JR      Z,o0070         ; skip to NO-RESET if ZERO
        JP      (HL)            ; jump to routine ( i.e. o0000 )

;; NO-RESET
o0070:  POP     HL              ; restore the
      ENDIF
        POP     AF              ; registers.
        RETN                    ; return to previous interrupt state.

; ---------------------------
; THE 'CH ADD + 1' SUBROUTINE
; ---------------------------
;   This subroutine is called from RST 20, and three times from elsewhere
;   to fetch the next immediate character following the current valid character
;   address and update the associated system variable.
;   The entry point TEMP-PTR1 is used from the SCANNING routine.
;   Both TEMP-PTR1 and TEMP-PTR2 are used by the READ command routine.

;; CH-ADD+1
o0074:  LD      HL,(CH_ADD)     ; fetch address from CH_ADD.

;; TEMP-PTR1
o0077:  INC     HL              ; increase the character address by one.

;; TEMP-PTR2
o0078:  LD      (CH_ADD),HL     ; update CH_ADD with character address.
        LD      A,(HL)          ; load character to A from HL.
        RET                     ; and return.

; --------------------------
; THE 'SKIP OVER' SUBROUTINE
; --------------------------
;   This subroutine is called once from RST 18 to skip over white-space and
;   other characters irrelevant to the parsing of a BASIC line etc. .
;   Initially the A register holds the character to be considered
;   and HL holds its address which will not be within quoted text
;   when a BASIC line is parsed.
;   Although the 'tab' and 'at' characters will not appear in a BASIC line,
;   they could be present in a string expression, and in other situations.
;   Note. although white-space is usually poaced in a program to indent loops
;   and make it more readable, it can also be used for the opposite effect and
;   spaces may appear in variable names although the parser never sees them.
;   It is this routine that helps make the variables 'Anum bEr5 3BUS' and
;   'a number 53 bus' appear the same to the parser.

;; SKIP-OVER
o007D:  CP      $21             ; test if higher than space.
        RET     NC              ; return with carry clear if so.

        CP      $0D             ; carriage return ?
        RET     Z               ; return also with carry clear if so.

                                ; all other characters have no relevance
                                ; to the parser and must be returned with
                                ; carry set.

        CP      $10             ; test if 0-15d
        RET     C               ; return, if so, with carry set.

        CP      $18             ; test if 24-32d
        CCF                     ; complement carry flag.
        RET     C               ; return with carry set if so.

                                ; now leaves 16d-23d

        INC     HL              ; all above have at least one extra character
                                ; to be stepped over.

        CP      $16             ; controls 22d ('at') and 23d ('tab') have two.
        JR      C,o0090         ; forward to SKIPS with ink, paper, flash,
                                ; bright, inverse or over controls.
                                ; Note. the high byte of tab is for RS232 only.
                                ; it has no relevance on this machine.

        INC     HL              ; step over the second character of 'at'/'tab'.

;; SKIPS
o0090:  SCF                     ; set the carry flag
        LD      (CH_ADD),HL     ; update the CH_ADD system variable.
        RET                     ; return with carry set.


; ------------------
; THE 'TOKEN' TABLES
; ------------------
;   The tokenized characters 134d (RND) to 255d (COPY) are expanded using
;   this table. The last byte of a token is inverted to denote the end of
;   the word. The first is an inverted step-over byte.

;; TKN-TABLE
o0095:  DEFB    '?'+$80
        DEFM    "RN"
        DEFB    'D'+$80
        DEFM    "INKEY"
        DEFB    '$'+$80
        DEFB    'P','I'+$80
        DEFB    'F','N'+$80
        DEFM    "POIN"
        DEFB    'T'+$80
        DEFM    "SCREEN"
        DEFB    '$'+$80
        DEFM    "ATT"
        DEFB    'R'+$80
        DEFB    'A','T'+$80
        DEFM    "TA"
        DEFB    'B'+$80
        DEFM    "VAL"
        DEFB    '$'+$80
        DEFM    "COD"
        DEFB    'E'+$80
        DEFM    "VA"
        DEFB    'L'+$80
        DEFM    "LE"
        DEFB    'N'+$80
        DEFM    "SI"
        DEFB    'N'+$80
        DEFM    "CO"
        DEFB    'S'+$80
        DEFM    "TA"
        DEFB    'N'+$80
        DEFM    "AS"
        DEFB    'N'+$80
        DEFM    "AC"
        DEFB    'S'+$80
        DEFM    "AT"
        DEFB    'N'+$80
        DEFB    'L','N'+$80
        DEFM    "EX"
        DEFB    'P'+$80
        DEFM    "IN"
        DEFB    'T'+$80
        DEFM    "SQ"
        DEFB    'R'+$80
        DEFM    "SG"
        DEFB    'N'+$80
        DEFM    "AB"
        DEFB    'S'+$80
        DEFM    "PEE"
        DEFB    'K'+$80
        DEFB    'I','N'+$80
        DEFM    "US"
        DEFB    'R'+$80
        DEFM    "STR"
        DEFB    '$'+$80
        DEFM    "CHR"
        DEFB    '$'+$80
        DEFM    "NO"
        DEFB    'T'+$80
        DEFM    "BI"
        DEFB    'N'+$80

;   The previous 32 function-type words are printed without a leading space
;   The following have a leading space if they begin with a letter

        DEFB    'O','R'+$80
        DEFM    "AN"
        DEFB    'D'+$80
        DEFB    $3C,'='+$80             ; <=
        DEFB    $3E,'='+$80             ; >=
        DEFB    $3C,$3E+$80             ; <>
        DEFM    "LIN"
        DEFB    'E'+$80
        DEFM    "THE"
        DEFB    'N'+$80
        DEFB    'T','O'+$80
        DEFM    "STE"
        DEFB    'P'+$80
        DEFM    "DEF F"
        DEFB    'N'+$80
        DEFM    "CA"
        DEFB    'T'+$80
        DEFM    "FORMA"
        DEFB    'T'+$80
        DEFM    "MOV"
        DEFB    'E'+$80
        DEFM    "ERAS"
        DEFB    'E'+$80
        DEFM    "OPEN "
        DEFB    '#'+$80
        DEFM    "CLOSE "
        DEFB    '#'+$80
        DEFM    "MERG"
        DEFB    'E'+$80
        DEFM    "VERIF"
        DEFB    'Y'+$80
        DEFM    "BEE"
        DEFB    'P'+$80
        DEFM    "CIRCL"
        DEFB    'E'+$80
        DEFM    "IN"
        DEFB    'K'+$80
        DEFM    "PAPE"
        DEFB    'R'+$80
        DEFM    "FLAS"
        DEFB    'H'+$80
        DEFM    "BRIGH"
        DEFB    'T'+$80
        DEFM    "INVERS"
        DEFB    'E'+$80
        DEFM    "OVE"
        DEFB    'R'+$80
        DEFM    "OU"
        DEFB    'T'+$80
        DEFM    "LPRIN"
        DEFB    'T'+$80
        DEFM    "LLIS"
        DEFB    'T'+$80
        DEFM    "STO"
        DEFB    'P'+$80
        DEFM    "REA"
        DEFB    'D'+$80
        DEFM    "DAT"
        DEFB    'A'+$80
        DEFM    "RESTOR"
        DEFB    'E'+$80
        DEFM    "NE"
        DEFB    'W'+$80
        DEFM    "BORDE"
        DEFB    'R'+$80
        DEFM    "CONTINU"
        DEFB    'E'+$80
        DEFM    "DI"
        DEFB    'M'+$80
        DEFM    "RE"
        DEFB    'M'+$80
        DEFM    "FO"
        DEFB    'R'+$80
        DEFM    "GO T"
        DEFB    'O'+$80
        DEFM    "GO SU"
        DEFB    'B'+$80
        DEFM    "INPU"
        DEFB    'T'+$80
        DEFM    "LOA"
        DEFB    'D'+$80
        DEFM    "LIS"
        DEFB    'T'+$80
        DEFM    "LE"
        DEFB    'T'+$80
        DEFM    "PAUS"
        DEFB    'E'+$80
        DEFM    "NEX"
        DEFB    'T'+$80
        DEFM    "POK"
        DEFB    'E'+$80
        DEFM    "PRIN"
        DEFB    'T'+$80
        DEFM    "PLO"
        DEFB    'T'+$80
        DEFM    "RU"
        DEFB    'N'+$80
        DEFM    "SAV"
        DEFB    'E'+$80
        DEFM    "RANDOMIZ"
        DEFB    'E'+$80
        DEFB    'I','F'+$80
        DEFM    "CL"
        DEFB    'S'+$80
        DEFM    "DRA"
        DEFB    'W'+$80
        DEFM    "CLEA"
        DEFB    'R'+$80
        DEFM    "RETUR"
        DEFB    'N'+$80
        DEFM    "COP"
        DEFB    'Y'+$80

; ----------------
; THE 'KEY' TABLES
; ----------------
;   These six look-up tables are used by the keyboard reading routine
;   to decode the key values.
;
;   The first table contains the maps for the 39 keys of the standard
;   40-key Spectrum keyboard. The remaining key [SHIFT $27] is read directly.
;   The keys consist of the 26 upper-case alphabetic characters, the 10 digit
;   keys and the space, ENTER and symbol shift key.
;   Unshifted alphabetic keys have $20 added to the value.
;   The keywords for the main alphabetic keys are obtained by adding $A5 to
;   the values obtained from this table.

;; MAIN-KEYS
o0205:  DEFB    $42             ; B
        DEFB    $48             ; H
        DEFB    $59             ; Y
        DEFB    $36             ; 6
        DEFB    $35             ; 5
        DEFB    $54             ; T
        DEFB    $47             ; G
        DEFB    $56             ; V
        DEFB    $4E             ; N
        DEFB    $4A             ; J
        DEFB    $55             ; U
        DEFB    $37             ; 7
        DEFB    $34             ; 4
        DEFB    $52             ; R
        DEFB    $46             ; F
        DEFB    $43             ; C
        DEFB    $4D             ; M
        DEFB    $4B             ; K
        DEFB    $49             ; I
        DEFB    $38             ; 8
        DEFB    $33             ; 3
        DEFB    $45             ; E
        DEFB    $44             ; D
        DEFB    $58             ; X
        DEFB    $0E             ; SYMBOL SHIFT
        DEFB    $4C             ; L
        DEFB    $4F             ; O
        DEFB    $39             ; 9
        DEFB    $32             ; 2
        DEFB    $57             ; W
        DEFB    $53             ; S
        DEFB    $5A             ; Z
        DEFB    $20             ; SPACE
        DEFB    $0D             ; ENTER
        DEFB    $50             ; P
        DEFB    $30             ; 0
        DEFB    $31             ; 1
        DEFB    $51             ; Q
        DEFB    $41             ; A


;; E-UNSHIFT
;  The 26 unshifted extended mode keys for the alphabetic characters.
;  The green keywords on the original keyboard.
o022C:  DEFB    $E3             ; READ
        DEFB    $C4             ; BIN
        DEFB    $E0             ; LPRINT
        DEFB    $E4             ; DATA
        DEFB    $B4             ; TAN
        DEFB    $BC             ; SGN
        DEFB    $BD             ; ABS
        DEFB    $BB             ; SQR
        DEFB    $AF             ; CODE
        DEFB    $B0             ; VAL
        DEFB    $B1             ; LEN
        DEFB    $C0             ; USR
        DEFB    $A7             ; PI
        DEFB    $A6             ; INKEY$
        DEFB    $BE             ; PEEK
        DEFB    $AD             ; TAB
        DEFB    $B2             ; SIN
        DEFB    $BA             ; INT
        DEFB    $E5             ; RESTORE
        DEFB    $A5             ; RND
        DEFB    $C2             ; CHR$
        DEFB    $E1             ; LLIST
        DEFB    $B3             ; COS
        DEFB    $B9             ; EXP
        DEFB    $C1             ; STR$
        DEFB    $B8             ; LN


;; EXT-SHIFT
;  The 26 shifted extended mode keys for the alphabetic characters.
;  The red keywords below keys on the original keyboard.
o0246:  DEFB    $7E             ; ~
        DEFB    $DC             ; BRIGHT
        DEFB    $DA             ; PAPER
        DEFB    $5C             ; \
        DEFB    $B7             ; ATN
        DEFB    $7B             ; {
        DEFB    $7D             ; }
        DEFB    $D8             ; CIRCLE
        DEFB    $BF             ; IN
        DEFB    $AE             ; VAL$
        DEFB    $AA             ; SCREEN$
        DEFB    $AB             ; ATTR
        DEFB    $DD             ; INVERSE
        DEFB    $DE             ; OVER
        DEFB    $DF             ; OUT
        DEFB    $7F             ; (Copyright character)
        DEFB    $B5             ; ASN
        DEFB    $D6             ; VERIFY
        DEFB    $7C             ; |
        DEFB    $D5             ; MERGE
        DEFB    $5D             ; ]
        DEFB    $DB             ; FLASH
        DEFB    $B6             ; ACS
        DEFB    $D9             ; INK
        DEFB    $5B             ; [
        DEFB    $D7             ; BEEP


;; CTL-CODES
;  The ten control codes assigned to the top line of digits when the shift
;  key is pressed.
o0260:  DEFB    $0C             ; DELETE
        DEFB    $07             ; EDIT
        DEFB    $06             ; CAPS LOCK
        DEFB    $04             ; TRUE VIDEO
        DEFB    $05             ; INVERSE VIDEO
        DEFB    $08             ; CURSOR LEFT
        DEFB    $0A             ; CURSOR DOWN
        DEFB    $0B             ; CURSOR UP
        DEFB    $09             ; CURSOR RIGHT
        DEFB    $0F             ; GRAPHICS


;; SYM-CODES
;  The 26 red symbols assigned to the alphabetic characters of the keyboard.
;  The ten single-character digit symbols are converted without the aid of
;  a table using subtraction and minor manipulation.
o026A:  DEFB    $E2             ; STOP
        DEFB    $2A             ; *
        DEFB    $3F             ; ?
        DEFB    $CD             ; STEP
        DEFB    $C8             ; >=
        DEFB    $CC             ; TO
        DEFB    $CB             ; THEN
        DEFB    $5E             ; ^
        DEFB    $AC             ; AT
        DEFB    $2D             ; -
        DEFB    $2B             ; +
        DEFB    $3D             ; =
        DEFB    $2E             ; .
        DEFB    $2C             ; ,
        DEFB    $3B             ; ;
        DEFB    $22             ; "
        DEFB    $C7             ; <=
        DEFB    $3C             ; <
        DEFB    $C3             ; NOT
        DEFB    $3E             ; >
        DEFB    $C5             ; OR
        DEFB    $2F             ; /
        DEFB    $C9             ; <>
        DEFB    $60             ; pound
        DEFB    $C6             ; AND
        DEFB    $3A             ; :

;; E-DIGITS
;  The ten keywords assigned to the digits in extended mode.
;  The remaining red keywords below the keys.
o0284:  DEFB    $D0             ; FORMAT
        DEFB    $CE             ; DEF FN
        DEFB    $A8             ; FN
        DEFB    $CA             ; LINE
        DEFB    $D3             ; OPEN #
        DEFB    $D4             ; CLOSE #
        DEFB    $D1             ; MOVE
        DEFB    $D2             ; ERASE
        DEFB    $A9             ; POINT
        DEFB    $CF             ; CAT


;*******************************
;** Part 2. KEYBOARD ROUTINES **
;*******************************

;   Using shift keys and a combination of modes the Spectrum 40-key keyboard
;   can be mapped to 256 input characters

; ---------------------------------------------------------------------------
;
;         0     1     2     3     4 -Bits-  4     3     2     1     0
; PORT                                                                    PORT
;
; F7FE  [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]  |  [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 0 ]   EFFE
;  ^                                   |                                   v
; FBFE  [ Q ] [ W ] [ E ] [ R ] [ T ]  |  [ Y ] [ U ] [ I ] [ O ] [ P ]   DFFE
;  ^                                   |                                   v
; FDFE  [ A ] [ S ] [ D ] [ F ] [ G ]  |  [ H ] [ J ] [ K ] [ L ] [ ENT ] BFFE
;  ^                                   |                                   v
; FEFE  [SHI] [ Z ] [ X ] [ C ] [ V ]  |  [ B ] [ N ] [ M ] [sym] [ SPC ] 7FFE
;  ^     $27                                                 $18           v
; Start                                                                   End
;        00100111                                            00011000
;
; ---------------------------------------------------------------------------
;   The above map may help in reading.
;   The neat arrangement of ports means that the B register need only be
;   rotated left to work up the left hand side and then down the right
;   hand side of the keyboard. When the reset bit drops into the carry
;   then all 8 half-rows have been read. Shift is the first key to be
;   read. The lower six bits of the shifts are unambiguous.

; -------------------------------
; THE 'KEYBOARD SCANNING' ROUTINE
; -------------------------------
;   From keyboard and s-inkey$
;   Returns 1 or 2 keys in DE, most significant shift first if any
;   key values 0-39 else 255

;; KEY-SCAN
o028E:  LD      L,$2F           ; initial key value
                                ; valid values are obtained by subtracting
                                ; eight five times.
        LD      DE,$FFFF        ; a buffer to receive 2 keys.

        LD      BC,$FEFE        ; the commencing port address
                                ; B holds 11111110 initially and is also
                                ; used to count the 8 half-rows
;; KEY-LINE
o0296:  IN      A,(C)           ; read the port to A - bits will be reset
                                ; if a key is pressed else set.
        CPL                     ; complement - pressed key-bits are now set
        AND     $1F             ; apply 00011111 mask to pick up the
                                ; relevant set bits.

        JR      Z,o02AB         ; forward to KEY-DONE if zero and therefore
                                ; no keys pressed in row at all.

        LD      H,A             ; transfer row bits to H
        LD      A,L             ; load the initial key value to A

;; KEY-3KEYS
o029F:  INC     D               ; now test the key buffer
        RET     NZ              ; if we have collected 2 keys already
                                ; then too many so quit.

;; KEY-BITS
o02A1:  SUB     $08             ; subtract 8 from the key value
                                ; cycling through key values (top = $27)
                                ; e.g. 2F>   27>1F>17>0F>07
                                ;      2E>   26>1E>16>0E>06
        SRL     H               ; shift key bits right into carry.
        JR      NC,o02A1        ; back to KEY-BITS if not pressed
                                ; but if pressed we have a value (0-39d)

        LD      D,E             ; transfer a possible previous key to D
        LD      E,A             ; transfer the new key to E
        JR      NZ,o029F        ; back to KEY-3KEYS if there were more
                                ; set bits - H was not yet zero.

;; KEY-DONE
o02AB:  DEC     L               ; cycles 2F>2E>2D>2C>2B>2A>29>28 for
                                ; each half-row.
        RLC     B               ; form next port address e.g. FEFE > FDFE
        JR      C,o0296         ; back to KEY-LINE if still more rows to do.

        LD      A,D             ; now test if D is still FF ?
        INC     A               ; if it is zero we have at most 1 key
                                ; range now $01-$28  (1-40d)
        RET     Z               ; return if one key or no key.

        CP      $28             ; is it capsshift (was $27) ?
        RET     Z               ; return if so.

        CP      $19             ; is it symbol shift (was $18) ?
        RET     Z               ; return also

        LD      A,E             ; now test E
        LD      E,D             ; but first switch
        LD      D,A             ; the two keys.
        CP      $18             ; is it symbol shift ?
        RET                     ; return (with zero set if it was).
                                ; but with symbol shift now in D

; ----------------------
; THE 'KEYBOARD' ROUTINE
; ----------------------
;   Called from the interrupt 50 times a second.
;

;; KEYBOARD
o02BF:  CALL    o028E           ; routine KEY-SCAN
        RET     NZ              ; return if invalid combinations

;   then decrease the counters within the two key-state maps
;   as this could cause one to become free.
;   if the keyboard has not been pressed during the last five interrupts
;   then both sets will be free.


        LD      HL,$5C00        ; point to KSTATE-0

;; K-ST-LOOP
o02C6:  BIT     7,(HL)          ; is it free ?  (i.e. $FF)
        JR      NZ,o02D1        ; forward to K-CH-SET if so

        INC     HL              ; address the 5-counter
        DEC     (HL)            ; decrease the counter
        DEC     HL              ; step back

        JR      NZ,o02D1        ; forward to K-CH-SET if not at end of count

        LD      (HL),$FF        ; else mark this particular map free.

;; K-CH-SET
o02D1:  LD      A,L             ; make a copy of the low address byte.
        LD      HL,$5C04        ; point to KSTATE-4
                                ; (ld l,$04 would do)
        CP      L               ; have both sets been considered ?
        JR      NZ,o02C6        ; back to K-ST-LOOP to consider this 2nd set

;   now the raw key (0-38d) is converted to a main key (uppercase).

        CALL    o031E           ; routine K-TEST to get main key in A

        RET     NC              ; return if just a single shift

        LD      HL,$5C00        ; point to KSTATE-0
        CP      (HL)            ; does the main key code match ?
        JR      Z,o0310         ; forward to K-REPEAT if so

;   if not consider the second key map.

        EX      DE,HL           ; save kstate-0 in de
        LD      HL,$5C04        ; point to KSTATE-4
        CP      (HL)            ; does the main key code match ?
        JR      Z,o0310         ; forward to K-REPEAT if so

;   having excluded a repeating key we can now consider a new key.
;   the second set is always examined before the first.

        BIT     7,(HL)          ; is the key map free ?
        JR      NZ,o02F1        ; forward to K-NEW if so.

        EX      DE,HL           ; bring back KSTATE-0
        BIT     7,(HL)          ; is it free ?
        RET     Z               ; return if not.
                                ; as we have a key but nowhere to put it yet.

;   continue or jump to here if one of the buffers was free.

;; K-NEW
o02F1:  LD      E,A             ; store key in E
        LD      (HL),A          ; place in free location
        INC     HL              ; advance to the interrupt counter
        LD      (HL),$05        ; and initialize counter to 5
        INC     HL              ; advance to the delay
        LD      A,($5C09)       ; pick up the system variable REPDEL
        LD      (HL),A          ; and insert that for first repeat delay.
        INC     HL              ; advance to last location of state map.

        LD      C,(IY+$07)      ; pick up MODE  (3 bytes)
        LD      D,(IY+$01)      ; pick up FLAGS (3 bytes)
        PUSH    HL              ; save state map location
                                ; Note. could now have used, to avoid IY,
                                ; ld l,$41; ld c,(hl); ld l,$3B; ld d,(hl).
                                ; six and two threes of course.

        CALL    o0333           ; routine K-DECODE

        POP     HL              ; restore map pointer
        LD      (HL),A          ; put the decoded key in last location of map.

;; K-END
o0308:  LD      ($5C08),A       ; update LASTK system variable.
        SET     5,(IY+$01)      ; update FLAGS  - signal a new key.
        RET                     ; return to interrupt routine.

; -----------------------
; THE 'REPEAT KEY' BRANCH
; -----------------------
;   A possible repeat has been identified. HL addresses the raw key.
;   The last location of the key map holds the decoded key from the first
;   context.  This could be a keyword and, with the exception of NOT a repeat
;   is syntactically incorrect and not really desirable.

;; K-REPEAT
o0310:  INC     HL              ; increment the map pointer to second location.
        LD      (HL),$05        ; maintain interrupt counter at 5.
        INC     HL              ; now point to third location.
        DEC     (HL)            ; decrease the REPDEL value which is used to
                                ; time the delay of a repeat key.

        RET     NZ              ; return if not yet zero.

        LD      A,($5C0A)       ; fetch the system variable value REPPER.
        LD      (HL),A          ; for subsequent repeats REPPER will be used.

        INC     HL              ; advance
                                ;
        LD      A,(HL)          ; pick up the key decoded possibly in another
                                ; context.
                                ; Note. should compare with $A5 (RND) and make
                                ; a simple return if this is a keyword.
                                ; e.g. cp $a5; ret nc; (3 extra bytes)
        JR      o0308           ; back to K-END

; ----------------------
; THE 'KEY-TEST' ROUTINE
; ----------------------
;   also called from s-inkey$
;   begin by testing for a shift with no other.

;; K-TEST
o031E:  LD      B,D             ; load most significant key to B
                                ; will be $FF if not shift.
        LD      D,$00           ; and reset D to index into main table
        LD      A,E             ; load least significant key from E
        CP      $27             ; is it higher than 39d   i.e. FF
        RET     NC              ; return with just a shift (in B now)

        CP      $18             ; is it symbol shift ?
        JR      NZ,o032C        ; forward to K-MAIN if not

;   but we could have just symbol shift and no other

        BIT     7,B             ; is other key $FF (ie not shift)
        RET     NZ              ; return with solitary symbol shift


;; K-MAIN
o032C:  LD      HL,o0205        ; address: MAIN-KEYS
        ADD     HL,DE           ; add offset 0-38
        LD      A,(HL)          ; pick up main key value
        SCF                     ; set carry flag
        RET                     ; return    (B has other key still)

; ----------------------------------
; THE 'KEYBOARD DECODING' SUBROUTINE
; ----------------------------------
;   also called from s-inkey$

;; K-DECODE
o0333:  LD      A,E             ; pick up the stored main key
        CP      $3A             ; an arbitrary point between digits and letters
        JR      C,o0367         ; forward to K-DIGIT with digits, space, enter.

        DEC     C               ; decrease MODE ( 0='KLC', 1='E', 2='G')

        JP      M,o034F         ; to K-KLC-LET if was zero

        JR      Z,o0341         ; to K-E-LET if was 1 for extended letters.

;   proceed with graphic codes.
;   Note. should selectively drop return address if code > 'U' ($55).
;   i.e. abort the KEYBOARD call.
;   e.g. cp 'V'; jr c,addit; pop af ;pop af ;;addit etc. (6 extra bytes).
;   (s-inkey$ never gets into graphics mode.)

;; addit
        ADD     A,$4F           ; add offset to augment 'A' to graphics A say.
        RET                     ; return.
                                ; Note. ( but [GRAPH] V gives RND, etc ).

; ---

;   the jump was to here with extended mode with uppercase A-Z.

;; K-E-LET
o0341:  LD      HL,o022C-$41    ; base address of E-UNSHIFT o022c.
                                ; ( $01EB in standard ROM ).
        INC     B               ; test B is it empty i.e. not a shift.
        JR      Z,o034A         ; forward to K-LOOK-UP if neither shift.

        LD      HL,o0246-$41    ; Address: $0205 o0246-$41 EXT-SHIFT base

;; K-LOOK-UP
o034A:  LD      D,$00           ; prepare to index.
        ADD     HL,DE           ; add the main key value.
        LD      A,(HL)          ; pick up other mode value.
        RET                     ; return.

; ---

;   the jump was here with mode = 0

;; K-KLC-LET
o034F:  LD      HL,o026A-$41    ; prepare base of sym-codes
        BIT     0,B             ; shift=$27 sym-shift=$18
        JR      Z,o034A         ; back to K-LOOK-UP with symbol-shift

        BIT     3,D             ; test FLAGS is it 'K' mode (from OUT-CURS)
        JR      Z,o0364         ; skip to K-TOKENS if so

        BIT     3,(IY+$30)      ; test FLAGS2 - consider CAPS LOCK ?
        RET     NZ              ; return if so with main code.

        INC     B               ; is shift being pressed ?
                                ; result zero if not
        RET     NZ              ; return if shift pressed.

        ADD     A,$20           ; else convert the code to lower case.
        RET                     ; return.

; ---

;   the jump was here for tokens

;; K-TOKENS
o0364:  ADD     A,$A5           ; add offset to main code so that 'A'
                                ; becomes 'NEW' etc.

        RET                     ; return.

; ---

;   the jump was here with digits, space, enter and symbol shift (< $xx)

;; K-DIGIT
o0367:  CP      $30             ; is it '0' or higher ?
        RET     C               ; return with space, enter and symbol-shift

        DEC     C               ; test MODE (was 0='KLC', 1='E', 2='G')
        JP      M,o039D         ; jump to K-KLC-DGT if was 0.

        JR      NZ,o0389        ; forward to K-GRA-DGT if mode was 2.

;   continue with extended digits 0-9.

        LD      HL,o0284-$30    ; $0254 - base of E-DIGITS
        BIT     5,B             ; test - shift=$27 sym-shift=$18
        JR      Z,o034A         ; to K-LOOK-UP if sym-shift

        CP      $38             ; is character '8' ?
        JR      NC,o0382        ; to K-8-&-9 if greater than '7'

        SUB     $20             ; reduce to ink range $10-$17
        INC     B               ; shift ?
        RET     Z               ; return if not.

        ADD     A,$08           ; add 8 to give paper range $18 - $1F
        RET                     ; return

; ---

;   89

;; K-8-&-9
o0382:  SUB     $36             ; reduce to 02 and 03  bright codes
        INC     B               ; test if shift pressed.
        RET     Z               ; return if not.

        ADD     A,$FE           ; subtract 2 setting carry
        RET                     ; to give 0 and 1    flash codes.

; ---

;   graphics mode with digits

;; K-GRA-DGT
o0389:  LD      HL,o0260-$30    ; $0230 base address of CTL-CODES

        CP      $39             ; is key '9' ?
        JR      Z,o034A         ; back to K-LOOK-UP - changed to $0F, GRAPHICS.

        CP      $30             ; is key '0' ?
        JR      Z,o034A         ; back to K-LOOK-UP - changed to $0C, delete.

;   for keys '0' - '7' we assign a mosaic character depending on shift.

        AND     $07             ; convert character to number. 0 - 7.
        ADD     A,$80           ; add offset - they start at $80

        INC     B               ; destructively test for shift
        RET     Z               ; and return if not pressed.

        XOR     $0F             ; toggle bits becomes range $88-$8F
        RET                     ; return.

; ---

;   now digits in 'KLC' mode

;; K-KLC-DGT
o039D:  INC     B               ; return with digit codes if neither
        RET     Z               ; shift key pressed.

        BIT     5,B             ; test for caps shift.

        LD      HL,o0260-$30    ; prepare base of table CTL-CODES.
        JR      NZ,o034A        ; back to K-LOOK-UP if shift pressed.

;   must have been symbol shift

        SUB     $10             ; for ASCII most will now be correct
                                ; on a standard typewriter.

        CP      $22             ; but '@' is not - see below.
        JR      Z,o03B2         ; forward to K-@-CHAR if so

        CP      $20             ; '_' is the other one that fails
        RET     NZ              ; return if not.

        LD      A,$5F           ; substitute ASCII '_'
        RET                     ; return.

; ---

;; K-@-CHAR
o03B2:  LD      A,$40           ; substitute ASCII '@'
        RET                     ; return.


; ------------------------------------------------------------------------
;   The Spectrum Input character keys. One or two are abbreviated.
;   From $00 Flash 0 to $FF COPY. The routine above has decoded all these.

;  | 00 Fl0| 01 Fl1| 02 Br0| 03 Br1| 04 In0| 05 In1| 06 CAP| 07 EDT|
;  | 08 LFT| 09 RIG| 0A DWN| 0B UP | 0C DEL| 0D ENT| 0E SYM| 0F GRA|
;  | 10 Ik0| 11 Ik1| 12 Ik2| 13 Ik3| 14 Ik4| 15 Ik5| 16 Ik6| 17 Ik7|
;  | 18 Pa0| 19 Pa1| 1A Pa2| 1B Pa3| 1C Pa4| 1D Pa5| 1E Pa6| 1F Pa7|
;  | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
;  | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
;  | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
;  | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
;  | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
;  | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
;  | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
;  | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
;  | 60  Â£ | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
;  | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
;  | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
;  | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F  Â© |
;  | 80 128| 81 129| 82 130| 83 131| 84 132| 85 133| 86 134| 87 135|
;  | 88 136| 89 137| 8A 138| 8B 139| 8C 140| 8D 141| 8E 142| 8F 143|
;  | 90 [A]| 91 [B]| 92 [C]| 93 [D]| 94 [E]| 95 [F]| 96 [G]| 97 [H]|
;  | 98 [I]| 99 [J]| 9A [K]| 9B [L]| 9C [M]| 9D [N]| 9E [O]| 9F [P]|
;  | A0 [Q]| A1 [R]| A2 [S]| A3 [T]| A4 [U]| A5 RND| A6 IK$| A7 PI |
;  | A8 FN | A9 PNT| AA SC$| AB ATT| AC AT | AD TAB| AE VL$| AF COD|
;  | B0 VAL| B1 LEN| B2 SIN| B3 COS| B4 TAN| B5 ASN| B6 ACS| B7 ATN|
;  | B8 LN | B9 EXP| BA INT| BB SQR| BC SGN| BD ABS| BE PEK| BF IN |
;  | C0 USR| C1 ST$| C2 CH$| C3 NOT| C4 BIN| C5 OR | C6 AND| C7 <= |
;  | C8 >= | C9 <> | CA LIN| CB THN| CC TO | CD STP| CE DEF| CF CAT|
;  | D0 FMT| D1 MOV| D2 ERS| D3 OPN| D4 CLO| D5 MRG| D6 VFY| D7 BEP|
;  | D8 CIR| D9 INK| DA PAP| DB FLA| DC BRI| DD INV| DE OVR| DF OUT|
;  | E0 LPR| E1 LLI| E2 STP| E3 REA| E4 DAT| E5 RES| E6 NEW| E7 BDR|
;  | E8 CON| E9 DIM| EA REM| EB FOR| EC GTO| ED GSB| EE INP| EF LOA|
;  | F0 LIS| F1 LET| F2 PAU| F3 NXT| F4 POK| F5 PRI| F6 PLO| F7 RUN|
;  | F8 SAV| F9 RAN| FA IF | FB CLS| FC DRW| FD CLR| FE RET| FF CPY|

;   Note that for simplicity, Sinclair have located all the control codes
;   below the space character.
;   ASCII DEL, $7F, has been made a copyright symbol.
;   Also $60, '`', not used in BASIC but used in other languages, has been
;   allocated the local currency symbol for the relevant country -
;    Â£  in most Spectrums.

; ------------------------------------------------------------------------


;**********************************
;** Part 3. LOUDSPEAKER ROUTINES **
;**********************************

; Documented by Alvin Albrecht.

; ------------------------------
; Routine to control loudspeaker
; ------------------------------
; Outputs a square wave of given duration and frequency
; to the loudspeaker.
;   Enter with: DE = #cycles - 1
;               HL = tone period as described next
;
; The tone period is measured in T states and consists of
; three parts: a coarse part (H register), a medium part
; (bits 7..2 of L) and a fine part (bits 1..0 of L) which
; contribute to the waveform timing as follows:
;
;                          coarse    medium       fine
; duration of low  = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
; duration of hi   = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
; Tp = tone period = 236 + 2048*H + 32*(L>>2) + 8*(L&0x3)
;                  = 236 + 2048*H + 8*L = 236 + 8*HL
;
; As an example, to output five seconds of middle C (261.624 Hz):
;   (a) Tone period = 1/261.624 = 3.822ms
;   (b) Tone period in T-States = 3.822ms*fCPU = 13378
;         where fCPU = clock frequency of the CPU = 3.5MHz
;    Â©  Find H and L for desired tone period:
;         HL = (Tp - 236) / 8 = (13378 - 236) / 8 = 1643 = 0x066B
;   (d) Tone duration in cycles = 5s/3.822ms = 1308 cycles
;         DE = 1308 - 1 = 0x051B
;
; The resulting waveform has a duty ratio of exactly 50%.
;
;
;; BEEPER
o03B5:  DI                      ; Disable Interrupts so they don't disturb timing
        LD      A,L             ;
        SRL     L               ;
        SRL     L               ; L = medium part of tone period
        CPL                     ;
        AND     $03             ; A = 3 - fine part of tone period
        LD      C,A             ;
        LD      B,$00           ;
        LD      IX,o03D1        ; Address: BE-IX+3
        ADD     IX,BC           ;   IX holds address of entry into the loop
                                ;   the loop will contain 0-3 NOPs, implementing
                                ;   the fine part of the tone period.
        LD      A,(BORDCR)      ; BORDCR
        AND     $38             ; bits 5..3 contain border colour
        RRCA                    ; border colour bits moved to 2..0
        RRCA                    ;   to match border bits on port #FE
        RRCA                    ;
        OR       $08            ; bit 3 set (tape output bit on port #FE)
                                ;   for loud sound output
;; BE-IX+3
o03D1:  NOP              ;(4)   ; optionally executed NOPs for small
                                ;   adjustments to tone period
;; BE-IX+2
o03D2:  NOP              ;(4)   ;

;; BE-IX+1
o03D3:  NOP              ;(4)   ;

;; BE-IX+0
o03D4:  INC     B        ;(4)   ;
        INC     C        ;(4)   ;

;; BE-H&L-LP
o03D6:  DEC     C        ;(4)   ; timing loop for duration of
        JR      NZ,o03D6 ;(12/7);   high or low pulse of waveform

        LD      C,$3F    ;(7)   ;
        DEC     B        ;(4)   ;
        JP      NZ,o03D6 ;(10)  ; to BE-H&L-LP

        XOR     $10      ;(7)   ; toggle output beep bit
        OUT     ($FE),A  ;(11)  ; output pulse
        LD      B,H      ;(4)   ; B = coarse part of tone period
        LD      C,A      ;(4)   ; save port #FE output byte
        BIT     4,A      ;(8)   ; if new output bit is high, go
        JR      NZ,o03F2 ;(12/7);   to BE-AGAIN

        LD      A,D      ;(4)   ; one cycle of waveform has completed
        OR      E        ;(4)   ;   (low->low). if cycle countdown = 0
        JR      Z,o03F6  ;(12/7);   go to BE-END

        LD      A,C      ;(4)   ; restore output byte for port #FE
        LD      C,L      ;(4)   ; C = medium part of tone period
        DEC     DE       ;(6)   ; decrement cycle count
        JP      (IX)     ;(8)   ; do another cycle

;; BE-AGAIN                     ; halfway through cycle
o03F2:  LD      C,L      ;(4)   ; C = medium part of tone period
        INC     C        ;(4)   ; adds 16 cycles to make duration of high = duration of low
        JP      (IX)     ;(8)   ; do high pulse of tone

;; BE-END
o03F6:  EI                      ; Enable Interrupts
        RET                     ;


; ------------------
; THE 'BEEP' COMMAND
; ------------------
; BASIC interface to BEEPER subroutine.
; Invoked in BASIC with:
;   BEEP dur, pitch
;   where dur   = duration in seconds
;         pitch = # of semitones above/below middle C
;
; Enter with: pitch on top of calculator stack
;             duration next on calculator stack
;
;; beep
o03F8:  RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate                  ; duplicate pitch
        DEFB    $27             ;;int                        ; convert to integer
        DEFB    $C0             ;;st-mem-0                   ; store integer pitch to memory 0
        DEFB    $03             ;;subtract                   ; calculate fractional part of pitch = fp_pitch - int_pitch
        DEFB    $34             ;;stk-data                   ; push constant
        DEFB    $EC             ;;Exponent: $7C, Bytes: 4    ; constant = 0.05762265
        DEFB    $6C,$98,$1F,$F5 ;;($6C,$98,$1F,$F5)
        DEFB    $04             ;;multiply                   ; compute:
        DEFB    $A1             ;;stk-one                    ; 1 + 0.05762265 * fraction_part(pitch)
        DEFB    $0F             ;;addition
        DEFB    $38             ;;end-calc                   ; leave on calc stack

        LD      HL,$5C92        ; MEM-0: number stored here is in 16 bit integer format (pitch)
                                ;   0, 0/FF (pos/neg), LSB, MSB, 0
                                ;   LSB/MSB is stored in two's complement
                                ; In the following, the pitch is checked if it is in the range -128<=p<=127
        LD      A,(HL)          ; First byte must be zero, otherwise
        AND     A               ;   error in integer conversion
        JR      NZ,o046C        ; to REPORT-B

        INC     HL              ;
        LD      C,(HL)          ; C = pos/neg flag = 0/FF
        INC     HL              ;
        LD      B,(HL)          ; B = LSB, two's complement
        LD      A,B             ;
        RLA                     ;
        SBC     A,A             ; A = 0/FF if B is pos/neg
        CP      C               ; must be the same as C if the pitch is -128<=p<=127
        JR      NZ,o046C        ; if no, error REPORT-B

        INC     HL              ; if -128<=p<=127, MSB will be 0/FF if B is pos/neg
        CP      (HL)            ; verify this
        JR      NZ,o046C        ; if no, error REPORT-B
                                ; now we know -128<=p<=127
        LD      A,B             ; A = pitch + 60
        ADD     A,$3C           ; if -60<=pitch<=67,
        JP      P,o0425         ;   goto BE-i-OK

        JP      PO,o046C        ; if pitch <= 67 goto REPORT-B
                                ;   lower bound of pitch set at -60

;; BE-I-OK                      ; here, -60<=pitch<=127
                                ; and A=pitch+60 -> 0<=A<=187

o0425:  LD      B,$FA           ; 6 octaves below middle C

;; BE-OCTAVE                    ; A=# semitones above 5 octaves below middle C
o0427:  INC     B               ; increment octave
        SUB     $0C             ; 12 semitones = one octave
        JR      NC,o0427        ; to BE-OCTAVE

        ADD     A,$0C           ; A = # semitones above C (0-11)
        PUSH    BC              ; B = octave displacement from middle C, 2's complement: -5<=B<=10
        LD      HL,o046E        ; Address: semi-tone
        CALL    o3406           ; routine LOC-MEM
                                ;   HL = 5*A + $046E
        CALL    o33B4           ; routine STACK-NUM
                                ;   read FP value (freq) from semitone table (HL) and push onto calc stack

        RST     28H             ;; FP-CALC
        DEFB    $04             ;;multiply   mult freq by 1 + 0.0576 * fraction_part(pitch) stacked earlier
                                ;;             thus taking into account fractional part of pitch.
                                ;;           the number 0.0576*frequency is the distance in Hz to the next
                                ;;             note (verify with the frequencies recorded in the semitone
                                ;;             table below) so that the fraction_part of the pitch does
                                ;;             indeed represent a fractional distance to the next note.
        DEFB    $38             ;;end-calc   HL points to first byte of fp num on stack = middle frequency to generate

        POP     AF              ; A = octave displacement from middle C, 2's complement: -5<=A<=10
        ADD     A,(HL)          ; increase exponent by A (equivalent to multiplying by 2^A)
        LD      (HL),A          ;

        RST     28H             ;; FP-CALC
        DEFB    $C0             ;;st-mem-0          ; store frequency in memory 0
        DEFB    $02             ;;delete            ; remove from calc stack
        DEFB    $31             ;;duplicate         ; duplicate duration (seconds)
        DEFB    $38             ;;end-calc

        CALL    o1E94           ; routine FIND-INT1 ; FP duration to A
        CP      $0B             ; if dur > 10 seconds,
        JR      NC,o046C        ;   goto REPORT-B

        ;;; The following calculation finds the tone period for HL and the cycle count
        ;;; for DE expected in the BEEPER subroutine.  From the example in the BEEPER comments,
        ;;;
        ;;; HL = ((fCPU / f) - 236) / 8 = fCPU/8/f - 236/8 = 437500/f -29.5
        ;;; DE = duration * frequency - 1
        ;;;
        ;;; Note the different constant (30.125) used in the calculation of HL
        ;;; below.  This is probably an error.

        RST     28H             ;; FP-CALC
        DEFB    $E0             ;;get-mem-0                 ; push frequency
        DEFB    $04             ;;multiply                  ; result1: #cycles = duration * frequency
        DEFB    $E0             ;;get-mem-0                 ; push frequency
        DEFB    $34             ;;stk-data                  ; push constant
        DEFB    $80             ;;Exponent $93, Bytes: 3    ; constant = 437500
        DEFB    $43,$55,$9F,$80 ;;($55,$9F,$80,$00)
        DEFB    $01             ;;exchange                  ; frequency on top
        DEFB    $05             ;;division                  ; 437500 / frequency
        DEFB    $34             ;;stk-data                  ; push constant
        DEFB    $35             ;;Exponent: $85, Bytes: 1   ; constant = 30.125
        DEFB    $71             ;;($71,$00,$00,$00)
        DEFB    $03             ;;subtract                  ; result2: tone_period(HL) = 437500 / freq - 30.125
        DEFB    $38             ;;end-calc

        CALL    o1E99           ; routine FIND-INT2
        PUSH    BC              ;   BC = tone_period(HL)
        CALL    o1E99           ; routine FIND-INT2, BC = #cycles to generate
        POP     HL              ; HL = tone period
        LD      D,B             ;
        LD      E,C             ; DE = #cycles
        LD      A,D             ;
        OR      E               ;
        RET     Z               ; if duration = 0, skip BEEP and avoid 65536 cycle
                                ;   boondoggle that would occur next
        DEC     DE              ; DE = #cycles - 1
        JP      o03B5           ; to BEEPER

; ---


;; REPORT-B
o046C:  RST     08H             ; ERROR-1
        DEFB    $0A             ; Error Report: Integer out of range



; ---------------------
; THE 'SEMI-TONE' TABLE
; ---------------------
;
;   Holds frequencies corresponding to semitones in middle octave.
;   To move n octaves higher or lower, frequencies are multiplied by 2^n.

;; semi-tone         five byte fp         decimal freq     note (middle)
o046E:  DEFB    $89, $02, $D0, $12, $86;  261.625565290         C
        DEFB    $89, $0A, $97, $60, $75;  277.182631135         C#
        DEFB    $89, $12, $D5, $17, $1F;  293.664768100         D
        DEFB    $89, $1B, $90, $41, $02;  311.126983881         D#
        DEFB    $89, $24, $D0, $53, $CA;  329.627557039         E
        DEFB    $89, $2E, $9D, $36, $B1;  349.228231549         F
        DEFB    $89, $38, $FF, $49, $3E;  369.994422674         F#
        DEFB    $89, $43, $FF, $6A, $73;  391.995436072         G
        DEFB    $89, $4F, $A7, $00, $54;  415.304697513         G#
        DEFB    $89, $5C, $00, $00, $00;  440.000000000         A
        DEFB    $89, $69, $14, $F6, $24;  466.163761616         A#
        DEFB    $89, $76, $F1, $10, $05;  493.883301378         B


;   "Music is the hidden mathematical endeavour of a soul unconscious it
;    is calculating" - Gottfried Wilhelm Liebnitz 1646 - 1716


;****************************************
;** Part 4. CASSETTE HANDLING ROUTINES **
;****************************************

;   These routines begin with the service routines followed by a single
;   command entry point.
;   The first of these service routines is a curiosity.

; -----------------------
; THE 'ZX81 NAME' ROUTINE
; -----------------------
;   This routine fetches a filename in ZX81 format and is not used by the
;   cassette handling routines in this ROM.

;; zx81-name

o04AA:  CALL    o24FB           ; routine SCANNING to evaluate expression.
        LD      A,($5C3B)       ; fetch system variable FLAGS.
        ADD     A,A             ; test bit 7 - syntax, bit 6 - result type.
        JP      M,o1C8A         ; to REPORT-C if not string result
                                ; 'Nonsense in BASIC'.

        POP     HL              ; drop return address.
        RET     NC              ; return early if checking syntax.

        PUSH    HL              ; re-save return address.
        CALL    o2BF1           ; routine STK-FETCH fetches string parameters.
        LD      H,D             ; transfer start of filename
        LD      L,E             ; to the HL register.
        DEC     C               ; adjust to point to last character and
        RET     M               ; return if the null string.
                                ; or multiple of 256!

        ADD     HL,BC           ; find last character of the filename.
                                ; and also clear carry.
        SET     7,(HL)          ; invert it.
        RET                     ; return.

; =========================================
;
; PORT 254 ($FE)
;
;                      spk mic { border  }
;          ___ ___ ___ ___ ___ ___ ___ ___
; PORT    |   |   |   |   |   |   |   |   |
; 254     |   |   |   |   |   |   |   |   |
; $FE     |___|___|___|___|___|___|___|___|
;           7   6   5   4   3   2   1   0
;

; ----------------------------------
; Save header and program/data bytes
; ----------------------------------
;   This routine saves a section of data. It is called from SA-CTRL to save the
;   seventeen bytes of header data. It is also the exit route from that routine
;   when it is set up to save the actual data.
;   On entry -
;   HL points to start of data.
;   IX points to descriptor.
;   The accumulator is set to  $00 for a header, $FF for data.

;; SA-BYTES
o04C2:  LD      HL,o053F        ; address: SA/LD-RET
        PUSH    HL              ; is pushed as common exit route.
                                ; however there is only one non-terminal exit
                                ; point.

o04C6:  LD      HL,$1F80        ; a timing constant H=$1F, L=$80
                                ; inner and outer loop counters
                                ; a five second lead-in is used for a header.

        BIT     7,A             ; test one bit of accumulator.
                                ; (AND A ?)
        JR      Z,o04D0         ; skip to SA-FLAG if a header is being saved.

;   else is data bytes and a shorter lead-in is used.

        LD      HL,$0C98        ; another timing value H=$0C, L=$98.
                                ; a two second lead-in is used for the data.


;; SA-FLAG
o04D0:  EX      AF,AF'          ; save flag
        INC     DE              ; increase length by one.
        DEC     IX              ; decrease start.

        DI                      ; disable interrupts

        LD      A,$02           ; select red for border, microphone bit on.
        LD      B,A             ; also does as an initial slight counter value.

;; SA-oEADER
o04D8:  DJNZ    o04D8           ; self loop to SA-oEADER for delay.
                                ; after initial loop, count is $A4 (or $A3)

        OUT     ($FE),A         ; output byte $02/$0D to tape port.

        XOR     $0F             ; switch from RED (mic on) to CYAN (mic off).

        LD      B,$A4           ; hold count. also timed instruction.

        DEC     L               ; originally $80 or $98.
                                ; but subsequently cycles 256 times.
        JR      NZ,o04D8        ; back to SA-oEADER until L is zero.

;   the outer loop is counted by H

        DEC     B               ; decrement count
        DEC     H               ; originally  twelve or thirty-one.
        JP      P,o04D8         ; back to SA-oEADER until H becomes $FF

;   now send a sync pulse. At this stage mic is off and A holds value
;   for mic on.
;   A sync pulse is much shorter than the steady pulses of the lead-in.

        LD      B,$2F           ; another short timed delay.

;; SA-SYNC-1
o04EA:  DJNZ    o04EA           ; self loop to SA-SYNC-1

        OUT     ($FE),A         ; switch to mic on and red.
        LD      A,$0D           ; prepare mic off - cyan
        LD      B,$37           ; another short timed delay.

;; SA-SYNC-2
o04F2:  DJNZ    o04F2           ; self loop to SA-SYNC-2

        OUT     ($FE),A         ; output mic off, cyan border.
        LD      BC,$3B0E        ; B=$3B time(*), C=$0E, YELLOW, MIC OFF.

;

        EX      AF,AF'          ; restore saved flag
                                ; which is 1st byte to be saved.

        LD      L,A             ; and transfer to L.
                                ; the initial parity is A, $FF or $00.
        JP      o0507           ; JUMP forward to SA-START     ->
                                ; the mid entry point of loop.

; -------------------------
;   During the save loop a parity byte is maintained in H.
;   the save loop begins by testing if reduced length is zero and if so
;   the final parity byte is saved reducing count to $FFFF.

;; SA-LOOP
o04FE:  LD      A,D             ; fetch high byte
        OR      E               ; test against low byte.
        JR      Z,o050E         ; forward to SA-PARITY if zero.

        LD      L,(IX+$00)      ; load currently addressed byte to L.

;; SA-LOOP-P
o0505:  LD      A,H             ; fetch parity byte.
        XOR     L               ; exclusive or with new byte.

; -> the mid entry point of loop.

;; SA-START
o0507:  LD      H,A             ; put parity byte in H.
        LD      A,$01           ; prepare blue, mic=on.
        SCF                     ; set carry flag ready to rotate in.
        JP      o0525           ; JUMP forward to SA-8-BITS            -8->

; ---

;; SA-PARITY
o050E:  LD      L,H             ; transfer the running parity byte to L and
        JR      o0505           ; back to SA-LOOP-P
                                ; to output that byte before quitting normally.

; ---

;   The entry point to save yellow part of bit.
;   A bit consists of a period with mic on and blue border followed by
;   a period of mic off with yellow border.
;   Note. since the DJNZ instruction does not affect flags, the zero flag is
;   used to indicate which of the two passes is in effect and the carry
;   maintains the state of the bit to be saved.

;; SA-BIT-2
o0511:  LD      A,C             ; fetch 'mic on and yellow' which is
                                ; held permanently in C.
        BIT     7,B             ; set the zero flag. B holds $3E.

;   The entry point to save 1 entire bit. For first bit B holds $3B(*).
;   Carry is set if saved bit is 1. zero is reset NZ on entry.

;; SA-BIT-1
o0514:  DJNZ    o0514           ; self loop for delay to SA-BIT-1

        JR      NC,o051C        ; forward to SA-OUT if bit is 0.

;   but if bit is 1 then the mic state is held for longer.

        LD      B,$42           ; set timed delay. (66 decimal)

;; SA-SET
o051A:  DJNZ    o051A           ; self loop to SA-SET
                                ; (roughly an extra 66*13 clock cycles)

;; SA-OUT
o051C:  OUT     ($FE),A         ; blue and mic on OR  yellow and mic off.

        LD      B,$3E           ; set up delay
        JR      NZ,o0511        ; back to SA-BIT-2 if zero reset NZ (first pass)

;   proceed when the blue and yellow bands have been output.

        DEC     B               ; change value $3E to $3D.
        XOR     A               ; clear carry flag (ready to rotate in).
        INC     A               ; reset zero flag i.e. NZ.

; -8->

;; SA-8-BITS
o0525:  RL      L               ; rotate left through carry
                                ; C<76543210<C
        JP      NZ,o0514        ; JUMP back to SA-BIT-1
                                ; until all 8 bits done.

;   when the initial set carry is passed out again then a byte is complete.

        DEC     DE              ; decrease length
        INC     IX              ; increase byte pointer
        LD      B,$31           ; set up timing.

        LD      A,$7F           ; test the space key and
        IN      A,($FE)         ; return to common exit (to restore border)
        RRA                     ; if a space is pressed
        RET     NC              ; return to SA/LD-RET.   - - >

;   now test if byte counter has reached $FFFF.

        LD      A,D             ; fetch high byte
        INC     A               ; increment.
        JP      NZ,o04FE        ; JUMP to SA-LOOP if more bytes.

        LD      B,$3B           ; a final delay.

;; SA-DELAY
o053C:  DJNZ    o053C           ; self loop to SA-DELAY

        RET                     ; return - - >

; ------------------------------
; THE 'SAVE/LOAD RETURN' ROUTINE
; ------------------------------
;   The address of this routine is pushed on the stack prior to any load/save
;   operation and it handles normal completion with the restoration of the
;   border and also abnormal termination when the break key, or to be more
;   precise the space key is pressed during a tape operation.
;
; - - >

;; SA/LD-RET
o053F:  PUSH    AF              ; preserve accumulator throughout.
        LD      A,(BORDCR)      ; fetch border colour from BORDCR.
        AND     $38             ; mask off paper bits.
        RRCA                    ; rotate
        RRCA                    ; to the
        RRCA                    ; range 0-7.

        OUT     ($FE),A         ; change the border colour.

        LD      A,$7F           ; read from port address $7FFE the
        IN      A,($FE)         ; row with the space key at outside.

        RRA                     ; test for space key pressed.
        EI                      ; enable interrupts
        JR      C,o0554         ; forward to SA/LD-END if not


;; REPORT-Da
o0552:  RST     08H             ; ERROR-1
        DEFB    $0C             ; Error Report: BREAK - CONT repeats

; ---

;; SA/LD-END
o0554:  POP     AF              ; restore the accumulator.
        RET                     ; return.

; ------------------------------------
; Load header or block of information
; ------------------------------------
;   This routine is used to load bytes and on entry A is set to $00 for a
;   header or to $FF for data.  IX points to the start of receiving location
;   and DE holds the length of bytes to be loaded. If, on entry the carry flag
;   is set then data is loaded, if reset then it is verified.

;; LD-BYTES
o0556:  INC     D               ; reset the zero flag without disturbing carry.
        EX      AF,AF'          ; preserve entry flags.
        DEC     D               ; restore high byte of length.

        DI                      ; disable interrupts

        LD      A,$0F           ; make the border white and mic off.
        OUT     ($FE),A         ; output to port.

        LD      HL,o053F        ; Address: SA/LD-RET
        PUSH    HL              ; is saved on stack as terminating routine.

;   the reading of the EAR bit (D6) will always be preceded by a test of the
;   space key (D0), so store the initial post-test state.
      IF zx_tap
        CALL    NEW_LOAD
CONT_LOAD:
      ELSE
        IN      A,($FE)         ; read the ear state - bit 6.
        RRA                     ; rotate to bit 5.
      ENDIF
        
        AND     $20             ; isolate this bit.
        OR      $02             ; combine with red border colour.
        LD      C,A             ; and store initial state long-term in C.
        CP      A               ; set the zero flag.

;

;; LD-BREAK
o056B:  RET     NZ              ; return if at any time space is pressed.

;; LD-START
o056C:  CALL    o05E7           ; routine LD-EDGE-1
        JR      NC,o056B        ; back to LD-BREAK with time out and no
                                ; edge present on tape.

;   but continue when a transition is found on tape.

        LD      HL,$0415        ; set up 16-bit outer loop counter for
                                ; approx 1 second delay.

;; LD-WAIT
o0574:  DJNZ    o0574           ; self loop to LD-WAIT (for 256 times)

        DEC     HL              ; decrease outer loop counter.
        LD      A,H             ; test for
        OR      L               ; zero.
        JR      NZ,o0574        ; back to LD-WAIT, if not zero, with zero in B.

;   continue after delay with H holding zero and B also.
;   sample 256 edges to check that we are in the middle of a lead-in section.

        CALL    o05E3           ; routine LD-EDGE-2
        JR      NC,o056B        ; back to LD-BREAK
                                ; if no edges at all.

;; LD-oEADER
o0580:  LD      B,$9C           ; two edges must be spaced apart.
        CALL    o05E3           ; routine LD-EDGE-2
        JR      NC,o056B        ; back to LD-BREAK if time-out

        LD      A,$C6           ; two edges must be spaced apart.
        CP      B               ; compare
        JR      NC,o056C        ; back to LD-START if too close together for a
                                ; lead-in.

        INC     H               ; proceed to test 256 edged sample.
        JR      NZ,o0580        ; back to LD-oEADER while more to do.

;   sample indicates we are in the middle of a two or five second lead-in.
;   Now test every edge looking for the terminal sync signal.

;; LD-SYNC
o058F:  LD      B,$C9           ; two edges must be spaced apart.
        CALL    o05E7           ; routine LD-EDGE-1
        JR      NC,o056B        ; back to LD-BREAK with time-out.

        LD      A,B             ; fetch augmented timing value from B.
        CP      $D4             ; compare
        JR      NC,o058F        ; back to LD-SYNC if gap too big, that is,
                                ; a normal lead-in edge gap.

;   but a short gap will be the sync pulse.
;   in which case another edge should appear before B rises to $FF

        CALL    o05E7           ; routine LD-EDGE-1
        RET     NC              ; return with time-out.

; proceed when the sync at the end of the lead-in is found.
; We are about to load data so change the border colours.

        LD      A,C             ; fetch long-term mask from C
        XOR     $03             ; and make blue/yellow.

        LD      C,A             ; store the new long-term byte.

        LD      H,$00           ; set up parity byte as zero.
        LD      B,$B0           ; two edges must be spaced apart.
        JR      o05C8           ; forward to LD-MARKER
                                ; the loop mid entry point with the alternate
                                ; zero flag reset to indicate first byte
                                ; is discarded.

; --------------
;   the loading loop loads each byte and is entered at the mid point.

;; LD-LOOP
o05A9:  EX      AF,AF'          ; restore entry flags and type in A.
        JR      NZ,o05B3        ; forward to LD-FLAG if awaiting initial flag
                                ; which is to be discarded.

        JR      NC,o05BD        ; forward to LD-VERIFY if not to be loaded.

        LD      (IX+$00),L      ; place loaded byte at memory location.
        JR      o05C2           ; forward to LD-NEXT

; ---

;; LD-FLAG
o05B3:  RL      C               ; preserve carry (verify) flag in long-term
                                ; state byte. Bit 7 can be lost.

        XOR     L               ; compare type in A with first byte in L.
        RET     NZ              ; return if no match e.g. CODE vs. DATA.

;   continue when data type matches.

        LD      A,C             ; fetch byte with stored carry
        RRA                     ; rotate it to carry flag again
        LD      C,A             ; restore long-term port state.

        INC     DE              ; increment length ??
        JR      o05C4           ; forward to LD-DEC.
                                ; but why not to location after ?

; ---
;   for verification the byte read from tape is compared with that in memory.

;; LD-VERIFY
o05BD:  LD      A,(IX+$00)      ; fetch byte from memory.
        XOR     L               ; compare with that on tape
        RET     NZ              ; return if not zero.

;; LD-NEXT
o05C2:  INC     IX              ; increment byte pointer.

;; LD-DEC
o05C4:  DEC     DE              ; decrement length.
        EX      AF,AF'          ; store the flags.
        LD      B,$B2           ; timing.

;   when starting to read 8 bits the receiving byte is marked with bit at right.
;   when this is rotated out again then 8 bits have been read.

;; LD-MARKER
o05C8:  LD      L,$01           ; initialize as %00000001

;; LD-8-BITS
o05CA:  CALL    o05E3           ; routine LD-EDGE-2 increments B relative to
                                ; gap between 2 edges.
        RET     NC              ; return with time-out.

        LD      A,$CB           ; the comparison byte.
        CP      B               ; compare to incremented value of B.
                                ; if B is higher then bit on tape was set.
                                ; if <= then bit on tape is reset.

        RL      L               ; rotate the carry bit into L.

        LD      B,$B0           ; reset the B timer byte.
        JP      NC,o05CA        ; JUMP back to LD-8-BITS

;   when carry set then marker bit has been passed out and byte is complete.

        LD      A,H             ; fetch the running parity byte.
        XOR     L               ; include the new byte.
        LD      H,A             ; and store back in parity register.

        LD      A,D             ; check length of
        OR      E               ; expected bytes.
        JR      NZ,o05A9        ; back to LD-LOOP
                                ; while there are more.

;   when all bytes loaded then parity byte should be zero.

        LD      A,H             ; fetch parity byte.
        CP      $01             ; set carry if zero.
        RET                     ; return
                                ; in no carry then error as checksum disagrees.

; -------------------------
; Check signal being loaded
; -------------------------
;   An edge is a transition from one mic state to another.
;   More specifically a change in bit 6 of value input from port $FE.
;   Graphically it is a change of border colour, say, blue to yellow.
;   The first entry point looks for two adjacent edges. The second entry point
;   is used to find a single edge.
;   The B register holds a count, up to 256, within which the edge (or edges)
;   must be found. The gap between two edges will be more for a '1' than a '0'
;   so the value of B denotes the state of the bit (two edges) read from tape.

; ->

;; LD-EDGE-2
o05E3:  CALL    o05E7           ; call routine LD-EDGE-1 below.
        RET     NC              ; return if space pressed or time-out.
                                ; else continue and look for another adjacent
                                ; edge which together represent a bit on the
                                ; tape.

; ->
;   this entry point is used to find a single edge from above but also
;   when detecting a read-in signal on the tape.

;; LD-EDGE-1
o05E7:  LD      A,$16           ; a delay value of twenty two.

;; LD-DELAY
o05E9:  DEC     A               ; decrement counter
        JR      NZ,o05E9        ; loop back to LD-DELAY 22 times.

        AND      A              ; clear carry.

;; LD-SAMPLE
o05ED:  INC     B               ; increment the time-out counter.
        RET     Z               ; return with failure when $FF passed.

        LD      A,$7F           ; prepare to read keyboard and EAR port
        IN      A,($FE)         ; row $7FFE. bit 6 is EAR, bit 0 is SPACE key.
        RRA                     ; test outer key the space. (bit 6 moves to 5)
        RET     NC              ; return if space pressed.  >>>

        XOR     C               ; compare with initial long-term state.
        AND     $20             ; isolate bit 5
        JR      Z,o05ED         ; back to LD-SAMPLE if no edge.

;   but an edge, a transition of the EAR bit, has been found so switch the
;   long-term comparison byte containing both border colour and EAR bit.

        LD      A,C             ; fetch comparison value.
        CPL                     ; switch the bits
        LD      C,A             ; and put back in C for long-term.

        AND     $07             ; isolate new colour bits.
        OR      $08             ; set bit 3 - MIC off.
        OUT     ($FE),A         ; send to port to effect the change of colour.

        SCF                     ; set carry flag signaling edge found within
                                ; time allowed.
        RET                     ; return.

; ---------------------------------
; Entry point for all tape commands
; ---------------------------------
;   This is the single entry point for the four tape commands.
;   The routine first determines in what context it has been called by examining
;   the low byte of the Syntax table entry which was stored in T_ADDR.
;   Subtracting $EO (the present arrangement) gives a value of
;   $00 - SAVE
;   $01 - LOAD
;   $02 - VERIFY
;   $03 - MERGE
;   As with all commands the address STMT-RET is on the stack.

;; SAVE-ETC
o0605:  POP     AF              ; discard address STMT-RET.
        LD      A,(T_ADDR)      ; fetch T_ADDR

;   Now reduce the low byte of the Syntax table entry to give command.
;   Note. For ZASM use SUB $E0 as next instruction.

o0609:  SUB     (o1ADF+1) % 256 ; subtract the known offset.
                                ; ( is SUB $E0 in standard ROM )

        LD      (T_ADDR),A      ; and put back in T_ADDR as 0,1,2, or 3
                                ; for future reference.

        CALL    o1C8C           ; routine EXPT-EXP checks that a string
                                ; expression follows and stacks the
                                ; parameters in run-time.

        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o0652         ; forward to SA-DATA if checking syntax.

        LD      BC,$0011        ; presume seventeen bytes for a header.
        LD      A,(T_ADDR)      ; fetch command from T_ADDR.
        AND     A               ; test for zero - SAVE.
        JR      Z,o0621         ; forward to SA-SPACE if so.

        LD      C,$22           ; else double length to thirty four.

;; SA-SPACE
o0621:  RST     30H             ; BC-SPACES creates 17/34 bytes in workspace.

        PUSH    DE              ; transfer the start of new space to
        POP     IX              ; the available index register.

;   ten spaces are required for the default filename but it is simpler to
;   overwrite the first file-type indicator byte as well.

        LD      B,$0B           ; set counter to eleven.
        LD      A,$20           ; prepare a space.

;; SA-BLANK
o0629:  LD      (DE),A          ; set workspace location to space.
        INC     DE              ; next location.
        DJNZ    o0629           ; loop back to SA-BLANK till all eleven done.

        LD      (IX+$01),$FF    ; set first byte of ten character filename
                                ; to $FF as a default to signal null string.

        CALL    o2BF1           ; routine STK-FETCH fetches the filename
                                ; parameters from the calculator stack.
                                ; length of string in BC.
                                ; start of string in DE.

        LD      HL,$FFF6        ; prepare the value minus ten.
        DEC     BC              ; decrement length.
                                ; ten becomes nine, zero becomes $FFFF.
        ADD     HL,BC           ; trial addition.
        INC     BC              ; restore true length.
        JR      NC,o064B        ; forward to SA-NAME if length is one to ten.

;   the filename is more than ten characters in length or the null string.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR.
        AND     A               ; test for zero - SAVE.
        JR      NZ,o0644        ; forward to SA-NULL if not the SAVE command.

;   but no more than ten characters are allowed for SAVE.
;   The first ten characters of any other command parameter are acceptable.
;   Weird, but necessary, if saving to sectors.
;   Note. the golden rule that there are no restriction on anything is broken.

;; REPORT-Fa
o0642:  RST     08H             ; ERROR-1
        DEFB    $0E             ; Error Report: Invalid file name

;   continue with LOAD, MERGE, VERIFY and also SAVE within ten character limit.

;; SA-NULL
o0644:  LD      A,B             ; test length of filename
        OR      C               ; for zero.
        JR      Z,o0652         ; forward to SA-DATA if so using the 255
                                ; indicator followed by spaces.

        LD      BC,$000A        ; else trim length to ten.

;   other paths rejoin here with BC holding length in range 1 - 10.

;; SA-NAME
o064B:  PUSH    IX              ; push start of file descriptor.
        POP     HL              ; and pop into HL.

        INC     HL              ; HL now addresses first byte of filename.
        EX      DE,HL           ; transfer destination address to DE, start
                                ; of string in command to HL.
        LDIR                    ; copy up to ten bytes
                                ; if less than ten then trailing spaces follow.

;   the case for the null string rejoins here.

;; SA-DATA
o0652:  RST     18H             ; GET-CHAR
        CP      $E4             ; is character after filename the token 'DATA' ?
        JR      NZ,o06A0        ; forward to SA-SCR$ to consider SCREEN$ if
                                ; not.

;   continue to consider DATA.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR
        CP      $03             ; is it 'VERIFY' ?
        JP      Z,o1C8A         ; jump forward to REPORT-C if so.
                                ; 'Nonsense in BASIC'
                                ; VERIFY "d" DATA is not allowed.

;   continue with SAVE, LOAD, MERGE of DATA.

        RST     20H             ; NEXT-CHAR
        CALL    o28B2           ; routine LOOK-VARS searches variables area
                                ; returning with carry reset if found or
                                ; checking syntax.
        SET     7,C             ; this converts a simple string to a
                                ; string array. The test for an array or string
                                ; comes later.
        JR      NC,o0672        ; forward to SA-V-OLD if variable found.

        LD      HL,$0000        ; set destination to zero as not fixed.
        LD      A,(T_ADDR)      ; fetch command from T_ADDR
        DEC     A               ; test for 1 - LOAD
        JR      Z,o0685         ; forward to SA-V-NEW with LOAD DATA.
                                ; to load a new array.

;   otherwise the variable was not found in run-time with SAVE/MERGE.

;; REPORT-2a
o0670:  RST     08H             ; ERROR-1
        DEFB    $01             ; Error Report: Variable not found

;   continue with SAVE/LOAD  DATA

;; SA-V-OLD
o0672:  JP      NZ,o1C8A        ; to REPORT-C if not an array variable.
                                ; or erroneously a simple string.
                                ; 'Nonsense in BASIC'


        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o0692         ; forward to SA-DATA-1 if checking syntax.

        INC     HL              ; step past single character variable name.
        LD      A,(HL)          ; fetch low byte of length.
        LD      (IX+$0B),A      ; place in descriptor.
        INC     HL              ; point to high byte.
        LD      A,(HL)          ; and transfer that
        LD      (IX+$0C),A      ; to descriptor.
        INC     HL              ; increase pointer within variable.

;; SA-V-NEW
o0685:  LD      (IX+$0E),C      ; place character array name in  header.
        LD      A,$01           ; default to type numeric.
        BIT     6,C             ; test result from look-vars.
        JR      Z,o068F         ; forward to SA-V-TYPE if numeric.

        INC     A               ; set type to 2 - string array.

;; SA-V-TYPE
o068F:  LD      (IX+$00),A      ; place type 0, 1 or 2 in descriptor.

;; SA-DATA-1
o0692:  EX      DE,HL           ; save var pointer in DE

        RST     20H             ; NEXT-CHAR
        CP      $29             ; is character ')' ?
        JR      NZ,o0672        ; back if not to SA-V-OLD to report
                                ; 'Nonsense in BASIC'

        RST     20H             ; NEXT-CHAR advances character address.
        CALL    o1BEE           ; routine CHECK-END errors if not end of
                                ; the statement.

        EX      DE,HL           ; bring back variables data pointer.
        JP      o075A           ; jump forward to SA-ALL

; ---
;   the branch was here to consider a 'SCREEN$', the display file.

;; SA-SCR$
o06A0:  CP      $AA             ; is character the token 'SCREEN$' ?
        JR      NZ,o06C3        ; forward to SA-CODE if not.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR
        CP      $03             ; is it MERGE ?
        JP       Z,o1C8A        ; jump to REPORT-C if so.
                                ; 'Nonsense in BASIC'

;   continue with SAVE/LOAD/VERIFY SCREEN$.

        RST     20H             ; NEXT-CHAR
        CALL    o1BEE           ; routine CHECK-END errors if not at end of
                                ; statement.

;   continue in runtime.

        LD      (IX+$0B),$00    ; set descriptor length
        LD      (IX+$0C),$1B    ; to $1b00 to include bitmaps and attributes.

        LD      HL,$4000        ; set start to display file start.
        LD      (IX+$0D),L      ; place start in
        LD      (IX+$0E),H      ; the descriptor.
        JR      o0710           ; forward to SA-TYPE-3

; ---
;   the branch was here to consider CODE.

;; SA-CODE
o06C3:  CP      $AF             ; is character the token 'CODE' ?
        JR      NZ,o0716        ; forward if not to SA-LINE to consider an
                                ; auto-started BASIC program.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR
        CP      $03             ; is it MERGE ?
        JP      Z,o1C8A         ; jump forward to REPORT-C if so.
                                ; 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR advances character address.
        CALL    o2048           ; routine PR-ST-END checks if a carriage
                                ; return or ':' follows.
        JR      NZ,o06E1        ; forward to SA-CODE-1 if there are parameters.

        LD      A,(T_ADDR)      ; else fetch the command from T_ADDR.
        AND     A               ; test for zero - SAVE without a specification.
        JP      Z,o1C8A         ; jump to REPORT-C if so.
                                ; 'Nonsense in BASIC'

;   for LOAD/VERIFY put zero on stack to signify handle at location saved from.

        CALL    o1CE6           ; routine USE-ZERO
        JR      o06F0           ; forward to SA-CODE-2

; ---

;   if there are more characters after CODE expect start and possibly length.

;; SA-CODE-1
o06E1:  CALL    o1C82           ; routine EXPT-1NUM checks for numeric
                                ; expression and stacks it in run-time.

        RST     18H             ; GET-CHAR
        CP      $2C             ; does a comma follow ?
        JR      Z,o06F5         ; forward if so to SA-CODE-3

;   else allow saved code to be loaded to a specified address.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR.
        AND     A               ; is the command SAVE which requires length ?
        JP      Z,o1C8A         ; jump to REPORT-C if so.
                                ; 'Nonsense in BASIC'

;   the command LOAD code may rejoin here with zero stacked as start.

;; SA-CODE-2
o06F0:  CALL    o1CE6           ; routine USE-ZERO stacks zero for length.
        JR      o06F9           ; forward to SA-CODE-4

; ---
;   the branch was here with SAVE CODE start,

;; SA-CODE-3
o06F5:  RST     20H             ; NEXT-CHAR advances character address.
        CALL    o1C82           ; routine EXPT-1NUM checks for expression
                                ; and stacks in run-time.

;   paths converge here and nothing must follow.

;; SA-CODE-4
o06F9:  CALL    o1BEE           ; routine CHECK-END errors with extraneous
                                ; characters and quits if checking syntax.

;   in run-time there are two 16-bit parameters on the calculator stack.

        CALL    o1E99           ; routine FIND-INT2 gets length.
        LD      (IX+$0B),C      ; place length
        LD      (IX+$0C),B      ; in descriptor.
        CALL    o1E99           ; routine FIND-INT2 gets start.
        LD      (IX+$0D),C      ; place start
        LD      (IX+$0E),B      ; in descriptor.
        LD      H,B             ; transfer the
        LD      L,C             ; start to HL also.

;; SA-TYPE-3
o0710:  LD      (IX+$00),$03    ; place type 3 - code in descriptor.
        JR      o075A           ; forward to SA-ALL.

; ---
;   the branch was here with BASIC to consider an optional auto-start line
;   number.

;; SA-LINE
o0716:  CP      $CA             ; is character the token 'LINE' ?
        JR      Z,o0723         ; forward to SA-LINE-1 if so.

;   else all possibilities have been considered and nothing must follow.

        CALL    o1BEE           ; routine CHECK-END

;   continue in run-time to save BASIC without auto-start.

        LD      (IX+$0E),$80    ; place high line number in descriptor to
                                ; disable auto-start.
        JR      o073A           ; forward to SA-TYPE-0 to save program.

; ---
;   the branch was here to consider auto-start.

;; SA-LINE-1
o0723:  LD      A,(T_ADDR)      ; fetch command from T_ADDR
        AND     A               ; test for SAVE.
        JP      NZ,o1C8A        ; jump forward to REPORT-C with anything else.
                                ; 'Nonsense in BASIC'

;

        RST     20H             ; NEXT-CHAR
        CALL    o1C82           ; routine EXPT-1NUM checks for numeric
                                ; expression and stacks in run-time.
        CALL    o1BEE           ; routine CHECK-END quits if syntax path.
        CALL    o1E99           ; routine FIND-INT2 fetches the numeric
                                ; expression.
        LD      (IX+$0D),C      ; place the auto-start
        LD      (IX+$0E),B      ; line number in the descriptor.

;   Note. this isn't checked, but is subsequently handled by the system.
;   If the user typed 40000 instead of 4000 then it won't auto-start
;   at line 4000, or indeed, at all.

;   continue to save program and any variables.

;; SA-TYPE-0
o073A:  LD      (IX+$00),$00    ; place type zero - program in descriptor.
        LD      HL,($5C59)      ; fetch E_LINE to HL.
        LD      DE,(PROG)       ; fetch PROG to DE.
        SCF                     ; set carry flag to calculate from end of
                                ; variables E_LINE -1.
        SBC     HL,DE           ; subtract to give total length.

        LD      (IX+$0B),L      ; place total length
        LD      (IX+$0C),H      ; in descriptor.
        LD      HL,(VARS)       ; load HL from system variable VARS
        SBC     HL,DE           ; subtract to give program length.
        LD      (IX+$0F),L      ; place length of program
        LD      (IX+$10),H      ; in the descriptor.
        EX      DE,HL           ; start to HL, length to DE.

;; SA-ALL
o075A:  LD      A,(T_ADDR)      ; fetch command from T_ADDR
        AND     A               ; test for zero - SAVE.
        JP      Z,o0970         ; jump forward to SA-CONTRL with SAVE  ->

; ---
;   continue with LOAD, MERGE and VERIFY.

        PUSH    HL              ; save start.
        LD      BC,$0011        ; prepare to add seventeen
        ADD     IX,BC           ; to point IX at second descriptor.

;; LD-LOOK-H
o0767:  PUSH    IX              ; save IX
        LD      DE,$0011        ; seventeen bytes
        XOR     A               ; reset zero flag
        SCF                     ; set carry flag
        CALL    o0556           ; routine LD-BYTES loads a header from tape
                                ; to second descriptor.
        POP     IX              ; restore IX.
        JR      NC,o0767        ; loop back to LD-LOOK-H until header found.

        LD      A,$FE           ; select system channel 'S'
        CALL    o1601           ; routine CHAN-OPEN opens it.

        LD      (IY+$52),$03    ; set SCR_CT to 3 lines.

        LD      C,$80           ; C has bit 7 set to indicate type mismatch as
                                ; a default startpoint.

        LD      A,(IX+$00)      ; fetch loaded header type to A
        CP      (IX-$11)        ; compare with expected type.
        JR      NZ,o078A        ; forward to LD-TYPE with mis-match.

        LD      C,$F6           ; set C to minus ten - will count characters
                                ; up to zero.

;; LD-TYPE
o078A:  CP      $04             ; check if type in acceptable range 0 - 3.
        JR      NC,o0767        ; back to LD-LOOK-H with 4 and over.

;   else A indicates type 0-3.

        LD      DE,o09C0        ; address base of last 4 tape messages
        PUSH    BC              ; save BC
        CALL    o0C0A           ; routine PO-MSG outputs relevant message.
                                ; Note. all messages have a leading newline.
        POP     BC              ; restore BC

        PUSH    IX              ; transfer IX,
        POP     DE              ; the 2nd descriptor, to DE.
        LD      HL,$FFF0        ; prepare minus seventeen.
        ADD     HL,DE           ; add to point HL to 1st descriptor.
        LD      B,$0A           ; the count will be ten characters for the
                                ; filename.

        LD      A,(HL)          ; fetch first character and test for
        INC     A               ; value 255.
        JR      NZ,o07A6        ; forward to LD-NAME if not the wildcard.

;   but if it is the wildcard, then add ten to C which is minus ten for a type
;   match or -128 for a type mismatch. Although characters have to be counted
;   bit 7 of C will not alter from state set here.

        LD      A,C             ; transfer $F6 or $80 to A
        ADD     A,B             ; add $0A
        LD      C,A             ; place result, zero or -118, in C.

;   At this point we have either a type mismatch, a wildcard match or ten
;   characters to be counted. The characters must be shown on the screen.

;; LD-NAME
o07A6:  INC     DE              ; address next input character
        LD      A,(DE)          ; fetch character
        CP      (HL)            ; compare to expected
        INC     HL              ; address next expected character
        JR      NZ,o07AD        ; forward to LD-CH-PR with mismatch

        INC     C               ; increment matched character count

;; LD-CH-PR
o07AD:  RST     10H             ; PRINT-A prints character
        DJNZ    o07A6           ; loop back to LD-NAME for ten characters.

;   if ten characters matched and the types previously matched then C will
;   now hold zero.

        BIT     7,C             ; test if all matched
        JR      NZ,o0767        ; back to LD-LOOK-H if not

;   else print a terminal carriage return.

        LD      A,$0D           ; prepare carriage return.
        RST     10H             ; PRINT-A outputs it.

;   The various control routines for LOAD, VERIFY and MERGE are executed
;   during the one-second gap following the header on tape.

        POP     HL              ; restore xx
        LD      A,(IX+$00)      ; fetch incoming type
        CP      $03             ; compare with CODE
        JR      Z,o07CB         ; forward to VR-CONTRL if it is CODE.

;  type is a program or an array.

        LD      A,(T_ADDR)      ; fetch command from T_ADDR
        DEC     A               ; was it LOAD ?
        JP      Z,o0808         ; JUMP forward to LD-CONTRL if so to
                                ; load BASIC or variables.

        CP      $02             ; was command MERGE ?
        JP      Z,o08B6         ; jump forward to ME-CONTRL if so.

;   else continue into VERIFY control routine to verify.

; ----------------------------
; THE 'VERIFY CONTROL' ROUTINE
; ----------------------------
;   There are two branches to this routine.
;   1) From above to verify a program or array
;   2) from earlier with no carry to load or verify code.

;; VR-CONTRL
o07CB:  PUSH    HL              ; save pointer to data.
        LD      L,(IX-$06)      ; fetch length of old data
        LD      H,(IX-$05)      ; to HL.
        LD      E,(IX+$0B)      ; fetch length of new data
        LD      D,(IX+$0C)      ; to DE.
        LD      A,H             ; check length of old
        OR      L               ; for zero.
        JR      Z,o07E9         ; forward to VR-CONT-1 if length unspecified
                                ; e.g. LOAD "x" CODE

;   as opposed to, say, LOAD 'x' CODE 32768,300.

        SBC     HL,DE           ; subtract the two lengths.
        JR      C,o0806         ; forward to REPORT-R if the length on tape is
                                ; larger than that specified in command.
                                ; 'Tape loading error'

        JR      Z,o07E9         ; forward to VR-CONT-1 if lengths match.

;   a length on tape shorter than expected is not allowed for CODE

        LD      A,(IX+$00)      ; else fetch type from tape.
        CP      $03             ; is it CODE ?
        JR      NZ,o0806        ; forward to REPORT-R if so
                                ; 'Tape loading error'

;; VR-CONT-1
o07E9:  POP     HL              ; pop pointer to data
        LD      A,H             ; test for zero
        OR      L               ; e.g. LOAD 'x' CODE
        JR      NZ,o07F4        ; forward to VR-CONT-2 if destination specified.

        LD      L,(IX+$0D)      ; else use the destination in the header
        LD      H,(IX+$0E)      ; and load code at address saved from.

;; VR-CONT-2
o07F4:  PUSH    HL              ; push pointer to start of data block.
        POP     IX              ; transfer to IX.
        LD      A,(T_ADDR)      ; fetch reduced command from T_ADDR
        CP      $02             ; is it VERIFY ?
        SCF                     ; prepare a set carry flag
        JR      NZ,o0800        ; skip to VR-CONT-3 if not

        AND     A               ; clear carry flag for VERIFY so that
                                ; data is not loaded.

;; VR-CONT-3
o0800:  LD      A,$FF           ; signal data block to be loaded

; -----------------
; Load a data block
; -----------------
;   This routine is called from 3 places other than above to load a data block.
;   In all cases the accumulator is first set to $FF so the routine could be
;   called at the previous instruction.

;; LD-BLOCK
o0802:  CALL    o0556           ; routine LD-BYTES
        RET     C               ; return if successful.


;; REPORT-R
o0806:  RST     08H             ; ERROR-1
        DEFB    $1A             ; Error Report: Tape loading error

; --------------------------
; THE 'LOAD CONTROL' ROUTINE
; --------------------------
;   This branch is taken when the command is LOAD with type 0, 1 or 2.

;; LD-CONTRL
o0808:  LD      E,(IX+$0B)      ; fetch length of found data block
        LD      D,(IX+$0C)      ; from 2nd descriptor.
        PUSH    HL              ; save destination
        LD      A,H             ; test for zero
        OR      L               ;
        JR      NZ,o0819        ; forward if not to LD-CONT-1

        INC     DE              ; increase length
        INC     DE              ; for letter name
        INC     DE              ; and 16-bit length
        EX      DE,HL           ; length to HL,
        JR      o0825           ; forward to LD-CONT-2

; ---

;; LD-CONT-1
o0819:  LD      L,(IX-$06)      ; fetch length from
        LD      H,(IX-$05)      ; the first header.
        EX      DE,HL           ;
        SCF                     ; set carry flag
        SBC     HL,DE           ;
        JR      C,o082E         ; to LD-DATA

;; LD-CONT-2
o0825:  LD      DE,$0005        ; allow overhead of five bytes.
        ADD     HL,DE           ; add in the difference in data lengths.
        LD      B,H             ; transfer to
        LD      C,L             ; the BC register pair
        CALL    o1F05           ; routine TEST-ROOM fails if not enough room.

;; LD-DATA
o082E:  POP     HL              ; pop destination
        LD      A,(IX+$00)      ; fetch type 0, 1 or 2.
        AND     A               ; test for program and variables.
        JR      Z,o0873         ; forward if so to LD-PROG

;   the type is a numeric or string array.

        LD      A,H             ; test the destination for zero
        OR      L               ; indicating variable does not already exist.
        JR      Z,o084C         ; forward if so to LD-DATA-1

;   else the destination is the first dimension within the array structure

        DEC     HL              ; address high byte of total length
        LD      B,(HL)          ; transfer to B.
        DEC     HL              ; address low byte of total length.
        LD      C,(HL)          ; transfer to C.
        DEC     HL              ; point to letter of variable.
        INC     BC              ; adjust length to
        INC     BC              ; include these
        INC     BC              ; three bytes also.
        LD      (X_PTR),IX      ; save header pointer in X_PTR.
        CALL    o19E8           ; routine RECLAIM-2 reclaims the old variable
                                ; sliding workspace including the two headers
                                ; downwards.
        LD      IX,(X_PTR)      ; reload IX from X_PTR which will have been
                                ; adjusted down by POINTERS routine.

;; LD-DATA-1
o084C:  LD      HL,($5C59)      ; address E_LINE
        DEC     HL              ; now point to the $80 variables end-marker.
        LD      C,(IX+$0B)      ; fetch new data length
        LD      B,(IX+$0C)      ; from 2nd header.
        PUSH    BC              ; * save it.
        INC     BC              ; adjust the
        INC     BC              ; length to include
        INC     BC              ; letter name and total length.
        LD      A,(IX-$03)      ; fetch letter name from old header.
        PUSH    AF              ; preserve accumulator though not corrupted.

        CALL    o1655           ; routine MAKE-ROOM creates space for variable
                                ; sliding workspace up. IX no longer addresses
                                ; anywhere meaningful.
        INC     HL              ; point to first new location.

        POP     AF              ; fetch back the letter name.
        LD      (HL),A          ; place in first new location.
        POP     DE              ; * pop the data length.
        INC     HL              ; address 2nd location
        LD      (HL),E          ; store low byte of length.
        INC     HL              ; address next.
        LD      (HL),D          ; store high byte.
        INC     HL              ; address start of data.
        PUSH    HL              ; transfer address
        POP     IX              ; to IX register pair.
        SCF                     ; set carry flag indicating load not verify.
        LD      A,$FF           ; signal data not header.
        JP      o0802           ; JUMP back to LD-BLOCK

; -----------------
;   the branch is here when a program as opposed to an array is to be loaded.

;; LD-PROG
o0873:  EX      DE,HL           ; transfer dest to DE.
        LD      HL,($5C59)      ; address E_LINE
        DEC     HL              ; now variables end-marker.
        LD      (X_PTR),IX      ; place the IX header pointer in X_PTR
        LD      C,(IX+$0B)      ; get new length
        LD      B,(IX+$0C)      ; from 2nd header
        PUSH    BC              ; and save it.

        CALL    o19E5           ; routine RECLAIM-1 reclaims program and vars.
                                ; adjusting X-PTR.

        POP     BC              ; restore new length.
        PUSH    HL              ; * save start
        PUSH    BC              ; ** and length.

        CALL    o1655           ; routine MAKE-ROOM creates the space.

        LD      IX,(X_PTR)      ; reload IX from adjusted X_PTR
        INC     HL              ; point to start of new area.
        LD      C,(IX+$0F)      ; fetch length of BASIC on tape
        LD      B,(IX+$10)      ; from 2nd descriptor
        ADD     HL,BC           ; add to address the start of variables.
        LD      (VARS),HL       ; set system variable VARS

        LD      H,(IX+$0E)      ; fetch high byte of autostart line number.
        LD      A,H             ; transfer to A
        AND     $C0             ; test if greater than $3F.
        JR      NZ,o08AD        ; forward to LD-PROG-1 if so with no autostart.

        LD      L,(IX+$0D)      ; else fetch the low byte.
        LD      ($5C42),HL      ; set system variable to line number NEWPPC
        LD      (IY+$0A),$00    ; set statement NSPPC to zero.

;; LD-PROG-1
o08AD:  POP     DE              ; ** pop the length
        POP     IX              ; * and start.
        SCF                     ; set carry flag
        LD      A,$FF           ; signal data as opposed to a header.
        JP      o0802           ; jump back to LD-BLOCK

; ---------------------------
; THE 'MERGE CONTROL' ROUTINE
; ---------------------------
;   the branch was here to merge a program and its variables or an array.
;

;; ME-CONTRL
o08B6:  LD      C,(IX+$0B)      ; fetch length
        LD      B,(IX+$0C)      ; of data block on tape.
        PUSH    BC              ; save it.
        INC     BC              ; one for the pot.

        RST     30H             ; BC-SPACES creates room in workspace.
                                ; HL addresses last new location.
        LD      (HL),$80        ; place end-marker at end.
        EX      DE,HL           ; transfer first location to HL.
        POP     DE              ; restore length to DE.
        PUSH    HL              ; save start.

        PUSH    HL              ; and transfer it
        POP     IX              ; to IX register.
        SCF                     ; set carry flag to load data on tape.
        LD      A,$FF           ; signal data not a header.
        CALL    o0802           ; routine LD-BLOCK loads to workspace.
        POP     HL              ; restore first location in workspace to HL.
        LD      DE,(PROG)       ; set DE from system variable PROG.

;   now enter a loop to merge the data block in workspace with the program and
;   variables.

;; ME-NEW-LP
o08D2:  LD      A,(HL)          ; fetch next byte from workspace.
        AND     $C0             ; compare with $3F.
        JR      NZ,o08F0        ; forward to ME-VAR-LP if a variable or
                                ; end-marker.

;   continue when HL addresses a BASIC line number.

;; ME-OLD-LP
o08D7:  LD      A,(DE)          ; fetch high byte from program area.
        INC     DE              ; bump prog address.
        CP      (HL)            ; compare with that in workspace.
        INC     HL              ; bump workspace address.
        JR      NZ,o08DF        ; forward to ME-OLD-L1 if high bytes don't match

        LD      A,(DE)          ; fetch the low byte of program line number.
        CP      (HL)            ; compare with that in workspace.

;; ME-OLD-L1
o08DF:  DEC     DE              ; point to start of
        DEC     HL              ; respective lines again.
        JR      NC,o08EB        ; forward to ME-NEW-L2 if line number in
                                ; workspace is less than or equal to current
                                ; program line as has to be added to program.

        PUSH    HL              ; else save workspace pointer.
        EX      DE,HL           ; transfer prog pointer to HL
        CALL    o19B8           ; routine NEXT-ONE finds next line in DE.
        POP     HL              ; restore workspace pointer
        JR      o08D7           ; back to ME-OLD-LP until destination position
                                ; in program area found.

; ---
;   the branch was here with an insertion or replacement point.

;; ME-NEW-L2
o08EB:  CALL    o092C           ; routine ME-ENTER enters the line
        JR      o08D2           ; loop back to ME-NEW-LP.

; ---
;   the branch was here when the location in workspace held a variable.

;; ME-VAR-LP
o08F0:  LD      A,(HL)          ; fetch first byte of workspace variable.
        LD      C,A             ; copy to C also.
        CP      $80             ; is it the end-marker ?
        RET     Z               ; return if so as complete.  >>>>>

        PUSH    HL              ; save workspace area pointer.
        LD      HL,(VARS)       ; load HL with VARS - start of variables area.

;; ME-OLD-VP
o08F9:  LD      A,(HL)          ; fetch first byte.
        CP      $80             ; is it the end-marker ?
        JR      Z,o0923         ; forward if so to ME-VAR-L2 to add
                                ; variable at end of variables area.

        CP      C               ; compare with variable in workspace area.
        JR      Z,o0909         ; forward to ME-OLD-V2 if a match to replace.

;   else entire variables area has to be searched.

;; ME-OLD-V1
o0901:  PUSH    BC              ; save character in C.
        CALL    o19B8           ; routine NEXT-ONE gets following variable
                                ; address in DE.
        POP     BC              ; restore character in C
        EX      DE,HL           ; transfer next address to HL.
        JR      o08F9           ; loop back to ME-OLD-VP

; ---
;   the branch was here when first characters of name matched.

;; ME-OLD-V2
o0909:  AND     $E0             ; keep bits 11100000
        CP      $A0             ; compare   10100000 - a long-named variable.

        JR      NZ,o0921        ; forward to ME-VAR-L1 if just one-character.

;   but long-named variables have to be matched character by character.

        POP     DE              ; fetch workspace 1st character pointer
        PUSH    DE              ; and save it on the stack again.
        PUSH    HL              ; save variables area pointer on stack.

;; ME-OLD-V3
o0912:  INC     HL              ; address next character in vars area.
        INC     DE              ; address next character in workspace area.
        LD      A,(DE)          ; fetch workspace character.
        CP      (HL)            ; compare to variables character.
        JR      NZ,o091E        ; forward to ME-OLD-V4 with a mismatch.

        RLA                     ; test if the terminal inverted character.
        JR      NC,o0912        ; loop back to ME-OLD-V3 if more to test.

;   otherwise the long name matches in its entirety.

        POP     HL              ; restore pointer to first character of variable
        JR      o0921           ; forward to ME-VAR-L1

; ---
;   the branch is here when two characters don't match

;; ME-OLD-V4
o091E:  POP     HL              ; restore the prog/vars pointer.
        JR      o0901           ; back to ME-OLD-V1 to resume search.

; ---
;   branch here when variable is to replace an existing one

;; ME-VAR-L1
o0921:  LD      A,$FF           ; indicate a replacement.

;   this entry point is when A holds $80 indicating a new variable.

;; ME-VAR-L2
o0923:  POP     DE              ; pop workspace pointer.
        EX      DE,HL           ; now make HL workspace pointer, DE vars pointer
        INC     A               ; zero flag set if replacement.
        SCF                     ; set carry flag indicating a variable not a
                                ; program line.
        CALL    o092C           ; routine ME-ENTER copies variable in.
        JR      o08F0           ; loop back to ME-VAR-LP

; ------------------------
; Merge a Line or Variable
; ------------------------
;   A BASIC line or variable is inserted at the current point. If the line
;   number or variable names match (zero flag set) then a replacement takes
;   place.

;; ME-ENTER
o092C:  JR      NZ,o093E        ; forward to ME-ENT-1 for insertion only.

;   but the program line or variable matches so old one is reclaimed.

        EX      AF,AF'          ; save flag??
        LD      (X_PTR),HL      ; preserve workspace pointer in dynamic X_PTR
        EX      DE,HL           ; transfer program dest pointer to HL.
        CALL    o19B8           ; routine NEXT-ONE finds following location
                                ; in program or variables area.
        CALL    o19E8           ; routine RECLAIM-2 reclaims the space between.
        EX      DE,HL           ; transfer program dest pointer back to DE.
        LD      HL,(X_PTR)      ; fetch adjusted workspace pointer from X_PTR
        EX      AF,AF'          ; restore flags.

;   now the new line or variable is entered.

;; ME-ENT-1
o093E:  EX      AF,AF'          ; save or re-save flags.
        PUSH    DE              ; save dest pointer in prog/vars area.
        CALL    o19B8           ; routine NEXT-ONE finds next in workspace.
                                ; gets next in DE, difference in BC.
                                ; prev addr in HL
        LD      (X_PTR),HL      ; store pointer in X_PTR
        LD      HL,(PROG)       ; load HL from system variable PROG
        EX      (SP),HL         ; swap with prog/vars pointer on stack.
        PUSH    BC              ; ** save length of new program line/variable.
        EX      AF,AF'          ; fetch flags back.
        JR      C,o0955         ; skip to ME-ENT-2 if variable

        DEC     HL              ; address location before pointer
        CALL    o1655           ; routine MAKE-ROOM creates room for BASIC line
        INC     HL              ; address next.
        JR      o0958           ; forward to ME-ENT-3

; ---

;; ME-ENT-2
o0955:  CALL    o1655           ; routine MAKE-ROOM creates room for variable.

;; ME-ENT-3
o0958:  INC     HL              ; address next?

        POP     BC              ; ** pop length
        POP     DE              ; * pop value for PROG which may have been
                                ; altered by POINTERS if first line.
        LD      (PROG),DE       ; set PROG to original value.
        LD      DE,(X_PTR)      ; fetch adjusted workspace pointer from X_PTR
        PUSH    BC              ; save length
        PUSH    DE              ; and workspace pointer
        EX      DE,HL           ; make workspace pointer source, prog/vars
                                ; pointer the destination
        LDIR                    ; copy bytes of line or variable into new area.
        POP     HL              ; restore workspace pointer.
        POP     BC              ; restore length.
        PUSH    DE              ; save new prog/vars pointer.
        CALL    o19E8           ; routine RECLAIM-2 reclaims the space used
                                ; by the line or variable in workspace block
                                ; as no longer required and space could be
                                ; useful for adding more lines.
        POP     DE              ; restore the prog/vars pointer
        RET                     ; return.

; --------------------------
; THE 'SAVE CONTROL' ROUTINE
; --------------------------
;   A branch from the main SAVE-ETC routine at SAVE-ALL.
;   First the header data is saved. Then after a wait of 1 second
;   the data itself is saved.
;   HL points to start of data.
;   IX points to start of descriptor.

;; SA-CONTRL
o0970:  PUSH    HL              ; save start of data

        LD      A,$FD           ; select system channel 'S'
        CALL    o1601           ; routine CHAN-OPEN

        XOR     A               ; clear to address table directly
        LD      DE,o09A1        ; address: tape-msgs
        CALL    o0C0A           ; routine PO-MSG -
                                ; 'Start tape then press any key.'

        SET     5,(IY+$02)      ; TV_FLAG  - Signal lower screen requires
                                ; clearing
        CALL    o15D4           ; routine WAIT-KEY

        PUSH    IX              ; save pointer to descriptor.
        LD      DE,$0011        ; there are seventeen bytes.
        XOR     A               ; signal a header.
        CALL    o04C2           ; routine SA-BYTES

        POP     IX              ; restore descriptor pointer.

        LD      B,$32           ; wait for a second - 50 interrupts.

;; SA-1-SEC
o0991:  HALT                    ; wait for interrupt
        DJNZ    o0991           ; back to SA-1-SEC until pause complete.

        LD      E,(IX+$0B)      ; fetch length of bytes from the
        LD      D,(IX+$0C)      ; descriptor.

        LD      A,$FF           ; signal data bytes.

        POP     IX              ; retrieve pointer to start
        JP      o04C2           ; jump back to SA-BYTES


;   Arrangement of two headers in workspace.
;   Originally IX addresses first location and only one header is required
;   when saving.
;
;   OLD     NEW         PROG   DATA  DATA  CODE
;   HEADER  HEADER             num   chr          NOTES.
;   ------  ------      ----   ----  ----  ----   -----------------------------
;   IX-$11  IX+$00      0      1     2     3      Type.
;   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
;   IX-$0F  IX+$02      x      x     x     x      i
;   IX-$0E  IX+$03      x      x     x     x      l
;   IX-$0D  IX+$04      x      x     x     x      e
;   IX-$0C  IX+$05      x      x     x     x      n
;   IX-$0B  IX+$06      x      x     x     x      a
;   IX-$0A  IX+$07      x      x     x     x      m
;   IX-$09  IX+$08      x      x     x     x      e
;   IX-$08  IX+$09      x      x     x     x      .
;   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
;   IX-$06  IX+$0B      lo     lo    lo    lo     Total
;   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
;   IX-$04  IX+$0D      Auto   -     -     Start  Various
;   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
;   IX-$02  IX+$0F      lo     -     -     -      Length of Program
;   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.
;


; ------------------------
; Canned cassette messages
; ------------------------
;   The last-character-inverted Cassette messages.
;   Starts with normal initial step-over byte.

;; tape-msgs
    IF spanish
o09A1:  DEFB    $80
        DEFM    "PREPARE LA CINTA Y PULSE "
      IF v41 || garry
        DEFM    "ENTER"
      ELSE
        DEFM    "INTRO"
      ENDIF
o09C0:  DEFB    '.'+$80
        DEFB    $0D
        DEFM    "PROGRAMA:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "MATRIZ NUM.:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "MATRIZ LITERAL:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "BYTES: "
        DEFB    ' '+$80
    ELSE
o09A1:  DEFB    $80
        DEFM    "Press REC & PLAY, then any key"
o09C0:  DEFB    '.'+$80
        DEFB    $0D
        DEFM    "Program:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "Number array:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "Character array:"
        DEFB    ' '+$80
        DEFB    $0D
        DEFM    "Bytes:"
        DEFB    ' '+$80
    ENDIF

;**************************************************
;** Part 5. SCREEN AND PRINTER HANDLING ROUTINES **
;**************************************************

; --------------------------
; THE 'PRINT OUTPUT' ROUTINE
; --------------------------
;   This is the routine most often used by the RST 10 restart although the
;   subroutine is on two occasions called directly when it is known that
;   output will definitely be to the lower screen.

;; PRINT-OUT
o09F4:  CALL    o0B03           ; routine PO-FETCH fetches print position
                                ; to HL register pair.
        CP      $20             ; is character a space or higher ?
        JP      NC,o0AD9        ; jump forward to PO-ABLE if so.

        CP      $06             ; is character in range 00-05 ?
        JR      C,o0A69         ; to PO-QUEST to print '?' if so.

        CP      $18             ; is character in range 24d - 31d ?
        JR      NC,o0A69        ; to PO-QUEST to also print '?' if so.

        LD      HL,o0A11 - 6    ; address 0A0B - the base address of control
                                ; character table - where zero would be.
        LD      E,A             ; control character 06 - 23d
        LD      D,$00           ; is transferred to DE.

        ADD     HL,DE           ; index into table.

        LD      E,(HL)          ; fetch the offset to routine.
        ADD     HL,DE           ; add to make HL the address.
        PUSH    HL              ; push the address.

        JP      o0B03           ; Jump forward to PO-FETCH,
                                ; as the screen/printer position has been
                                ; disturbed, and then indirectly to the PO-STORE
                                ; routine on stack.

; -----------------------------
; THE 'CONTROL CHARACTER' TABLE
; -----------------------------
;   For control characters in the range 6 - 23d the following table
;   is indexed to provide an offset to the handling routine that
;   follows the table.

;; ctlchrtab
o0A11:  DEFB    o0A5F - $       ; 06d offset $4E to Address: PO-COMMA
        DEFB    o0A69 - $       ; 07d offset $57 to Address: PO-QUEST
        DEFB    o0A23 - $       ; 08d offset $10 to Address: PO-BACK-1
        DEFB    o0A3D - $       ; 09d offset $29 to Address: PO-RIGHT
        DEFB    o0A69 - $       ; 10d offset $54 to Address: PO-QUEST
        DEFB    o0A69 - $       ; 11d offset $53 to Address: PO-QUEST
        DEFB    o0A69 - $       ; 12d offset $52 to Address: PO-QUEST
        DEFB    o0A4F - $       ; 13d offset $37 to Address: PO-ENTER
        DEFB    o0A69 - $       ; 14d offset $50 to Address: PO-QUEST
        DEFB    o0A69 - $       ; 15d offset $4F to Address: PO-QUEST
        DEFB    o0A7A - $       ; 16d offset $5F to Address: PO-1-OPER
        DEFB    o0A7A - $       ; 17d offset $5E to Address: PO-1-OPER
        DEFB    o0A7A - $       ; 18d offset $5D to Address: PO-1-OPER
        DEFB    o0A7A - $       ; 19d offset $5C to Address: PO-1-OPER
        DEFB    o0A7A - $       ; 20d offset $5B to Address: PO-1-OPER
        DEFB    o0A7A - $       ; 21d offset $5A to Address: PO-1-OPER
        DEFB    o0A75 - $       ; 22d offset $54 to Address: PO-2-OPER
        DEFB    o0A75 - $       ; 23d offset $53 to Address: PO-2-OPER


; -------------------------
; THE 'CURSOR LEFT' ROUTINE
; -------------------------
;   Backspace and up a line if that action is from the left of screen.
;   For ZX printer backspace up to first column but not beyond.

;; PO-BACK-1
o0A23:  INC     C               ; move left one column.
        LD      A,$22           ; value $21 is leftmost column.
        CP      C               ; have we passed ?
        JR      NZ,o0A3A        ; to PO-BACK-3 if not and store new position.

        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        JR      NZ,o0A38        ; to PO-BACK-2 if so, as we are unable to
                                ; backspace from the leftmost position.


        INC     B               ; move up one screen line
        LD      C,$02           ; the rightmost column position.
        LD      A,$18           ; Note. This should be $19
                                ; credit. Dr. Frank O'Hara, 1982

        CP      B               ; has position moved past top of screen ?
        JR      NZ,o0A3A        ; to PO-BACK-3 if not and store new position.

        DEC     B               ; else back to $18.

;; PO-BACK-2
o0A38:  LD      C,$21           ; the leftmost column position.

;; PO-BACK-3
o0A3A:  JP      o0DD9           ; to CL-SET and PO-STORE to save new
                                ; position in system variables.

; --------------------------
; THE 'CURSOR RIGHT' ROUTINE
; --------------------------
;   This moves the print position to the right leaving a trail in the
;   current background colour.
;   "However the programmer has failed to store the new print position
;   so CHR$ 9 will only work if the next print position is at a newly
;   defined place.
;   e.g. PRINT PAPER 2; CHR$ 9; AT 4,0;
;   does work but is not very helpful"
;   - Dr. Ian Logan, Understanding Your Spectrum, 1982.

;; PO-RIGHT
o0A3D:  LD      A,($5C91)       ; fetch P_FLAG value
        PUSH    AF              ; and save it on stack.

        LD      (IY+$57),$01    ; temporarily set P_FLAG 'OVER 1'.
        LD      A,$20           ; prepare a space.
        CALL    o0B65           ; routine PO-CHAR to print it.
                                ; Note. could be PO-ABLE which would update
                                ; the column position.

        POP     AF              ; restore the permanent flag.
        LD      ($5C91),A       ; and restore system variable P_FLAG

        RET                     ; return without updating column position

; -----------------------
; Perform carriage return
; -----------------------
; A carriage return is 'printed' to screen or printer buffer.

;; PO-ENTER
o0A4F:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        JP      NZ,o0ECD        ; to COPY-BUFF if so, to flush buffer and reset
                                ; the print position.

        LD      C,$21           ; the leftmost column position.
        CALL    o0C55           ; routine PO-SCR handles any scrolling required.
        DEC     B               ; to next screen line.
        JP      o0DD9           ; jump forward to CL-SET to store new position.

; -----------
; Print comma
; -----------
; The comma control character. The 32 column screen has two 16 character
; tabstops.  The routine is only reached via the control character table.

;; PO-COMMA
o0A5F:  CALL    o0B03           ; routine PO-FETCH - seems unnecessary.

        LD      A,C             ; the column position. $21-$01
        DEC     A               ; move right. $20-$00
        DEC     A               ; and again   $1F-$00 or $FF if trailing
        AND     $10             ; will be $00 or $10.
        JR      o0AC3           ; forward to PO-FILL

; -------------------
; Print question mark
; -------------------
; This routine prints a question mark which is commonly
; used to print an unassigned control character in range 0-31d.
; there are a surprising number yet to be assigned.

;; PO-QUEST
o0A69:  LD      A,$3F           ; prepare the character '?'.
        JR      o0AD9           ; forward to PO-ABLE.

; --------------------------------
; Control characters with operands
; --------------------------------
; Certain control characters are followed by 1 or 2 operands.
; The entry points from control character table are PO-2-OPER and PO-1-OPER.
; The routines alter the output address of the current channel so that
; subsequent RST $10 instructions take the appropriate action
; before finally resetting the output address back to PRINT-OUT.

;; PO-TV-2
o0A6D:  LD      DE,o0A87        ; address: PO-CONT will be next output routine
        LD      ($5C0F),A       ; store first operand in TVDATA-hi
        JR      o0A80           ; forward to PO-CHANGE >>

; ---

; -> This initial entry point deals with two operands - AT or TAB.

;; PO-2-OPER
o0A75:  LD      DE,o0A6D        ; address: PO-TV-2 will be next output routine
        JR      o0A7D           ; forward to PO-TV-1

; ---

; -> This initial entry point deals with one operand INK to OVER.

;; PO-1-OPER
o0A7A:  LD      DE,o0A87        ; address: PO-CONT will be next output routine

;; PO-TV-1
o0A7D:  LD      ($5C0E),A       ; store control code in TVDATA-lo

;; PO-CHANGE
o0A80:  LD      HL,(CURCHL)     ; use CURCHL to find current output channel.
        LD      (HL),E          ; make it
        INC     HL              ; the supplied
        LD      (HL),D          ; address from DE.
        RET                     ; return.

; ---

;; PO-CONT
o0A87:  LD      DE,o09F4        ; Address: PRINT-OUT
        CALL    o0A80           ; routine PO-CHANGE to restore normal channel.
        LD      HL,($5C0E)      ; TVDATA gives control code and possible
                                ; subsequent character
        LD      D,A             ; save current character
        LD      A,L             ; the stored control code
        CP      $16             ; was it INK to OVER (1 operand) ?
        JP      C,o2211         ; to CO-TEMP-5

        JR      NZ,o0AC2        ; to PO-TAB if not 22d i.e. 23d TAB.

                                ; else must have been 22d AT.
        LD      B,H             ; line to H   (0-23d)
        LD      C,D             ; column to C (0-31d)
        LD      A,$1F           ; the value 31d
        SUB     C               ; reverse the column number.
        JR      C,o0AAC         ; to PO-AT-ERR if C was greater than 31d.

        ADD     A,$02           ; transform to system range $02-$21
        LD      C,A             ; and place in column register.

        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        JR      NZ,o0ABF        ; to PO-AT-SET as line can be ignored.

        LD      A,$16           ; 22 decimal
        SUB     B               ; subtract line number to reverse
                                ; 0 - 22 becomes 22 - 0.

;; PO-AT-ERR
o0AAC:  JP      C,o1E9F         ; to REPORT-B if higher than 22 decimal
                                ; Integer out of range.

        INC     A               ; adjust for system range $01-$17
        LD      B,A             ; place in line register
        INC     B               ; adjust to system range  $02-$18
        BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?
        JP      NZ,o0C55        ; exit to PO-SCR to test for scrolling

        CP      (IY+$31)        ; Compare against DF_SZ
        JP      C,o0C86         ; to REPORT-5 if too low
                                ; Out of screen.

;; PO-AT-SET
o0ABF:  JP      o0DD9           ; print position is valid so exit via CL-SET

; ---

; Continue here when dealing with TAB.
; Note. In BASIC, TAB is followed by a 16-bit number and was initially
; designed to work with any output device.

;; PO-TAB
o0AC2:  LD      A,H             ; transfer parameter to A
                                ; Losing current character -
                                ; High byte of TAB parameter.


;; PO-FILL
o0AC3:  CALL    o0B03           ; routine PO-FETCH, HL-addr, BC=line/column.
                                ; column 1 (right), $21 (left)
        ADD     A,C             ; add operand to current column
        DEC     A               ; range 0 - 31+
        AND     $1F             ; make range 0 - 31d
        RET     Z               ; return if result zero

        LD      D,A             ; Counter to D
        SET     0,(IY+$01)      ; update FLAGS  - signal suppress leading space.

;; PO-SPACE
o0AD0:  LD      A,$20           ; space character.

        CALL    o0C3B           ; routine PO-SAVE prints the character
                                ; using alternate set (normal output routine)

        DEC     D               ; decrement counter.
        JR      NZ,o0AD0        ; to PO-SPACE until done

        RET                     ; return

; ----------------------
; Printable character(s)
; ----------------------
; This routine prints printable characters and continues into
; the position store routine

;; PO-ABLE
o0AD9:  CALL    o0B24           ; routine PO-ANY
                                ; and continue into position store routine.

; ----------------------------
; THE 'POSITION STORE' ROUTINE
; ----------------------------
;   This routine updates the system variables associated with the main screen,
;   the lower screen/input buffer or the ZX printer.

;; PO-STORE
o0ADC:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
        JR      NZ,o0AFC        ; Forward, if so, to PO-ST-PR

        BIT     0,(IY+$02)      ; Test TV_FLAG - is lower screen in use ?
        JR      NZ,o0AF0        ; Forward, if so, to PO-ST-E

;   This section deals with the upper screen.

        LD      ($5C88),BC      ; Update S_POSN - line/column upper screen
        LD      ($5C84),HL      ; Update DF_CC - upper display file address

        RET                     ; Return.

; ---

;   This section deals with the lower screen.

;; PO-ST-E
o0AF0:  LD      ($5C8A),BC      ; Update SPOSNL line/column lower screen
        LD      ($5C82),BC      ; Update ECHO_E line/column input buffer
        LD      ($5C86),HL      ; Update DFCCL  lower screen memory address
        RET                     ; Return.

; ---

;   This section deals with the ZX Printer.

;; PO-ST-PR
o0AFC:  LD      (IY+$45),C      ; Update P_POSN column position printer
        LD      ($5C80),HL      ; Update PR_CC - full printer buffer memory
                                ; address
        RET                     ; Return.

;   Note. that any values stored in location 23681 will be overwritten with
;   the value 91 decimal.
;   Credit April 1983, Dilwyn Jones. "Delving Deeper into your ZX Spectrum".

; ----------------------------
; THE 'POSITION FETCH' ROUTINE
; ----------------------------
;   This routine fetches the line/column and display file address of the upper
;   and lower screen or, if the printer is in use, the column position and
;   absolute memory address.
;   Note. that PR-CC-hi (23681) is used by this routine and if, in accordance
;   with the manual (that says this is unused), the location has been used for
;   other purposes, then subsequent output to the printer buffer could corrupt
;   a 256-byte section of memory.

;; PO-FETCH
o0B03:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
        JR      NZ,o0B1D        ; Forward, if so, to PO-F-PR

;   assume upper screen in use and thus optimize for path that requires speed.

        LD      BC,($5C88)      ; Fetch line/column from S_POSN
        LD      HL,($5C84)      ; Fetch DF_CC display file address

        BIT     0,(IY+$02)      ; Test TV_FLAG - lower screen in use ?
        RET     Z               ; Return if upper screen in use.

;   Overwrite registers with values for lower screen.

        LD      BC,($5C8A)      ; Fetch line/column from SPOSNL
        LD      HL,($5C86)      ; Fetch display file address from DFCCL
        RET                     ; Return.

; ---

;   This section deals with the ZX Printer.

;; PO-F-PR
o0B1D:  LD      C,(IY+$45)      ; Fetch column from P_POSN.
        LD      HL,($5C80)      ; Fetch printer buffer address from PR_CC.
        RET                     ; Return.

; ---------------------------------
; THE 'PRINT ANY CHARACTER' ROUTINE
; ---------------------------------
;   This routine is used to print any character in range 32d - 255d
;   It is only called from PO-ABLE which continues into PO-STORE

;; PO-ANY
o0B24:  CP      $80             ; ASCII ?
        JR      C,o0B65         ; to PO-CHAR is so.

        CP      $90             ; test if a block graphic character.
        JR      NC,o0B52        ; to PO-T&UDG to print tokens and UDGs

; The 16 2*2 mosaic characters 128-143 decimal are formed from
; bits 0-3 of the character.

        LD      B,A             ; save character
        CALL    o0B38           ; routine PO-GR-1 to construct top half
                                ; then bottom half.
        CALL    o0B03           ; routine PO-FETCH fetches print position.
        LD      DE,$5C92        ; MEM-0 is location of 8 bytes of character
        JR      o0B7F           ; to PR-ALL to print to screen or printer

; ---

;; PO-GR-1
o0B38:  LD      HL,$5C92        ; address MEM-0 - a temporary buffer in
                                ; systems variables which is normally used
                                ; by the calculator.
        CALL    o0B3E           ; routine PO-GR-2 to construct top half
                                ; and continue into routine to construct
                                ; bottom half.

;; PO-GR-2
o0B3E:  RR      B               ; rotate bit 0/2 to carry
        SBC     A,A             ; result $00 or $FF
        AND     $0F             ; mask off right hand side
        LD      C,A             ; store part in C
        RR      B               ; rotate bit 1/3 of original chr to carry
        SBC     A,A             ; result $00 or $FF
        AND     $F0             ; mask off left hand side
        OR      C               ; combine with stored pattern
        LD      C,$04           ; four bytes for top/bottom half

;; PO-GR-3
o0B4C:  LD      (HL),A          ; store bit patterns in temporary buffer
        INC     HL              ; next address
        DEC     C               ; jump back to
        JR      NZ,o0B4C        ; to PO-GR-3 until byte is stored 4 times

        RET                     ; return

; ---

; Tokens and User defined graphics are now separated.

;; PO-T&UDG
o0B52:  JP      o3A7E
        NOP

o0B56:  ADD     A,$15           ; add 21d to restore to 0 - 20
        PUSH    BC              ; save current print position
        LD      BC,(UDG)        ; fetch UDG to address bit patterns
        JR      o0B6A           ; to PO-CHAR-2 - common code to lay down
                                ; a bit patterned character

; ---

;; PO-T
o0B5F:  CALL    o0C10           ; routine PO-TOKENS prints tokens
        JP      o0B03           ; exit via a JUMP to PO-FETCH as this routine
                                ; must continue into PO-STORE.
                                ; A JR instruction could be used.

; This point is used to print ASCII characters  32d - 127d.

;; PO-CHAR
o0B65:  PUSH    BC              ; save print position
        LD      BC,($5C36)      ; address CHARS

; This common code is used to transfer the character bytes to memory.

;; PO-CHAR-2
o0B6A:  EX      DE,HL           ; transfer destination address to DE
        LD      HL,$5C3B        ; point to FLAGS
        RES     0,(HL)          ; allow for leading space
        CP      $20             ; is it a space ?
        JR      NZ,o0B76        ; to PO-CHAR-3 if not

        SET     0,(HL)          ; signal no leading space to FLAGS

;; PO-CHAR-3
o0B76:  LD      H,$00           ; set high byte to 0
        LD      L,A             ; character to A
                                ; 0-21 UDG or 32-127 ASCII.
        ADD     HL,HL           ; multiply
        ADD     HL,HL           ; by
        ADD     HL,HL           ; eight
        ADD     HL,BC           ; HL now points to first byte of character
        POP     BC              ; the source address CHARS or UDG
        EX      DE,HL           ; character address to DE

; ----------------------------------
; THE 'PRINT ALL CHARACTERS' ROUTINE
; ----------------------------------
;   This entry point entered from above to print ASCII and UDGs but also from
;   earlier to print mosaic characters.
;   HL=destination
;   DE=character source
;   BC=line/column

;; PR-ALL
o0B7F:  LD      A,C             ; column to A
        DEC     A               ; move right
        LD      A,$21           ; pre-load with leftmost position
        JR      NZ,o0B93        ; but if not zero to PR-ALL-1

        DEC     B               ; down one line
        LD      C,A             ; load C with $21
        BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use
        JR      Z,o0B93         ; to PR-ALL-1 if not

        PUSH    DE              ; save source address
        CALL    o0ECD           ; routine COPY-BUFF outputs line to printer
        POP     DE              ; restore character source address
        LD      A,C             ; the new column number ($21) to C

;; PR-ALL-1
o0B93:  CP      C               ; this test is really for screen - new line ?
        PUSH    DE              ; save source

        CALL    Z,o0C55         ; routine PO-SCR considers scrolling

        POP     DE              ; restore source
        PUSH    BC              ; save line/column
        PUSH    HL              ; and destination
        LD      A,($5C91)       ; fetch P_FLAG to accumulator
        LD      B,$FF           ; prepare OVER mask in B.
        RRA                     ; bit 0 set if OVER 1
        JR      C,o0BA4         ; to PR-ALL-2

        INC     B               ; set OVER mask to 0

;; PR-ALL-2
o0BA4:  RRA                     ; skip bit 1 of P_FLAG
        RRA                     ; bit 2 is INVERSE
        SBC     A,A             ; will be FF for INVERSE 1 else zero
        LD      C,A             ; transfer INVERSE mask to C
        LD      A,$08           ; prepare to count 8 bytes
        AND     A               ; clear carry to signal screen
        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        JR      Z,o0BB6         ; to PR-ALL-3 if screen

        SET     1,(IY+$30)      ; update FLAGS2  - signal printer buffer has
                                ; been used.
        SCF                     ; set carry flag to signal printer.

;; PR-ALL-3
o0BB6:  EX      DE,HL           ; now HL=source, DE=destination

;; PR-ALL-4
o0BB7:  EX      AF,AF'          ; save printer/screen flag
        LD      A,(DE)          ; fetch existing destination byte
        AND     B               ; consider OVER
        XOR     (HL)            ; now XOR with source
        XOR     C               ; now with INVERSE MASK
        LD      (DE),A          ; update screen/printer
        EX      AF,AF'          ; restore flag
        JR      C,o0BD3         ; to PR-ALL-6 - printer address update

        INC     D               ; gives next pixel line down screen

;; PR-ALL-5
o0BC1:  INC     HL              ; address next character byte
        DEC     A               ; the byte count is decremented
        JR      NZ,o0BB7        ; back to PR-ALL-4 for all 8 bytes

        EX      DE,HL           ; destination to HL
        DEC     H               ; bring back to last updated screen position
        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        CALL    Z,o0BDB         ; if not, call routine PO-ATTR to update
                                ; corresponding colour attribute.
        POP     HL              ; restore original screen/printer position
        POP     BC              ; and line column
        DEC     C               ; move column to right
        INC     HL              ; increase screen/printer position
        RET                     ; return and continue into PO-STORE
                                ; within PO-ABLE

; ---

;   This branch is used to update the printer position by 32 places
;   Note. The high byte of the address D remains constant (which it should).

;; PR-ALL-6
o0BD3:  EX      AF,AF'          ; save the flag
        LD      A,$20           ; load A with 32 decimal
        ADD     A,E             ; add this to E
        LD      E,A             ; and store result in E
        EX      AF,AF'          ; fetch the flag
        JR      o0BC1           ; back to PR-ALL-5

; -----------------------------------
; THE 'GET ATTRIBUTE ADDRESS' ROUTINE
; -----------------------------------
;   This routine is entered with the HL register holding the last screen
;   address to be updated by PRINT or PLOT.
;   The Spectrum screen arrangement leads to the L register holding the correct
;   value for the attribute file and it is only necessary to manipulate H to
;   form the correct colour attribute address.

;; PO-ATTR
o0BDB:  LD       A,H            ; fetch high byte $40 - $57
        RRCA                    ; shift
        RRCA                    ; bits 3 and 4
        RRCA                    ; to right.
        AND     $03             ; range is now 0 - 2
        OR      $58             ; form correct high byte for third of screen
        LD      H,A             ; HL is now correct
        LD      DE,(ATTR_T)     ; make D hold ATTR_T, E hold MASK-T
        LD      A,(HL)          ; fetch existing attribute
        XOR     E               ; apply masks
        AND     D               ;
        XOR     E               ;
        BIT     6,(IY+$57)      ; test P_FLAG  - is this PAPER 9 ??
        JR      Z,o0BFA         ; skip to PO-ATTR-1 if not.

        AND     $C7             ; set paper
        BIT     2,A             ; to contrast with ink
        JR      NZ,o0BFA        ; skip to PO-ATTR-1

        XOR     $38             ;

;; PO-ATTR-1
o0BFA:  BIT     4,(IY+$57)      ; test P_FLAG  - Is this INK 9 ??
        JR      Z,o0C08         ; skip to PO-ATTR-2 if not

        AND     $F8             ; make ink
        BIT     5,A             ; contrast with paper.
        JR      NZ,o0C08        ; to PO-ATTR-2

        XOR     $07             ;

;; PO-ATTR-2
o0C08:  LD      (HL),A          ; save the new attribute.
        RET                     ; return.

; ---------------------------------
; THE 'MESSAGE PRINTING' SUBROUTINE
; ---------------------------------
;   This entry point is used to print tape, boot-up, scroll? and error messages.
;   On entry the DE register points to an initial step-over byte or the
;   inverted end-marker of the previous entry in the table.
;   Register A contains the message number, often zero to print first message.
;   (HL has nothing important usually P_FLAG)

;; PO-MSG
o0C0A:  PUSH    HL              ; put hi-byte zero on stack to suppress
        LD      H,$00           ; trailing spaces
        EX      (SP),HL         ; ld h,0; push hl would have done ?.
        JR      o0C14           ; forward to PO-TABLE.

; ---

;   This entry point prints the BASIC keywords, '<>' etc. from alt set

;; PO-TOKENS
o0C10:  LD      DE,o0095        ; address: TKN-TABLE
        PUSH    AF              ; save the token number to control
                                ; trailing spaces - see later *

; ->

;; PO-TABLE
o0C14:  CALL    o0C41           ; routine PO-SEARCH will set carry for
                                ; all messages and function words.

o0C17:  JR      C,o0C22         ; forward to PO-EACH if not a command, '<>' etc.

        LD      A,$20           ; prepare leading space
        BIT     0,(IY+$01)      ; test FLAGS  - leading space if not set

        CALL    Z,o0C3B         ; routine PO-SAVE to print a space without
                                ; disturbing registers.

;; PO-EACH
o0C22:  LD      A,(DE)          ; Fetch character from the table.
        AND     $7F             ; Cancel any inverted bit.

        CALL    o0C3B           ; Routine PO-SAVE to print using the alternate
                                ; set of registers.

        LD      A,(DE)          ; Re-fetch character from table.
        INC     DE              ; Address next character in the table.

        ADD     A,A             ; Was character inverted ?
                                ; (this also doubles character)
        JR      NC,o0C22        ; back to PO-EACH if not.

        POP     DE              ; * re-fetch trailing space byte to D

        CP      $48             ; was the last character '$' ?
        JR      Z,o0C35         ; forward to PO-TR-SP to consider trailing
                                ; space if so.

        CP      $82             ; was it < 'A' i.e. '#','>','=' from tokens
                                ; or ' ','.' (from tape) or '?' from scroll

        RET     C               ; Return if so as no trailing space required.

;; PO-TR-SP
o0C35:  LD      A,D             ; The trailing space flag (zero if an error msg)

        CP      $03             ; Test against RND, INKEY$ and PI which have no
                                ; parameters and therefore no trailing space.

        RET     C               ; Return if no trailing space.

        LD      A,$20           ; Prepare the space character and continue to
                                ; print and make an indirect return.

; -----------------------------------
; THE 'RECURSIVE PRINTING' SUBROUTINE
; -----------------------------------
;   This routine which is part of PRINT-OUT allows RST $10 to be used
;   recursively to print tokens and the spaces associated with them.
;   It is called on three occasions when the value of DE must be preserved.

;; PO-SAVE
o0C3B:  PUSH    DE              ; Save DE value.
        EXX                     ; Switch in main set

        RST     10H             ; PRINT-A prints using this alternate set.

        EXX                     ; Switch back to this alternate set.
        POP     DE              ; Restore the initial DE value.

        RET                     ; Return.

; ------------
; Table search
; ------------
; This subroutine searches a message or the token table for the
; message number held in A. DE holds the address of the table.

;; PO-SEARCH
o0C41:  PUSH    AF              ; save the message/token number
        EX      DE,HL           ; transfer DE to HL
        INC     A               ; adjust for initial step-over byte

;; PO-STEP
o0C44:  BIT     7,(HL)          ; is character inverted ?
        INC     HL              ; address next
        JR      Z,o0C44         ; back to PO-STEP if not inverted.

        DEC     A               ; decrease counter
        JR      NZ,o0C44        ; back to PO-STEP if not zero

        EX      DE,HL           ; transfer address to DE
        POP     AF              ; restore message/token number
        CP      $20             ; return with carry set
        RET     C               ; for all messages and function tokens

        LD      A,(DE)          ; test first character of token
        SUB     $41             ; and return with carry set
        RET                     ; if it is less that 'A'
                                ; i.e. '<>', '<=', '>='

; ---------------
; Test for scroll
; ---------------
; This test routine is called when printing carriage return, when considering
; PRINT AT and from the general PRINT ALL characters routine to test if
; scrolling is required, prompting the user if necessary.
; This is therefore using the alternate set.
; The B register holds the current line.

;; PO-SCR
o0C55:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        RET     NZ              ; return immediately if so.

        LD      DE,o0DD9        ; set DE to address: CL-SET
        PUSH    DE              ; and push for return address.

        LD      A,B             ; transfer the line to A.
        BIT     0,(IY+$02)      ; test TV_FLAG - lower screen in use ?
        JP      NZ,o0D02        ; jump forward to PO-SCR-4 if so.

        CP      (IY+$31)        ; greater than DF_SZ display file size ?
        JR      C,o0C86         ; forward to REPORT-5 if less.
                                ; 'Out of screen'

        RET     NZ              ; return (via CL-SET) if greater

        BIT     4,(IY+$02)      ; test TV_FLAG  - Automatic listing ?
        JR      Z,o0C88         ; forward to PO-SCR-2 if not.

        LD      E,(IY+$2D)      ; fetch BREG - the count of scroll lines to E.
        DEC     E               ; decrease and jump
        JR      Z,o0CD2         ; to PO-SCR-3 if zero and scrolling required.

        LD      A,$00           ; explicit - select channel zero.
        CALL    o1601           ; routine CHAN-OPEN opens it.

        LD      SP,($5C3F)      ; set stack pointer to LIST_SP

        RES     4,(IY+$02)      ; reset TV_FLAG  - signal auto listing finished.
        RET                     ; return ignoring pushed value, CL-SET
                                ; to MAIN or EDITOR without updating
                                ; print position                         >>

; ---


;; REPORT-5
o0C86:  RST     08H             ; ERROR-1
        DEFB    $04             ; Error Report: Out of screen

; continue here if not an automatic listing.

;; PO-SCR-2
o0C88:  DEC     (IY+$52)        ; decrease SCR_CT
        JR      NZ,o0CD2        ; forward to PO-SCR-3 to scroll display if
                                ; result not zero.

; now produce prompt.

        LD      A,$18           ; reset
        SUB     B               ; the
        LD      ($5C8C),A       ; SCR_CT scroll count
        LD      HL,(ATTR_T)     ; L=ATTR_T, H=MASK_T
        PUSH    HL              ; save on stack
        LD      A,($5C91)       ; P_FLAG
        PUSH    AF              ; save on stack to prevent lower screen
                                ; attributes (BORDCR etc.) being applied.
        LD      A,$FD           ; select system channel 'K'
        CALL    o1601           ; routine CHAN-OPEN opens it
        XOR     A               ; clear to address message directly
        LD      DE,o0CF8        ; make DE address: scrl-mssg
        CALL    o0C0A           ; routine PO-MSG prints to lower screen
        SET     5,(IY+$02)      ; set TV_FLAG  - signal lower screen requires
                                ; clearing
        LD      HL,$5C3B        ; make HL address FLAGS
        SET     3,(HL)          ; signal 'L' mode.
        RES     5,(HL)          ; signal 'no new key'.
        EXX                     ; switch to main set.
                                ; as calling chr input from alternative set.
        CALL    o15D4           ; routine WAIT-KEY waits for new key
                                ; Note. this is the right routine but the
                                ; stream in use is unsatisfactory. From the
                                ; choices available, it is however the best.

        EXX                     ; switch back to alternate set.
        CP      $20             ; space is considered as BREAK
        JR      Z,o0D00         ; forward to REPORT-D if so
                                ; 'BREAK - CONT repeats'

        CP      $E2             ; is character 'STOP' ?
        JR      Z,o0D00         ; forward to REPORT-D if so

        OR      $20             ; convert to lower-case
        CP      $6E             ; is character 'n' ?
        JR      Z,o0D00         ; forward to REPORT-D if so else scroll.

        LD      A,$FE           ; select system channel 'S'
        CALL    o1601           ; routine CHAN-OPEN
        POP     AF              ; restore original P_FLAG
        LD      ($5C91),A       ; and save in P_FLAG.
        POP     HL              ; restore original ATTR_T, MASK_T
        LD      (ATTR_T),HL     ; and reset ATTR_T, MASK-T as 'scroll?' has
                                ; been printed.

;; PO-SCR-3
o0CD2:  CALL    o0DFE           ; routine CL-SC-ALL to scroll whole display
        LD      B,(IY+$31)      ; fetch DF_SZ to B
        INC     B               ; increase to address last line of display
        LD      C,$21           ; set C to $21 (was $21 from above routine)
        PUSH    BC              ; save the line and column in BC.

        CALL    o0E9B           ; routine CL-ADDR finds display address.

        LD      A,H             ; now find the corresponding attribute byte
        RRCA                    ; (this code sequence is used twice
        RRCA                    ; elsewhere and is a candidate for
        RRCA                    ; a subroutine.)
        AND     $03             ;
        OR      $58             ;
        LD      H,A             ;

        LD      DE,$5AE0        ; start of last 'line' of attribute area
        LD      A,(DE)          ; get attribute for last line
        LD      C,(HL)          ; transfer to base line of upper part
        LD      B,$20           ; there are thirty two bytes
        EX      DE,HL           ; swap the pointers.

;; PO-SCR-3A
o0CF0:  LD      (DE),A          ; transfer
        LD      (HL),C          ; attributes.
        INC     DE              ; address next.
        INC     HL              ; address next.
        DJNZ    o0CF0           ; loop back to PO-SCR-3A for all adjacent
                                ; attribute lines.

        POP     BC              ; restore the line/column.
        RET                     ; return via CL-SET (was pushed on stack).

; ---

; The message 'scroll?' appears here with last byte inverted.

;; scrl-mssg
o0CF8:  DEFB    $80             ; initial step-over byte.
      IF spanish
        DEFM    "]MAS? "
        DEFB    ' '+$80
      ELSE
        DEFM    "scroll"
        DEFB    '?'+$80
      ENDIF

;; REPORT-D
o0D00:  RST     08H             ; ERROR-1
        DEFB    $0C             ; Error Report: BREAK - CONT repeats

; continue here if using lower display - A holds line number.

;; PO-SCR-4
o0D02:  CP      $02             ; is line number less than 2 ?
        JR      C,o0C86         ; to REPORT-5 if so
                                ; 'Out of Screen'.

        ADD     A,(IY+$31)      ; add DF_SZ
        SUB     $19             ;
        RET     NC              ; return if scrolling unnecessary

        NEG                     ; Negate to give number of scrolls required.
        PUSH    BC              ; save line/column
        LD      B,A             ; count to B
        LD      HL,(ATTR_T)     ; fetch current ATTR_T, MASK_T to HL.
        PUSH    HL              ; and save
        LD      HL,($5C91)      ; fetch P_FLAG
        PUSH    HL              ; and save.
                                ; to prevent corruption by input AT

        CALL    o0D4D           ; routine TEMPS sets to BORDCR etc
        LD      A,B             ; transfer scroll number to A.

;; PO-SCR-4A
o0D1C:  PUSH    AF              ; save scroll number.
        LD      HL,$5C6B        ; address DF_SZ
        LD      B,(HL)          ; fetch old value
        LD      A,B             ; transfer to A
        INC     A               ; and increment
        LD      (HL),A          ; then put back.
        LD      HL,$5C89        ; address S_POSN_hi - line
        CP      (HL)            ; compare
        JR      C,o0D2D         ; forward to PO-SCR-4B if scrolling required

        INC     (HL)            ; else increment S_POSN_hi
        LD      B,$18           ; set count to whole display ??
                                ; Note. should be $17 and the top line will be
                                ; scrolled into the ROM which is harmless on
                                ; the standard set up.
                                ; credit P.Giblin 1984.

;; PO-SCR-4B
o0D2D:  CALL    o0E00           ; routine CL-SCROLL scrolls B lines
        POP     AF              ; restore scroll counter.
        DEC     A               ; decrease
        JR      NZ,o0D1C        ; back to PO-SCR-4A until done

        POP     HL              ; restore original P_FLAG.
        LD      (IY+$57),L      ; and overwrite system variable P_FLAG.

        POP     HL              ; restore original ATTR_T/MASK_T.
        LD      (ATTR_T),HL     ; and update system variables.

        LD      BC,($5C88)      ; fetch S_POSN to BC.
        RES     0,(IY+$02)      ; signal to TV_FLAG  - main screen in use.
        CALL    o0DD9           ; call routine CL-SET for upper display.

        SET     0,(IY+$02)      ; signal to TV_FLAG  - lower screen in use.
        POP     BC              ; restore line/column
        RET                     ; return via CL-SET for lower display.

; ----------------------
; Temporary colour items
; ----------------------
; This subroutine is called 11 times to copy the permanent colour items
; to the temporary ones.

;; TEMPS
o0D4D:  XOR     A               ; clear the accumulator
        LD      HL,(ATTR_P)     ; fetch L=ATTR_P and H=MASK_P
        BIT     0,(IY+$02)      ; test TV_FLAG  - is lower screen in use ?
        JR      Z,o0D5B         ; skip to TEMPS-1 if not

        LD      H,A             ; set H, MASK P, to 00000000.
        LD      L,(IY+$0E)      ; fetch BORDCR to L which is used for lower
                                ; screen.

;; TEMPS-1
o0D5B:  LD      (ATTR_T),HL     ; transfer values to ATTR_T and MASK_T

; for the print flag the permanent values are odd bits, temporary even bits.

        LD      HL,$5C91        ; address P_FLAG.
        JR      NZ,o0D65        ; skip to TEMPS-2 if lower screen using A=0.

        LD      A,(HL)          ; else pick up flag bits.
        RRCA                    ; rotate permanent bits to temporary bits.

;; TEMPS-2
o0D65:  XOR     (HL)            ;
        AND     $55             ; BIN 01010101
        XOR     (HL)            ; permanent now as original
        LD      (HL),A          ; apply permanent bits to temporary bits.
        RET                     ; and return.

; -----------------
; THE 'CLS' COMMAND
; -----------------
;    This command clears the display.
;    The routine is also called during initialization and by the CLEAR command.
;    If it's difficult to write it should be difficult to read.

;; CLS
o0D6B:  CALL    o0DAF           ; Routine CL-ALL clears the entire display and
                                ; sets the attributes to the permanent ones
                                ; from ATTR-P.

;   Having cleared all 24 lines of the display area, continue into the
;   subroutine that clears the lower display area.  Note that at the moment
;   the attributes for the lower lines are the same as upper ones and have
;   to be changed to match the BORDER colour.

; --------------------------
; THE 'CLS-LOWER' SUBROUTINE
; --------------------------
;   This routine is called from INPUT, and from the MAIN execution loop.
;   This is very much a housekeeping routine which clears between 2 and 23
;   lines of the display, setting attributes and correcting situations where
;   errors have occurred while the normal input and output routines have been
;   temporarily diverted to deal with, say colour control codes.

;; CLS-LOWER
o0D6E:  LD      HL,$5C3C        ; address System Variable TV_FLAG.
        RES     5,(HL)          ; TV_FLAG - signal do not clear lower screen.
        SET     0,(HL)          ; TV_FLAG - signal lower screen in use.

        CALL    o0D4D           ; routine TEMPS applies permanent attributes,
                                ; in this case BORDCR to ATTR_T.
                                ; Note. this seems unnecessary and is repeated
                                ; within CL-LINE.

        LD      B,(IY+$31)      ; fetch lower screen display file size DF_SZ

        CALL    o0E44           ; routine CL-LINE clears lines to bottom of the
                                ; display and sets attributes from BORDCR while
                                ; preserving the B register.

        LD      HL,$5AC0        ; set initial attribute address to the leftmost
                                ; cell of second line up.

        LD      A,(ATTR_P)      ; fetch permanent attribute from ATTR_P.

        DEC     B               ; decrement lower screen display file size.

        JR      o0D8E           ; forward to enter the backfill loop at CLS-3
                                ; where B is decremented again.

; ---

;   The backfill loop is entered at midpoint and ensures, if more than 2
;   lines have been cleared, that any other lines take the permanent screen
;   attributes.

;; CLS-1
o0D87:  LD      C,$20           ; set counter to 32 character cells per line

;; CLS-2
o0D89:  DEC     HL              ; decrease attribute address.
        LD      (HL),A          ; and place attributes in next line up.
        DEC     C               ; decrease the 32 counter.
        JR      NZ,o0D89        ; loop back to CLS-2 until all 32 cells done.

;; CLS-3
o0D8E:  DJNZ    o0D87           ; decrease B counter and back to CLS-1
                                ; if not zero.

        LD      (IY+$31),$02    ; now set DF_SZ lower screen to 2

; This entry point is also called from CL-ALL below to
; reset the system channel input and output addresses to normal.

;; CL-CHAN
o0D94:  LD      A,$FD           ; select system channel 'K'

        CALL    o1601           ; routine CHAN-OPEN opens it.

        LD      HL,(CURCHL)     ; fetch CURCHL to HL to address current channel
        LD      DE,o09F4        ; set address to PRINT-OUT for first pass.
        AND     A               ; clear carry for first pass.

;; CL-CHAN-A
o0DA0:  LD      (HL),E          ; Insert the output address on the first pass
        INC     HL              ; or the input address on the second pass.
        LD      (HL),D          ;
        INC     HL              ;

        LD      DE,o10A8        ; fetch address KEY-INPUT for second pass
        CCF                     ; complement carry flag - will set on pass 1.

        JR      C,o0DA0         ; back to CL-CHAN-A if first pass else done.

        LD      BC,$1721        ; line 23 for lower screen
        JR      o0DD9           ; exit via CL-SET to set column
                                ; for lower display

; ---------------------------
; Clearing whole display area
; ---------------------------
; This subroutine called from CLS, AUTO-LIST and MAIN-3
; clears 24 lines of the display and resets the relevant system variables.
; This routine also recovers from an error situation where, for instance, an
; invalid colour or position control code has left the output routine addressing
; PO-TV-2 or PO-CONT.

;; CL-ALL
o0DAF:  LD      HL,$0000        ; Initialize plot coordinates.
        LD      ($5C7D),HL      ; Set system variable COORDS to 0,0.

        RES     0,(IY+$30)      ; update FLAGS2  - signal main screen is clear.

        CALL    o0D94           ; routine CL-CHAN makes channel 'K' 'normal'.

        LD      A,$FE           ; select system channel 'S'
        CALL    o1601           ; routine CHAN-OPEN opens it.

        CALL    o0D4D           ; routine TEMPS applies permanent attributes,
                                ; in this case ATTR_P, to ATTR_T.
                                ; Note. this seems unnecessary.

        LD      B,$18           ; There are 24 lines.

        CALL    o0E44           ; routine CL-LINE clears 24 text lines and sets
                                ; attributes from ATTR-P.
                                ; This routine preserves B and sets C to $21.

        LD      HL,(CURCHL)     ; fetch CURCHL make HL address output routine.

        LD      DE,o09F4        ; address: PRINT-OUT
        LD      (HL),E          ; is made
        INC     HL              ; the normal
        LD      (HL),D          ; output address.

        LD      (IY+$52),$01    ; set SCR_CT - scroll count - to default.

;   Note. BC already contains $1821.

        LD      BC,$1821        ; reset column and line to 0,0
                                ; and continue into CL-SET, below, exiting
                                ; via PO-STORE (for the upper screen).

; --------------------
; THE 'CL-SET' ROUTINE
; --------------------
; This important subroutine is used to calculate the character output
; address for screens or printer based on the line/column for screens
; or the column for printer.

;; CL-SET
o0DD9:  LD      HL,$5B00        ; the base address of printer buffer
        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        JR      NZ,o0DF4        ; forward to CL-SET-2 if so.

        LD      A,B             ; transfer line to A.
        BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
        JR      Z,o0DEE         ; skip to CL-SET-1 if handling upper part

        ADD     A,(IY+$31)      ; add DF_SZ for lower screen
        SUB     $18             ; and adjust.

;; CL-SET-1
o0DEE:  PUSH    BC              ; save the line/column.
        LD      B,A             ; transfer line to B
                                ; (adjusted if lower screen)

        CALL    o0E9B           ; routine CL-ADDR calculates address at left
                                ; of screen.
        POP     BC              ; restore the line/column.

;; CL-SET-2
o0DF4:  LD      A,$21           ; the column $01-$21 is reversed
        SUB     C               ; to range $00 - $20
        LD      E,A             ; now transfer to DE
        LD      D,$00           ; prepare for addition
        ADD     HL,DE           ; and add to base address

        JP      o0ADC           ; exit via PO-STORE to update the relevant
                                ; system variables.
; ----------------
; Handle scrolling
; ----------------
; The routine CL-SC-ALL is called once from PO to scroll all the display
; and from the routine CL-SCROLL, once, to scroll part of the display.

;; CL-SC-ALL
o0DFE:  LD      B,$17           ; scroll 23 lines, after 'scroll?'.

;; CL-SCROLL
o0E00:  CALL    o0E9B           ; routine CL-ADDR gets screen address in HL.
        LD      C,$08           ; there are 8 pixel lines to scroll.

;; CL-SCR-1
o0E05:  PUSH    BC              ; save counters.
        PUSH    HL              ; and initial address.
        LD      A,B             ; get line count.
        AND     $07             ; will set zero if all third to be scrolled.
        LD      A,B             ; re-fetch the line count.
        JR      NZ,o0E19        ; forward to CL-SCR-3 if partial scroll.

; HL points to top line of third and must be copied to bottom of previous 3rd.
; ( so HL = $4800 or $5000 ) ( but also sometimes $4000 )

;; CL-SCR-2
o0E0D:  EX      DE,HL           ; copy HL to DE.
        LD      HL,$F8E0        ; subtract $08 from H and add $E0 to L -
        ADD     HL,DE           ; to make destination bottom line of previous
                                ; third.
        EX      DE,HL           ; restore the source and destination.
        LD      BC,$0020        ; thirty-two bytes are to be copied.
        DEC     A               ; decrement the line count.
        LDIR                    ; copy a pixel line to previous third.

;; CL-SCR-3
o0E19:  EX      DE,HL           ; save source in DE.
        LD      HL,$FFE0        ; load the value -32.
        ADD     HL,DE           ; add to form destination in HL.
        EX      DE,HL           ; switch source and destination
        LD      B,A             ; save the count in B.
        AND     $07             ; mask to find count applicable to current
        RRCA                    ; third and
        RRCA                    ; multiply by
        RRCA                    ; thirty two (same as 5 RLCAs)

        LD      C,A             ; transfer byte count to C ($E0 at most)
        LD      A,B             ; store line count to A
        LD      B,$00           ; make B zero
        LDIR                    ; copy bytes (BC=0, H incremented, L=0)
        LD      B,$07           ; set B to 7, C is zero.
        ADD     HL,BC           ; add 7 to H to address next third.
        AND     $F8             ; has last third been done ?
        JR      NZ,o0E0D        ; back to CL-SCR-2 if not.

        POP     HL              ; restore topmost address.
        INC     H               ; next pixel line down.
        POP     BC              ; restore counts.
        DEC     C               ; reduce pixel line count.
        JR      NZ,o0E05        ; back to CL-SCR-1 if all eight not done.

        CALL    o0E88           ; routine CL-ATTR gets address in attributes
                                ; from current 'ninth line', count in BC.

        LD      HL,$FFE0        ; set HL to the 16-bit value -32.
        ADD     HL,DE           ; and add to form destination address.
        EX      DE,HL           ; swap source and destination addresses.
        LDIR                    ; copy bytes scrolling the linear attributes.
        LD      B,$01           ; continue to clear the bottom line.

; ------------------------------
; THE 'CLEAR TEXT LINES' ROUTINE
; ------------------------------
; This subroutine, called from CL-ALL, CLS-LOWER and AUTO-LIST and above,
; clears text lines at bottom of display.
; The B register holds on entry the number of lines to be cleared 1-24.

;; CL-LINE
o0E44:  PUSH    BC              ; save line count
        CALL    o0E9B           ; routine CL-ADDR gets top address
        LD      C,$08           ; there are eight screen lines to a text line.

;; CL-LINE-1
o0E4A:  PUSH    BC              ; save pixel line count
        PUSH    HL              ; and save the address
        LD      A,B             ; transfer the line to A (1-24).

;; CL-LINE-2
o0E4D:  AND     $07             ; mask 0-7 to consider thirds at a time
        RRCA                    ; multiply
        RRCA                    ; by 32  (same as five RLCA instructions)
        RRCA                    ; now 32 - 256(0)
        LD      C,A             ; store result in C
        LD      A,B             ; save line in A (1-24)
        LD      B,$00           ; set high byte to 0, prepare for ldir.
        DEC     C               ; decrement count 31-255.
        LD      D,H             ; copy HL
        LD      E,L             ; to DE.
        LD      (HL),$00        ; blank the first byte.
        INC     DE              ; make DE point to next byte.
        LDIR                    ; ldir will clear lines.
        LD      DE,$0701        ; now address next third adjusting
        ADD     HL,DE           ; register E to address left hand side
        DEC     A               ; decrease the line count.
        AND     $F8             ; will be 16, 8 or 0  (AND $18 will do).
        LD      B,A             ; transfer count to B.
        JR      NZ,o0E4D        ; back to CL-LINE-2 if 16 or 8 to do
                                ; the next third.

        POP     HL              ; restore start address.
        INC     H               ; address next line down.
        POP     BC              ; fetch counts.
        DEC     C               ; decrement pixel line count
        JR      NZ,o0E4A        ; back to CL-LINE-1 till all done.

        CALL    o0E88           ; routine CL-ATTR gets attribute address
                                ; in DE and B * 32 in BC.

        LD      H,D             ; transfer the address
        LD      L,E             ; to HL.

        INC     DE              ; make DE point to next location.

        LD      A,(ATTR_P)      ; fetch ATTR_P - permanent attributes
        BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
        JR      Z,o0E80         ; skip to CL-LINE-3 if not.

        LD      A,(BORDCR)      ; else lower screen uses BORDCR as attribute.

;; CL-LINE-3
o0E80:  LD      (HL),A          ; put attribute in first byte.
        DEC     BC              ; decrement the counter.
        LDIR                    ; copy bytes to set all attributes.
        POP     BC              ; restore the line $01-$24.
        LD      C,$21           ; make column $21. (No use is made of this)
        RET                     ; return to the calling routine.

; ------------------
; Attribute handling
; ------------------
; This subroutine is called from CL-LINE or CL-SCROLL with the HL register
; pointing to the 'ninth' line and H needs to be decremented before or after
; the division. Had it been done first then either present code or that used
; at the start of PO-ATTR could have been used.
; The Spectrum screen arrangement leads to the L register already holding
; the correct value for the attribute file and it is only necessary
; to manipulate H to form the correct colour attribute address.

;; CL-ATTR
o0E88:  LD      A,H             ; fetch H to A - $48, $50, or $58.
        RRCA                    ; divide by
        RRCA                    ; eight.
        RRCA                    ; $09, $0A or $0B.
        DEC     A               ; $08, $09 or $0A.
        OR      $50             ; $58, $59 or $5A.
        LD      H,A             ; save high byte of attributes.

        EX      DE,HL           ; transfer attribute address to DE
        LD      H,C             ; set H to zero - from last LDIR.
        LD      L,B             ; load L with the line from B.
        ADD     HL,HL           ; multiply
        ADD     HL,HL           ; by
        ADD     HL,HL           ; thirty two
        ADD     HL,HL           ; to give count of attribute
        ADD     HL,HL           ; cells to the end of display.

        LD      B,H             ; transfer the result
        LD      C,L             ; to register BC.

        RET                     ; return.

; -------------------------------
; Handle display with line number
; -------------------------------
; This subroutine is called from four places to calculate the address
; of the start of a screen character line which is supplied in B.

;; CL-ADDR
o0E9B:  LD      A,$18           ; reverse the line number
        SUB     B               ; to range $00 - $17.
        LD      D,A             ; save line in D for later.
        RRCA                    ; multiply
        RRCA                    ; by
        RRCA                    ; thirty-two.

        AND     $E0             ; mask off low bits to make
        LD      L,A             ; L a multiple of 32.

        LD      A,D             ; bring back the line to A.

        AND     $18             ; now $00, $08 or $10.

        OR      $40             ; add the base address of screen.

        LD      H,A             ; HL now has the correct address.
        RET                     ; return.

; -------------------
; Handle COPY command
; -------------------
; This command copies the top 176 lines to the ZX Printer
; It is popular to call this from machine code at point
; o0EAF with B holding 192 (and interrupts disabled) for a full-screen
; copy. This particularly applies to 16K Spectrums as time-critical
; machine code routines cannot be written in the first 16K of RAM as
; it is shared with the ULA which has precedence over the Z80 chip.

;; COPY
o0EAC:  DI                      ; disable interrupts as this is time-critical.

        LD      B,$B0           ; top 176 lines.
o0EAF:  LD      HL,$4000        ; address start of the display file.

; now enter a loop to handle each pixel line.

;; COPY-1
o0EB2:  PUSH    HL              ; save the screen address.
        PUSH    BC              ; and the line counter.

        CALL    o0EF4           ; routine COPY-LINE outputs one line.

        POP     BC              ; restore the line counter.
        POP     HL              ; and display address.
        INC     H               ; next line down screen within 'thirds'.
        LD      A,H             ; high byte to A.
        AND     $07             ; result will be zero if we have left third.
        JR      NZ,o0EC9        ; forward to COPY-2 if not to continue loop.

        LD      A,L             ; consider low byte first.
        ADD     A,$20           ; increase by 32 - sets carry if back to zero.
        LD      L,A             ; will be next group of 8.
        CCF                     ; complement - carry set if more lines in
                                ; the previous third.
        SBC     A,A             ; will be FF, if more, else 00.
        AND     $F8             ; will be F8 (-8) or 00.
        ADD     A,H             ; that is subtract 8, if more to do in third.
        LD      H,A             ; and reset address.

;; COPY-2
o0EC9:  DJNZ    o0EB2           ; back to COPY-1 for all lines.

        JR      o0EDA           ; forward to COPY-END to switch off the printer
                                ; motor and enable interrupts.
                                ; Note. Nothing else is required.

; ------------------------------
; Pass printer buffer to printer
; ------------------------------
; This routine is used to copy 8 text lines from the printer buffer
; to the ZX Printer. These text lines are mapped linearly so HL does
; not need to be adjusted at the end of each line.

;; COPY-BUFF
o0ECD:  DI                      ; disable interrupts
        LD      HL,$5B00        ; the base address of the Printer Buffer.
        LD      B,$08           ; set count to 8 lines of 32 bytes.

;; COPY-3
o0ED3:  PUSH    BC              ; save counter.

        CALL    o0EF4           ; routine COPY-LINE outputs 32 bytes

        POP     BC              ; restore counter.
        DJNZ    o0ED3           ; loop back to COPY-3 for all 8 lines.
                                ; then stop motor and clear buffer.

; Note. the COPY command rejoins here, essentially to execute the next
; three instructions.

;; COPY-END
o0EDA:  LD      A,$04           ; output value 4 to port
        OUT     ($FB),A         ; to stop the slowed printer motor.
        EI                      ; enable interrupts.

; --------------------
; Clear Printer Buffer
; --------------------
; This routine clears an arbitrary 256 bytes of memory.
; Note. The routine seems designed to clear a buffer that follows the
; system variables.
; The routine should check a flag or HL address and simply return if COPY
; is in use.
; As a consequence of this omission the buffer will needlessly
; be cleared when COPY is used and the screen/printer position may be set to
; the start of the buffer and the line number to 0 (B)
; giving an 'Out of Screen' error.
; There seems to have been an unsuccessful attempt to circumvent the use
; of PR_CC_hi.

;; CLEAR-PRB
o0EDF:  LD      HL,$5B00        ; the location of the buffer.
        LD      (IY+$46),L      ; update PR_CC_lo - set to zero - superfluous.
        XOR     A               ; clear the accumulator.
        LD      B,A             ; set count to 256 bytes.

;; PRB-BYTES
o0EE7:  LD      (HL),A          ; set addressed location to zero.
        INC     HL              ; address next byte - Note. not INC L.
        DJNZ    o0EE7           ; back to PRB-BYTES. repeat for 256 bytes.

        RES     1,(IY+$30)      ; set FLAGS2 - signal printer buffer is clear.
        LD      C,$21           ; set the column position .
        JP      o0DD9           ; exit via CL-SET and then PO-STORE.

; -----------------
; Copy line routine
; -----------------
; This routine is called from COPY and COPY-BUFF to output a line of
; 32 bytes to the ZX Printer.
; Output to port $FB -
; bit 7 set - activate stylus.
; bit 7 low - deactivate stylus.
; bit 2 set - stops printer.
; bit 2 reset - starts printer
; bit 1 set - slows printer.
; bit 1 reset - normal speed.

;; COPY-LINE
o0EF4:  LD      A,B             ; fetch the counter 1-8 or 1-176
        CP      $03             ; is it 01 or 02 ?.
        SBC     A,A             ; result is $FF if so else $00.
        AND     $02             ; result is 02 now else 00.
                                ; bit 1 set slows the printer.
        OUT     ($FB),A         ; slow the printer for the
                                ; last two lines.
        LD      D,A             ; save the mask to control the printer later.

;; COPY-L-1
o0EFD:  CALL    o1F54           ; call BREAK-KEY to read keyboard immediately.
        JR      C,o0F0C         ; forward to COPY-L-2 if 'break' not pressed.

        LD      A,$04           ; else stop the
        OUT     ($FB),A         ; printer motor.
        EI                      ; enable interrupts.
        CALL    o0EDF           ; call routine CLEAR-PRB.
                                ; Note. should not be cleared if COPY in use.

;; REPORT-Dc
o0F0A:  RST     08H             ; ERROR-1
        DEFB    $0C             ; Error Report: BREAK - CONT repeats

;; COPY-L-2
o0F0C:  IN      A,($FB)         ; test now to see if
        ADD     A,A             ; a printer is attached.
        RET     M               ; return if not - but continue with parent
                                ; command.

        JR      NC,o0EFD        ; back to COPY-L-1 if stylus of printer not
                                ; in position.

        LD      C,$20           ; set count to 32 bytes.

;; COPY-L-3
o0F14:  LD      E,(HL)          ; fetch a byte from line.
        INC     HL              ; address next location. Note. not INC L.
        LD      B,$08           ; count the bits.

;; COPY-L-4
o0F18:  RL      D               ; prepare mask to receive bit.
        RL      E               ; rotate leftmost print bit to carry
        RR      D               ; and back to bit 7 of D restoring bit 1

;; COPY-L-5
o0F1E:  IN      A,($FB)         ; read the port.
        RRA                     ; bit 0 to carry.
        JR      NC,o0F1E        ; back to COPY-L-5 if stylus not in position.

        LD      A,D             ; transfer command bits to A.
        OUT     ($FB),A         ; and output to port.
        DJNZ    o0F18           ; loop back to COPY-L-4 for all 8 bits.

        DEC     C               ; decrease the byte count.
        JR      NZ,o0F14        ; back to COPY-L-3 until 256 bits done.

        RET                     ; return to calling routine COPY/COPY-BUFF.


; ----------------------------------
; Editor routine for BASIC and INPUT
; ----------------------------------
; The editor is called to prepare or edit a BASIC line.
; It is also called from INPUT to input a numeric or string expression.
; The behaviour and options are quite different in the various modes
; and distinguished by bit 5 of FLAGX.
;
; This is a compact and highly versatile routine.

;; EDITOR
o0F2C:  LD      HL,(ERR_SP)     ; fetch ERR_SP
        PUSH    HL              ; save on stack

;; ED-AGAIN
o0F30:  LD      HL,o107F        ; address: ED-ERROR
        PUSH    HL              ; save address on stack and
        LD      (ERR_SP),SP     ; make ERR_SP point to it.

; Note. While in editing/input mode should an error occur then RST 08 will
; update X_PTR to the location reached by CH_ADD and jump to ED-ERROR
; where the error will be cancelled and the loop begin again from ED-AGAIN
; above. The position of the error will be apparent when the lower screen is
; reprinted. If no error then the re-iteration is to ED-LOOP below when
; input is arriving from the keyboard.

;; ED-LOOP
o0F38:  CALL    o15D4           ; routine WAIT-KEY gets key possibly
                                ; changing the mode.
        PUSH    AF              ; save key.
        LD      D,$00           ; and give a short click based
        LD      E,(IY-$01)      ; on PIP value for duration.
        LD      HL,$00C8        ; and pitch.
        CALL    o03B5           ; routine BEEPER gives click - effective
                                ; with rubber keyboard.
        POP     AF              ; get saved key value.
        LD      HL,o0F38        ; address: ED-LOOP is loaded to HL.
        PUSH    HL              ; and pushed onto stack.

; At this point there is a looping return address on the stack, an error
; handler and an input stream set up to supply characters.
; The character that has been received can now be processed.

        CP      $18             ; range 24 to 255 ?
        JR      NC,o0F81        ; forward to ADD-CHAR if so.

        CP      $07             ; lower than 7 ?
        JR      C,o0F81         ; forward to ADD-CHAR also.
                                ; Note. This is a 'bug' and chr$ 6, the comma
                                ; control character, should have had an
                                ; entry in the ED-KEYS table.
                                ; Steven Vickers, 1984, Pitman.

        CP      $10             ; less than 16 ?
        JR      C,o0F92         ; forward to ED-KEYS if editing control
                                ; range 7 to 15 dealt with by a table

        LD      BC,$0002        ; prepare for ink/paper etc.
        LD      D,A             ; save character in D
        CP      $16             ; is it ink/paper/bright etc. ?
        JR      C,o0F6C         ; forward to ED-CONTR if so

                                ; leaves 22d AT and 23d TAB
                                ; which can't be entered via KEY-INPUT.
                                ; so this code is never normally executed
                                ; when the keyboard is used for input.

        INC     BC              ; if it was AT/TAB - 3 locations required
        BIT     7,(IY+$37)      ; test FLAGX  - Is this INPUT LINE ?
        JP      Z,o101E         ; jump to ED-IGNORE if not, else

        CALL    o15D4           ; routine WAIT-KEY - input address is KEY-NEXT
                                ; but is reset to KEY-INPUT
        LD      E,A             ; save first in E

;; ED-CONTR
o0F6C:  CALL    o15D4           ; routine WAIT-KEY for control.
                                ; input address will be key-next.

        PUSH    DE              ; saved code/parameters
        LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
        RES     0,(IY+$07)      ; set MODE to 'L'

        CALL    o1655           ; routine MAKE-ROOM makes 2/3 spaces at cursor

        POP     BC              ; restore code/parameters
        INC     HL              ; address first location
        LD      (HL),B          ; place code (ink etc.)
        INC     HL              ; address next
        LD      (HL),C          ; place possible parameter. If only one
                                ; then DE points to this location also.
        JR      o0F8B           ; forward to ADD-CH-1

; ------------------------
; Add code to current line
; ------------------------
; this is the branch used to add normal non-control characters
; with ED-LOOP as the stacked return address.
; it is also the OUTPUT service routine for system channel 'R'.

;; ADD-CHAR
o0F81:  RES     0,(IY+$07)      ; set MODE to 'L'
o0F85:  LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
        CALL    o1652           ; routine ONE-SPACE creates one space.

; either a continuation of above or from ED-CONTR with ED-LOOP on stack.

;; ADD-CH-1
o0F8B:  LD      (DE),A          ; load current character to last new location.
        INC     DE              ; address next
        LD      ($5C5B),DE      ; and update K_CUR system variable.
        RET                     ; return - either a simple return
                                ; from ADD-CHAR or to ED-LOOP on stack.

; ---

; a branch of the editing loop to deal with control characters
; using a look-up table.

;; ED-KEYS
o0F92:  LD      E,A             ; character to E.
        LD      D,$00           ; prepare to add.
        LD      HL,o0FA0 - 7    ; base address of editing keys table. $0F99
        ADD     HL,DE           ; add E
        LD      E,(HL)          ; fetch offset to E
        ADD     HL,DE           ; add offset for address of handling routine.
        PUSH    HL              ; push the address on machine stack.
        LD      HL,($5C5B)      ; load address of cursor from K_CUR.
        RET                     ; Make an indirect jump forward to routine.

; ------------------
; Editing keys table
; ------------------
; For each code in the range $07 to $0F this table contains a
; single offset byte to the routine that services that code.
; Note. for what was intended there should also have been an
; entry for chr$ 6 with offset to ed-symbol.

;; ed-keys-t
o0FA0:  DEFB    o0FA9 - $  ; 07d offset $09 to Address: ED-EDIT
        DEFB    o1007 - $  ; 08d offset $66 to Address: ED-LEFT
        DEFB    o100C - $  ; 09d offset $6A to Address: ED-RIGHT
        DEFB    o0FF3 - $  ; 10d offset $50 to Address: ED-DOWN
        DEFB    o1059 - $  ; 11d offset $B5 to Address: ED-UP
        DEFB    o1015 - $  ; 12d offset $70 to Address: ED-DELETE
        DEFB    o1024 - $  ; 13d offset $7E to Address: ED-ENTER
        DEFB    o1076 - $  ; 14d offset $CF to Address: ED-SYMBOL
        DEFB    o107C - $  ; 15d offset $D4 to Address: ED-GRAPH

; ---------------
; Handle EDIT key
; ---------------
; The user has pressed SHIFT 1 to bring edit line down to bottom of screen.
; Alternatively the user wishes to clear the input buffer and start again.
; Alternatively ...

;; ED-EDIT
o0FA9:  LD      HL,($5C49)      ; fetch E_PPC the last line number entered.
                                ; Note. may not exist and may follow program.
        BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
        JP      NZ,o1097        ; jump forward to CLEAR-SP if not in editor.

        CALL    o196E           ; routine LINE-ADDR to find address of line
                                ; or following line if it doesn't exist.
        CALL    o1695           ; routine LINE-NO will get line number from
                                ; address or previous line if at end-marker.
        LD      A,D             ; if there is no program then DE will
        OR      E               ; contain zero so test for this.
        JP      Z,o1097         ; jump to CLEAR-SP if so.

; Note. at this point we have a validated line number, not just an
; approximation and it would be best to update E_PPC with the true
; cursor line value which would enable the line cursor to be suppressed
; in all situations - see shortly.

        PUSH    HL              ; save address of line.
        INC     HL              ; address low byte of length.
        LD      C,(HL)          ; transfer to C
        INC     HL              ; next to high byte
        LD      B,(HL)          ; transfer to B.
        LD      HL,$000A        ; an overhead of ten bytes
        ADD     HL,BC           ; is added to length.
        LD      B,H             ; transfer adjusted value
        LD      C,L             ; to BC register.
        CALL    o1F05           ; routine TEST-ROOM checks free memory.
        CALL    o1097           ; routine CLEAR-SP clears editing area.
        LD      HL,(CURCHL)     ; address CURCHL
        EX      (SP),HL         ; swap with line address on stack
        PUSH    HL              ; save line address underneath

        LD      A,$FF           ; select system channel 'R'
        CALL    o1601           ; routine CHAN-OPEN opens it

        POP     HL              ; drop line address
        DEC     HL              ; make it point to first byte of line num.
        DEC     (IY+$0F)        ; decrease E_PPC_lo to suppress line cursor.
                                ; Note. ineffective when E_PPC is one
                                ; greater than last line of program perhaps
                                ; as a result of a delete.
                                ; credit. Paul Harrison 1982.

        CALL    o1855           ; routine OUT-LINE outputs the BASIC line
                                ; to the editing area.
        INC     (IY+$0F)        ; restore E_PPC_lo to the previous value.
        LD      HL,($5C59)      ; address E_LINE in editing area.
        INC     HL              ; advance
        INC     HL              ; past space
        INC     HL              ; and digit characters
        INC     HL              ; of line number.

        LD      ($5C5B),HL      ; update K_CUR to address start of BASIC.
        POP     HL              ; restore the address of CURCHL.
        CALL    o1615           ; routine CHAN-FLAG sets flags for it.

        RET                     ; RETURN to ED-LOOP.

; -------------------
; Cursor down editing
; -------------------
;   The BASIC lines are displayed at the top of the screen and the user
;   wishes to move the cursor down one line in edit mode.
;   With INPUT LINE, this key must be used instead of entering STOP.

;; ED-DOWN
o0FF3:  BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
        JR      NZ,o1001        ; skip to ED-STOP if so

        LD      HL,$5C49        ; address E_PPC - 'current line'
        CALL    o190F           ; routine LN-FETCH fetches number of next
                                ; line or same if at end of program.
        JR      o106E           ; forward to ED-LIST to produce an
                                ; automatic listing.

; ---

;; ED-STOP
o1001:  LD      (IY+$00),$10    ; set ERR_NR to 'STOP in INPUT' code
        JR      o1024           ; forward to ED-ENTER to produce error.

; -------------------
; Cursor left editing
; -------------------
; This acts on the cursor in the lower section of the screen in both
; editing and input mode.

;; ED-LEFT
o1007:  CALL    o1031           ; routine ED-EDGE moves left if possible
        JR      o1011           ; forward to ED-CUR to update K-CUR
                                ; and return to ED-LOOP.

; --------------------
; Cursor right editing
; --------------------
; This acts on the cursor in the lower screen in both editing and input
; mode and moves it to the right.

;; ED-RIGHT
o100C:  LD      A,(HL)          ; fetch addressed character.
        CP      $0D             ; is it carriage return ?
        RET     Z               ; return if so to ED-LOOP

        INC     HL              ; address next character

;; ED-CUR
o1011:  LD      ($5C5B),HL      ; update K_CUR system variable
        RET                     ; return to ED-LOOP

; --------------
; DELETE editing
; --------------
; This acts on the lower screen and deletes the character to left of
; cursor. If control characters are present these are deleted first
; leaving the naked parameter (0-7) which appears as a '?' except in the
; case of chr$ 6 which is the comma control character. It is not mandatory
; to delete these second characters.

;; ED-DELETE
o1015:  CALL    o1031           ; routine ED-EDGE moves cursor to left.
        LD      BC,$0001        ; of character to be deleted.
        JP      o19E8           ; to RECLAIM-2 reclaim the character.

; ------------------------------------------
; Ignore next 2 codes from key-input routine
; ------------------------------------------
; Since AT and TAB cannot be entered this point is never reached
; from the keyboard. If inputting from a tape device or network then
; the control and two following characters are ignored and processing
; continues as if a carriage return had been received.
; Here, perhaps, another Spectrum has said print #15; AT 0,0; "This is yellow"
; and this one is interpreting input #15; a$.

;; ED-IGNORE
o101E:  CALL    o15D4           ; routine WAIT-KEY to ignore keystroke.
        CALL    o15D4           ; routine WAIT-KEY to ignore next key.

; -------------
; Enter/newline
; -------------
; The enter key has been pressed to have BASIC line or input accepted.

;; ED-ENTER
o1024:  POP     HL              ; discard address ED-LOOP
        POP     HL              ; drop address ED-ERROR

;; ED-END
o1026:  POP     HL              ; the previous value of ERR_SP
        LD      (ERR_SP),HL     ; is restored to ERR_SP system variable
        BIT     7,(IY+$00)      ; is ERR_NR $FF (= 'OK') ?
        RET     NZ              ; return if so

        LD      SP,HL           ; else put error routine on stack
        RET                     ; and make an indirect jump to it.

; -----------------------------
; Move cursor left when editing
; -----------------------------
; This routine moves the cursor left. The complication is that it must
; not position the cursor between control codes and their parameters.
; It is further complicated in that it deals with TAB and AT characters
; which are never present from the keyboard.
; The method is to advance from the beginning of the line each time,
; jumping one, two, or three characters as necessary saving the original
; position at each jump in DE. Once it arrives at the cursor then the next
; legitimate leftmost position is in DE.

;; ED-EDGE
o1031:  SCF                     ; carry flag must be set to call the nested
        CALL    o1195           ; subroutine SET-DE.
                                ; if input   then DE=WORKSP
                                ; if editing then DE=E_LINE
        SBC     HL,DE           ; subtract address from start of line
        ADD     HL,DE           ; and add back.
        INC     HL              ; adjust for carry.
        POP     BC              ; drop return address
        RET     C               ; return to ED-LOOP if already at left
                                ; of line.

        PUSH    BC              ; resave return address - ED-LOOP.
        LD      B,H             ; transfer HL - cursor address
        LD      C,L             ; to BC register pair.
                                ; at this point DE addresses start of line.

;; ED-EDGE-1
o103E:  LD      H,D             ; transfer DE - leftmost pointer
        LD      L,E             ; to HL
        INC     HL              ; address next leftmost character to
                                ; advance position each time.
        LD      A,(DE)          ; pick up previous in A
        AND     $F0             ; lose the low bits
        CP      $10             ; is it INK to TAB $10-$1F ?
                                ; that is, is it followed by a parameter ?
        JR      NZ,o1051        ; to ED-EDGE-2 if not
                                ; HL has been incremented once

        INC     HL              ; address next as at least one parameter.

; in fact since 'tab' and 'at' cannot be entered the next section seems
; superfluous.
; The test will always fail and the jump to ED-EDGE-2 will be taken.

        LD      A,(DE)          ; reload leftmost character
        SUB     $17             ; decimal 23 ('tab')
        ADC     A,$00           ; will be 0 for 'tab' and 'at'.
        JR      NZ,o1051        ; forward to ED-EDGE-2 if not
                                ; HL has been incremented twice

        INC     HL              ; increment a third time for 'at'/'tab'

;; ED-EDGE-2
o1051:  AND     A               ; prepare for true subtraction
        SBC     HL,BC           ; subtract cursor address from pointer
        ADD     HL,BC           ; and add back
                                ; Note when HL matches the cursor position BC,
                                ; there is no carry and the previous
                                ; position is in DE.
        EX      DE,HL           ; transfer result to DE if looping again.
                                ; transfer DE to HL to be used as K-CUR
                                ; if exiting loop.
        JR      C,o103E         ; back to ED-EDGE-1 if cursor not matched.

        RET                     ; return.

; -----------------
; Cursor up editing
; -----------------
; The main screen displays part of the BASIC program and the user wishes
; to move up one line scrolling if necessary.
; This has no alternative use in input mode.

;; ED-UP
o1059:  BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
        RET     NZ              ; return if not in editor - to ED-LOOP.

        LD      HL,($5C49)      ; get current line from E_PPC
        CALL    o196E           ; routine LINE-ADDR gets address
        EX      DE,HL           ; and previous in DE
        CALL    o1695           ; routine LINE-NO gets prev line number
        LD      HL,$5C4A        ; set HL to E_PPC_hi as next routine stores
                                ; top first.
        CALL    o191C           ; routine LN-STORE loads DE value to HL
                                ; high byte first - E_PPC_lo takes E

; this branch is also taken from ed-down.

;; ED-LIST
o106E:  CALL    o1795           ; routine AUTO-LIST lists to upper screen
                                ; including adjusted current line.
        LD      A,$00           ; select lower screen again
        JP      o1601           ; exit via CHAN-OPEN to ED-LOOP

; --------------------------------
; Use of symbol and graphics codes
; --------------------------------
; These will not be encountered with the keyboard but would be handled
; otherwise as follows.
; As noted earlier, Vickers says there should have been an entry in
; the KEYS table for chr$ 6 which also pointed here.
; If, for simplicity, two Spectrums were both using #15 as a bi-directional
; channel connected to each other:-
; then when the other Spectrum has said PRINT #15; x, y
; input #15; i ; j  would treat the comma control as a newline and the
; control would skip to input j.
; You can get round the missing chr$ 6 handler by sending multiple print
; items separated by a newline '.

; chr$14 would have the same functionality.

; This is chr$ 14.
;; ED-SYMBOL
o1076:  BIT     7,(IY+$37)      ; test FLAGX - is this INPUT LINE ?
        JR      Z,o1024         ; back to ED-ENTER if not to treat as if
                                ; enter had been pressed.
                                ; else continue and add code to buffer.

; Next is chr$ 15
; Note that ADD-CHAR precedes the table so we can't offset to it directly.

;; ED-GRAPH
o107C:  JP      o0F81           ; jump back to ADD-CHAR

; --------------------
; Editor error routine
; --------------------
; If an error occurs while editing, or inputting, then ERR_SP
; points to the stack location holding address ED_ERROR.

;; ED-ERROR
o107F:  BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
        JR      Z,o1026         ; back to ED-END if not.

; but as long as we're editing lines or inputting from the keyboard, then
; we've run out of memory so give a short rasp.

        LD      (IY+$00),$FF    ; reset ERR_NR to 'OK'.
        LD      D,$00           ; prepare for beeper.
        LD      E,(IY-$02)      ; use RASP value.
        LD      HL,$1A90        ; set the pitch - or tone period.
        CALL    o03B5           ; routine BEEPER emits a warning rasp.
        JP      o0F30           ; to ED-AGAIN to re-stack address of
                                ; this routine and make ERR_SP point to it.

; ---------------------
; Clear edit/work space
; ---------------------
; The editing area or workspace is cleared depending on context.
; This is called from ED-EDIT to clear workspace if edit key is
; used during input, to clear editing area if no program exists
; and to clear editing area prior to copying the edit line to it.
; It is also used by the error routine to clear the respective
; area depending on FLAGX.

;; CLEAR-SP
o1097:  PUSH    HL              ; preserve HL
        CALL    o1190           ; routine SET-HL
                                ; if in edit   HL = WORKSP-1, DE = E_LINE
                                ; if in input  HL = STKBOT,   DE = WORKSP
        DEC     HL              ; adjust
        CALL    o19E5           ; routine RECLAIM-1 reclaims space
        LD      ($5C5B),HL      ; set K_CUR to start of empty area
        LD      (IY+$07),$00    ; set MODE to 'KLC'
        POP     HL              ; restore HL.
        RET                     ; return.

; ----------------------------
; THE 'KEYBOARD INPUT' ROUTINE
; ----------------------------
; This is the service routine for the input stream of the keyboard channel 'K'.

;; KEY-INPUT
o10A8:  BIT     3,(IY+$02)      ; test TV_FLAG  - has a key been pressed in
                                ; editor ?

        CALL    NZ,o111D        ; routine ED-COPY, if so, to reprint the lower
                                ; screen at every keystroke/mode change.

        AND     A               ; clear carry flag - required exit condition.

        BIT     5,(IY+$01)      ; test FLAGS  - has a new key been pressed ?
        RET     Z               ; return if not.                        >>

        LD      A,($5C08)       ; system variable LASTK will hold last key -
                                ; from the interrupt routine.

        RES     5,(IY+$01)      ; update FLAGS  - reset the new key flag.
        PUSH    AF              ; save the input character.

        BIT     5,(IY+$02)      ; test TV_FLAG  - clear lower screen ?

        CALL    NZ,o0D6E        ; routine CLS-LOWER if so.

        POP     AF              ; restore the character code.

        CP      $20             ; if space or higher then
        JR      NC,o111B        ; forward to KEY-DONE2 and return with carry
                                ; set to signal key-found.

        CP      $10             ; with 16d INK and higher skip
        JR      NC,o10FA        ; forward to KEY-CONTR.

        CP      $06             ; for 6 - 15d
        JR      NC,o10DB        ; skip forward to KEY-M-CL to handle Modes
                                ; and CapsLock.

; that only leaves 0-5, the flash bright inverse switches.

        LD      B,A             ; save character in B
        AND     $01             ; isolate the embedded parameter (0/1).
        LD      C,A             ; and store in C
        LD      A,B             ; re-fetch copy (0-5)
        RRA                     ; halve it 0, 1 or 2.
        ADD     A,$12           ; add 18d gives 'flash', 'bright'
                                ; and 'inverse'.
        JR      o1105           ; forward to KEY-DATA with the
                                ; parameter (0/1) in C.

; ---

; Now separate capslock 06 from modes 7-15.

;; KEY-M-CL
o10DB:  JR      NZ,o10E6        ; forward to KEY-MODE if not 06 (capslock)

        LD      HL,$5C6A        ; point to FLAGS2
        LD      A,$08           ; value 00001000
        XOR     (HL)            ; toggle BIT 3 of FLAGS2 the capslock bit
        LD      (HL),A          ; and store result in FLAGS2 again.
        JR      o10F4           ; forward to KEY-FLAG to signal no-key.

; ---

;; KEY-MODE
o10E6:  CP      $0E             ; compare with chr 14d
        RET     C               ; return with carry set "key found" for
                                ; codes 7 - 13d leaving 14d and 15d
                                ; which are converted to mode codes.

        SUB     $0D             ; subtract 13d leaving 1 and 2
                                ; 1 is 'E' mode, 2 is 'G' mode.
        LD      HL,$5C41        ; address the MODE system variable.
        CP      (HL)            ; compare with existing value before
        LD      (HL),A          ; inserting the new value.
        JR      NZ,o10F4        ; forward to KEY-FLAG if it has changed.

        LD      (HL),$00        ; else make MODE zero - KLC mode
                                ; Note. while in Extended/Graphics mode,
                                ; the Extended Mode/Graphics key is pressed
                                ; again to get out.

;; KEY-FLAG
o10F4:  SET     3,(IY+$02)      ; update TV_FLAG  - show key state has changed
        CP      A               ; clear carry and reset zero flags -
                                ; no actual key returned.
        RET                     ; make the return.

; ---

; now deal with colour controls - 16-23 ink, 24-31 paper

;; KEY-CONTR
o10FA:  LD      B,A             ; make a copy of character.
        AND     $07             ; mask to leave bits 0-7
        LD      C,A             ; and store in C.
        LD      A,$10           ; initialize to 16d - INK.
        BIT     3,B             ; was it paper ?
        JR      NZ,o1105        ; forward to KEY-DATA with INK 16d and
                                ; colour in C.

        INC     A               ; else change from INK to PAPER (17d) if so.

;; KEY-DATA
o1105:  LD      (IY-$2D),C      ; put the colour (0-7)/state(0/1) in KDATA
        LD      DE,o110D        ; address: KEY-NEXT will be next input stream
        JR      o1113           ; forward to KEY-CHAN to change it ...

; ---

; ... so that INPUT_AD directs control to here at next call to WAIT-KEY

;; KEY-NEXT
o110D:  LD      A,($5C0D)       ; pick up the parameter stored in KDATA.
        LD      DE,o10A8        ; address: KEY-INPUT will be next input stream
                                ; continue to restore default channel and
                                ; make a return with the control code.

;; KEY-CHAN
o1113:  LD      HL,(CHANS)      ; address start of CHANNELS area using CHANS
                                ; system variable.
                                ; Note. One might have expected CURCHL to
                                ; have been used.
        INC     HL              ; step over the
        INC     HL              ; output address
        LD      (HL),E          ; and update the input
        INC     HL              ; routine address for
        LD      (HL),D          ; the next call to WAIT-KEY.

;; KEY-DONE2
o111B:  SCF                     ; set carry flag to show a key has been found
        RET                     ; and return.

; --------------------
; Lower screen copying
; --------------------
; This subroutine is called whenever the line in the editing area or
; input workspace is required to be printed to the lower screen.
; It is by calling this routine after any change that the cursor, for
; instance, appears to move to the left.
; Remember the edit line will contain characters and tokens
; e.g. "1000 LET a=1" is 8 characters.

;; ED-COPY
o111D:  CALL    o0D4D           ; routine TEMPS sets temporary attributes.
        RES     3,(IY+$02)      ; update TV_FLAG  - signal no change in mode
        RES     5,(IY+$02)      ; update TV_FLAG  - signal don't clear lower
                                ; screen.
        LD      HL,($5C8A)      ; fetch SPOSNL
        PUSH    HL              ; and save on stack.

        LD      HL,(ERR_SP)     ; fetch ERR_SP
        PUSH    HL              ; and save also
        LD      HL,o1167        ; address: ED-FULL
        PUSH    HL              ; is pushed as the error routine
        LD      (ERR_SP),SP     ; and ERR_SP made to point to it.

        LD      HL,($5C82)      ; fetch ECHO_E
        PUSH    HL              ; and push also

        SCF                     ; set carry flag to control SET-DE
        CALL    o1195           ; call routine SET-DE
                                ; if in input DE = WORKSP
                                ; if in edit  DE = E_LINE
        EX      DE,HL           ; start address to HL

        CALL    o187D           ; routine OUT-LINE2 outputs entire line up to
                                ; carriage return including initial
                                ; characterized line number when present.
        EX      DE,HL           ; transfer new address to DE
        CALL    o18E1           ; routine OUT-CURS considers a
                                ; terminating cursor.

        LD      HL,($5C8A)      ; fetch updated SPOSNL
        EX      (SP),HL         ; exchange with ECHO_E on stack
        EX      DE,HL           ; transfer ECHO_E to DE
        CALL    o0D4D           ; routine TEMPS to re-set attributes
                                ; if altered.

; the lower screen was not cleared, at the outset, so if deleting then old
; text from a previous print may follow this line and requires blanking.

;; ED-BLANK
o1150:  LD      A,($5C8B)       ; fetch SPOSNL_hi is current line
        SUB     D               ; compare with old
        JR      C,o117C         ; forward to ED-C-DONE if no blanking

        JR      NZ,o115E        ; forward to ED-SPACES if line has changed

        LD      A,E             ; old column to A
        SUB     (IY+$50)        ; subtract new in SPOSNL_lo
        JR      NC,o117C        ; forward to ED-C-DONE if no backfilling.

;; ED-SPACES
o115E:  LD      A,$20           ; prepare a space.
        PUSH    DE              ; save old line/column.
        CALL    o09F4           ; routine PRINT-OUT prints a space over
                                ; any text from previous print.
                                ; Note. Since the blanking only occurs when
                                ; using $09F4 to print to the lower screen,
                                ; there is no need to vector via a RST 10
                                ; and we can use this alternate set.
        POP     DE              ; restore the old line column.
        JR      o1150           ; back to ED-BLANK until all old text blanked.

; -------------------------------
; THE 'EDITOR-FULL' ERROR ROUTINE
; -------------------------------
;   This is the error routine addressed by ERR_SP.  This is not for the out of
;   memory situation as we're just printing.  The pitch and duration are exactly
;   the same as used by ED-ERROR from which this has been augmented.  The
;   situation is that the lower screen is full and a rasp is given to suggest
;   that this is perhaps not the best idea you've had that day.

;; ED-FULL
o1167:  LD      D,$00           ; prepare to moan.
        LD      E,(IY-$02)      ; fetch RASP value.
        LD      HL,$1A90        ; set pitch or tone period.

        CALL    o03B5           ; routine BEEPER.

        LD      (IY+$00),$FF    ; clear ERR_NR.
        LD      DE,($5C8A)      ; fetch SPOSNL.
        JR      o117E           ; forward to ED-C-END

; -------

; the exit point from line printing continues here.

;; ED-C-DONE
o117C:  POP     DE              ; fetch new line/column.
        POP     HL              ; fetch the error address.

; the error path rejoins here.

;; ED-C-END
o117E:  POP     HL              ; restore the old value of ERR_SP.
        LD      (ERR_SP),HL     ; update the system variable ERR_SP

        POP     BC              ; old value of SPOSN_L
        PUSH    DE              ; save new value

        CALL    o0DD9           ; routine CL-SET and PO-STORE
                                ; update ECHO_E and SPOSN_L from BC

        POP     HL              ; restore new value
        LD      ($5C82),HL      ; and overwrite ECHO_E

        LD      (IY+$26),$00    ; make error pointer X_PTR_hi out of bounds

        RET                     ; return

; -----------------------------------------------
; Point to first and last locations of work space
; -----------------------------------------------
;   These two nested routines ensure that the appropriate pointers are
;   selected for the editing area or workspace. The routines that call
;   these routines are designed to work on either area.

; this routine is called once

;; SET-HL
o1190:  LD      HL,($5C61)      ; fetch WORKSP to HL.
        DEC     HL              ; point to last location of editing area.
        AND     A               ; clear carry to limit exit points to first
                                ; or last.

; this routine is called with carry set and exits at a conditional return.

;; SET-DE
o1195:  LD      DE,($5C59)      ; fetch E_LINE to DE
        BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
        RET     Z               ; return now if in editing mode

        LD      DE,($5C61)      ; fetch WORKSP to DE
        RET     C               ; return if carry set ( entry = set-de)

        LD      HL,($5C63)      ; fetch STKBOT to HL as well
        RET                     ; and return  (entry = set-hl (in input))

; -----------------------------------
; THE 'REMOVE FLOATING POINT' ROUTINE
; -----------------------------------
;   When a BASIC LINE or the INPUT BUFFER is parsed any numbers will have
;   an invisible chr 14d inserted after them and the 5-byte integer or
;   floating point form inserted after that.  Similar invisible value holders
;   are also created after the numeric and string variables in a DEF FN list.
;   This routine removes these 'compiled' numbers from the edit line or
;   input workspace.

;; REMOVE-FP
o11A7:  LD      A,(HL)          ; fetch character
        CP      $0E             ; is it the CHR$ 14 number marker ?
        LD      BC,$0006        ; prepare to strip six bytes

        CALL    Z,o19E8         ; routine RECLAIM-2 reclaims bytes if CHR$ 14.

        LD      A,(HL)          ; reload next (or same) character
        INC     HL              ; and advance address
        CP      $0D             ; end of line or input buffer ?
        JR      NZ,o11A7        ; back to REMOVE-FP until entire line done.

        RET                     ; return.


; *********************************
; ** Part 6. EXECUTIVE ROUTINES  **
; *********************************


; The memory.
;
; +---------+-----------+------------+--------------+-------------+--
; | BASIC   |  Display  | Attributes | ZX Printer   |    System   |
; |  ROM    |   File    |    File    |   Buffer     |  Variables  |
; +---------+-----------+------------+--------------+-------------+--
; ^         ^           ^            ^              ^             ^
; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS
;
;
;  --+----------+---+---------+-----------+---+------------+--+---+--
;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|
;    |   Info   |   | Program |   Area    |   | or Command |  |   |
;  --+----------+---+---------+-----------+---+------------+--+---+--
;    ^              ^         ^               ^                   ^
;  CHANS           PROG      VARS           E_LINE              WORKSP
;
;
;                             ---5-->         <---2---  <--3---
;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |
;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |
;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
;    ^                       ^       ^       ^                   ^   ^      ^
;  WORKSP                  STKBOT  STKEND   sp               RAMTOP UDG  P_RAMT
;

; -----------------
; THE 'NEW' COMMAND
; -----------------
;   The NEW command is about to set all RAM below RAMTOP to zero and then
;   re-initialize the system.  All RAM above RAMTOP should, and will be,
;   preserved.
;   There is nowhere to store values in RAM or on the stack which becomes
;   inoperable. Similarly PUSH and CALL instructions cannot be used to store
;   values or section common code. The alternate register set is the only place
;   available to store 3 persistent 16-bit system variables.

;; NEW
o11B7:  DI                      ; Disable Interrupts - machine stack will be
                                ; cleared.
        LD      A,$FF           ; Flag coming from NEW.
        LD      DE,($5CB2)      ; Fetch RAMTOP as top value.
        EXX                     ; Switch in alternate set.
        LD      BC,($5CB4)      ; Fetch P-RAMT differs on 16K/48K machines.
        LD      DE,($5C38)      ; Fetch RASP/PIP.
        LD      HL,(UDG)        ; Fetch UDG    differs on 16K/48K machines.
        EXX                     ; Switch back to main set and continue into...

; ----------------------
; THE 'START-NEW' BRANCH
; ----------------------
;   This branch is taken from above and from RST 00h.
;   The common code tests RAM and sets it to zero re-initializing all the
;   non-zero system variables and channel information.  The A register flags
;   if coming from START or NEW.

;; START-NEW
o11CB:  LD      B,A             ; Save the flag to control later branching.

        LD      A,$07           ; Select a white border
        OUT     ($FE),A         ; and set it now by writing to a port.

        LD      A,$3F           ; Load the accumulator with last page in ROM.
        LD      I,A             ; Set the I register - this remains constant
                                ; and can't be in the range $40 - $7F as 'snow'
                                ; appears on the screen.

        NOP                     ; These seem unnecessary.
        NOP                     ;
        NOP                     ;
        NOP                     ;
        NOP                     ;
        NOP                     ;

; -----------------------
; THE 'RAM CHECK' SECTION
; -----------------------
;   Typically, a Spectrum will have 16K or 48K of RAM and this code will test
;   it all till it finds an unpopulated location or, less likely, a faulty
;   location.  Usually it stops when it reaches the top $FFFF, or in the case
;   of NEW the supplied top value.  The entire screen turns black with
;   sometimes red stripes on black paper just visible.

;; ram-check
o11DA:  LD      H,D             ; Transfer the top value to the HL register
        LD      L,E             ; pair.

;; RAM-FILL
o11DC:  LD      (HL),$02        ; Load memory with $02 - red ink on black paper.
        DEC     HL              ; Decrement memory address.
        CP      H               ; Have we reached ROM - $3F ?
        JR      NZ,o11DC        ; Back to RAM-FILL if not.

;; RAM-READ
o11E2:  AND     A               ; Clear carry - prepare to subtract.
        SBC     HL,DE           ; subtract and add back setting
        ADD     HL,DE           ; carry when back at start.
        INC     HL              ; and increment for next iteration.
        JR      NC,o11EF        ; forward to RAM-DONE if we've got back to
                                ; starting point with no errors.

        DEC     (HL)            ; decrement to 1.
        JR      Z,o11EF         ; forward to RAM-DONE if faulty.

        DEC     (HL)            ; decrement to zero.
        JR      Z,o11E2         ; back to RAM-READ if zero flag was set.

;; RAM-DONE
o11EF:  DEC     HL              ; step back to last valid location.
        EXX                     ; regardless of state, set up possibly
                                ; stored system variables in case from NEW.
        LD      ($5CB4),BC      ; insert P-RAMT.
        LD      ($5C38),DE      ; insert RASP/PIP.
        LD      (UDG),HL        ; insert UDG.
        EXX                     ; switch in main set.
        INC     B               ; now test if we arrived here from NEW.
        JR      Z,o1219         ; forward to RAM-SET if we did.

;   This section applies to START only.

        LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM
                                ; address.
        LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.
        LD      BC,$00A8        ; there are 21 user defined graphics.
        EX      DE,HL           ; switch pointers and make the UDGs a
        LDDR                    ; copy of the standard characters A - U.
        EX      DE,HL           ; switch the pointer to HL.
        INC     HL              ; update to start of 'A' in RAM.
        LD      (UDG),HL        ; make UDG system variable address the first
                                ; bitmap.
        DEC     HL              ; point at RAMTOP again.

        LD      BC,$0040        ; set the values of
        LD      ($5C38),BC      ; the PIP and RASP system variables.

;   The NEW command path rejoins here.

;; RAM-SET
o1219:  LD      ($5CB2),HL      ; set system variable RAMTOP to HL.

;
;   Note. this entry point is a disabled Warm Restart that was almost certainly
;   once pointed to by the System Variable NMIADD.  It would be essential that
;   any NMI Handler would perform the tasks from here to the EI instruction
;   below.

;; NMI_VECT
o121C:
        LD      HL,$3C00        ; a strange place to set the pointer to the
        LD      ($5C36),HL      ; character set, CHARS - as no printing yet.

        LD      HL,($5CB2)      ; fetch RAMTOP to HL again as we've lost it.

        LD      (HL),$3E        ; top of user ram holds GOSUB end marker
                                ; an impossible line number - see RETURN.
                                ; no significance in the number $3E. It has
                                ; been traditional since the ZX80.

        DEC     HL              ; followed by empty byte (not important).
        LD      SP,HL           ; set up the machine stack pointer.
        DEC     HL              ;
        DEC     HL              ;
        LD      (ERR_SP),HL     ; ERR_SP is where the error pointer is
                                ; at moment empty - will take address MAIN-4
                                ; at the call preceding that address,
                                ; although interrupts and calls will make use
                                ; of this location in meantime.

        IM      1               ; select interrupt mode 1.

        LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard
                                ; system variables but shadow ROM system
                                ; variables will be mostly out of range.

        EI                      ; enable interrupts now that we have a stack.

;   If, as suggested above, the NMI service routine pointed to this section of
;   code then a decision would have to be made at this point to jump forward,
;   in a Warm Restart scenario, to produce a report code, leaving any program
;   intact.

        LD      HL,$5CB6        ; The address of the channels - initially
                                ; following system variables.
        LD      (CHANS),HL      ; Set the CHANS system variable.

        LD      DE,o15AF        ; Address: init-chan in ROM.
        LD      BC,$0015        ; There are 21 bytes of initial data in ROM.
        EX      DE,HL           ; swap the pointers.
        LDIR                    ; Copy the bytes to RAM.

        EX      DE,HL           ; Swap pointers. HL points to program area.
        DEC     HL              ; Decrement address.
        LD      (DATADD),HL     ; Set DATADD to location before program area.
        INC     HL              ; Increment again.

        LD      (PROG),HL       ; Set PROG the location where BASIC starts.
        LD      (VARS),HL       ; Set VARS to same location with a
        LD      (HL),$80        ; variables end-marker.
        INC     HL              ; Advance address.
        LD      ($5C59),HL      ; Set E_LINE, where the edit line
                                ; will be created.
                                ; Note. it is not strictly necessary to
                                ; execute the next fifteen bytes of code
                                ; as this will be done by the call to SET-MIN.
                                ; --
        LD      (HL),$0D        ; initially just has a carriage return
        INC     HL              ; followed by
        LD      (HL),$80        ; an end-marker.
        INC     HL              ; address the next location.
        LD      ($5C61),HL      ; set WORKSP - empty workspace.
        LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.
        LD      (STKEND),HL     ; set STKEND to the end of the empty stack.
                                ; --
        LD      A,$38           ; the colour system is set to white paper,
                                ; black ink, no flash or bright.
        LD      (ATTR_P),A      ; set ATTR_P permanent colour attributes.
        LD      (ATTR_T),A      ; set ATTR_T temporary colour attributes.
        LD      (BORDCR),A      ; set BORDCR the border colour/lower screen
                                ; attributes.

        LD      HL,$0523        ; The keyboard repeat and delay values are
        LD      ($5C09),HL      ; loaded to REPDEL and REPPER.

        DEC     (IY-$3A)        ; set KSTATE-0 to $FF - keyboard map available.
        DEC     (IY-$36)        ; set KSTATE-4 to $FF - keyboard map available.

        LD      HL,o15C6        ; set source to ROM Address: init-strm
        LD      DE,STRMS        ; set destination to system variable STRMS-FD
        LD      BC,$000E        ; copy the 14 bytes of initial 7 streams data
        LDIR                    ; from ROM to RAM.

        SET     1,(IY+$01)      ; update FLAGS  - signal printer in use.
        CALL    o0EDF           ; call routine CLEAR-PRB to initialize system
                                ; variables associated with printer.
                                ; The buffer is clear.

        LD      (IY+$31),$02    ; set DF_SZ the lower screen display size to
                                ; two lines
        CALL    o0D6B           ; call routine CLS to set up system
                                ; variables associated with screen and clear
                                ; the screen and set attributes.
        XOR     A               ; clear accumulator so that we can address
        LD      DE,o1539-1      ; the message table directly.
        CALL    o0C0A           ; routine PO-MSG puts
                                ; ' Â©  1982 Sinclair Research Ltd'
                                ; at bottom of display.
        SET     5,(IY+$02)      ; update TV_FLAG  - signal lower screen will
                                ; require clearing.

        JR      o12A9           ; forward to MAIN-1
; -------------------------
; THE 'MAIN EXECUTION LOOP'
; -------------------------
;
;

;; MAIN-EXEC
o12A2:  LD      (IY+$31),$02    ; set DF_SZ lower screen display file size to
                                ; two lines.
        CALL    o1795           ; routine AUTO-LIST

;; MAIN-1
o12A9:  CALL    o16B0           ; routine SET-MIN clears work areas.

;; MAIN-2
o12AC:  LD      A,$00           ; select channel 'K' the keyboard

        CALL    o1601           ; routine CHAN-OPEN opens it

        CALL    o0F2C           ; routine EDITOR is called.
                                ; Note the above routine is where the Spectrum
                                ; waits for user-interaction. Perhaps the
                                ; most common input at this stage
                                ; is LOAD "".

        CALL    o1B17           ; routine LINE-SCAN scans the input.

        BIT     7,(IY+$00)      ; test ERR_NR - will be $FF if syntax is OK.
        JR      NZ,o12CF        ; forward, if correct, to MAIN-3.

;

        BIT     4,(IY+$30)      ; test FLAGS2 - K channel in use ?
        JR      Z,o1303         ; forward to MAIN-4 if not.

;

        LD      HL,($5C59)      ; an editing error so address E_LINE.
        CALL    o11A7           ; routine REMOVE-FP removes the hidden
                                ; floating-point forms.
        LD      (IY+$00),$FF    ; system variable ERR_NR is reset to 'OK'.
        JR      o12AC           ; back to MAIN-2 to allow user to correct.

; ---

; the branch was here if syntax has passed test.

;; MAIN-3
o12CF:  LD      HL,($5C59)      ; fetch the edit line address from E_LINE.

        LD      (CH_ADD),HL     ; system variable CH_ADD is set to first
                                ; character of edit line.
                                ; Note. the above two instructions are a little
                                ; inadequate.
                                ; They are repeated with a subtle difference
                                ; at the start of the next subroutine and are
                                ; therefore not required above.

        CALL    o19FB           ; routine E-LINE-NO will fetch any line
                                ; number to BC if this is a program line.

        LD      A,B             ; test if the number of
        OR      C               ; the line is non-zero.
        JP      NZ,o155D        ; jump forward to MAIN-ADD if so to add the
                                ; line to the BASIC program.

; Has the user just pressed the ENTER key ?

        RST     18H             ; GET-CHAR gets character addressed by CH_ADD.
        CP      $0D             ; is it a carriage return ?
        JR      Z,o12A2         ; back to MAIN-EXEC if so for an automatic
                                ; listing.

; this must be a direct command.

        BIT     0,(IY+$30)      ; test FLAGS2 - clear the main screen ?

        CALL    NZ,o0DAF        ; routine CL-ALL, if so, e.g. after listing.

        CALL    o0D6E           ; routine CLS-LOWER anyway.

        LD      A,$19           ; compute scroll count as 25 minus
        SUB     (IY+$4F)        ; value of S_POSN_hi.
        LD      ($5C8C),A       ; update SCR_CT system variable.
        SET     7,(IY+$01)      ; update FLAGS - signal running program.
        LD      (IY+$00),$FF    ; set ERR_NR to 'OK'.
        LD      (IY+$0A),$01    ; set NSPPC to one for first statement.
o1300:  CALL    o1B8A           ; call routine LINE-RUN to run the line.
                                ; sysvar ERR_SP therefore addresses MAIN-4

; Examples of direct commands are RUN, CLS, LOAD "", PRINT USR 40000,
; LPRINT "A"; etc..
; If a user written machine-code program disables interrupts then it
; must enable them to pass the next step. We also jumped to here if the
; keyboard was not being used.

;; MAIN-4
o1303:  HALT                    ; wait for interrupt the only routine that can
                                ; set bit 5 of FLAGS.

        RES     5,(IY+$01)      ; update bit 5 of FLAGS - signal no new key.

        BIT     1,(IY+$30)      ; test FLAGS2 - is printer buffer clear ?
        CALL    NZ,o0ECD        ; call routine COPY-BUFF if not.
                                ; Note. the programmer has neglected
                                ; to set bit 1 of FLAGS first.

        LD      A,($5C3A)       ; fetch ERR_NR
        INC     A               ; increment to give true code.

; Now deal with a runtime error as opposed to an editing error.
; However if the error code is now zero then the OK message will be printed.

;; MAIN-G
o1313:  PUSH    AF              ; save the error number.

        LD      HL,$0000        ; prepare to clear some system variables.
        LD      (IY+$37),H      ; clear all the bits of FLAGX.
        LD      (IY+$26),H      ; blank X_PTR_hi to suppress error marker.
        LD      ($5C0B),HL      ; blank DEFADD to signal that no defined
                                ; function is currently being evaluated.

        LD      HL,$0001        ; explicit - inc hl would do.
        LD      ($5C16),HL      ; ensure STRMS-00 is keyboard.

        CALL    o16B0           ; routine SET-MIN clears workspace etc.
        RES     5,(IY+$37)      ; update FLAGX - signal in EDIT not INPUT mode.
                                ; Note. all the bits were reset earlier.

        CALL    o0D6E           ; call routine CLS-LOWER.

        SET     5,(IY+$02)      ; update TV_FLAG - signal lower screen
                                ; requires clearing.

        POP     AF              ; bring back the true error number
        LD      B,A             ; and make a copy in B.
        CP      $0A             ; is it a print-ready digit ?
        JR      C,o133C         ; forward to MAIN-5 if so.

        ADD     A,$07           ; add ASCII offset to letters.

;; MAIN-5
o133C:  CALL    o15EF           ; call routine OUT-CODE to print the code.

        LD      A,$20           ; followed by a space.
        RST     10H             ; PRINT-A

        LD      A,B             ; fetch stored report code.
        LD      DE,o1391        ; address: rpt-mesgs.

        CALL    o0C0A           ; call routine PO-MSG to print the message.
        CALL    o3A29
        NOP
        CALL    o0C0A           ; routine PO-MSG prints ', ' although it would
                                ; be more succinct to use RST $10.

        LD      BC,($5C45)      ; fetch PPC the current line number.
        CALL    o1A1B           ; routine OUT-NUM-1 will print that

        LD      A,$3A           ; then a ':' character.
        RST     10H             ; PRINT-A

        LD      C,(IY+$0D)      ; then SUBPPC for statement
        LD      B,$00           ; limited to 127
        CALL    o1A1B           ; routine OUT-NUM-1 prints BC.

        CALL    o1097           ; routine CLEAR-SP clears editing area which
                                ; probably contained 'RUN'.

        LD      A,($5C3A)       ; fetch ERR_NR again
        INC     A               ; test for no error originally $FF.
        JR      Z,o1386         ; forward to MAIN-9 if no error.

        CP      $09             ; is code Report 9 STOP ?
        JR      Z,o1373         ; forward to MAIN-6 if so

        CP      $15             ; is code Report L Break ?
        JR      NZ,o1376        ; forward to MAIN-7 if not

; Stop or Break was encountered so consider CONTINUE.

;; MAIN-6
o1373:  INC     (IY+$0D)        ; increment SUBPPC to next statement.

;; MAIN-7
o1376:  LD      BC,$0003        ; prepare to copy 3 system variables to
        LD      DE,$5C70        ; address OSPPC - statement for CONTINUE.
                                ; also updating OLDPPC line number below.

        LD      HL,$5C44        ; set source top to NSPPC next statement.
        BIT     7,(HL)          ; did BREAK occur before the jump ?
                                ; e.g. between GO TO and next statement.
        JR      Z,o1384         ; skip forward to MAIN-8, if not, as set-up
                                ; is correct.

        ADD     HL,BC           ; set source to SUBPPC number of current
                                ; statement/line which will be repeated.

;; MAIN-8
o1384:  LDDR                    ; copy PPC to OLDPPC and SUBPPC to OSPCC
                                ; or NSPPC to OLDPPC and NEWPPC to OSPCC

;; MAIN-9
o1386:  LD      (IY+$0A),$FF    ; update NSPPC - signal 'no jump'.
        RES     3,(IY+$01)      ; update FLAGS - signal use 'K' mode for
                                ; the first character in the editor and

        JP      o12AC           ; jump back to MAIN-2.


; ----------------------
; Canned report messages
; ----------------------
; The Error reports with the last byte inverted. The first entry
; is a dummy entry. The last, which begins with $7F, the Spectrum
; character for copyright symbol, is poaced here for convenience
; as is the preceding comma and space.
; The report line must accommodate a 4-digit line number and a 3-digit
; statement number which limits the length of the message text to twenty
; characters.
; e.g.  "B Integer out of range, 1000:127"

;; rpt-mesgs
o1391:  DEFB    $80
        DEFB    'O','K'+$80                             ; 0
  IF spanish
        DEFM    "NEXT "
      IF v41 || garry
        DEFM    "SIN"
      ELSE
        DEFM    "sin"
      ENDIF
        DEFM    " FO"
        DEFB    'R'+$80                                 ; 1
        DEFM    "VARIABLE NO DEFINID"
        DEFB    'A'+$80                                 ; 2
        DEFM    "SUBINDICE INCORRECT"
        DEFB    'O'+$80                                 ; 3
        DEFM    "MEMORIA AGOTAD"
        DEFB    'A'+$80                                 ; 4
        DEFM    "FUERA DE PANTALL"
        DEFB    'A'+$80                                 ; 5
        DEFM    "NUMERO MUY GRAND"
        DEFB    'E'+$80                                 ; 6
        DEFM    "RETURN "
      IF v41 || garry
        DEFM    "SIN"
      ELSE
        DEFM    "sin"
      ENDIF
        DEFM    " GOSU"
        DEFB    'B'+$80                                 ; 7
        DEFM    "FIN DE FICHER"
        DEFB    'O'+$80                                 ; 8
      IF v41 || garry
        DEFM    "SENTENCIA STO"
      ELSE
        DEFM    "Sentencia STO"
      ENDIF
        DEFB    'P'+$80                                 ; 9
        DEFM    "ARG. INVALID"
        DEFB    'O'+$80                                 ; A
        DEFM    "ENTERO EXCEDE MARGE"
        DEFB    'N'+$80                                 ; B
        DEFM    "SIN SENTIDO EN BASI"
        DEFB    'C'+$80                                 ; C
        DEFM    "BREAK/CONT "
      IF v41 || garry
        DEFM    "REPIT"
        DEFB    'E'+$80                                 ; D
      ELSE
        DEFM    "repit"
        DEFB    'e'+$80                                 ; D
      ENDIF
        DEFM    "DATOS AGOTADO"
        DEFB    'S'+$80                                 ; E
        DEFM    "NOMBRE INCORRECT"
        DEFB    'O'+$80                                 ; F
        DEFM    "NO CABE LA LINE"
        DEFB    'A'+$80                                 ; G
        DEFM    "STOP "
      IF v41 || garry
        DEFM    "EN"
      ELSE
        DEFM    "en"
      ENDIF
        DEFB    " INPU"
        DEFB    'T'+$80                                 ; H
        DEFM    "FOR "
      IF v41 || garry
        DEFM    "SIN"
      ELSE
        DEFM    "sin"
      ENDIF
        DEFM    " NEX"
        DEFB    'T'+$80                                 ; I
        DEFM    "DISP. E/S INCORRECT"
        DEFB    'O'+$80                                 ; J
        DEFM    "COLOR NO VALID"
        DEFB    'O'+$80                                 ; K
        DEFM    "PROGR. INTERRUMPID"
        DEFB    'O'+$80                                 ; L
        DEFM    "RAMTOP "
      IF v41 || garry
        DEFM    "INCORRECT"
        DEFB    'A'+$80                                 ; M
      ELSE
        DEFM    "incorrect"
        DEFB    'a'+$80                                 ; M
      ENDIF
        DEFM    "SENT. PERDID"
        DEFB    'A'+$80                                 ; N
        DEFM    "CANAL NO VALID"
        DEFB    'O'+$80                                 ; O
        DEFM    "FN "
      IF v41 || garry
        DEFM    "SIN"
      ELSE
        DEFM    "sin"
      ENDIF
        DEFM    " DE"
        DEFB    'F'+$80                                 ; P
        DEFM    "PARAMETRO ERRONE"
        DEFB    'O'+$80                                 ; Q
        DEFM    "ERROR CARGANDO CINT"
o1536:  DEFB    'A'+$80                                 ; R
;; comma-sp
o1537:  DEFB    ',',' '+$80                             ; used in report line.
;; copyright
o1539:
        DEFB    $7F                                     ; copyright
        DEFM    " 1982 Amstra"
o1547:  DEFB    'd'+$80
  ELSE
        DEFM    "NEXT without FO"
        DEFB    'R'+$80                                 ; 1
        DEFM    "Variable not foun"
        DEFB    'd'+$80                                 ; 2
        DEFM    "Subscript wron"
        DEFB    'g'+$80                                 ; 3
        DEFM    "Out of memor"
        DEFB    'y'+$80                                 ; 4
        DEFM    "Out of scree"
        DEFB    'n'+$80                                 ; 5
        DEFM    "Number too bi"
        DEFB    'g'+$80                                 ; 6
        DEFM    "RETURN without GOSU"
        DEFB    'B'+$80                                 ; 7
        DEFM    "End of fil"
        DEFB    'e'+$80                                 ; 8
        DEFM    "STOP statemen"
        DEFB    't'+$80                                 ; 9
        DEFM    "Invalid argumen"
        DEFB    't'+$80                                 ; A
        DEFM    "Integer out of rang"
        DEFB    'e'+$80                                 ; B
        DEFM    "Nonsense in BASI"
        DEFB    'C'+$80                                 ; C
        DEFM    "BREAK - CONT repeat"
        DEFB    's'+$80                                 ; D
        DEFM    "Out of DAT"
        DEFB    'A'+$80                                 ; E
        DEFM    "Invalid file nam"
        DEFB    'e'+$80                                 ; F
        DEFM    "No room for lin"
        DEFB    'e'+$80                                 ; G
        DEFM    "STOP in INPU"
        DEFB    'T'+$80                                 ; H
        DEFM    "FOR without NEX"
        DEFB    'T'+$80                                 ; I
        DEFM    "Invalid I/O devic"
        DEFB    'e'+$80                                 ; J
        DEFM    "Invalid colou"
        DEFB    'r'+$80                                 ; K
        DEFM    "BREAK into progra"
        DEFB    'm'+$80                                 ; L
        DEFM    "RAMTOP no goo"
        DEFB    'd'+$80                                 ; M
        DEFM    "Statement los"
        DEFB    't'+$80                                 ; N
        DEFM    "Invalid strea"
        DEFB    'm'+$80                                 ; O
        DEFM    "FN without DE"
        DEFB    'F'+$80                                 ; P
        DEFM    "Parameter erro"
        DEFB    'r'+$80                                 ; Q
        DEFM    "Tape loading erro"
o1536:  DEFB    'r'+$80                                 ; R
;; comma-sp
o1537:  DEFB    ',',' '+$80                             ; used in report line.
;; copyright
o1539:
        DEFB    $7F                                     ; copyright
        DEFM    " 1982 Amstrad             "
o1547:  DEFB    ' '+$80
  ENDIF

; -------------
; REPORT-G
; -------------
; Note ERR_SP points here during line entry which allows the
; normal 'Out of Memory' report to be augmented to the more
; precise 'No Room for line' report.

;; REPORT-G
; No Room for line
o1555:  LD      A,$10           ; i.e. 'G' -$30 -$07
        LD      BC,$0000        ; this seems unnecessary.
        JP      o1313           ; jump back to MAIN-G

; -----------------------------
; Handle addition of BASIC line
; -----------------------------
; Note this is not a subroutine but a branch of the main execution loop.
; System variable ERR_SP still points to editing error handler.
; A new line is added to the BASIC program at the appropriate place.
; An existing line with same number is deleted first.
; Entering an existing line number deletes that line.
; Entering a non-existent line allows the subsequent line to be edited next.

;; MAIN-ADD
o155D:  LD      ($5C49),BC      ; set E_PPC to extracted line number.
        LD      HL,(CH_ADD)     ; fetch CH_ADD - points to location after the
                                ; initial digits (set in E_LINE_NO).
        EX      DE,HL           ; save start of BASIC in DE.

        LD      HL,o1555        ; Address: REPORT-G
        PUSH    HL              ; is pushed on stack and addressed by ERR_SP.
                                ; the only error that can occur is
                                ; 'Out of memory'.

        LD      HL,($5C61)      ; fetch WORKSP - end of line.
        SCF                     ; prepare for true subtraction.
        SBC     HL,DE           ; find length of BASIC and
        PUSH    HL              ; save it on stack.
        LD      H,B             ; transfer line number
        LD      L,C             ; to HL register.
        CALL    o196E           ; routine LINE-ADDR will see if
                                ; a line with the same number exists.
        JR      NZ,o157D        ; forward if no existing line to MAIN-ADD1.

        CALL    o19B8           ; routine NEXT-ONE finds the existing line.
        CALL    o19E8           ; routine RECLAIM-2 reclaims it.

;; MAIN-ADD1
o157D:  POP     BC              ; retrieve the length of the new line.
        LD      A,C             ; and test if carriage return only
        DEC     A               ; i.e. one byte long.
        OR      B               ; result would be zero.
        JR      Z,o15AB         ; forward to MAIN-ADD2 is so.

        PUSH    BC              ; save the length again.
        INC     BC              ; adjust for inclusion
        INC     BC              ; of line number (two bytes)
        INC     BC              ; and line length
        INC     BC              ; (two bytes).
        DEC     HL              ; HL points to location before the destination

        LD      DE,(PROG)       ; fetch the address of PROG
        PUSH    DE              ; and save it on the stack
        CALL    o1655           ; routine MAKE-ROOM creates BC spaces in
                                ; program area and updates pointers.
        POP     HL              ; restore old program pointer.
        LD      (PROG),HL       ; and put back in PROG as it may have been
                                ; altered by the POINTERS routine.

        POP     BC              ; retrieve BASIC length
        PUSH    BC              ; and save again.

        INC     DE              ; points to end of new area.
        LD      HL,($5C61)      ; set HL to WORKSP - location after edit line.
        DEC     HL              ; decrement to address end marker.
        DEC     HL              ; decrement to address carriage return.
        LDDR                    ; copy the BASIC line back to initial command.

        LD      HL,($5C49)      ; fetch E_PPC - line number.
        EX      DE,HL           ; swap it to DE, HL points to last of
                                ; four locations.
        POP     BC              ; retrieve length of line.
        LD      (HL),B          ; high byte last.
        DEC     HL              ;
        LD      (HL),C          ; then low byte of length.
        DEC     HL              ;
        LD      (HL),E          ; then low byte of line number.
        DEC     HL              ;
        LD      (HL),D          ; then high byte range $0 - $27 (1-9999).

;; MAIN-ADD2
o15AB:  POP     AF              ; drop the address of Report G
        JP      o12A2           ; and back to MAIN-EXEC producing a listing
                                ; and to reset ERR_SP in EDITOR.


; ---------------------------------
; THE 'INITIAL CHANNEL' INFORMATION
; ---------------------------------
;   This initial channel information is copied from ROM to RAM, during
;   initialization.  It's new location is after the system variables and is
;   addressed by the system variable CHANS which means that it can slide up and
;   down in memory.  The table is never searched, by this ROM, and the last
;   character, which could be anything other than a comma, provides a
;   convenient resting place for DATADD.

;; init-chan
o15AF:  DEFW    o09F4           ; PRINT-OUT
        DEFW    o10A8           ; KEY-INPUT
        DEFB    $4B             ; 'K'
        DEFW    o09F4           ; PRINT-OUT
        DEFW    o15C4           ; REPORT-J
        DEFB    $53             ; 'S'
        DEFW    o0F81           ; ADD-CHAR
        DEFW    o15C4           ; REPORT-J
        DEFB    $52             ; 'R'
        DEFW    o09F4           ; PRINT-OUT
        DEFW    o15C4           ; REPORT-J
        DEFB    $50             ; 'P'

        DEFB    $80             ; End Marker

;; REPORT-J
o15C4:  RST     08H             ; ERROR-1
        DEFB    $12             ; Error Report: Invalid I/O device


; -------------------------
; THE 'INITIAL STREAM' DATA
; -------------------------
;   This is the initial stream data for the seven streams $FD - $03 that is
;   copied from ROM to the STRMS system variables area during initialization.
;   There are reserved locations there for another 12 streams.  Each location
;   contains an offset to the second byte of a channel.  The first byte of a
;   channel can't be used as that would result in an offset of zero for some
;   and zero is used to denote that a stream is closed.

;; init-strm
o15C6:  DEFB    $01, $00        ; stream $FD offset to channel 'K'
        DEFB    $06, $00        ; stream $FE offset to channel 'S'
        DEFB    $0B, $00        ; stream $FF offset to channel 'R'

        DEFB    $01, $00        ; stream $00 offset to channel 'K'
        DEFB    $01, $00        ; stream $01 offset to channel 'K'
        DEFB    $06, $00        ; stream $02 offset to channel 'S'
        DEFB    $10, $00        ; stream $03 offset to channel 'P'

; ------------------------------
; THE 'INPUT CONTROL' SUBROUTINE
; ------------------------------
;

;; WAIT-KEY
o15D4:  BIT     5,(IY+$02)      ; test TV_FLAG - clear lower screen ?
        JR      NZ,o15DE        ; forward to WAIT-KEY1 if so.

        SET     3,(IY+$02)      ; update TV_FLAG - signal reprint the edit
                                ; line to the lower screen.

;; WAIT-KEY1
o15DE:  CALL    o15E6           ; routine INPUT-AD is called.

        RET     C               ; return with acceptable keys.

        JR      Z,o15DE         ; back to WAIT-KEY1 if no key is pressed
                                ; or it has been handled within INPUT-AD.

;   Note. When inputting from the keyboard all characters are returned with
;   above conditions so this path is never taken.

;; REPORT-8
o15E4:  RST     08H             ; ERROR-1
        DEFB    $07             ; Error Report: End of file

; ---------------------------
; THE 'INPUT ADDRESS' ROUTINE
; ---------------------------
;   This routine fetches the address of the input stream from the current
;   channel area using the system variable CURCHL.

;; INPUT-AD
o15E6:  EXX                     ; switch in alternate set.
        PUSH    HL              ; save HL register
        LD      HL,(CURCHL)     ; fetch address of CURCHL - current channel.
        INC     HL              ; step over output routine
        INC     HL              ; to point to low byte of input routine.
        JR      o15F7           ; forward to CALL-SUB.

; -------------------------
; THE 'CODE OUTPUT' ROUTINE
; -------------------------
;   This routine is called on five occasions to print the ASCII equivalent of
;   a value 0-9.

;; OUT-CODE
o15EF:  LD      E,$30           ; add 48 decimal to give the ASCII character
        ADD     A,E             ; '0' to '9' and continue into the main output
                                ; routine.

; -------------------------
; THE 'MAIN OUTPUT' ROUTINE
; -------------------------
;   PRINT-A-2 is a continuation of the RST 10 restart that prints any character.
;   The routine prints to the current channel and the printing of control codes
;   may alter that channel to divert subsequent RST 10 instructions to temporary
;   routines. The normal channel is $09F4.

;; PRINT-A-2
o15F2:  EXX                     ; switch in alternate set
        PUSH    HL              ; save HL register
        LD      HL,(CURCHL)     ; fetch CURCHL the current channel.

; input-ad rejoins here also.

;; CALL-SUB
o15F7:  LD      E,(HL)          ; put the low byte in E.
        INC     HL              ; advance address.
        LD      D,(HL)          ; put the high byte to D.
        EX      DE,HL           ; transfer the stream to HL.
        CALL    o162C           ; use routine CALL-JUMP.
                                ; in effect CALL (HL).

        POP     HL              ; restore saved HL register.
        EXX                     ; switch back to the main set and
        RET                     ; return.

; --------------------------
; THE 'OPEN CHANNEL' ROUTINE
; --------------------------
;   This subroutine is used by the ROM to open a channel 'K', 'S', 'R' or 'P'.
;   This is either for its own use or in response to a user's request, for
;   example, when '#' is encountered with output - PRINT, LIST etc.
;   or with input - INPUT, INKEY$ etc.
;   It is entered with a system stream $FD - $FF, or a user stream $00 - $0F
;   in the accumulator.

;; CHAN-OPEN
o1601:  ADD     A,A             ; double the stream ($FF will become $FE etc.)
        ADD     A,$16           ; add the offset to stream 0 from $5C00
        LD      L,A             ; result to L
        LD      H,$5C           ; now form the address in STRMS area.
        LD      E,(HL)          ; fetch low byte of CHANS offset
        INC     HL              ; address next
        LD      D,(HL)          ; fetch high byte of offset
        LD      A,D             ; test that the stream is open.
        OR      E               ; zero if closed.
        JR      NZ,o1610        ; forward to CHAN-OP-1 if open.

;; REPORT-Oa
o160E:  RST     08H             ; ERROR-1
        DEFB    $17             ; Error Report: Invalid stream

; continue here if stream was open. Note that the offset is from CHANS
; to the second byte of the channel.

;; CHAN-OP-1
o1610:  DEC     DE              ; reduce offset so it points to the channel.
        LD      HL,(CHANS)      ; fetch CHANS the location of the base of
                                ; the channel information area
        ADD     HL,DE           ; and add the offset to address the channel.
                                ; and continue to set flags.

; -----------------
; Set channel flags
; -----------------
; This subroutine is used from ED-EDIT, str$ and read-in to reset the
; current channel when it has been temporarily altered.

;; CHAN-FLAG
o1615:  LD      (CURCHL),HL     ; set CURCHL system variable to the
                                ; address in HL
        RES     4,(IY+$30)      ; update FLAGS2  - signal K channel not in use.
                                ; Note. provide a default for channel 'R'.
        INC     HL              ; advance past
        INC     HL              ; output routine.
        INC     HL              ; advance past
        INC     HL              ; input routine.
        LD      C,(HL)          ; pick up the letter.
        LD      HL,o162D        ; address: chn-cd-lu
        CALL    o16DC           ; routine INDEXER finds offset to a
                                ; flag-setting routine.

        RET     NC              ; but if the letter wasn't found in the
                                ; table just return now. - channel 'R'.

        LD      D,$00           ; prepare to add
        LD      E,(HL)          ; offset to E
        ADD     HL,DE           ; add offset to location of offset to form
                                ; address of routine

;; CALL-JUMP
o162C:  JP      (HL)            ; jump to the routine

; Footnote. calling any location that holds JP (HL) is the equivalent to
; a pseudo Z80 instruction CALL (HL). The ROM uses the instruction above.

; --------------------------
; Channel code look-up table
; --------------------------
; This table is used by the routine above to find one of the three
; flag setting routines below it.
; A zero end-marker is required as channel 'R' is not present.

;; chn-cd-lu
o162D:  DEFB    'K', o1634-$-1  ; offset $06 to CHAN-K
        DEFB    'S', o1642-$-1  ; offset $12 to CHAN-S
        DEFB    'P', o164D-$-1  ; offset $1B to CHAN-P

        DEFB    $00             ; end marker.

; --------------
; Channel K flag
; --------------
; routine to set flags for lower screen/keyboard channel.

;; CHAN-K
o1634:  SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
        RES     5,(IY+$01)      ; update FLAGS    - signal no new key
        SET     4,(IY+$30)      ; update FLAGS2   - signal K channel in use
        JR      o1646           ; forward to CHAN-S-1 for indirect exit

; --------------
; Channel S flag
; --------------
; routine to set flags for upper screen channel.

;; CHAN-S
o1642:  RES     0,(IY+$02)      ; TV_FLAG  - signal main screen in use

;; CHAN-S-1
o1646:  RES     1,(IY+$01)      ; update FLAGS  - signal printer not in use
        JP      o0D4D           ; jump back to TEMPS and exit via that
                                ; routine after setting temporary attributes.
; --------------
; Channel P flag
; --------------
; This routine sets a flag so that subsequent print related commands
; print to printer or update the relevant system variables.
; This status remains in force until reset by the routine above.

;; CHAN-P
o164D:  SET     1,(IY+$01)      ; update FLAGS  - signal printer in use
        RET                     ; return

; --------------------------
; THE 'ONE SPACE' SUBROUTINE
; --------------------------
; This routine is called once only to create a single space
; in workspace by ADD-CHAR.

;; ONE-SPACE
o1652:  LD      BC,$0001        ; create space for a single character.

; ---------
; Make Room
; ---------
; This entry point is used to create BC spaces in various areas such as
; program area, variables area, workspace etc..
; The entire free RAM is available to each BASIC statement.
; On entry, HL addresses where the first location is to be created.
; Afterwards, HL will point to the location before this.

;; MAKE-ROOM
o1655:  PUSH    HL              ; save the address pointer.
        CALL    o1F05           ; routine TEST-ROOM checks if room
                                ; exists and generates an error if not.
        POP     HL              ; restore the address pointer.
        CALL    o1664           ; routine POINTERS updates the
                                ; dynamic memory location pointers.
                                ; DE now holds the old value of STKEND.
        LD      HL,(STKEND)     ; fetch new STKEND the top destination.

        EX      DE,HL           ; HL now addresses the top of the area to
                                ; be moved up - old STKEND.
o1661:  LDDR                    ; the program, variables, etc are moved up.
        RET                     ; return with new area ready to be populated.
                                ; HL points to location before new area,
                                ; and DE to last of new locations.

; -----------------------------------------------
; Adjust pointers before making or reclaiming room
; -----------------------------------------------
; This routine is called by MAKE-ROOM to adjust upwards and by RECLAIM to
; adjust downwards the pointers within dynamic memory.
; The fourteen pointers to dynamic memory, starting with VARS and ending
; with STKEND, are updated adding BC if they are higher than the position
; in HL.
; The system variables are in no particular order except that STKEND, the first
; free location after dynamic memory must be the last encountered.

;; POINTERS
o1664:  PUSH    AF              ; preserve accumulator.
        PUSH    HL              ; put pos pointer on stack.
        LD      HL,VARS         ; address VARS the first of the
        LD      A,$0E           ; fourteen variables to consider.

;; PTR-NEXT
o166B:  LD      E,(HL)          ; fetch the low byte of the system variable.
        INC     HL              ; advance address.
        LD      D,(HL)          ; fetch high byte of the system variable.
        EX      (SP),HL         ; swap pointer on stack with the variable
                                ; pointer.
        AND     A               ; prepare to subtract.
        SBC     HL,DE           ; subtract variable address
        ADD     HL,DE           ; and add back
        EX      (SP),HL         ; swap pos with system variable pointer
        JR      NC,o167F        ; forward to PTR-DONE if var before pos

        PUSH    DE              ; save system variable address.
        EX      DE,HL           ; transfer to HL
        ADD     HL,BC           ; add the offset
        EX      DE,HL           ; back to DE
        LD      (HL),D          ; load high byte
        DEC     HL              ; move back
        LD      (HL),E          ; load low byte
        INC     HL              ; advance to high byte
        POP     DE              ; restore old system variable address.

;; PTR-DONE
o167F:  INC     HL              ; address next system variable.
        DEC     A               ; decrease counter.
        JR      NZ,o166B        ; back to PTR-NEXT if more.
        EX      DE,HL           ; transfer old value of STKEND to HL.
                                ; Note. this has always been updated.
        POP     DE              ; pop the address of the position.

        POP     AF              ; pop preserved accumulator.
        AND     A               ; clear carry flag preparing to subtract.

        SBC     HL,DE           ; subtract position from old stkend
        LD      B,H             ; to give number of data bytes
        LD      C,L             ; to be moved.
        INC     BC              ; increment as we also copy byte at old STKEND.
        ADD     HL,DE           ; recompute old stkend.
        EX      DE,HL           ; transfer to DE.
        RET                     ; return.



; -------------------
; Collect line number
; -------------------
; This routine extracts a line number, at an address that has previously
; been found using LINE-ADDR, and it is entered at LINE-NO. If it encounters
; the program 'end-marker' then the previous line is used and if that
; should also be unacceptable then zero is used as it must be a direct
; command. The program end-marker is the variables end-marker $80, or
; if variables exist, then the first character of any variable name.

;; LINE-ZERO
o168F:  DEFB    $00, $00        ; dummy line number used for direct commands


;; LINE-NO-A
o1691:  EX      DE,HL           ; fetch the previous line to HL and set
        LD      DE,o168F        ; DE to LINE-ZERO should HL also fail.

; -> The Entry Point.

;; LINE-NO
o1695:  LD      A,(HL)          ; fetch the high byte - max $2F
        AND     $C0             ; mask off the invalid bits.
        JR      NZ,o1691        ; to LINE-NO-A if an end-marker.

        LD      D,(HL)          ; reload the high byte.
        INC     HL              ; advance address.
        LD      E,(HL)          ; pick up the low byte.
        RET                     ; return from here.

; -------------------
; Handle reserve room
; -------------------
; This is a continuation of the restart BC-SPACES

;; RESERVE
o169E:  LD      HL,($5C63)      ; STKBOT first location of calculator stack
        DEC     HL              ; make one less than new location
        CALL    o1655           ; routine MAKE-ROOM creates the room.
        INC     HL              ; address the first new location
        INC     HL              ; advance to second
        POP     BC              ; restore old WORKSP
        LD      ($5C61),BC      ; system variable WORKSP was perhaps
                                ; changed by POINTERS routine.
        POP     BC              ; restore count for return value.
        EX      DE,HL           ; switch. DE = location after first new space
        INC     HL              ; HL now location after new space
        RET                     ; return.

; ---------------------------
; Clear various editing areas
; ---------------------------
; This routine sets the editing area, workspace and calculator stack
; to their minimum configurations as at initialization and indeed this
; routine could have been relied on to perform that task.
; This routine uses HL only and returns with that register holding
; WORKSP/STKBOT/STKEND though no use is made of this. The routines also
; reset MEM to its usual place in the systems variable area should it
; have been relocated to a FOR-NEXT variable. The main entry point
; SET-MIN is called at the start of the MAIN-EXEC loop and prior to
; displaying an error.

;; SET-MIN
o16B0:  LD      HL,($5C59)      ; fetch E_LINE
        LD      (HL),$0D        ; insert carriage return
        LD      ($5C5B),HL      ; make K_CUR keyboard cursor point there.
        INC     HL              ; next location
        LD      (HL),$80        ; holds end-marker $80
        INC     HL              ; next location becomes
        LD      ($5C61),HL      ; start of WORKSP

; This entry point is used prior to input and prior to the execution,
; or parsing, of each statement.

;; SET-WORK
o16BF:  LD      HL,($5C61)      ; fetch WORKSP value
        LD      ($5C63),HL      ; and place in STKBOT

; This entry point is used to move the stack back to its normal place
; after temporary relocation during line entry and also from ERROR-3

;; SET-STK
o16C5:  LD      HL,($5C63)      ; fetch STKBOT value
        LD      (STKEND),HL     ; and place in STKEND.

        PUSH    HL              ; perhaps an obsolete entry point.
        LD      HL,$5C92        ; normal location of MEM-0
        LD      ($5C68),HL      ; is restored to system variable MEM.
        POP     HL              ; saved value not required.
        RET                     ; return.

; ------------------
; Reclaim edit-line?
; ------------------
; This seems to be legacy code from the ZX80/ZX81 as it is
; not used in this ROM.
; That task, in fact, is performed here by the dual-area routine CLEAR-SP.
; This routine is designed to deal with something that is known to be in the
; edit buffer and not workspace.
; On entry, HL must point to the end of the something to be deleted.

;; REC-EDIT
o16D4:  LD      DE,($5C59)      ; fetch start of edit line from E_LINE.
        JP      o19E5           ; jump forward to RECLAIM-1.

; --------------------------
; The Table INDEXING routine
; --------------------------
; This routine is used to search two-byte hash tables for a character
; held in C, returning the address of the following offset byte.
; if it is known that the character is in the table e.g. for priorities,
; then the table requires no zero end-marker. If this is not known at the
; outset then a zero end-marker is required and carry is set to signal
; success.

;; INDEXER-1
o16DB:  INC     HL              ; address the next pair of values.

; -> The Entry Point.

;; INDEXER
o16DC:  LD      A,(HL)          ; fetch the first byte of pair
        AND     A               ; is it the end-marker ?
        RET     Z               ; return with carry reset if so.

        CP      C               ; is it the required character ?
        INC     HL              ; address next location.
        JR      NZ,o16DB        ; back to INDEXER-1 if no match.

        SCF                     ; else set the carry flag.
        RET                     ; return with carry set

; --------------------------------
; The Channel and Streams Routines
; --------------------------------
; A channel is an input/output route to a hardware device
; and is identified to the system by a single letter e.g. 'K' for
; the keyboard. A channel can have an input and output route
; associated with it in which case it is bi-directional like
; the keyboard. Others like the upper screen 'S' are output
; only and the input routine usually points to a report message.
; Channels 'K' and 'S' are system channels and it would be inappropriate
; to close the associated streams so a mechanism is provided to
; re-attach them. When the re-attachment is no longer required, then
; closing these streams resets them as at initialization.
; Early adverts said that the network and RS232 were in this ROM.
; Channels 'N' and 'B' are user channels and have been removed successfully
; if, as seems possible, they existed.
; Ironically the tape streamer is not accessed through streams and
; channels.
; Early demonstrations of the Spectrum showed a single microdrive being
; controlled by the main ROM.

; ---------------------
; THE 'CLOSE #' COMMAND
; ---------------------
;   This command allows streams to be closed after use.
;   Any temporary memory areas used by the stream would be reclaimed and
;   finally flags set or reset if necessary.

;; CLOSE
o16E5:  CALL    o171E           ; routine STR-DATA fetches parameter
                                ; from calculator stack and gets the
                                ; existing STRMS data pointer address in HL
                                ; and stream offset from CHANS in BC.

                                ; Note. this offset could be zero if the
                                ; stream is already closed. A check for this
                                ; should occur now and an error should be
                                ; generated, for example,
                                ; Report S 'Stream status closed'.

        CALL    o1701           ; routine CLOSE-2 would perform any actions
                                ; peculiar to that stream without disturbing
                                ; data pointer to STRMS entry in HL.

        LD      BC,$0000        ; the stream is to be blanked.
        LD      DE,$A3E2        ; the number of bytes from stream 4, $5C1E,
                                ; to $10000
        EX      DE,HL           ; transfer offset to HL, STRMS data pointer
                                ; to DE.
        ADD     HL,DE           ; add the offset to the data pointer.
        JR      C,o16FC         ; forward to CLOSE-1 if a non-system stream.
                                ; i.e. higher than 3.

; proceed with a negative result.

        LD      BC,o15C6 + 14   ; prepare the address of the byte after
                                ; the initial stream data in ROM. ($15D4)
        ADD     HL,BC           ; index into the data table with negative value.
        LD      C,(HL)          ; low byte to C
        INC     HL              ; address next.
        LD      B,(HL)          ; high byte to B.

;   and for streams 0 - 3 just enter the initial data back into the STRMS entry
;   streams 0 - 2 can't be closed as they are shared by the operating system.
;   -> for streams 4 - 15 then blank the entry.

;; CLOSE-1
o16FC:  EX      DE,HL           ; address of stream to HL.
        LD      (HL),C          ; place zero (or low byte).
        INC     HL              ; next address.
        LD      (HL),B          ; place zero (or high byte).
        RET                     ; return.

; ------------------------
; THE 'CLOSE-2' SUBROUTINE
; ------------------------
;   There is not much point in coming here.
;   The purpose was once to find the offset to a special closing routine,
;   in this ROM and within 256 bytes of the close stream look up table that
;   would reclaim any buffers associated with a stream. At least one has been
;   removed.
;   Any attempt to CLOSE streams $00 to $04, without first opening the stream,
;   will lead to either a system restart or the production of a strange report.
;   credit: Martin Wren-Hilton 1982.

;; CLOSE-2
o1701:  PUSH    HL              ; * save address of stream data pointer
                                ; in STRMS on the machine stack.
        LD      HL,(CHANS)      ; fetch CHANS address to HL
        ADD     HL,BC           ; add the offset to address the second
                                ; byte of the output routine hopefully.
        INC     HL              ; step past
        INC     HL              ; the input routine.

;    Note. When the Sinclair Interface1 is fitted then an instruction fetch
;    on the next address pages this ROM out and the shadow ROM in.

;; ROM_TRAP
o1708:  INC     HL              ; to address channel's letter
        LD      C,(HL)          ; pick it up in C.
                                ; Note. but if stream is already closed we
                                ; get the value $10 (the byte preceding 'K').

        EX      DE,HL           ; save the pointer to the letter in DE.

;   Note. The string pointer is saved but not used!!

        LD      HL,o1716        ; address: cl-str-lu in ROM.
        CALL    o16DC           ; routine INDEXER uses the code to get
                                ; the 8-bit offset from the current point to
                                ; the address of the closing routine in ROM.
                                ; Note. it won't find $10 there!

        LD      C,(HL)          ; transfer the offset to C.
        LD      B,$00           ; prepare to add.
        ADD     HL,BC           ; add offset to point to the address of the
                                ; routine that closes the stream.
                                ; (and presumably removes any buffers that
                                ; are associated with it.)
        JP      (HL)            ; jump to that routine.

; --------------------------------
; THE 'CLOSE STREAM LOOK-UP' TABLE
; --------------------------------
;   This table contains an entry for a letter found in the CHANS area.
;   followed by an 8-bit displacement, from that byte's address in the
;   table to the routine that performs any ancillary actions associated
;   with closing the stream of that channel.
;   The table doesn't require a zero end-marker as the letter has been
;   picked up from a channel that has an open stream.

;; cl-str-lu
o1716:  DEFB    'K', o171C-$-1  ; offset 5 to CLOSE-STR
        DEFB    'S', o171C-$-1  ; offset 3 to CLOSE-STR
        DEFB    'P', o171C-$-1  ; offset 1 to CLOSE-STR


; ------------------------------
; THE 'CLOSE STREAM' SUBROUTINES
; ------------------------------
; The close stream routines in fact have no ancillary actions to perform
; which is not surprising with regard to 'K' and 'S'.

;; CLOSE-STR
o171C:  POP     HL              ; * now just restore the stream data pointer
        RET                     ; in STRMS and return.

; -----------
; Stream data
; -----------
; This routine finds the data entry in the STRMS area for the specified
; stream which is passed on the calculator stack. It returns with HL
; pointing to this system variable and BC holding a displacement from
; the CHANS area to the second byte of the stream's channel. If BC holds
; zero, then that signifies that the stream is closed.

;; STR-DATA
o171E:  CALL    o1E94           ; routine FIND-INT1 fetches parameter to A
        CP      $10             ; is it less than 16d ?
        JR      C,o1727         ; skip forward to STR-DATA1 if so.

;; REPORT-Ob
o1725:  RST     08H             ; ERROR-1
        DEFB    $17             ; Error Report: Invalid stream

;; STR-DATA1
o1727:  ADD     A,$03           ; add the offset for 3 system streams.
                                ; range 00 - 15d becomes 3 - 18d.
        RLCA                    ; double as there are two bytes per
                                ; stream - now 06 - 36d
        LD      HL,STRMS        ; address STRMS - the start of the streams
                                ; data area in system variables.
        LD      C,A             ; transfer the low byte to A.
        LD      B,$00           ; prepare to add offset.
        ADD     HL,BC           ; add to address the data entry in STRMS.

; the data entry itself contains an offset from CHANS to the address of the
; stream

        LD      C,(HL)          ; low byte of displacement to C.
        INC     HL              ; address next.
        LD      B,(HL)          ; high byte of displacement to B.
        DEC     HL              ; step back to leave HL pointing to STRMS
                                ; data entry.
        RET                     ; return with CHANS displacement in BC
                                ; and address of stream data entry in HL.

; --------------------
; Handle OPEN# command
; --------------------
; Command syntax example: OPEN #5,"s"
; On entry the channel code entry is on the calculator stack with the next
; value containing the stream identifier. They have to swapped.

;; OPEN
o1736:  RST     28H             ;; FP-CALC    ;s,c.
        DEFB    $01             ;;exchange    ;c,s.
        DEFB    $38             ;;end-calc

        CALL    o171E           ; routine STR-DATA fetches the stream off
                                ; the stack and returns with the CHANS
                                ; displacement in BC and HL addressing
                                ; the STRMS data entry.
        LD      A,B             ; test for zero which
        OR      C               ; indicates the stream is closed.
        JR      Z,o1756         ; skip forward to OPEN-1 if so.

; if it is a system channel then it can re-attached.

        EX      DE,HL           ; save STRMS address in DE.
        LD      HL,(CHANS)      ; fetch CHANS.
        ADD     HL,BC           ; add the offset to address the second
                                ; byte of the channel.
        INC     HL              ; skip over the
        INC     HL              ; input routine.
        INC     HL              ; and address the letter.
        LD      A,(HL)          ; pick up the letter.
        EX      DE,HL           ; save letter pointer and bring back
                                ; the STRMS pointer.

        CP      $4B             ; is it 'K' ?
        JR      Z,o1756         ; forward to OPEN-1 if so

        CP      $53             ; is it 'S' ?
        JR      Z,o1756         ; forward to OPEN-1 if so

        CP      $50             ; is it 'P' ?
        JR      NZ,o1725        ; back to REPORT-Ob if not.
                                ; to report 'Invalid stream'.

; continue if one of the upper-case letters was found.
; and rejoin here from above if stream was closed.

;; OPEN-1
o1756:  CALL    o175D           ; routine OPEN-2 opens the stream.

; it now remains to update the STRMS variable.

        LD      (HL),E          ; insert or overwrite the low byte.
        INC     HL              ; address high byte in STRMS.
        LD      (HL),D          ; insert or overwrite the high byte.
        RET                     ; return.

; -----------------
; OPEN-2 Subroutine
; -----------------
; There is some point in coming here as, as well as once creating buffers,
; this routine also sets flags.

;; OPEN-2
o175D:  PUSH    HL              ; * save the STRMS data entry pointer.
        CALL    o2BF1           ; routine STK-FETCH now fetches the
                                ; parameters of the channel string.
                                ; start in DE, length in BC.

        LD      A,B             ; test that it is not
        OR      C               ; the null string.
        JR      NZ,o1767        ; skip forward to OPEN-3 with 1 character
                                ; or more!

;; REPORT-Fb
o1765:  RST     08H             ; ERROR-1
        DEFB    $0E             ; Error Report: Invalid file name

;; OPEN-3
o1767:  PUSH    BC              ; save the length of the string.
        LD      A,(DE)          ; pick up the first character.
                                ; Note. There can be more than one character.
        AND     $DF             ; make it upper-case.
        LD      C,A             ; place it in C.
        LD      HL,o177A        ; address: op-str-lu is loaded.
        CALL    o16DC           ; routine INDEXER will search for letter.
        JR      NC,o1765        ; back to REPORT-F if not found
                                ; 'Invalid filename'

        LD      C,(HL)          ; fetch the displacement to opening routine.
        LD      B,$00           ; prepare to add.
        ADD     HL,BC           ; now form address of opening routine.
        POP     BC              ; restore the length of string.
        JP      (HL)            ; now jump forward to the relevant routine.

; -------------------------
; OPEN stream look-up table
; -------------------------
; The open stream look-up table consists of matched pairs.
; The channel letter is followed by an 8-bit displacement to the
; associated stream-opening routine in this ROM.
; The table requires a zero end-marker as the letter has been
; provided by the user and not the operating system.

;; op-str-lu
o177A:  DEFB    'K', o1781-$-1  ; $06 offset to OPEN-K
        DEFB    'S', o1785-$-1  ; $08 offset to OPEN-S
        DEFB    'P', o1789-$-1  ; $0A offset to OPEN-P

        DEFB    $00             ; end-marker.

; ----------------------------
; The Stream Opening Routines.
; ----------------------------
; These routines would have opened any buffers associated with the stream
; before jumping forward to OPEN-END with the displacement value in E
; and perhaps a modified value in BC. The strange pathing does seem to
; provide for flexibility in this respect.
;
; There is no need to open the printer buffer as it is there already
; even if you are still saving up for a ZX Printer or have moved onto
; something bigger. In any case it would have to be created after
; the system variables but apart from that it is a simple task
; and all but one of the ROM routines can handle a buffer in that position.
; (PR-ALL-6 would require an extra 3 bytes of code).
; However it wouldn't be wise to have two streams attached to the ZX Printer
; as you can now, so one assumes that if PR_CC_hi was non-zero then
; the OPEN-P routine would have refused to attach a stream if another
; stream was attached.

; Something of significance is being passed to these ghost routines in the
; second character. Strings 'RB', 'RT' perhaps or a drive/station number.
; The routine would have to deal with that and exit to OPEN_END with BC
; containing $0001 or more likely there would be an exit within the routine.
; Anyway doesn't matter, these routines are long gone.

; -----------------
; OPEN-K Subroutine
; -----------------
; Open Keyboard stream.

;; OPEN-K
o1781:  LD      E,$01           ; 01 is offset to second byte of channel 'K'.
        JR      o178B           ; forward to OPEN-END

; -----------------
; OPEN-S Subroutine
; -----------------
; Open Screen stream.

;; OPEN-S
o1785:  LD      E,$06           ; 06 is offset to 2nd byte of channel 'S'
        JR      o178B           ; to OPEN-END

; -----------------
; OPEN-P Subroutine
; -----------------
; Open Printer stream.

;; OPEN-P
o1789:  LD      E,$10           ; 16d is offset to 2nd byte of channel 'P'

;; OPEN-END
o178B:  DEC     BC              ; the stored length of 'K','S','P' or
                                ; whatever is now tested. ??
        LD      A,B             ; test now if initial or residual length
        OR      C               ; is one character.
        JR      NZ,o1765        ; to REPORT-Fb 'Invalid file name' if not.

        LD      D,A             ; load D with zero to form the displacement
                                ; in the DE register.
        POP     HL              ; * restore the saved STRMS pointer.
        RET                     ; return to update STRMS entry thereby
                                ; signaling stream is open.

; ----------------------------------------
; Handle CAT, ERASE, FORMAT, MOVE commands
; ----------------------------------------
; These just generate an error report as the ROM is 'incomplete'.
;
; Luckily this provides a mechanism for extending these in a shadow ROM
; but without the powerful mechanisms set up in this ROM.
; An instruction fetch on $0008 may page in a peripheral ROM,
; e.g. the Sinclair Interface 1 ROM, to handle these commands.
; However that wasn't the plan.
; Development of this ROM continued for another three months until the cost
; of replacing it and the manual became unfeasible.
; The ultimate power of channels and streams died at birth.

;; CAT-ETC
o1793:  JR      o1725           ; to REPORT-Ob

; -----------------
; Perform AUTO-LIST
; -----------------
; This produces an automatic listing in the upper screen.

;; AUTO-LIST
o1795:  LD      ($5C3F),SP      ; save stack pointer in LIST_SP
        LD      (IY+$02),$10    ; update TV_FLAG set bit 3
        CALL    o0DAF           ; routine CL-ALL.
        SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use

        LD      B,(IY+$31)      ; fetch DF_SZ to B.
        CALL    o0E44           ; routine CL-LINE clears lower display
                                ; preserving B.
        RES     0,(IY+$02)      ; update TV_FLAG  - signal main screen in use
        SET     0,(IY+$30)      ; update FLAGS2 - signal will be necessary to
                                ; clear main screen.
        LD      HL,($5C49)      ; fetch E_PPC current edit line to HL.
        LD      DE,($5C6C)      ; fetch S_TOP to DE, the current top line
                                ; (initially zero)
        AND     A               ; prepare for true subtraction.
        SBC     HL,DE           ; subtract and
        ADD     HL,DE           ; add back.
        JR      C,o17E1         ; to AUTO-L-2 if S_TOP higher than E_PPC
                                ; to set S_TOP to E_PPC

        PUSH    DE              ; save the top line number.
        CALL    o196E           ; routine LINE-ADDR gets address of E_PPC.
        LD      DE,$02C0        ; prepare known number of characters in
                                ; the default upper screen.
        EX      DE,HL           ; offset to HL, program address to DE.
        SBC     HL,DE           ; subtract high value from low to obtain
                                ; negated result used in addition.
        EX      (SP),HL         ; swap result with top line number on stack.
        CALL    o196E           ; routine LINE-ADDR  gets address of that
                                ; top line in HL and next line in DE.
        POP     BC              ; restore the result to balance stack.

;; AUTO-L-1
o17CE:  PUSH    BC              ; save the result.
        CALL    o19B8           ; routine NEXT-ONE gets address in HL of
                                ; line after auto-line (in DE).
        POP     BC              ; restore result.
        ADD     HL,BC           ; compute back.
        JR      C,o17E4         ; to AUTO-L-3 if line 'should' appear

        EX      DE,HL           ; address of next line to HL.
        LD      D,(HL)          ; get line
        INC     HL              ; number
        LD      E,(HL)          ; in DE.
        DEC     HL              ; adjust back to start.
        LD      ($5C6C),DE      ; update S_TOP.
        JR      o17CE           ; to AUTO-L-1 until estimate reached.

; ---

; the jump was to here if S_TOP was greater than E_PPC

;; AUTO-L-2
o17E1:  LD      ($5C6C),HL      ; make S_TOP the same as E_PPC.

; continue here with valid starting point from above or good estimate
; from computation

;; AUTO-L-3
o17E4:  LD      HL,($5C6C)      ; fetch S_TOP line number to HL.
        CALL    o196E           ; routine LINE-ADDR gets address in HL.
                                ; address of next in DE.
        JR      Z,o17ED         ; to AUTO-L-4 if line exists.

        EX      DE,HL           ; else use address of next line.

;; AUTO-L-4
o17ED:  CALL    o1833           ; routine LIST-ALL                >>>

; The return will be to here if no scrolling occurred

        RES     4,(IY+$02)      ; update TV_FLAG  - signal no auto listing.
        RET                     ; return.

; ------------
; Handle LLIST
; ------------
; A short form of LIST #3. The listing goes to stream 3 - default printer.

;; LLIST
o17F5:  LD      A,$03           ; the usual stream for ZX Printer
        JR      o17FB           ; forward to LIST-1

; -----------
; Handle LIST
; -----------
; List to any stream.
; Note. While a starting line can be specified it is
; not possible to specify an end line.
; Just listing a line makes it the current edit line.

;; LIST
o17F9:  LD      A,$02           ; default is stream 2 - the upper screen.

;; LIST-1
o17FB:  LD      (IY+$02),$00    ; the TV_FLAG is initialized with bit 0 reset
                                ; indicating upper screen in use.
        CALL    o2530           ; routine SYNTAX-Z - checking syntax ?
        CALL    NZ,o1601        ; routine CHAN-OPEN if in run-time.

        RST     18H             ; GET-CHAR
        CALL    o2070           ; routine STR-ALTER will alter if '#'.
        JR      C,o181F         ; forward to LIST-4 not a '#' .


        RST     18H             ; GET-CHAR
        CP      $3B             ; is it ';' ?
        JR      Z,o1814         ; skip to LIST-2 if so.

        CP      $2C             ; is it ',' ?
        JR      NZ,o181A        ; forward to LIST-3 if neither separator.

; we have, say,  LIST #15, and a number must follow the separator.

;; LIST-2
o1814:  RST     20H             ; NEXT-CHAR
        CALL    o1C82           ; routine EXPT-1NUM
        JR      o1822           ; forward to LIST-5

; ---

; the branch was here with just LIST #3 etc.

;; LIST-3
o181A:  CALL    o1CE6           ; routine USE-ZERO
        JR      o1822           ; forward to LIST-5

; ---

; the branch was here with LIST

;; LIST-4
o181F:  CALL    o1CDE           ; routine FETCH-NUM checks if a number
                                ; follows else uses zero.

;; LIST-5
o1822:  CALL    o1BEE           ; routine CHECK-END quits if syntax OK >>>

o1825:  CALL    o1E99           ; routine FIND-INT2 fetches the number
                                ; from the calculator stack in run-time.
        LD      A,B             ; fetch high byte of line number and
        AND     $3F             ; make less than $40 so that NEXT-ONE
                                ; (from LINE-ADDR) doesn't lose context.
                                ; Note. this is not satisfactory and the typo
                                ; LIST 20000 will list an entirely different
                                ; section than LIST 2000. Such typos are not
                                ; available for checking if they are direct
                                ; commands.

        LD      H,A             ; transfer the modified
        LD      L,C             ; line number to HL.
        LD      ($5C49),HL      ; update E_PPC to new line number.
        CALL    o196E           ; routine LINE-ADDR gets the address of the
                                ; line.

; This routine is called from AUTO-LIST

;; LIST-ALL
o1833:  LD      E,$01           ; signal current line not yet printed

;; LIST-ALL-2
o1835:  CALL    o1855           ; routine OUT-LINE outputs a BASIC line
                                ; using PRINT-OUT and makes an early return
                                ; when no more lines to print. >>>

        RST     10H             ; PRINT-A prints the carriage return (in A)

        BIT     4,(IY+$02)      ; test TV_FLAG  - automatic listing ?
        JR      Z,o1835         ; back to LIST-ALL-2 if not
                                ; (loop exit is via OUT-LINE)

; continue here if an automatic listing required.

        LD      A,($5C6B)       ; fetch DF_SZ lower display file size.
        SUB     (IY+$4F)        ; subtract S_POSN_hi ithe current line number.
        JR      NZ,o1835        ; back to LIST-ALL-2 if upper screen not full.

        XOR     E               ; A contains zero, E contains one if the
                                ; current edit line has not been printed
                                ; or zero if it has (from OUT-LINE).
        RET     Z               ; return if the screen is full and the line
                                ; has been printed.

; continue with automatic listings if the screen is full and the current
; edit line is missing. OUT-LINE will scroll automatically.

        PUSH    HL              ; save the pointer address.
        PUSH    DE              ; save the E flag.
        LD      HL,$5C6C        ; fetch S_TOP the rough estimate.
        CALL    o190F           ; routine LN-FETCH updates S_TOP with
                                ; the number of the next line.
        POP     DE              ; restore the E flag.
        POP     HL              ; restore the address of the next line.
        JR      o1835           ; back to LIST-ALL-2.

; ------------------------
; Print a whole BASIC line
; ------------------------
; This routine prints a whole BASIC line and it is called
; from LIST-ALL to output the line to current channel
; and from ED-EDIT to 'sprint' the line to the edit buffer.

;; OUT-LINE
o1855:  LD      BC,($5C49)      ; fetch E_PPC the current line which may be
                                ; unchecked and not exist.
        CALL    o1980           ; routine CP-LINES finds match or line after.
        LD      D,$3E           ; prepare cursor '>' in D.
        JR      Z,o1865         ; to OUT-LINE1 if matched or line after.

        LD      DE,$0000        ; put zero in D, to suppress line cursor.
        RL      E               ; pick up carry in E if line before current
                                ; leave E zero if same or after.

;; OUT-LINE1
o1865:  LD      (IY+$2D),E      ; save flag in BREG which is spare.
        LD      A,(HL)          ; get high byte of line number.
        CP      $40             ; is it too high ($2F is maximum possible) ?
        POP     BC              ; drop the return address and
        RET     NC              ; make an early return if so >>>

        PUSH    BC              ; save return address
        CALL    o1A28           ; routine OUT-NUM-2 to print addressed number
                                ; with leading space.
        INC     HL              ; skip low number byte.
        INC     HL              ; and the two
        INC     HL              ; length bytes.
        RES     0,(IY+$01)      ; update FLAGS - signal leading space required.
        LD      A,D             ; fetch the cursor.
        AND     A               ; test for zero.
        JR      Z,o1881         ; to OUT-LINE3 if zero.


        RST     10H             ; PRINT-A prints '>' the current line cursor.

; this entry point is called from ED-COPY

;; OUT-LINE2
o187D:  SET     0,(IY+$01)      ; update FLAGS - suppress leading space.

;; OUT-LINE3
o1881:  PUSH    DE              ; save flag E for a return value.
        EX      DE,HL           ; save HL address in DE.
        RES     2,(IY+$30)      ; update FLAGS2 - signal NOT in QUOTES.

        LD      HL,$5C3B        ; point to FLAGS.
        RES     2,(HL)          ; signal 'K' mode. (starts before keyword)
        BIT     5,(IY+$37)      ; test FLAGX - input mode ?
        JR      Z,o1894         ; forward to OUT-LINE4 if not.

        SET     2,(HL)          ; signal 'L' mode. (used for input)

;; OUT-LINE4
o1894:  LD      HL,(X_PTR)      ; fetch X_PTR - possibly the error pointer
                                ; address.
        AND     A               ; clear the carry flag.
        SBC     HL,DE           ; test if an error address has been reached.
        JR      NZ,o18A1        ; forward to OUT-LINE5 if not.

        LD      A,$3F           ; load A with '?' the error marker.
        CALL    o18C1           ; routine OUT-FLASH to print flashing marker.

;; OUT-LINE5
o18A1:  CALL    o18E1           ; routine OUT-CURS will print the cursor if
                                ; this is the right position.
        EX      DE,HL           ; restore address pointer to HL.
        LD      A,(HL)          ; fetch the addressed character.
        CALL    o18B6           ; routine NUMBER skips a hidden floating
                                ; point number if present.
        INC     HL              ; now increment the pointer.
        CP      $0D             ; is character end-of-line ?
        JR      Z,o18B4         ; to OUT-LINE6, if so, as line is finished.

        EX      DE,HL           ; save the pointer in DE.
        CALL    o1937           ; routine OUT-CHAR to output character/token.

        JR      o1894           ; back to OUT-LINE4 until entire line is done.

; ---

;; OUT-LINE6
o18B4:  POP     DE              ; bring back the flag E, zero if current
                                ; line printed else 1 if still to print.
        RET                     ; return with A holding $0D

; -------------------------
; Check for a number marker
; -------------------------
; this subroutine is called from two processes. while outputting BASIC lines
; and while searching statements within a BASIC line.
; during both, this routine will pass over an invisible number indicator
; and the five bytes floating-point number that follows it.
; Note that this causes floating point numbers to be stripped from
; the BASIC line when it is fetched to the edit buffer by OUT_LINE.
; the number marker also appears after the arguments of a DEF FN statement
; and may mask old 5-byte string parameters.

;; NUMBER
o18B6:  CP      $0E             ; character fourteen ?
        RET     NZ              ; return if not.

        INC     HL              ; skip the character
        INC     HL              ; and five bytes
        INC     HL              ; following.
        INC     HL              ;
        INC     HL              ;
        INC     HL              ;
        LD      A,(HL)          ; fetch the following character
        RET                     ; for return value.

; --------------------------
; Print a flashing character
; --------------------------
; This subroutine is called from OUT-LINE to print a flashing error
; marker '?' or from the next routine to print a flashing cursor e.g. 'L'.
; However, this only gets called from OUT-LINE when printing the edit line
; or the input buffer to the lower screen so a direct call to $09F4 can
; be used, even though out-line outputs to other streams.
; In fact the alternate set is used for the whole routine.

;; OUT-FLASH
o18C1:  EXX                     ; switch in alternate set

        LD      HL,(ATTR_T)     ; fetch L = ATTR_T, H = MASK-T
        PUSH    HL              ; save masks.
        RES     7,H             ; reset flash mask bit so active.
        SET     7,L             ; make attribute FLASH.
        LD      (ATTR_T),HL     ; resave ATTR_T and MASK-T

        LD      HL,$5C91        ; address P_FLAG
        LD      D,(HL)          ; fetch to D
        PUSH    DE              ; and save.
        LD      (HL),$00        ; clear inverse, over, ink/paper 9

        CALL    o09F4           ; routine PRINT-OUT outputs character
                                ; without the need to vector via RST 10.

        POP     HL              ; pop P_FLAG to H.
        LD      (IY+$57),H      ; and restore system variable P_FLAG.
        POP     HL              ; restore temporary masks
        LD      (ATTR_T),HL     ; and restore system variables ATTR_T/MASK_T

        EXX                     ; switch back to main set
        RET                     ; return

; ----------------
; Print the cursor
; ----------------
; This routine is called before any character is output while outputting
; a BASIC line or the input buffer. This includes listing to a printer
; or screen, copying a BASIC line to the edit buffer and printing the
; input buffer or edit buffer to the lower screen. It is only in the
; latter two cases that it has any relevance and in the last case it
; performs another very important function also.

;; OUT-CURS
o18E1:  LD      HL,($5C5B)      ; fetch K_CUR the current cursor address
        AND     A               ; prepare for true subtraction.
        SBC     HL,DE           ; test against pointer address in DE and
        RET     NZ              ; return if not at exact position.

; the value of MODE, maintained by KEY-INPUT, is tested and if non-zero
; then this value 'E' or 'G' will take precedence.

        LD      A,($5C41)       ; fetch MODE  0='KLC', 1='E', 2='G'.
        RLC     A               ; double the value and set flags.
        JR      Z,o18F3         ; to OUT-C-1 if still zero ('KLC').

        ADD     A,$43           ; add 'C' - will become 'E' if originally 1
                                ; or 'G' if originally 2.
        JR      o1909           ; forward to OUT-C-2 to print.

; ---

; If mode was zero then, while printing a BASIC line, bit 2 of flags has been
; set if 'THEN' or ':' was encountered as a main character and reset otherwise.
; This is now used to determine if the 'K' cursor is to be printed but this
; transient state is also now transferred permanently to bit 3 of FLAGS
; to let the interrupt routine know how to decode the next key.

;; OUT-C-1
o18F3:  LD      HL,$5C3B        ; Address FLAGS
        RES     3,(HL)          ; signal 'K' mode initially.
        LD      A,$4B           ; prepare letter 'K'.
        BIT     2,(HL)          ; test FLAGS - was the
                                ; previous main character ':' or 'THEN' ?
        JR      Z,o1909         ; forward to OUT-C-2 if so to print.

        SET     3,(HL)          ; signal 'L' mode to interrupt routine.
                                ; Note. transient bit has been made permanent.
        INC     A               ; augment from 'K' to 'L'.

        BIT     3,(IY+$30)      ; test FLAGS2 - consider caps lock ?
                                ; which is maintained by KEY-INPUT.
        JR      Z,o1909         ; forward to OUT-C-2 if not set to print.

        LD      A,$43           ; alter 'L' to 'C'.

;; OUT-C-2
o1909:  PUSH    DE              ; save address pointer but OK as OUT-FLASH
                                ; uses alternate set without RST 10.

        CALL    o18C1           ; routine OUT-FLASH to print.

        POP     DE              ; restore and
        RET                     ; return.

; ----------------------------
; Get line number of next line
; ----------------------------
; These two subroutines are called while editing.
; This entry point is from ED-DOWN with HL addressing E_PPC
; to fetch the next line number.
; Also from AUTO-LIST with HL addressing S_TOP just to update S_TOP
; with the value of the next line number. It gets fetched but is discarded.
; These routines never get called while the editor is being used for input.

;; LN-FETCH
o190F:  LD      E,(HL)          ; fetch low byte
        INC     HL              ; address next
        LD      D,(HL)          ; fetch high byte.
        PUSH    HL              ; save system variable hi pointer.
        EX      DE,HL           ; line number to HL,
        INC     HL              ; increment as a starting point.
        CALL    o196E           ; routine LINE-ADDR gets address in HL.
        CALL    o1695           ; routine LINE-NO gets line number in DE.
        POP     HL              ; restore system variable hi pointer.

; This entry point is from the ED-UP with HL addressing E_PPC_hi

;; LN-STORE
o191C:  BIT     5,(IY+$37)      ; test FLAGX - input mode ?
        RET     NZ              ; return if so.
                                ; Note. above already checked by ED-UP/ED-DOWN.

        LD      (HL),D          ; save high byte of line number.
        DEC     HL              ; address lower
        LD      (HL),E          ; save low byte of line number.
        RET                     ; return.

; -----------------------------------------
; Outputting numbers at start of BASIC line
; -----------------------------------------
; This routine entered at OUT-SP-NO is used to compute then output the first
; three digits of a 4-digit BASIC line printing a space if necessary.
; The line number, or residual part, is held in HL and the BC register
; holds a subtraction value -1000, -100 or -10.
; Note. for example line number 200 -
; space(out_char), 2(out_code), 0(out_char) final number always out-code.

;; OUT-SP-2
o1925:  LD      A,E             ; will be space if OUT-CODE not yet called.
                                ; or $FF if spaces are suppressed.
                                ; else $30 ('0').
                                ; (from the first instruction at OUT-CODE)
                                ; this guy is just too clever.
        AND     A               ; test bit 7 of A.
        RET     M               ; return if $FF, as leading spaces not
                                ; required. This is set when printing line
                                ; number and statement in MAIN-5.

        JR      o1937           ; forward to exit via OUT-CHAR.

; ---

; -> the single entry point.

;; OUT-SP-NO
o192A:  XOR     A               ; initialize digit to 0

;; OUT-SP-1
o192B:  ADD     HL,BC           ; add negative number to HL.
        INC     A               ; increment digit
        JR      C,o192B         ; back to OUT-SP-1 until no carry from
                                ; the addition.

        SBC     HL,BC           ; cancel the last addition
        DEC     A               ; and decrement the digit.
        JR      Z,o1925         ; back to OUT-SP-2 if it is zero.

        JP      o15EF           ; jump back to exit via OUT-CODE.    ->


; -------------------------------------
; Outputting characters in a BASIC line
; -------------------------------------
; This subroutine ...

;; OUT-CHAR
o1937:  CALL    o2D1B           ; routine NUMERIC tests if it is a digit ?
        JR      NC,o196C        ; to OUT-CH-3 to print digit without
                                ; changing mode. Will be 'K' mode if digits
                                ; are at beginning of edit line.

        CP      $21             ; less than quote character ?
        JR      C,o196C         ; to OUT-CH-3 to output controls and space.

        RES     2,(IY+$01)      ; initialize FLAGS to 'K' mode and leave
                                ; unchanged if this character would precede
                                ; a keyword.

        CP      $CB             ; is character 'THEN' token ?
        JR      Z,o196C         ; to OUT-CH-3 to output if so.

        CP      $3A             ; is it ':' ?
        JR      NZ,o195A        ; to OUT-CH-1 if not statement separator
                                ; to change mode back to 'L'.

        BIT     5,(IY+$37)      ; FLAGX  - Input Mode ??
        JR      NZ,o1968        ; to OUT-CH-2 if in input as no statements.
                                ; Note. this check should seemingly be at
                                ; the start. Commands seem inappropriate in
                                ; INPUT mode and are rejected by the syntax
                                ; checker anyway.
                                ; unless INPUT LINE is being used.

        BIT     2,(IY+$30)      ; test FLAGS2 - is the ':' within quotes ?
        JR      Z,o196C         ; to OUT-CH-3 if ':' is outside quoted text.

        JR      o1968           ; to OUT-CH-2 as ':' is within quotes

; ---

;; OUT-CH-1
o195A:  CP      $22             ; is it quote character '"'  ?
        JR      NZ,o1968        ; to OUT-CH-2 with others to set 'L' mode.

        PUSH    AF              ; save character.
        LD      A,($5C6A)       ; fetch FLAGS2.
        XOR     $04             ; toggle the quotes flag.
        LD      ($5C6A),A       ; update FLAGS2
        POP     AF              ; and restore character.

;; OUT-CH-2
o1968:  SET     2,(IY+$01)      ; update FLAGS - signal L mode if the cursor
                                ; is next.

;; OUT-CH-3
o196C:  RST     10H             ; PRINT-A vectors the character to
                                ; channel 'S', 'K', 'R' or 'P'.
        RET                     ; return.

; -------------------------------------------
; Get starting address of line, or line after
; -------------------------------------------
; This routine is used often to get the address, in HL, of a BASIC line
; number supplied in HL, or failing that the address of the following line
; and the address of the previous line in DE.

;; LINE-ADDR
o196E:  PUSH    HL              ; save line number in HL register
        LD      HL,(PROG)       ; fetch start of program from PROG
        LD      D,H             ; transfer address to
        LD      E,L             ; the DE register pair.

;; LINE-AD-1
o1974:  POP     BC              ; restore the line number to BC
        CALL    o1980           ; routine CP-LINES compares with that
                                ; addressed by HL
        RET     NC              ; return if line has been passed or matched.
                                ; if NZ, address of previous is in DE

        PUSH    BC              ; save the current line number
        CALL    o19B8           ; routine NEXT-ONE finds address of next
                                ; line number in DE, previous in HL.
        EX      DE,HL           ; switch so next in HL
        JR      o1974           ; back to LINE-AD-1 for another comparison

; --------------------
; Compare line numbers
; --------------------
; This routine compares a line number supplied in BC with an addressed
; line number pointed to by HL.

;; CP-LINES
o1980:  LD      A,(HL)          ; Load the high byte of line number and
        CP      B               ; compare with that of supplied line number.
        RET     NZ              ; return if yet to match (carry will be set).

        INC     HL              ; address low byte of
        LD      A,(HL)          ; number and pick up in A.
        DEC     HL              ; step back to first position.
        CP      C               ; now compare.
        RET                     ; zero set if exact match.
                                ; carry set if yet to match.
                                ; no carry indicates a match or
                                ; next available BASIC line or
                                ; program end marker.

; -------------------
; Find each statement
; -------------------
; The single entry point EACH-STMT is used to
; 1) To find the D'th statement in a line.
; 2) To find a token in held E.

;; not-used
o1988:  INC     HL              ;
        INC     HL              ;
        INC     HL              ;

; -> entry point.

;; EACH-STMT
o198B:  LD      (CH_ADD),HL     ; save HL in CH_ADD
        LD      C,$00           ; initialize quotes flag

;; EACH-S-1
o1990:  DEC     D               ; decrease statement count
        RET     Z               ; return if zero


        RST     20H             ; NEXT-CHAR
        CP      E               ; is it the search token ?
        JR      NZ,o199A        ; forward to EACH-S-3 if not

        AND     A               ; clear carry
        RET                     ; return signalling success.

; ---

;; EACH-S-2
o1998:  INC     HL              ; next address
        LD      A,(HL)          ; next character

;; EACH-S-3
o199A:  CALL    o18B6           ; routine NUMBER skips if number marker
        LD      (CH_ADD),HL     ; save in CH_ADD
        CP      $22             ; is it quotes '"' ?
        JR      NZ,o19A5        ; to EACH-S-4 if not

        DEC     C               ; toggle bit 0 of C

;; EACH-S-4
o19A5:  CP      $3A             ; is it ':'
        JR      Z,o19AD         ; to EACH-S-5

        CP      $CB             ; 'THEN'
        JR      NZ,o19B1        ; to EACH-S-6

;; EACH-S-5
o19AD:  BIT     0,C             ; is it in quotes
        JR      Z,o1990         ; to EACH-S-1 if not

;; EACH-S-6
o19B1:  CP      $0D             ; end of line ?
        JR      NZ,o1998        ; to EACH-S-2

        DEC     D               ; decrease the statement counter
                                ; which should be zero else
                                ; 'Statement Lost'.
        SCF                     ; set carry flag - not found
        RET                     ; return

; -----------------------------------------------------------------------
; Storage of variables. For full details - see chapter 24.
; ZX Spectrum BASIC Programming by Steven Vickers 1982.
; It is bits 7-5 of the first character of a variable that allow
; the six types to be distinguished. Bits 4-0 are the reduced letter.
; So any variable name is higher that $3F and can be distinguished
; also from the variables area end-marker $80.
;
; 76543210 meaning                               brief outline of format.
; -------- ------------------------              -----------------------
; 010      string variable.                      2 byte length + contents.
; 110      string array.                         2 byte length + contents.
; 100      array of numbers.                     2 byte length + contents.
; 011      simple numeric variable.              5 bytes.
; 101      variable length named numeric.        5 bytes.
; 111      for-next loop variable.               18 bytes.
; 10000000 the variables area end-marker.
;
; Note. any of the above seven will serve as a program end-marker.
;
; -----------------------------------------------------------------------

; ------------
; Get next one
; ------------
; This versatile routine is used to find the address of the next line
; in the program area or the next variable in the variables area.
; The reason one routine is made to handle two apparently unrelated tasks
; is that it can be called indiscriminately when merging a line or a
; variable.

;; NEXT-ONE
o19B8:  PUSH    HL              ; save the pointer address.
        LD      A,(HL)          ; get first byte.
        CP      $40             ; compare with upper limit for line numbers.
        JR      C,o19D5         ; forward to NEXT-O-3 if within BASIC area.

; the continuation here is for the next variable unless the supplied
; line number was erroneously over 16383. see RESTORE command.

        BIT     5,A             ; is it a string or an array variable ?
        JR      Z,o19D6         ; forward to NEXT-O-4 to compute length.

        ADD     A,A             ; test bit 6 for single-character variables.
        JP      M,o19C7         ; forward to NEXT-O-1 if so

        CCF                     ; clear the carry for long-named variables.
                                ; it remains set for for-next loop variables.

;; NEXT-O-1
o19C7:  LD      BC,$0005        ; set BC to 5 for floating point number
        JR      NC,o19CE        ; forward to NEXT-O-2 if not a for/next
                                ; variable.

        LD      C,$12           ; set BC to eighteen locations.
                                ; value, limit, step, line and statement.

; now deal with long-named variables

;; NEXT-O-2
o19CE:  RLA                     ; test if character inverted. carry will also
                                ; be set for single character variables
        INC     HL              ; address next location.
        LD      A,(HL)          ; and load character.
        JR      NC,o19CE        ; back to NEXT-O-2 if not inverted bit.
                                ; forward immediately with single character
                                ; variable names.

        JR      o19DB           ; forward to NEXT-O-5 to add length of
                                ; floating point number(s etc.).

; ---

; this branch is for line numbers.

;; NEXT-O-3
o19D5:  INC     HL              ; increment pointer to low byte of line no.

; strings and arrays rejoin here

;; NEXT-O-4
o19D6:  INC     HL              ; increment to address the length low byte.
        LD      C,(HL)          ; transfer to C and
        INC     HL              ; point to high byte of length.
        LD      B,(HL)          ; transfer that to B
        INC     HL              ; point to start of BASIC/variable contents.

; the three types of numeric variables rejoin here

;; NEXT-O-5
o19DB:  ADD     HL,BC           ; add the length to give address of next
                                ; line/variable in HL.
        POP     DE              ; restore previous address to DE.

; ------------------
; Difference routine
; ------------------
; This routine terminates the above routine and is also called from the
; start of the next routine to calculate the length to reclaim.

;; DIFFER
o19DD:  AND     A               ; prepare for true subtraction.
        SBC     HL,DE           ; subtract the two pointers.
        LD      B,H             ; transfer result
        LD      C,L             ; to BC register pair.
        ADD     HL,DE           ; add back
        EX      DE,HL           ; and switch pointers
        RET                     ; return values are the length of area in BC,
                                ; low pointer (previous) in HL,
                                ; high pointer (next) in DE.

; -----------------------
; Handle reclaiming space
; -----------------------
;

;; RECLAIM-1
o19E5:  CALL    o19DD           ; routine DIFFER immediately above

;; RECLAIM-2
o19E8:  PUSH    BC              ;

        LD      A,B             ;
        CPL                     ;
        LD      B,A             ;
        LD      A,C             ;
        CPL                     ;
        LD      C,A             ;
        INC     BC              ;

        CALL    o1664           ; routine POINTERS
        EX      DE,HL           ;
        POP     HL              ;

        ADD     HL,DE           ;
        PUSH    DE              ;
        LDIR                    ; copy bytes

        POP     HL              ;
        RET                     ;

; ----------------------------------------
; Read line number of line in editing area
; ----------------------------------------
; This routine reads a line number in the editing area returning the number
; in the BC register or zero if no digits exist before commands.
; It is called from LINE-SCAN to check the syntax of the digits.
; It is called from MAIN-3 to extract the line number in preparation for
; inclusion of the line in the BASIC program area.
;
; Interestingly the calculator stack is moved from its normal place at the
; end of dynamic memory to an adequate area within the system variables area.
; This ensures that in a low memory situation, that valid line numbers can
; be extracted without raising an error and that memory can be reclaimed
; by deleting lines. If the stack was in its normal place then a situation
; arises whereby the Spectrum becomes locked with no means of reclaiming space.

;; E-LINE-NO
o19FB:  LD      HL,($5C59)      ; load HL from system variable E_LINE.

        DEC     HL              ; decrease so that NEXT_CHAR can be used
                                ; without skipping the first digit.

        LD      (CH_ADD),HL     ; store in the system variable CH_ADD.

        RST     20H             ; NEXT-CHAR skips any noise and white-space
                                ; to point exactly at the first digit.

        LD      HL,$5C92        ; use MEM-0 as a temporary calculator stack
                                ; an overhead of three locations are needed.
        LD      (STKEND),HL     ; set new STKEND.

        CALL    o2D3B           ; routine INT-TO-FP will read digits till
                                ; a non-digit found.
        CALL    o2DA2           ; routine FP-TO-BC will retrieve number
                                ; from stack at membot.
        JR      C,o1A15         ; forward to E-L-1 if overflow i.e. > 65535.
                                ; 'Nonsense in BASIC'

        LD      HL,$D8F0        ; load HL with value -9999
        ADD     HL,BC           ; add to line number in BC

;; E-L-1
o1A15:  JP      C,o1C8A         ; to REPORT-C 'Nonsense in BASIC' if over.
                                ; Note. As ERR_SP points to ED_ERROR
                                ; the report is never produced although
                                ; the RST $08 will update X_PTR leading to
                                ; the error marker being displayed when
                                ; the ED_LOOP is reiterated.
                                ; in fact, since it is immediately
                                ; cancelled, any report will do.

; a line in the range 0 - 9999 has been entered.

        JP      o16C5           ; jump back to SET-STK to set the calculator
                                ; stack back to its normal place and exit
                                ; from there.

; ---------------------------------
; Report and line number outputting
; ---------------------------------
; Entry point OUT-NUM-1 is used by the Error Reporting code to print
; the line number and later the statement number held in BC.
; If the statement was part of a direct command then -2 is used as a
; dummy line number so that zero will be printed in the report.
; This routine is also used to print the exponent of E-format numbers.
;
; Entry point OUT-NUM-2 is used from OUT-LINE to output the line number
; addressed by HL with leading spaces if necessary.

;; OUT-NUM-1
o1A1B:  PUSH    DE              ; save the
        PUSH    HL              ; registers.
        XOR     A               ; set A to zero.
        BIT     7,B             ; is the line number minus two ?
        JR      NZ,o1A42        ; forward to OUT-NUM-4 if so to print zero
                                ; for a direct command.

        LD      H,B             ; transfer the
        LD      L,C             ; number to HL.
        LD      E,$FF           ; signal 'no leading zeros'.
        JR      o1A30           ; forward to continue at OUT-NUM-3

; ---

; from OUT-LINE - HL addresses line number.

;; OUT-NUM-2
o1A28:  PUSH    DE              ; save flags
        LD      D,(HL)          ; high byte to D
        INC     HL              ; address next
        LD      E,(HL)          ; low byte to E
        PUSH    HL              ; save pointer
        EX      DE,HL           ; transfer number to HL
        LD      E,$20           ; signal 'output leading spaces'

;; OUT-NUM-3
o1A30:  LD      BC,$FC18        ; value -1000
        CALL    o192A           ; routine OUT-SP-NO outputs space or number
        LD      BC,$FF9C        ; value -100
        CALL    o192A           ; routine OUT-SP-NO
        LD      C,$F6           ; value -10 ( B is still $FF )
        CALL    o192A           ; routine OUT-SP-NO
        LD      A,L             ; remainder to A.

;; OUT-NUM-4
o1A42:  CALL    o15EF           ; routine OUT-CODE for final digit.
                                ; else report code zero wouldn't get
                                ; printed.
        POP     HL              ; restore the
        POP     DE              ; registers and
        RET                     ; return.


;***************************************************
;** Part 7. BASIC LINE AND COMMAND INTERPRETATION **
;***************************************************

; ----------------
; The offset table
; ----------------
; The BASIC interpreter has found a command code $CE - $FF
; which is then reduced to range $00 - $31 and added to the base address
; of this table to give the address of an offset which, when added to
; the offset therein, gives the location in the following parameter table
; where a list of class codes, separators and addresses relevant to the
; command exists.

;; offst-tbl
o1A48:  DEFB    o1AF9 - $       ; B1 offset to Address: P-DEF-FN
        DEFB    o1B14 - $       ; CB offset to Address: P-CAT
        DEFB    o1B06 - $       ; BC offset to Address: P-FORMAT
        DEFB    o1B0A - $       ; BF offset to Address: P-MOVE
        DEFB    o1B10 - $       ; C4 offset to Address: P-ERASE
        DEFB    o1AFC - $       ; AF offset to Address: P-OPEN
        DEFB    o1B02 - $       ; B4 offset to Address: P-CLOSE
        DEFB    o1AE2 - $       ; 93 offset to Address: P-MERGE
        DEFB    o1AE1 - $       ; 91 offset to Address: P-VERIFY
        DEFB    o1AE3 - $       ; 92 offset to Address: P-BEEP
        DEFB    o1AE7 - $       ; 95 offset to Address: P-CIRCLE
        DEFB    o1AEB - $       ; 98 offset to Address: P-INK
        DEFB    o1AEC - $       ; 98 offset to Address: P-PAPER
        DEFB    o1AED - $       ; 98 offset to Address: P-FLASH
        DEFB    o1AEE - $       ; 98 offset to Address: P-BRIGHT
        DEFB    o1AEF - $       ; 98 offset to Address: P-INVERSE
        DEFB    o1AF0 - $       ; 98 offset to Address: P-OVER
        DEFB    o1AF1 - $       ; 98 offset to Address: P-OUT
        DEFB    o1AD9 - $       ; 7F offset to Address: P-LPRINT
        DEFB    o1ADC - $       ; 81 offset to Address: P-LLIST
        DEFB    o1A8A - $       ; 2E offset to Address: P-STOP
        DEFB    o1AC9 - $       ; 6C offset to Address: P-READ
        DEFB    o1ACC - $       ; 6E offset to Address: P-DATA
        DEFB    o1ACF - $       ; 70 offset to Address: P-RESTORE
        DEFB    o1AA8 - $       ; 48 offset to Address: P-NEW
        DEFB    o1AF5 - $       ; 94 offset to Address: P-BORDER
        DEFB    o1AB8 - $       ; 56 offset to Address: P-CONT
        DEFB    o1AA2 - $       ; 3F offset to Address: P-DIM
        DEFB    o1AA5 - $       ; 41 offset to Address: P-REM
        DEFB    o1A90 - $       ; 2B offset to Address: P-FOR
        DEFB    o1A7D - $       ; 17 offset to Address: P-GO-TO
        DEFB    o1A86 - $       ; 1F offset to Address: P-GO-SUB
        DEFB    o1A9F - $       ; 37 offset to Address: P-INPUT
        DEFB    o1AE0 - $       ; 77 offset to Address: P-LOAD
        DEFB    o1AAE - $       ; 44 offset to Address: P-LIST
        DEFB    o1A7A - $       ; 0F offset to Address: P-LET
        DEFB    o1AC5 - $       ; 59 offset to Address: P-PAUSE
        DEFB    o1A98 - $       ; 2B offset to Address: P-NEXT
        DEFB    o1AB1 - $       ; 43 offset to Address: P-POKE
        DEFB    o1A9C - $       ; 2D offset to Address: P-PRINT
        DEFB    o1AC1 - $       ; 51 offset to Address: P-PLOT
        DEFB    o1AAB - $       ; 3A offset to Address: P-RUN
        DEFB    o1ADF - $       ; 6D offset to Address: P-SAVE
        DEFB    o1AB5 - $       ; 42 offset to Address: P-RANDOM
        DEFB    o1A81 - $       ; 0D offset to Address: P-IF
        DEFB    o1ABE - $       ; 49 offset to Address: P-CLS
        DEFB    o1AD2 - $       ; 5C offset to Address: P-DRAW
        DEFB    o1ABB - $       ; 44 offset to Address: P-CLEAR
        DEFB    o1A8D - $       ; 15 offset to Address: P-RETURN
        DEFB    o1AD6 - $       ; 5D offset to Address: P-COPY


; -------------------------------
; The parameter or "Syntax" table
; -------------------------------
; For each command there exists a variable list of parameters.
; If the character is greater than a space it is a required separator.
; If less, then it is a command class in the range 00 - 0B.
; Note that classes 00, 03 and 05 will fetch the addresses from this table.
; Some classes e.g. 07 and 0B have the same address in all invocations
; and the command is re-computed from the low-byte of the parameter address.
; Some e.g. 02 are only called once so a call to the command is made from
; within the class routine rather than holding the address within the table.
; Some class routines check syntax entirely and some leave this task for the
; command itself.
; Others for example CIRCLE (x,y,z) check the first part (x,y) using the
; class routine and the final part (,z) within the command.
; The last few commands appear to have been added in a rush but their syntax
; is rather simple e.g. MOVE "M1","M2"

;; P-LET
o1A7A:  DEFB    $01             ; Class-01 - A variable is required.
        DEFB    $3D             ; Separator:  '='
        DEFB    $02             ; Class-02 - An expression, numeric or string,
                                ; must follow.

;; P-GO-TO
o1A7D:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1E67           ; Address: $1E67; Address: GO-TO

;; P-IF
o1A81:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $CB             ; Separator:  'THEN'
        DEFB    $05             ; Class-05 - Variable syntax checked
                                ; by routine.
        DEFW    o1CF0           ; Address: $1CF0; Address: IF

;; P-GO-SUB
o1A86:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1EED           ; Address: $1EED; Address: GO-SUB

;; P-STOP
o1A8A:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1CEE           ; Address: $1CEE; Address: STOP

;; P-RETURN
o1A8D:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1F23           ; Address: $1F23; Address: RETURN

;; P-FOR
o1A90:  DEFB    $04             ; Class-04 - A single character variable must
                                ; follow.
        DEFB    $3D             ; Separator:  '='
        DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $CC             ; Separator:  'TO'
        DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $05             ; Class-05 - Variable syntax checked
                                ; by routine.
        DEFW    o1D03           ; Address: $1D03; Address: FOR

;; P-NEXT
o1A98:  DEFB    $04             ; Class-04 - A single character variable must
                                ; follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1DAB           ; Address: $1DAB; Address: NEXT

;; P-PRINT
o1A9C:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1FCD           ; Address: $1FCD; Address: PRINT

;; P-INPUT
o1A9F:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o2089           ; Address: $2089; Address: INPUT

;; P-DIM
o1AA2:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o2C02           ; Address: $2C02; Address: DIM

;; P-REM
o1AA5:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1BB2           ; Address: $1BB2; Address: REM

;; P-NEW
o1AA8:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o11B7           ; Address: $11B7; Address: NEW

;; P-RUN
o1AAB:  DEFB    $03             ; Class-03 - A numeric expression may follow
                                ; else default to zero.
        DEFW    o1EA1           ; Address: $1EA1; Address: RUN

;; P-LIST
o1AAE:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o17F9           ; Address: $17F9; Address: LIST

;; P-POKE
o1AB1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
                                ; expressions required.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1E80           ; Address: $1E80; Address: POKE

;; P-RANDOM
o1AB5:  DEFB    $03             ; Class-03 - A numeric expression may follow
                                ; else default to zero.
        DEFW    o1E4F           ; Address: $1E4F; Address: RANDOMIZE

;; P-CONT
o1AB8:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1E5F           ; Address: $1E5F; Address: CONTINUE

;; P-CLEAR
o1ABB:  DEFB    $03             ; Class-03 - A numeric expression may follow
                                ; else default to zero.
        DEFW    o1EAC           ; Address: $1EAC; Address: CLEAR

;; P-CLS
o1ABE:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o0D6B           ; Address: $0D6B; Address: CLS

;; P-PLOT
o1AC1:  DEFB    $09             ; Class-09 - Two comma-separated numeric
                                ; expressions required with optional colour
                                ; items.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o22DC           ; Address: $22DC; Address: PLOT

;; P-PAUSE
o1AC5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1F3A           ; Address: $1F3A; Address: PAUSE

;; P-READ
o1AC9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1DED           ; Address: $1DED; Address: READ

;; P-DATA
o1ACC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1E27           ; Address: $1E27; Address: DATA

;; P-RESTORE
o1ACF:  DEFB    $03             ; Class-03 - A numeric expression may follow
                                ; else default to zero.
        DEFW    o1E42           ; Address: $1E42; Address: RESTORE

;; P-DRAW
o1AD2:  DEFB    $09             ; Class-09 - Two comma-separated numeric
                                ; expressions required with optional colour
                                ; items.
        DEFB    $05             ; Class-05 - Variable syntax checked
                                ; by routine.
        DEFW    o2382           ; Address: $2382; Address: DRAW

;; P-COPY
o1AD6:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o0EAC           ; Address: $0EAC; Address: COPY

;; P-LPRINT
o1AD9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1FC9           ; Address: $1FC9; Address: LPRINT

;; P-LLIST
o1ADC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o17F5           ; Address: $17F5; Address: LLIST

;; P-SAVE
o1ADF:  DEFB    $0B             ; Class-0B - Offset address converted to tape
                                ; command.

;; P-LOAD
o1AE0:  DEFB    $0B             ; Class-0B - Offset address converted to tape
                                ; command.

;; P-VERIFY
o1AE1:  DEFB    $0B             ; Class-0B - Offset address converted to tape
                                ; command.

;; P-MERGE
o1AE2:  DEFB    $0B             ; Class-0B - Offset address converted to tape
                                ; command.

;; P-BEEP
o1AE3:  DEFB    $08             ; Class-08 - Two comma-separated numeric
                                ; expressions required.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o03F8           ; Address: $03F8; Address: BEEP

;; P-CIRCLE
o1AE7:  DEFB    $09             ; Class-09 - Two comma-separated numeric
                                ; expressions required with optional colour
                                ; items.
        DEFB    $05             ; Class-05 - Variable syntax checked
                                ; by routine.
        DEFW    o2320           ; Address: $2320; Address: CIRCLE

;; P-INK
o1AEB:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-PAPER
o1AEC:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-FLASH
o1AED:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-BRIGHT
o1AEE:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-INVERSE
o1AEF:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-OVER
o1AF0:  DEFB    $07             ; Class-07 - Offset address is converted to
                                ; colour code.

;; P-OUT
o1AF1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
                                ; expressions required.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1E7A           ; Address: $1E7A; Address: OUT

;; P-BORDER
o1AF5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o2294           ; Address: $2294; Address: BORDER

;; P-DEF-FN
o1AF9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
                                ; by routine.
        DEFW    o1F60           ; Address: $1F60; Address: DEF-FN

;; P-OPEN
o1AFC:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $2C             ; Separator:  ','          see Footnote *
        DEFB    $0A             ; Class-0A - A string expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1736           ; Address: $1736; Address: OPEN

;; P-CLOSE
o1B02:  DEFB    $06             ; Class-06 - A numeric expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o16E5           ; Address: $16E5; Address: CLOSE

;; P-FORMAT
o1B06:  DEFB    $0A             ; Class-0A - A string expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1793           ; Address: $1793; Address: CAT-ETC

;; P-MOVE
o1B0A:  DEFB    $0A             ; Class-0A - A string expression must follow.
        DEFB    $2C             ; Separator:  ','
        DEFB    $0A             ; Class-0A - A string expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1793           ; Address: $1793; Address: CAT-ETC

;; P-ERASE
o1B10:  DEFB    $0A             ; Class-0A - A string expression must follow.
        DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1793           ; Address: $1793; Address: CAT-ETC

;; P-CAT
o1B14:  DEFB    $00             ; Class-00 - No further operands.
        DEFW    o1793           ; Address: $1793; Address: CAT-ETC

; * Note that a comma is required as a separator with the OPEN command
; but the Interface 1 programmers relaxed this allowing ';' as an
; alternative for their channels creating a confusing mixture of
; allowable syntax as it is this ROM which opens or re-opens the
; normal channels.

; -------------------------------
; Main parser (BASIC interpreter)
; -------------------------------
; This routine is called once from MAIN-2 when the BASIC line is to
; be entered or re-entered into the Program area and the syntax
; requires checking.

;; LINE-SCAN
o1B17:  RES     7,(IY+$01)      ; update FLAGS - signal checking syntax
        CALL    o19FB           ; routine E-LINE-NO              >>
                                ; fetches the line number if in range.

        XOR     A               ; clear the accumulator.
        LD      ($5C47),A       ; set statement number SUBPPC to zero.
        DEC     A               ; set accumulator to $FF.
        LD      ($5C3A),A       ; set ERR_NR to 'OK' - 1.
        JR      o1B29           ; forward to continue at STMT-L-1.

; --------------
; Statement loop
; --------------
;
;

;; STMT-LOOP
o1B28:  RST     20H             ; NEXT-CHAR

; -> the entry point from above or LINE-RUN
;; STMT-L-1
o1B29:  CALL    o16BF           ; routine SET-WORK clears workspace etc.

        INC     (IY+$0D)        ; increment statement number SUBPPC
        JP      M,o1C8A         ; to REPORT-C to raise
                                ; 'Nonsense in BASIC' if over 127.

        RST     18H             ; GET-CHAR

        LD      B,$00           ; set B to zero for later indexing.
                                ; early so any other reason ???

        CP      $0D             ; is character carriage return ?
                                ; i.e. an empty statement.
        JR      Z,o1BB3         ; forward to LINE-END if so.

        CP      $3A             ; is it statement end marker ':' ?
                                ; i.e. another type of empty statement.
        JR      Z,o1B28         ; back to STMT-LOOP if so.

        LD      HL,o1B76        ; address: STMT-RET
        PUSH    HL              ; is now pushed as a return address
        LD      C,A             ; transfer the current character to C.

; advance CH_ADD to a position after command and test if it is a command.

        RST     20H             ; NEXT-CHAR to advance pointer
        LD      A,C             ; restore current character
        SUB     $CE             ; subtract 'DEF FN' - first command
        JP      C,o1C8A         ; jump to REPORT-C if less than a command
                                ; raising
                                ; 'Nonsense in BASIC'

        LD      C,A             ; put the valid command code back in C.
                                ; register B is zero.
        LD      HL,o1A48        ; address: offst-tbl
        ADD     HL,BC           ; index into table with one of 50 commands.
        LD      C,(HL)          ; pick up displacement to syntax table entry.
        ADD     HL,BC           ; add to address the relevant entry.
        JR      o1B55           ; forward to continue at GET-PARAM

; ----------------------
; The main scanning loop
; ----------------------
; not documented properly
;

;; SCAN-LOOP
o1B52:  LD      HL,(T_ADDR)     ; fetch temporary address from T_ADDR
                                ; during subsequent loops.

; -> the initial entry point with HL addressing start of syntax table entry.

;; GET-PARAM
o1B55:  LD      A,(HL)          ; pick up the parameter.
        INC     HL              ; address next one.
        LD      (T_ADDR),HL     ; save pointer in system variable T_ADDR

        LD      BC,o1B52        ; address: SCAN-LOOP
        PUSH    BC              ; is now pushed on stack as looping address.
        LD      C,A             ; store parameter in C.
        CP      $20             ; is it greater than ' '  ?
        JR      NC,o1B6F        ; forward to SEPARATOR to check that correct
                                ; separator appears in statement if so.

        LD      HL,o1C01        ; address: class-tbl.
        LD      B,$00           ; prepare to index into the class table.
        ADD     HL,BC           ; index to find displacement to routine.
        LD      C,(HL)          ; displacement to BC
        ADD     HL,BC           ; add to address the CLASS routine.
        PUSH    HL              ; push the address on the stack.

        RST     18H             ; GET-CHAR - HL points to place in statement.

        DEC     B               ; reset the zero flag - the initial state
                                ; for all class routines.

        RET                     ; and make an indirect jump to routine
                                ; and then SCAN-LOOP (also on stack).

; Note. one of the class routines will eventually drop the return address
; off the stack breaking out of the above seemingly endless loop.

; -----------------------
; THE 'SEPARATOR' ROUTINE
; -----------------------
;   This routine is called once to verify that the mandatory separator
;   present in the parameter table is also present in the correct
;   location following the command.  For example, the 'THEN' token after
;   the 'IF' token and expression.

;; SEPARATOR
o1B6F:  RST     18H             ; GET-CHAR
        CP      C               ; does it match the character in C ?
        JP      NZ,o1C8A        ; jump forward to REPORT-C if not
                                ; 'Nonsense in BASIC'.

        RST     20H             ; NEXT-CHAR advance to next character
        RET                     ; return.

; ------------------------------
; Come here after interpretation
; ------------------------------
;
;

;; STMT-RET
o1B76:  CALL    o1F54           ; routine BREAK-KEY is tested after every
                                ; statement.
        JR      C,o1B7D         ; step forward to STMT-R-1 if not pressed.

;; REPORT-L
o1B7B:  RST     08H             ; ERROR-1
        DEFB    $14             ; Error Report: BREAK into program

;; STMT-R-1
o1B7D:  CALL    o3A3B
        NOP
        JR      NZ,o1BF4        ; forward to STMT-NEXT if a program line.

        LD      HL,($5C42)      ; fetch line number from NEWPPC
        BIT     7,H             ; will be set if minus two - direct command(s)
        JR      Z,o1B9E         ; forward to LINE-NEW if a jump is to be
                                ; made to a new program line/statement.

; --------------------
; Run a direct command
; --------------------
; A direct command is to be run or, if continuing from above,
; the next statement of a direct command is to be considered.

;; LINE-RUN
o1B8A:  LD      HL,$FFFE        ; The dummy value minus two
        LD      ($5C45),HL      ; is set/reset as line number in PPC.
        LD      HL,($5C61)      ; point to end of line + 1 - WORKSP.
        DEC     HL              ; now point to $80 end-marker.
        LD      DE,($5C59)      ; address the start of line E_LINE.
        DEC     DE              ; now location before - for GET-CHAR.
        LD      A,($5C44)       ; load statement to A from NSPPC.
        JR      o1BD1           ; forward to NEXT-LINE.

; ------------------------------
; Find start address of new line
; ------------------------------
; The branch was to here if a jump is to made to a new line number
; and statement.
; That is the previous statement was a GO TO, GO SUB, RUN, RETURN, NEXT etc..

;; LINE-NEW
o1B9E:  CALL    o196E           ; routine LINE-ADDR gets address of line
                                ; returning zero flag set if line found.
        LD      A,($5C44)       ; fetch new statement from NSPPC
        JR      Z,o1BBF         ; forward to LINE-USE if line matched.

; continue as must be a direct command.

        AND     A               ; test statement which should be zero
        JR      NZ,o1BEC        ; forward to REPORT-N if not.
                                ; 'Statement lost'

;

        LD      B,A             ; save statement in B.??
        LD      A,(HL)          ; fetch high byte of line number.
        AND     $C0             ; test if using direct command
                                ; a program line is less than $3F
        LD      A,B             ; retrieve statement.
                                ; (we can assume it is zero).
        JR      Z,o1BBF         ; forward to LINE-USE if was a program line

; Alternatively a direct statement has finished correctly.

;; REPORT-0
o1BB0:  RST     08H             ; ERROR-1
        DEFB    $FF             ; Error Report: OK

; -----------------
; THE 'REM' COMMAND
; -----------------
; The REM command routine.
; The return address STMT-RET is dropped and the rest of line ignored.

;; REM
o1BB2:  POP     BC              ; drop return address STMT-RET and
                                ; continue ignoring rest of line.

; ------------
; End of line?
; ------------
;
;

;; LINE-END
o1BB3:  CALL    o2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
        RET     Z               ; return if checking syntax.

        LD      HL,($5C55)      ; fetch NXTLIN to HL.
        LD      A,$C0           ; test against the
        AND     (HL)            ; system limit $3F.
        RET     NZ              ; return if more as must be
                                ; end of program.
                                ; (or direct command)

        XOR     A               ; set statement to zero.

; and continue to set up the next following line and then consider this new one.

; ---------------------
; General line checking
; ---------------------
; The branch was here from LINE-NEW if BASIC is branching.
; or a continuation from above if dealing with a new sequential line.
; First make statement zero number one leaving others unaffected.

;; LINE-USE
o1BBF:  CP      $01             ; will set carry if zero.
        ADC     A,$00           ; add in any carry.

        LD      D,(HL)          ; high byte of line number to D.
        INC     HL              ; advance pointer.
        LD      E,(HL)          ; low byte of line number to E.
        LD      ($5C45),DE      ; set system variable PPC.

        INC     HL              ; advance pointer.
        LD      E,(HL)          ; low byte of line length to E.
        INC     HL              ; advance pointer.
        LD      D,(HL)          ; high byte of line length to D.

        EX      DE,HL           ; swap pointer to DE before
        ADD     HL,DE           ; adding to address the end of line.
        INC     HL              ; advance to start of next line.

; -----------------------------
; Update NEXT LINE but consider
; previous line or edit line.
; -----------------------------
; The pointer will be the next line if continuing from above or to
; edit line end-marker ($80) if from LINE-RUN.

;; NEXT-LINE
o1BD1:  LD      ($5C55),HL      ; store pointer in system variable NXTLIN

        EX      DE,HL           ; bring back pointer to previous or edit line
        LD      (CH_ADD),HL     ; and update CH_ADD with character address.

        LD      D,A             ; store statement in D.
        LD      E,$00           ; set E to zero to suppress token searching
                                ; if EACH-STMT is to be called.
        LD      (IY+$0A),$FF    ; set statement NSPPC to $FF signalling
                                ; no jump to be made.
        DEC     D               ; decrement and test statement
        LD      (IY+$0D),D      ; set SUBPPC to decremented statement number.
        JP      Z,o1B28         ; to STMT-LOOP if result zero as statement is
                                ; at start of line and address is known.

        INC     D               ; else restore statement.
        CALL    o198B           ; routine EACH-STMT finds the D'th statement
                                ; address as E does not contain a token.
        JR      Z,o1BF4         ; forward to STMT-NEXT if address found.

;; REPORT-N
o1BEC:  RST     08H             ; ERROR-1
        DEFB    $16             ; Error Report: Statement lost

; -----------------
; End of statement?
; -----------------
; This combination of routines is called from 20 places when
; the end of a statement should have been reached and all preceding
; syntax is in order.

;; CHECK-END
o1BEE:  CALL    o2530           ; routine SYNTAX-Z
        RET     NZ              ; return immediately in runtime

        POP     BC              ; drop address of calling routine.
        POP     BC              ; drop address STMT-RET.
                                ; and continue to find next statement.

; --------------------
; Go to next statement
; --------------------
; Acceptable characters at this point are carriage return and ':'.
; If so go to next statement which in the first case will be on next line.

;; STMT-NEXT
o1BF4:  CALL    o3A4B
        JR      Z,o1BB3         ; back to LINE-END if so.

        CP      $3A             ; is it ':' ?
        JP      Z,o1B28         ; jump back to STMT-LOOP to consider
                                ; further statements

        JP      o1C8A           ; jump to REPORT-C with any other character
                                ; 'Nonsense in BASIC'.

; Note. the two-byte sequence 'rst 08; defb $0b' could replace the above jp.

; -------------------
; Command class table
; -------------------
;

;; class-tbl
o1C01:  DEFB    o1C10 - $       ; 0F offset to Address: CLASS-00
        DEFB    o1C1F - $       ; 1D offset to Address: CLASS-01
        DEFB    o1C4E - $       ; 4B offset to Address: CLASS-02
        DEFB    o1C0D - $       ; 09 offset to Address: CLASS-03
        DEFB    o1C6C - $       ; 67 offset to Address: CLASS-04
        DEFB    o1C11 - $       ; 0B offset to Address: CLASS-05
        DEFB    o1C82 - $       ; 7B offset to Address: CLASS-06
        DEFB    o1C96 - $       ; 8E offset to Address: CLASS-07
        DEFB    o1C7A - $       ; 71 offset to Address: CLASS-08
        DEFB    o1CBE - $       ; B4 offset to Address: CLASS-09
        DEFB    o1C8C - $       ; 81 offset to Address: CLASS-0A
        DEFB    o1CDB - $       ; CF offset to Address: CLASS-0B


; --------------------------------
; Command classes---00, 03, and 05
; --------------------------------
; class-03 e.g. RUN or RUN 200   ;  optional operand
; class-00 e.g. CONTINUE         ;  no operand
; class-05 e.g. PRINT            ;  variable syntax checked by routine

;; CLASS-03
o1C0D:  CALL    o1CDE           ; routine FETCH-NUM

;; CLASS-00

o1C10:  CP      A               ; reset zero flag.

; if entering here then all class routines are entered with zero reset.

;; CLASS-05
o1C11:  POP     BC              ; drop address SCAN-LOOP.
        CALL    Z,o1BEE         ; if zero set then call routine CHECK-END >>>
                                ; as should be no further characters.

        EX      DE,HL           ; save HL to DE.
        LD      HL,(T_ADDR)     ; fetch T_ADDR
        LD      C,(HL)          ; fetch low byte of routine
        INC     HL              ; address next.
        LD      B,(HL)          ; fetch high byte of routine.
        EX      DE,HL           ; restore HL from DE
        PUSH    BC              ; push the address
        RET                     ; and make an indirect jump to the command.

; --------------------------------
; Command classes---01, 02, and 04
; --------------------------------
; class-01  e.g. LET A = 2*3     ; a variable is reqd

; This class routine is also called from INPUT and READ to find the
; destination variable for an assignment.

;; CLASS-01
o1C1F:  CALL    o28B2           ; routine LOOK-VARS returns carry set if not
                                ; found in runtime.

; ----------------------
; Variable in assignment
; ----------------------
;
;

;; VAR-A-1
o1C22:  LD      (IY+$37),$00    ; set FLAGX to zero
        JR      NC,o1C30        ; forward to VAR-A-2 if found or checking
                                ; syntax.

        SET     1,(IY+$37)      ; FLAGX  - Signal a new variable
        JR      NZ,o1C46        ; to VAR-A-3 if not assigning to an array
                                ; e.g. LET a$(3,3) = "X"

;; REPORT-2
o1C2E:  RST     08H             ; ERROR-1
        DEFB    $01             ; Error Report: Variable not found

;; VAR-A-2
o1C30:  CALL    Z,o2996         ; routine STK-VAR considers a subscript/slice
        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
        JR      NZ,o1C46        ; to VAR-A-3 if numeric

        XOR     A               ; default to array/slice - to be retained.
        CALL    o2530           ; routine SYNTAX-Z
        CALL    NZ,o2BF1        ; routine STK-FETCH is called in runtime
                                ; may overwrite A with 1.
        LD      HL,$5C71        ; address system variable FLAGX
        OR      (HL)            ; set bit 0 if simple variable to be reclaimed
        LD      (HL),A          ; update FLAGX
        EX      DE,HL           ; start of string/subscript to DE

;; VAR-A-3
o1C46:  LD      ($5C72),BC      ; update STRLEN
        LD      ($5C4D),HL      ; and DEST of assigned string.
        RET                     ; return.

; -------------------------------------------------
; class-02 e.g. LET a = 1 + 1   ; an expression must follow

;; CLASS-02
o1C4E:  POP     BC              ; drop return address SCAN-LOOP
        CALL    o1C56           ; routine VAL-FET-1 is called to check
                                ; expression and assign result in runtime
        CALL    o1BEE           ; routine CHECK-END checks nothing else
                                ; is present in statement.
        RET                     ; Return

; -------------
; Fetch a value
; -------------
;
;

;; VAL-FET-1
o1C56:  LD      A,($5C3B)       ; initial FLAGS to A

;; VAL-FET-2
o1C59:  PUSH    AF              ; save A briefly
        CALL    o24FB           ; routine SCANNING evaluates expression.
        POP     AF              ; restore A
        LD      D,(IY+$01)      ; post-SCANNING FLAGS to D
        XOR     D               ; xor the two sets of flags
        AND     $40             ; pick up bit 6 of xored FLAGS should be zero
        JR      NZ,o1C8A        ; forward to REPORT-C if not zero
                                ; 'Nonsense in BASIC' - results don't agree.

        BIT     7,D             ; test FLAGS - is syntax being checked ?
        JP      NZ,o2AFF        ; jump forward to LET to make the assignment
                                ; in runtime.

        RET                     ; but return from here if checking syntax.

; ------------------
; Command class---04
; ------------------
; class-04 e.g. FOR i            ; a single character variable must follow

;; CLASS-04
o1C6C:  CALL    o28B2           ; routine LOOK-VARS
        PUSH    AF              ; preserve flags.
        LD      A,C             ; fetch type - should be 011xxxxx
        OR      $9F             ; combine with 10011111.
        INC     A               ; test if now $FF by incrementing.
        JR      NZ,o1C8A        ; forward to REPORT-C if result not zero.

        POP     AF              ; else restore flags.
        JR      o1C22           ; back to VAR-A-1


; --------------------------------
; Expect numeric/string expression
; --------------------------------
; This routine is used to get the two coordinates of STRING$, ATTR and POINT.
; It is also called from PRINT-ITEM to get the two numeric expressions that
; follow the AT ( in PRINT AT, INPUT AT).

;; NEXT-2NUM
o1C79:  RST     20H             ; NEXT-CHAR advance past 'AT' or '('.

; --------
; class-08 e.g. POKE 65535,2     ; two numeric expressions separated by comma
;; CLASS-08
;; EXPT-2NUM
o1C7A:  CALL    o1C82           ; routine EXPT-1NUM is called for first
                                ; numeric expression
        CP      $2C             ; is character ',' ?
        JR      NZ,o1C8A        ; to REPORT-C if not required separator.
                                ; 'Nonsense in BASIC'.

        RST     20H             ; NEXT-CHAR

; ->
;  class-06  e.g. GOTO a*1000   ; a numeric expression must follow
;; CLASS-06
;; EXPT-1NUM
o1C82:  CALL    o24FB           ; routine SCANNING
        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
        RET     NZ              ; return if result is numeric.

;; REPORT-C
o1C8A:  RST     08H             ; ERROR-1
        DEFB    $0B             ; Error Report: Nonsense in BASIC

; ---------------------------------------------------------------
; class-0A e.g. ERASE "????"    ; a string expression must follow.
;                               ; these only occur in unimplemented commands
;                               ; although the routine expt-exp is called
;                               ; from SAVE-ETC

;; CLASS-0A
;; EXPT-EXP
o1C8C:  CALL    o24FB           ; routine SCANNING
        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
        RET     Z               ; return if string result.

        JR      o1C8A           ; back to REPORT-C if numeric.

; ---------------------
; Set permanent colours
; class 07
; ---------------------
; class-07 e.g. PAPER 6          ; a single class for a collection of
;                               ; similar commands. Clever.
;
; Note. these commands should ensure that current channel is 'S'

;; CLASS-07
o1C96:  BIT     7,(IY+$01)      ; test FLAGS - checking syntax only ?
                                ; Note. there is a subroutine to do this.
        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
        CALL    NZ,o0D4D        ; routine TEMPS is called in runtime.
        POP     AF              ; drop return address SCAN-LOOP
        LD      A,(T_ADDR)      ; T_ADDR_lo to accumulator.
                                ; points to '$07' entry + 1
                                ; e.g. for INK points to $EC now

; Note if you move alter the syntax table next line may have to be altered.

; Note. For ZASM assembler replace following expression with SUB $13.

o1CA5:  SUB     (o1AEB-$D8)%256 ; convert $EB to $D8 ('INK') etc.
                                ; ( is SUB $13 in standard ROM )

        CALL    o21FC           ; routine CO-TEMP-4
        CALL    o1BEE           ; routine CHECK-END check that nothing else
                                ; in statement.

; return here in runtime.

        LD      HL,(ATTR_T)     ; pick up ATTR_T and MASK_T
        LD      (ATTR_P),HL     ; and store in ATTR_P and MASK_P
        LD      HL,$5C91        ; point to P_FLAG.
        LD      A,(HL)          ; pick up in A
        RLCA                    ; rotate to left
        XOR     (HL)            ; combine with HL
        AND     $AA             ; 10101010
        XOR     (HL)            ; only permanent bits affected
        LD      (HL),A          ; reload into P_FLAG.
        RET                     ; return.

; ------------------
; Command class---09
; ------------------
; e.g. PLOT PAPER 0; 128,88     ; two coordinates preceded by optional
;                               ; embedded colour items.
;
; Note. this command should ensure that current channel is actually 'S'.

;; CLASS-09
o1CBE:  CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o1CD6         ; forward to CL-09-1 if checking syntax.

        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
        CALL    o0D4D           ; routine TEMPS is called.
        LD      HL,$5C90        ; point to MASK_T
        LD      A,(HL)          ; fetch mask to accumulator.
        OR      $F8             ; or with 11111000 paper/bright/flash 8
        LD      (HL),A          ; mask back to MASK_T system variable.
        RES     6,(IY+$57)      ; reset P_FLAG  - signal NOT PAPER 9 ?

        RST     18H             ; GET-CHAR

;; CL-09-1
o1CD6:  CALL    o21E2           ; routine CO-TEMP-2 deals with any embedded
                                ; colour items.
        JR      o1C7A           ; exit via EXPT-2NUM to check for x,y.

; Note. if either of the numeric expressions contain STR$ then the flag setting
; above will be undone when the channel flags are reset during STR$.
; e.g.
; 10 BORDER 3 : PLOT VAL STR$ 128, VAL STR$ 100
; credit John Elliott.

; ------------------
; Command class---0B
; ------------------
; Again a single class for four commands.
; This command just jumps back to SAVE-ETC to handle the four tape commands.
; The routine itself works out which command has called it by examining the
; address in T_ADDR_lo. Note therefore that the syntax table has to be
; located where these and other sequential command addresses are not split
; over a page boundary.

;; CLASS-0B
o1CDB:  JP      o0605           ; jump way back to SAVE-ETC

; --------------
; Fetch a number
; --------------
; This routine is called from CLASS-03 when a command may be followed by
; an optional numeric expression e.g. RUN. If the end of statement has
; been reached then zero is used as the default.
; Also called from LIST-4.

;; FETCH-NUM
o1CDE:  CP      $0D             ; is character a carriage return ?
        JR      Z,o1CE6         ; forward to USE-ZERO if so

        CP      $3A             ; is it ':' ?
        JR      NZ,o1C82        ; forward to EXPT-1NUM if not.
                                ; else continue and use zero.

; ----------------
; Use zero routine
; ----------------
; This routine is called four times to place the value zero on the
; calculator stack as a default value in runtime.

;; USE-ZERO
o1CE6:  CALL    o2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
        RET     Z               ;

        RST     28H             ;; FP-CALC
        DEFB    $A0             ;;stk-zero       ;0.
        DEFB    $38             ;;end-calc

        RET                     ; return.

; -------------------
; Handle STOP command
; -------------------
; Command Syntax: STOP
; One of the shortest and least used commands. As with 'OK' not an error.

;; REPORT-9
;; STOP
o1CEE:  RST     08H             ; ERROR-1
        DEFB    $08             ; Error Report: STOP statement

; -----------------
; Handle IF command
; -----------------
; e.g. IF score>100 THEN PRINT "You Win"
; The parser has already checked the expression the result of which is on
; the calculator stack. The presence of the 'THEN' separator has also been
; checked and CH-ADD points to the command after THEN.
;

;; IF
o1CF0:  POP     BC              ; drop return address - STMT-RET
        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o1D00         ; forward to IF-1 if checking syntax
                                ; to check syntax of PRINT "You Win"


        RST     28H             ;; FP-CALC    score>100 (1=TRUE 0=FALSE)
        DEFB    $02             ;;delete      .
        DEFB    $38             ;;end-calc

        EX      DE,HL           ; make HL point to deleted value
        CALL    o34E9           ; routine TEST-ZERO
        JP      C,o1BB3         ; jump to LINE-END if FALSE (0)

;; IF-1
o1D00:  JP      o1B29           ; to STMT-L-1, if true (1) to execute command
                                ; after 'THEN' token.

; ------------------
; Handle FOR command
; ------------------
; e.g. FOR i = 0 TO 1 STEP 0.1
; Using the syntax tables, the parser has already checked for a start and
; limit value and also for the intervening separator.
; the two values v,l are on the calculator stack.
; CLASS-04 has also checked the variable and the name is in STRLEN_lo.
; The routine begins by checking for an optional STEP.

;; FOR
o1D03:  CP      $CD             ; is there a 'STEP' ?
        JR      NZ,o1D10        ; to F-USE-1 if not to use 1 as default.

        RST     20H             ; NEXT-CHAR
        CALL    o1C82           ; routine EXPT-1NUM
        CALL    o1BEE           ; routine CHECK-END
        JR      o1D16           ; to F-REORDER

; ---

;; F-USE-1
o1D10:  CALL    o1BEE           ; routine CHECK-END

        RST     28H             ;; FP-CALC      v,l.
        DEFB    $A1             ;;stk-one       v,l,1=s.
        DEFB    $38             ;;end-calc


;; F-REORDER
o1D16:  RST     28H             ;; FP-CALC       v,l,s.
        DEFB    $C0             ;;st-mem-0       v,l,s.
        DEFB    $02             ;;delete         v,l.
        DEFB    $01             ;;exchange       l,v.
        DEFB    $E0             ;;get-mem-0      l,v,s.
        DEFB    $01             ;;exchange       l,s,v.
        DEFB    $38             ;;end-calc

        CALL    o2AFF           ; routine LET assigns the initial value v to
                                ; the variable altering type if necessary.
        LD      ($5C68),HL      ; The system variable MEM is made to point to
                                ; the variable instead of its normal
                                ; location MEMBOT
        DEC     HL              ; point to single-character name
        LD      A,(HL)          ; fetch name
        SET     7,(HL)          ; set bit 7 at location
        LD      BC,$0006        ; add six to HL
        ADD     HL,BC           ; to address where limit should be.
        RLCA                    ; test bit 7 of original name.
        JR      C,o1D34         ; forward to F-L-S if already a FOR/NEXT
                                ; variable

        LD      C,$0D           ; otherwise an additional 13 bytes are needed.
                                ; 5 for each value, two for line number and
                                ; 1 byte for looping statement.
        CALL    o1655           ; routine MAKE-ROOM creates them.
        INC     HL              ; make HL address limit.

;; F-L-S
o1D34:  PUSH    HL              ; save position.

        RST     28H             ;; FP-CALC         l,s.
        DEFB    $02             ;;delete           l.
        DEFB    $02             ;;delete           .
        DEFB    $38             ;;end-calc
                                ; DE points to STKEND, l.

        POP     HL              ; restore variable position
        EX      DE,HL           ; swap pointers
        LD      C,$0A           ; ten bytes to move
        LDIR                    ; Copy 'deleted' values to variable.
        LD      HL,($5C45)      ; Load with current line number from PPC
        EX      DE,HL           ; exchange pointers.
        LD      (HL),E          ; save the looping line
        INC     HL              ; in the next
        LD      (HL),D          ; two locations.
        LD      D,(IY+$0D)      ; fetch statement from SUBPPC system variable.
        INC     D               ; increment statement.
        INC     HL              ; and pointer
        LD      (HL),D          ; and store the looping statement.
                                ;
        CALL    o1DDA           ; routine NEXT-LOOP considers an initial
        RET     NC              ; iteration. Return to STMT-RET if a loop is
                                ; possible to execute next statement.

; no loop is possible so execution continues after the matching 'NEXT'

        LD      B,(IY+$38)      ; get single-character name from STRLEN_lo
        LD      HL,($5C45)      ; get the current line from PPC
        LD      ($5C42),HL      ; and store it in NEWPPC
        LD      A,($5C47)       ; fetch current statement from SUBPPC
        NEG                     ; Negate as counter decrements from zero
                                ; initially and we are in the middle of a
                                ; line.
        LD      D,A             ; Store result in D.
        LD      HL,(CH_ADD)      ; get current address from CH_ADD
        LD      E,$F3           ; search will be for token 'NEXT'

;; F-LOOP
o1D64:  PUSH    BC              ; save variable name.
        LD      BC,($5C55)      ; fetch NXTLIN
        CALL    o1D86           ; routine LOOK-PROG searches for 'NEXT' token.
        LD      ($5C55),BC      ; update NXTLIN
        POP     BC              ; and fetch the letter
        JR      C,o1D84         ; forward to REPORT-I if the end of program
                                ; was reached by LOOK-PROG.
                                ; 'FOR without NEXT'

        RST     20H             ; NEXT-CHAR fetches character after NEXT
        OR      $20             ; ensure it is upper-case.
        CP      B               ; compare with FOR variable name
        JR      Z,o1D7C         ; forward to F-FOUND if it matches.

; but if no match i.e. nested FOR/NEXT loops then continue search.

        RST     20H             ; NEXT-CHAR
        JR      o1D64           ; back to F-LOOP

; ---


;; F-FOUND
o1D7C:  RST     20H             ; NEXT-CHAR
        LD      A,$01           ; subtract the negated counter from 1
        SUB     D               ; to give the statement after the NEXT
        LD      ($5C44),A       ; set system variable NSPPC
        RET                     ; return to STMT-RET to branch to new
                                ; line and statement. ->
; ---

;; REPORT-I
o1D84:  RST     08H             ; ERROR-1
        DEFB    $11             ; Error Report: FOR without NEXT

; ---------
; LOOK-PROG
; ---------
; Find DATA, DEF FN or NEXT.
; This routine searches the program area for one of the above three keywords.
; On entry, HL points to start of search area.
; The token is in E, and D holds a statement count, decremented from zero.

;; LOOK-PROG
o1D86:  LD      A,(HL)          ; fetch current character
        CP      $3A             ; is it ':' a statement separator ?
        JR      Z,o1DA3         ; forward to LOOK-P-2 if so.

; The starting point was PROG - 1 or the end of a line.

;; LOOK-P-1
o1D8B:  INC     HL              ; increment pointer to address
        LD      A,(HL)          ; the high byte of line number
        AND     $C0             ; test for program end marker $80 or a
                                ; variable
        SCF                     ; Set Carry Flag
        RET     NZ              ; return with carry set if at end
                                ; of program.           ->

        LD      B,(HL)          ; high byte of line number to B
        INC     HL              ;
        LD      C,(HL)          ; low byte to C.
        LD      ($5C42),BC      ; set system variable NEWPPC.
        INC     HL              ;
        LD      C,(HL)          ; low byte of line length to C.
        INC     HL              ;
        LD      B,(HL)          ; high byte to B.
        PUSH    HL              ; save address
        ADD     HL,BC           ; add length to position.
        LD      B,H             ; and save result
        LD      C,L             ; in BC.
        POP     HL              ; restore address.
        LD      D,$00           ; initialize statement counter to zero.

;; LOOK-P-2
o1DA3:  PUSH    BC              ; save address of next line
        CALL    o198B           ; routine EACH-STMT searches current line.
        POP     BC              ; restore address.
        RET     NC              ; return if match was found. ->

        JR      o1D8B           ; back to LOOK-P-1 for next line.

; -------------------
; Handle NEXT command
; -------------------
; e.g. NEXT i
; The parameter tables have already evaluated the presence of a variable

;; NEXT
o1DAB:  BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
        JP      NZ,o1C2E        ; jump back to REPORT-2 if so
                                ; 'Variable not found'

; now test if found variable is a simple variable uninitialized by a FOR.

        LD      HL,($5C4D)      ; load address of variable from DEST
        BIT     7,(HL)          ; is it correct type ?
        JR      Z,o1DD8         ; forward to REPORT-1 if not
                                ; 'NEXT without FOR'

        INC     HL              ; step past variable name
        LD      ($5C68),HL      ; and set MEM to point to three 5-byte values
                                ; value, limit, step.

        RST     28H             ;; FP-CALC     add step and re-store
        DEFB    $E0             ;;get-mem-0    v.
        DEFB    $E2             ;;get-mem-2    v,s.
        DEFB    $0F             ;;addition     v+s.
        DEFB    $C0             ;;st-mem-0     v+s.
        DEFB    $02             ;;delete       .
        DEFB    $38             ;;end-calc

        CALL    o1DDA           ; routine NEXT-LOOP tests against limit.
        RET     C               ; return if no more iterations possible.

        LD      HL,($5C68)      ; find start of variable contents from MEM.
        LD      DE,$000F        ; add 3*5 to
        ADD     HL,DE           ; address the looping line number
        LD      E,(HL)          ; low byte to E
        INC     HL              ;
        LD      D,(HL)          ; high byte to D
        INC     HL              ; address looping statement
        LD      H,(HL)          ; and store in H
        EX      DE,HL           ; swap registers
        JP      o1E73           ; exit via GO-TO-2 to execute another loop.

; ---

;; REPORT-1
o1DD8:  RST     08H             ; ERROR-1
        DEFB    $00             ; Error Report: NEXT without FOR


; -----------------
; Perform NEXT loop
; -----------------
; This routine is called from the FOR command to test for an initial
; iteration and from the NEXT command to test for all subsequent iterations.
; the system variable MEM addresses the variable's contents which, in the
; latter case, have had the step, possibly negative, added to the value.

;; NEXT-LOOP
o1DDA:  RST     28H             ;; FP-CALC
        DEFB    $E1             ;;get-mem-1        l.
        DEFB    $E0             ;;get-mem-0        l,v.
        DEFB    $E2             ;;get-mem-2        l,v,s.
        DEFB    $36             ;;less-0           l,v,(1/0) negative step ?
        DEFB    $00             ;;jump-true        l,v.(1/0)

        DEFB    $02             ;;to o1DE2, NEXT-1 if step negative

        DEFB    $01             ;;exchange         v,l.

;; NEXT-1
o1DE2:  DEFB    $03             ;;subtract         l-v OR v-l.
        DEFB    $37             ;;greater-0        (1/0)
        DEFB    $00             ;;jump-true        .

        DEFB    $04             ;;to o1DE9, NEXT-2 if no more iterations.

        DEFB    $38             ;;end-calc         .

        AND     A               ; clear carry flag signalling another loop.
        RET                     ; return

; ---

;; NEXT-2
o1DE9:  DEFB    $38             ;;end-calc         .

        SCF                     ; set carry flag signalling looping exhausted.
        RET                     ; return


; -------------------
; Handle READ command
; -------------------
; e.g. READ a, b$, c$(1000 TO 3000)
; A list of comma-separated variables is assigned from a list of
; comma-separated expressions.
; As it moves along the first list, the character address CH_ADD is stored
; in X_PTR while CH_ADD is used to read the second list.

;; READ-3
o1DEC:  RST     20H             ; NEXT-CHAR

; -> Entry point.
;; READ
o1DED:  CALL    o1C1F           ; routine CLASS-01 checks variable.
        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o1E1E         ; forward to READ-2 if checking syntax


        RST     18H             ; GET-CHAR
        LD      (X_PTR),HL      ; save character position in X_PTR.
        LD      HL,(DATADD)     ; load HL with Data Address DATADD, which is
                                ; the start of the program or the address
                                ; after the last expression that was read or
                                ; the address of the line number of the
                                ; last RESTORE command.
        LD      A,(HL)          ; fetch character
        CP      $2C             ; is it a comma ?
        JR      Z,o1E0A         ; forward to READ-1 if so.

; else all data in this statement has been read so look for next DATA token

        LD      E,$E4           ; token 'DATA'
        CALL    o1D86           ; routine LOOK-PROG
        JR      NC,o1E0A        ; forward to READ-1 if DATA found

; else report the error.

;; REPORT-E
o1E08:  RST     08H             ; ERROR-1
        DEFB    $0D             ; Error Report: Out of DATA

;; READ-1
o1E0A:  CALL    o0077           ; routine TEMP-PTR1 advances updating CH_ADD
                                ; with new DATADD position.
        CALL    o1C56           ; routine VAL-FET-1 assigns value to variable
                                ; checking type match and adjusting CH_ADD.

        RST     18H             ; GET-CHAR fetches adjusted character position
        LD      (DATADD),HL     ; store back in DATADD
        LD      HL,(X_PTR)      ; fetch X_PTR  the original READ CH_ADD
        LD      (IY+$26),$00    ; now nullify X_PTR_hi
        CALL    o0078           ; routine TEMP-PTR2 restores READ CH_ADD

;; READ-2
o1E1E:  RST     18H             ; GET-CHAR
        CP      $2C             ; is it ',' indicating more variables to read ?
        JR      Z,o1DEC         ; back to READ-3 if so

        CALL    o1BEE           ; routine CHECK-END
        RET                     ; return from here in runtime to STMT-RET.

; -------------------
; Handle DATA command
; -------------------
; In runtime this 'command' is passed by but the syntax is checked when such
; a statement is found while parsing a line.
; e.g. DATA 1, 2, "text", score-1, a$(location, room, object), FN r(49),
;         wages - tax, TRUE, The meaning of life

;; DATA
o1E27:  CALL    o2530           ; routine SYNTAX-Z to check status
        JR      NZ,o1E37        ; forward to DATA-2 if in runtime

;; DATA-1
o1E2C:  CALL    o24FB           ; routine SCANNING to check syntax of
                                ; expression
        CP      $2C             ; is it a comma ?
        CALL    NZ,o1BEE        ; routine CHECK-END checks that statement
                                ; is complete. Will make an early exit if
                                ; so. >>>
        RST     20H             ; NEXT-CHAR
        JR      o1E2C           ; back to DATA-1

; ---

;; DATA-2
o1E37:  LD      A,$E4           ; set token to 'DATA' and continue into
                                ; the PASS-BY routine.


; ----------------------------------
; Check statement for DATA or DEF FN
; ----------------------------------
; This routine is used to backtrack to a command token and then
; forward to the next statement in runtime.

;; PASS-BY
o1E39:  LD      B,A             ; Give BC enough space to find token.
        CPDR                    ; Compare decrement and repeat. (Only use).
                                ; Work backwards till keyword is found which
                                ; is start of statement before any quotes.
                                ; HL points to location before keyword.
        LD      DE,$0200        ; count 1+1 statements, dummy value in E to
                                ; inhibit searching for a token.
        JP      o198B           ; to EACH-STMT to find next statement

; -----------------------------------------------------------------------
; A General Note on Invalid Line Numbers.
; =======================================
; One of the revolutionary concepts of Sinclair BASIC was that it supported
; virtual line numbers. That is the destination of a GO TO, RESTORE etc. need
; not exist. It could be a point before or after an actual line number.
; Zero suffices for a before but the after should logically be infinity.
; Since the maximum actual line limit is 9999 then the system limit, 16383
; when variables kick in, would serve fine as a virtual end point.
; However, ironically, only the LOAD command gets it right. It will not
; autostart a program that has been saved with a line higher than 16383.
; All the other commands deal with the limit unsatisfactorily.
; LIST, RUN, GO TO, GO SUB and RESTORE have problems and the latter may
; crash the machine when supplied with an inappropriate virtual line number.
; This is puzzling as very careful consideration must have been given to
; this point when the new variable types were allocated their masks and also
; when the routine NEXT-ONE was successfully re-written to reflect this.
; An enigma.
; -------------------------------------------------------------------------

; ----------------------
; Handle RESTORE command
; ----------------------
; The restore command sets the system variable for the data address to
; point to the location before the supplied line number or first line
; thereafter.
; This alters the position where subsequent READ commands look for data.
; Note. If supplied with inappropriate high numbers the system may crash
; in the LINE-ADDR routine as it will pass the program/variables end-marker
; and then lose control of what it is looking for - variable or line number.
; - observation, Steven Vickers, 1984, Pitman.

;; RESTORE
o1E42:  CALL    o1E99           ; routine FIND-INT2 puts integer in BC.
                                ; Note. B should be checked against limit $3F
                                ; and an error generated if higher.

; this entry point is used from RUN command with BC holding zero

;; REST-RUN
o1E45:  LD      H,B             ; transfer the line
        LD      L,C             ; number to the HL register.
        CALL    o196E           ; routine LINE-ADDR to fetch the address.
        DEC     HL              ; point to the location before the line.
        LD      (DATADD),HL     ; update system variable DATADD.
        RET                     ; return to STMT-RET (or RUN)

; ------------------------
; Handle RANDOMIZE command
; ------------------------
; This command sets the SEED for the RND function to a fixed value.
; With the parameter zero, a random start point is used depending on
; how long the computer has been switched on.

;; RANDOMIZE
o1E4F:  CALL    o1E99           ; routine FIND-INT2 puts parameter in BC.
        LD      A,B             ; test this
        OR      C               ; for zero.
        JR      NZ,o1E5A        ; forward to RAND-1 if not zero.

        LD      BC,($5C78)      ; use the lower two bytes at FRAMES1.

;; RAND-1
o1E5A:  LD      ($5C76),BC      ; place in SEED system variable.
        RET                     ; return to STMT-RET

; -----------------------
; Handle CONTINUE command
; -----------------------
; The CONTINUE command transfers the OLD (but incremented) values of
; line number and statement to the equivalent "NEW VALUE" system variables
; by using the last part of GO TO and exits indirectly to STMT-RET.

;; CONTINUE
o1E5F:  LD      HL,($5C6E)      ; fetch OLDPPC line number.
        LD      D,(IY+$36)      ; fetch OSPPC statement.
        JR      o1E73           ; forward to GO-TO-2

; --------------------
; Handle GO TO command
; --------------------
; The GO TO command routine is also called by GO SUB and RUN routines
; to evaluate the parameters of both commands.
; It updates the system variables used to fetch the next line/statement.
; It is at STMT-RET that the actual change in control takes place.
; Unlike some BASICs the line number need not exist.
; Note. the high byte of the line number is incorrectly compared with $F0
; instead of $3F. This leads to commands with operands greater than 32767
; being considered as having been run from the editing area and the
; error report 'Statement Lost' is given instead of 'OK'.
; - Steven Vickers, 1984.

;; GO-TO
o1E67:  CALL    o1E99           ; routine FIND-INT2 puts operand in BC
        LD      H,B             ; transfer line
        LD      L,C             ; number to HL.
        LD      D,$00           ; set statement to 0 - first.
        LD      A,H             ; compare high byte only
        CP      $F0             ; to $F0 i.e. 61439 in full.
        JR      NC,o1E9F        ; forward to REPORT-B if above.

; This call entry point is used to update the system variables e.g. by RETURN.

;; GO-TO-2
o1E73:  LD      ($5C42),HL      ; save line number in NEWPPC
        LD      (IY+$0A),D      ; and statement in NSPPC
        RET                     ; to STMT-RET (or GO-SUB command)

; ------------------
; Handle OUT command
; ------------------
; Syntax has been checked and the two comma-separated values are on the
; calculator stack.

;; OUT
o1E7A:  CALL    o1E85           ; routine TWO-PARAM fetches values
                                ; to BC and A.
        OUT     (C),A           ; perform the operation.
        RET                     ; return to STMT-RET.

; -------------------
; Handle POKE command
; -------------------
; This routine alters a single byte in the 64K address space.
; Happily no check is made as to whether ROM or RAM is addressed.
; Sinclair BASIC requires no poking of system variables.

;; POKE
o1E80:  CALL    o1E85           ; routine TWO-PARAM fetches values
                                ; to BC and A.
        LD      (BC),A          ; load memory location with A.
        RET                     ; return to STMT-RET.

; ------------------------------------
; Fetch two  parameters from calculator stack
; ------------------------------------
; This routine fetches a byte and word from the calculator stack
; producing an error if either is out of range.

;; TWO-PARAM
o1E85:  CALL    o2DD5           ; routine FP-TO-A
        JR      C,o1E9F         ; forward to REPORT-B if overflow occurred

        JR      Z,o1E8E         ; forward to TWO-P-1 if positive

        NEG                     ; negative numbers are made positive

;; TWO-P-1
o1E8E:  PUSH    AF              ; save the value
        CALL    o1E99           ; routine FIND-INT2 gets integer to BC
        POP     AF              ; restore the value
        RET                     ; return

; -------------
; Find integers
; -------------
; The first of these routines fetches a 8-bit integer (range 0-255) from the
; calculator stack to the accumulator and is used for colours, streams,
; durations and coordinates.
; The second routine fetches 16-bit integers to the BC register pair
; and is used to fetch command and function arguments involving line numbers
; or memory addresses and also array subscripts and tab arguments.
; ->

;; FIND-INT1
o1E94:  CALL    o2DD5           ; routine FP-TO-A
        JR      o1E9C           ; forward to FIND-I-1 for common exit routine.

; ---

; ->

;; FIND-INT2
o1E99:  CALL    o2DA2           ; routine FP-TO-BC

;; FIND-I-1
o1E9C:  JR      C,o1E9F         ; to REPORT-Bb with overflow.

        RET     Z               ; return if positive.


;; REPORT-Bb
o1E9F:  RST     08H             ; ERROR-1
        DEFB    $0A             ; Error Report: Integer out of range

; ------------------
; Handle RUN command
; ------------------
; This command runs a program starting at an optional line.
; It performs a 'RESTORE 0' then CLEAR

;; RUN
o1EA1:  CALL    o1E67           ; routine GO-TO puts line number in
                                ; system variables.
        LD      BC,$0000        ; prepare to set DATADD to first line.
        CALL    o1E45           ; routine REST-RUN does the 'restore'.
                                ; Note BC still holds zero.
        JR      o1EAF           ; forward to CLEAR-RUN to clear variables
                                ; without disturbing RAMTOP and
                                ; exit indirectly to STMT-RET

; --------------------
; Handle CLEAR command
; --------------------
; This command reclaims the space used by the variables.
; It also clears the screen and the GO SUB stack.
; With an integer expression, it sets the uppermost memory
; address within the BASIC system.
; "Contrary to the manual, CLEAR doesn't execute a RESTORE" -
; Steven Vickers, Pitman Pocket Guide to the Spectrum, 1984.

;; CLEAR
o1EAC:  CALL    o1E99           ; routine FIND-INT2 fetches to BC.

;; CLEAR-RUN
o1EAF:  LD      A,B             ; test for
        OR      C               ; zero.
        JR      NZ,o1EB7        ; skip to CLEAR-1 if not zero.

        LD      BC,($5CB2)      ; use the existing value of RAMTOP if zero.

;; CLEAR-1
o1EB7:  PUSH    BC              ; save ramtop value.

        LD      DE,(VARS)       ; fetch VARS
        LD      HL,($5C59)      ; fetch E_LINE
        DEC     HL              ; adjust to point at variables end-marker.
        CALL    o19E5           ; routine RECLAIM-1 reclaims the space used by
                                ; the variables.

        CALL    o0D6B           ; routine CLS to clear screen.

        LD      HL,(STKEND)     ; fetch STKEND the start of free memory.
        LD      DE,$0032        ; allow for another 50 bytes.
        ADD     HL,DE           ; add the overhead to HL.

        POP     DE              ; restore the ramtop value.
        SBC     HL,DE           ; if HL is greater than the value then jump
        JR      NC,o1EDA        ; forward to REPORT-M
                                ; 'RAMTOP no good'

        LD      HL,($5CB4)      ; now P-RAMT ($7FFF on 16K RAM machine)
        AND     A               ; exact this time.
        SBC     HL,DE           ; new ramtop must be lower or the same.
        JR      NC,o1EDC        ; skip to CLEAR-2 if in actual RAM.

;; REPORT-M
o1EDA:  RST     08H             ; ERROR-1
        DEFB    $15             ; Error Report: RAMTOP no good

;; CLEAR-2
o1EDC:  EX      DE,HL           ; transfer ramtop value to HL.
        LD      ($5CB2),HL      ; update system variable RAMTOP.
        POP     DE              ; pop the return address STMT-RET.
        POP     BC              ; pop the Error Address.
        LD      (HL),$3E        ; now put the GO SUB end-marker at RAMTOP.
        DEC     HL              ; leave a location beneath it.
        LD      SP,HL           ; initialize the machine stack pointer.
        PUSH    BC              ; push the error address.
        LD      (ERR_SP),SP     ; make ERR_SP point to location.
        EX      DE,HL           ; put STMT-RET in HL.
        JP      (HL)            ; and go there directly.

; ---------------------
; Handle GO SUB command
; ---------------------
; The GO SUB command diverts BASIC control to a new line number
; in a very similar manner to GO TO but
; the current line number and current statement + 1
; are poaced on the GO SUB stack as a RETURN point.

;; GO-SUB
o1EED:  POP     DE              ; drop the address STMT-RET
        LD      H,(IY+$0D)      ; fetch statement from SUBPPC and
        INC     H               ; increment it
        EX      (SP),HL         ; swap - error address to HL,
                                ; H (statement) at top of stack,
                                ; L (unimportant) beneath.
        INC     SP              ; adjust to overwrite unimportant byte
        LD      BC,($5C45)      ; fetch the current line number from PPC
        PUSH    BC              ; and PUSH onto GO SUB stack.
                                ; the empty machine-stack can be rebuilt
        PUSH    HL              ; push the error address.
        LD      (ERR_SP),SP     ; make system variable ERR_SP point to it.
        PUSH    DE              ; push the address STMT-RET.
        CALL    o1E67           ; call routine GO-TO to update the system
                                ; variables NEWPPC and NSPPC.
                                ; then make an indirect exit to STMT-RET via
        LD      BC,$0014        ; a 20-byte overhead memory check.

; ----------------------
; Check available memory
; ----------------------
; This routine is used on many occasions when extending a dynamic area
; upwards or the GO SUB stack downwards.

;; TEST-ROOM
o1F05:  LD      HL,(STKEND)     ; fetch STKEND
        ADD     HL,BC           ; add the supplied test value
        JR      C,o1F15         ; forward to REPORT-4 if over $FFFF

        EX      DE,HL           ; was less so transfer to DE
        LD      HL,$0050        ; test against another 80 bytes
        ADD     HL,DE           ; anyway
        JR      C,o1F15         ; forward to REPORT-4 if this passes $FFFF

        SBC     HL,SP           ; if less than the machine stack pointer
        RET     C               ; then return - OK.

;; REPORT-4
o1F15:  LD      L,$03           ; prepare 'Out of Memory'
        JP      o0055           ; jump back to ERROR-3 at $0055
                                ; Note. this error can't be trapped at $0008

; ------------------------------
; THE 'FREE MEMORY' USER ROUTINE
; ------------------------------
; This routine is not used by the ROM but allows users to evaluate
; approximate free memory with PRINT 65536 - USR 7962.

;; free-mem
o1F1A:  LD      BC,$0000        ; allow no overhead.

        CALL    o1F05           ; routine TEST-ROOM.

        LD      B,H             ; transfer the result
        LD      C,L             ; to the BC register.
        RET                     ; the USR function returns value of BC.

; --------------------
; THE 'RETURN' COMMAND
; --------------------
; As with any command, there are two values on the machine stack at the time
; it is invoked.  The machine stack is below the GOSUB stack.  Both grow
; downwards, the machine stack by two bytes, the GOSUB stack by 3 bytes.
; The highest location is a statement byte followed by a two-byte line number.

;; RETURN
o1F23:  POP     BC              ; drop the address STMT-RET.
        POP     HL              ; now the error address.
        POP     DE              ; now a possible BASIC return line.
        LD      A,D             ; the high byte $00 - $27 is
        CP      $3E             ; compared with the traditional end-marker $3E.
        JR      Z,o1F36         ; forward to REPORT-7 with a match.
                                ; 'RETURN without GOSUB'

; It was not the end-marker so a single statement byte remains at the base of
; the calculator stack. It can't be popped off.

        DEC     SP              ; adjust stack pointer to create room for two
                                ; bytes.
        EX      (SP),HL         ; statement to H, error address to base of
                                ; new machine stack.
        EX      DE,HL           ; statement to D,  BASIC line number to HL.
        LD      (ERR_SP),SP     ; adjust ERR_SP to point to new stack pointer
        PUSH    BC              ; now re-stack the address STMT-RET
        JP      o1E73           ; to GO-TO-2 to update statement and line
                                ; system variables and exit indirectly to the
                                ; address just pushed on stack.

; ---

;; REPORT-7
o1F36:  PUSH    DE              ; replace the end-marker.
        PUSH    HL              ; now restore the error address
                                ; as will be required in a few clock cycles.

        RST     08H             ; ERROR-1
        DEFB    $06             ; Error Report: RETURN without GOSUB

; --------------------
; Handle PAUSE command
; --------------------
; The pause command takes as its parameter the number of interrupts
; for which to wait. PAUSE 50 pauses for about a second.
; PAUSE 0 pauses indefinitely.
; Both forms can be finished by pressing a key.

;; PAUSE
o1F3A:  CALL    o1E99           ; routine FIND-INT2 puts value in BC

;; PAUSE-1
o1F3D:  HALT                    ; wait for interrupt.
        DEC     BC              ; decrease counter.
        LD      A,B             ; test if
        OR      C               ; result is zero.
        JR      Z,o1F4F         ; forward to PAUSE-END if so.

        LD      A,B             ; test if
        AND     C               ; now $FFFF
        INC     A               ; that is, initially zero.
        JR      NZ,o1F49        ; skip forward to PAUSE-2 if not.

        INC     BC              ; restore counter to zero.

;; PAUSE-2
o1F49:  BIT     5,(IY+$01)      ; test FLAGS - has a new key been pressed ?
        JR      Z,o1F3D         ; back to PAUSE-1 if not.

;; PAUSE-END
o1F4F:  RES     5,(IY+$01)      ; update FLAGS - signal no new key
        RET                     ; and return.

; -------------------
; Check for BREAK key
; -------------------
; This routine is called from COPY-LINE, when interrupts are disabled,
; to test if BREAK (SHIFT - SPACE) is being pressed.
; It is also called at STMT-RET after every statement.

;; BREAK-KEY
o1F54:  LD      A,$7F           ; Input address: $7FFE
        IN      A,($FE)         ; read lower right keys
        RRA                     ; rotate bit 0 - SPACE
        RET     C               ; return if not reset

        LD      A,$FE           ; Input address: $FEFE
        IN      A,($FE)         ; read lower left keys
        RRA                     ; rotate bit 0 - SHIFT
        RET                     ; carry will be set if not pressed.
                                ; return with no carry if both keys
                                ; pressed.

; ---------------------
; Handle DEF FN command
; ---------------------
; e.g. DEF FN r$(a$,a) = a$(a TO )
; this 'command' is ignored in runtime but has its syntax checked
; during line-entry.

;; DEF-FN
o1F60:  CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o1F6A         ; forward to DEF-FN-1 if parsing

        LD      A,$CE           ; else load A with 'DEF FN' and
        JP      o1E39           ; jump back to PASS-BY

; ---

; continue here if checking syntax.

;; DEF-FN-1
o1F6A:  SET      6,(IY+$01)     ; set FLAGS  - Assume numeric result
        CALL    o2C8D           ; call routine ALPHA
        JR      NC,o1F89        ; if not then to DEF-FN-4 to jump to
                                ; 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR
        CP      $24             ; is it '$' ?
        JR      NZ,o1F7D        ; to DEF-FN-2 if not as numeric.

        RES     6,(IY+$01)      ; set FLAGS  - Signal string result

        RST     20H             ; get NEXT-CHAR

;; DEF-FN-2
o1F7D:  CP      $28             ; is it '(' ?
        JR      NZ,o1FBD        ; to DEF-FN-7 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR
        CP      $29             ; is it ')' ?
        JR      Z,o1FA6         ; to DEF-FN-6 if null argument

;; DEF-FN-3
o1F86:  CALL    o2C8D           ; routine ALPHA checks that it is the expected
                                ; alphabetic character.

;; DEF-FN-4
o1F89:  JP      NC,o1C8A        ; to REPORT-C  if not
                                ; 'Nonsense in BASIC'.

        EX      DE,HL           ; save pointer in DE

        RST     20H             ; NEXT-CHAR re-initializes HL from CH_ADD
                                ; and advances.
        CP      $24             ; '$' ? is it a string argument.
        JR      NZ,o1F94        ; forward to DEF-FN-5 if not.

        EX      DE,HL           ; save pointer to '$' in DE

        RST     20H             ; NEXT-CHAR re-initializes HL and advances

;; DEF-FN-5
o1F94:  EX      DE,HL           ; bring back pointer.
        LD      BC,$0006        ; the function requires six hidden bytes for
                                ; each parameter passed.
                                ; The first byte will be $0E
                                ; then 5-byte numeric value
                                ; or 5-byte string pointer.

        CALL    o1655           ; routine MAKE-ROOM creates space in program
                                ; area.

        INC     HL              ; adjust HL (set by LDDR)
        INC     HL              ; to point to first location.
        LD      (HL),$0E        ; insert the 'hidden' marker.

; Note. these invisible storage locations hold nothing meaningful for the
; moment. They will be used every time the corresponding function is
; evaluated in runtime.
; Now consider the following character fetched earlier.

        CP      $2C             ; is it ',' ? (more than one parameter)
        JR      NZ,o1FA6        ; to DEF-FN-6 if not


        RST     20H             ; else NEXT-CHAR
        JR      o1F86           ; and back to DEF-FN-3

; ---

;; DEF-FN-6
o1FA6:  CP      $29             ; should close with a ')'
        JR      NZ,o1FBD        ; to DEF-FN-7 if not
                                ; 'Nonsense in BASIC'


        RST     20H             ; get NEXT-CHAR
        CP      $3D             ; is it '=' ?
        JR      NZ,o1FBD        ; to DEF-FN-7 if not 'Nonsense...'


        RST     20H             ; address NEXT-CHAR
        LD      A,($5C3B)       ; get FLAGS which has been set above
        PUSH    AF              ; and preserve

        CALL    o24FB           ; routine SCANNING checks syntax of expression
                                ; and also sets flags.

        POP     AF              ; restore previous flags
        XOR     (IY+$01)        ; xor with FLAGS - bit 6 should be same
                                ; therefore will be reset.
        AND     $40             ; isolate bit 6.

;; DEF-FN-7
o1FBD:  JP      NZ,o1C8A        ; jump back to REPORT-C if the expected result
                                ; is not the same type.
                                ; 'Nonsense in BASIC'

        CALL    o1BEE           ; routine CHECK-END will return early if
                                ; at end of statement and move onto next
                                ; else produce error report. >>>

                                ; There will be no return to here.

; -------------------------------
; Returning early from subroutine
; -------------------------------
; All routines are capable of being run in two modes - syntax checking mode
; and runtime mode.  This routine is called often to allow a routine to return
; early if checking syntax.

;; UNSTACK-Z
o1FC3:  CALL    o2530           ; routine SYNTAX-Z sets zero flag if syntax
                                ; is being checked.

        POP     HL              ; drop the return address.
        RET      Z              ; return to previous call in chain if checking
                                ; syntax.

        JP      (HL)            ; jump to return address as BASIC program is
                                ; actually running.

; ---------------------
; Handle LPRINT command
; ---------------------
; A simple form of 'PRINT #3' although it can output to 16 streams.
; Probably for compatibility with other BASICs particularly ZX81 BASIC.
; An extra UDG might have been better.

;; LPRINT
o1FC9:  LD      A,$03           ; the printer channel
        JR      o1FCF           ; forward to PRINT-1

; ---------------------
; Handle PRINT commands
; ---------------------
; The Spectrum's main stream output command.
; The default stream is stream 2 which is normally the upper screen
; of the computer. However the stream can be altered in range 0 - 15.

;; PRINT
o1FCD:  LD      A,$02           ; the stream for the upper screen.

; The LPRINT command joins here.

;; PRINT-1
o1FCF:  CALL    o2530           ; routine SYNTAX-Z checks if program running
        CALL    NZ,o1601        ; routine CHAN-OPEN if so
        CALL    o0D4D           ; routine TEMPS sets temporary colours.
        CALL    o1FDF           ; routine PRINT-2 - the actual item
        CALL    o1BEE           ; routine CHECK-END gives error if not at end
                                ; of statement
        RET                     ; and return >>>

; ------------------------------------
; this subroutine is called from above
; and also from INPUT.

;; PRINT-2
o1FDF:  RST     18H             ; GET-CHAR gets printable character
        CALL    o2045           ; routine PR-END-Z checks if more printing
        JR      Z,o1FF2         ; to PRINT-4 if not     e.g. just 'PRINT :'

; This tight loop deals with combinations of positional controls and
; print items. An early return can be made from within the loop
; if the end of a print sequence is reached.

;; PRINT-3
o1FE5:  CALL    o204E           ; routine PR-POSN-1 returns zero if more
                                ; but returns early at this point if
                                ; at end of statement!
                                ;
        JR      Z,o1FE5         ; to PRINT-3 if consecutive positioners

        CALL    o1FFC           ; routine PR-ITEM-1 deals with strings etc.
        CALL    o204E           ; routine PR-POSN-1 for more position codes
        JR      Z,o1FE5         ; loop back to PRINT-3 if so

;; PRINT-4
o1FF2:  CP      $29             ; return now if this is ')' from input-item.
                                ; (see INPUT.)
        RET     Z               ; or continue and print carriage return in
                                ; runtime

; ---------------------
; Print carriage return
; ---------------------
; This routine which continues from above prints a carriage return
; in run-time. It is also called once from PRINT-POSN.

;; PRINT-CR
o1FF5:  CALL    o1FC3           ; routine UNSTACK-Z

        LD      A,$0D           ; prepare a carriage return

        RST     10H             ; PRINT-A
        RET                     ; return


; -----------
; Print items
; -----------
; This routine deals with print items as in
; PRINT AT 10,0;"The value of A is ";a
; It returns once a single item has been dealt with as it is part
; of a tight loop that considers sequences of positional and print items

;; PR-ITEM-1
o1FFC:  RST     18H             ; GET-CHAR
        CP      $AC             ; is character 'AT' ?
        JR      NZ,o200E        ; forward to PR-ITEM-2 if not.

        CALL    o1C79           ; routine NEXT-2NUM  check for two comma
                                ; separated numbers placing them on the
                                ; calculator stack in runtime.
        CALL    o1FC3           ; routine UNSTACK-Z quits if checking syntax.

        CALL    o2307           ; routine STK-TO-BC get the numbers in B and C.
        LD      A,$16           ; prepare the 'at' control.
        JR      o201E           ; forward to PR-AT-TAB to print the sequence.

; ---

;; PR-ITEM-2
o200E:  CP      $AD             ; is character 'TAB' ?
        JR      NZ,o2024        ; to PR-ITEM-3 if not


        RST     20H             ; NEXT-CHAR to address next character
        CALL    o1C82           ; routine EXPT-1NUM
        CALL    o1FC3           ; routine UNSTACK-Z quits if checking syntax.

        CALL    o1E99           ; routine FIND-INT2 puts integer in BC.
        LD      A,$17           ; prepare the 'tab' control.

;; PR-AT-TAB
o201E:  RST     10H             ; PRINT-A outputs the control

        LD      A,C             ; first value to A
        RST     10H             ; PRINT-A outputs it.

        LD      A,B             ; second value
        RST     10H             ; PRINT-A

        RET                     ; return - item finished >>>

; ---

; Now consider paper 2; #2; a$

;; PR-ITEM-3
o2024:  CALL    o21F2           ; routine CO-TEMP-3 will print any colour
        RET     NC              ; items - return if success.

        CALL    o2070           ; routine STR-ALTER considers new stream
        RET     NC              ; return if altered.

        CALL    o24FB           ; routine SCANNING now to evaluate expression
        CALL    o1FC3           ; routine UNSTACK-Z if not runtime.

        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
        CALL    Z,o2BF1         ; routine STK-FETCH if string.
                                ; note no flags affected.
        JP      NZ,o2DE3        ; to PRINT-FP to print if numeric >>>

; It was a string expression - start in DE, length in BC
; Now enter a loop to print it

;; PR-STRING
o203C:  LD      A,B             ; this tests if the
        OR      C               ; length is zero and sets flag accordingly.
        DEC     BC              ; this doesn't but decrements counter.
        RET     Z               ; return if zero.

        LD      A,(DE)          ; fetch character.
        INC     DE              ; address next location.

        RST     10H             ; PRINT-A.

        JR      o203C           ; loop back to PR-STRING.

; ---------------
; End of printing
; ---------------
; This subroutine returns zero if no further printing is required
; in the current statement.
; The first terminator is found in  escaped input items only,
; the others in print_items.

;; PR-END-Z
o2045:  CP      $29             ; is character a ')' ?
        RET     Z               ; return if so -        e.g. INPUT (p$); a$

;; PR-ST-END
o2048:  CP      $0D             ; is it a carriage return ?
        RET     Z               ; return also -         e.g. PRINT a

        CP      $3A             ; is character a ':' ?
        RET                     ; return - zero flag will be set if so.
                                ;                       e.g. PRINT a :

; --------------
; Print position
; --------------
; This routine considers a single positional character ';', ',', '''

;; PR-POSN-1
o204E:  RST     18H             ; GET-CHAR
        CP      $3B             ; is it ';' ?
                                ; i.e. print from last position.
        JR      Z,o2067         ; forward to PR-POSN-3 if so.
                                ; i.e. do nothing.

        CP      $2C             ; is it ',' ?
                                ; i.e. print at next tabstop.
        JR      NZ,o2061        ; forward to PR-POSN-2 if anything else.

        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o2067         ; forward to PR-POSN-3 if checking syntax.

        LD      A,$06           ; prepare the 'comma' control character.

        RST     10H             ; PRINT-A  outputs to current channel in
                                ; run-time.

        JR      o2067           ; skip to PR-POSN-3.

; ---

; check for newline.

;; PR-POSN-2
o2061:  CP      $27             ; is character a "'" ? (newline)
        RET     NZ              ; return if no match              >>>

        CALL    o1FF5           ; routine PRINT-CR outputs a carriage return
                                ; in runtime only.

;; PR-POSN-3
o2067:  RST     20H             ; NEXT-CHAR to A.
        CALL    o2045           ; routine PR-END-Z checks if at end.
        JR      NZ,o206E        ; to PR-POSN-4 if not.

        POP     BC              ; drop return address if at end.

;; PR-POSN-4
o206E:  CP      A               ; reset the zero flag.
        RET                     ; and return to loop or quit.

; ------------
; Alter stream
; ------------
; This routine is called from PRINT ITEMS above, and also LIST as in
; LIST #15

;; STR-ALTER
o2070:  CP      $23             ; is character '#' ?
        SCF                     ; set carry flag.
        RET     NZ              ; return if no match.


        RST      20H            ; NEXT-CHAR
        CALL    o1C82           ; routine EXPT-1NUM gets stream number
        AND     A               ; prepare to exit early with carry reset
        CALL    o1FC3           ; routine UNSTACK-Z exits early if parsing
        CALL    o1E94           ; routine FIND-INT1 gets number off stack
        CP      $10             ; must be range 0 - 15 decimal.
        JP      NC,o160E        ; jump back to REPORT-Oa if not
                                ; 'Invalid stream'.

        CALL    o1601           ; routine CHAN-OPEN
        AND     A               ; clear carry - signal item dealt with.
        RET                     ; return

; -------------------
; THE 'INPUT' COMMAND
; -------------------
; This command is mysterious.
;

;; INPUT
o2089:  CALL    o2530           ; routine SYNTAX-Z to check if in runtime.

        JR      Z,o2096         ; forward to INPUT-1 if checking syntax.

        LD      A,$01           ; select channel 'K' the keyboard for input.
        CALL    o1601           ; routine CHAN-OPEN opens the channel and sets
                                ; bit 0 of TV_FLAG.

;   Note. As a consequence of clearing the lower screen channel 0 is made
;   the current channel so the above two instructions are superfluous.

        CALL    o0D6E           ; routine CLS-LOWER clears the lower screen
                                ; and sets DF_SZ to two and TV_FLAG to $01.

;; INPUT-1
o2096:  LD      (IY+$02),$01    ; update TV_FLAG - signal lower screen in use
                                ; ensuring that the correct set of system
                                ; variables are updated and that the border
                                ; colour is used.

;   Note. The Complete Spectrum ROM Disassembly incorrectly names DF-SZ as the
;   system variable that is updated above and if, as some have done, you make
;   this unnecessary alteration then there will be two blank lines between the
;   lower screen and the upper screen areas which will also scroll wrongly.

        CALL    o20C1           ; routine IN-ITEM-1 to handle the input.

        CALL    o1BEE           ; routine CHECK-END will make an early exit
                                ; if checking syntax. >>>

;   Keyboard input has been made and it remains to adjust the upper
;   screen in case the lower two lines have been extended upwards.

o20A0:  LD      BC,($5C88)      ; fetch S_POSN current line/column of
                                ; the upper screen.
        LD      A,($5C6B)       ; fetch DF_SZ the display file size of
                                ; the lower screen.
        CP      B               ; test that lower screen does not overlap
        JR      C,o20AD         ; forward to INPUT-2 if not.

; the two screens overlap so adjust upper screen.

        LD      C,$21           ; set column of upper screen to leftmost.
        LD      B,A             ; and line to one above lower screen.
                                ; continue forward to update upper screen
                                ; print position.

;; INPUT-2
o20AD:  LD      ($5C88),BC      ; set S_POSN update upper screen line/column.
        LD      A,$19           ; subtract from twenty five
        SUB     B               ; the new line number.
        LD      ($5C8C),A       ; and place result in SCR_CT - scroll count.
        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use.

        CALL    o0DD9           ; routine CL-SET sets the print position
                                ; system variables for the upper screen.

        JP      o0D6E           ; jump back to CLS-LOWER and make
                                ; an indirect exit >>.

; ---------------------
; INPUT ITEM subroutine
; ---------------------
;   This subroutine deals with the input items and print items.
;   from  the current input channel.
;   It is only called from the above INPUT routine but was obviously
;   once called from somewhere else in another context.

;; IN-ITEM-1
o20C1:  CALL    o204E           ; routine PR-POSN-1 deals with a single
                                ; position item at each call.
        JR      Z,o20C1         ; back to IN-ITEM-1 until no more in a
                                ; sequence.

        CP      $28             ; is character '(' ?
        JR      NZ,o20D8        ; forward to IN-ITEM-2 if not.

;   any variables within braces will be treated as part, or all, of the prompt
;   instead of being used as destination variables.

        RST     20H             ; NEXT-CHAR
        CALL    o1FDF           ; routine PRINT-2 to output the dynamic
                                ; prompt.

        RST     18H             ; GET-CHAR
        CP      $29             ; is character a matching ')' ?
        JP      NZ,o1C8A        ; jump back to REPORT-C if not.
                                ; 'Nonsense in BASIC'.

        RST     20H             ; NEXT-CHAR
        JP      o21B2           ; forward to IN-NEXT-2

; ---

;; IN-ITEM-2
o20D8:  CP      $CA             ; is the character the token 'LINE' ?
        JR      NZ,o20ED        ; forward to IN-ITEM-3 if not.

        RST     20H             ; NEXT-CHAR - variable must come next.
        CALL    o1C1F           ; routine CLASS-01 returns destination
                                ; address of variable to be assigned.
                                ; or generates an error if no variable
                                ; at this position.

        SET     7,(IY+$37)      ; update FLAGX  - signal handling INPUT LINE
        BIT     6,(IY+$01)      ; test FLAGS  - numeric or string result ?
        JP      NZ,o1C8A        ; jump back to REPORT-C if not string
                                ; 'Nonsense in BASIC'.

        JR      o20FA           ; forward to IN-PROMPT to set up workspace.

; ---

;   the jump was here for other variables.

;; IN-ITEM-3
o20ED:  CALL     o2C8D          ; routine ALPHA checks if character is
                                ; a suitable variable name.
        JP      NC,o21AF        ; forward to IN-NEXT-1 if not

        CALL    o1C1F           ; routine CLASS-01 returns destination
                                ; address of variable to be assigned.
        RES     7,(IY+$37)      ; update FLAGX  - signal not INPUT LINE.

;; IN-PROMPT
o20FA:  CALL    o2530           ; routine SYNTAX-Z
        JP      Z,o21B2         ; forward to IN-NEXT-2 if checking syntax.

        CALL    o16BF           ; routine SET-WORK clears workspace.
        LD      HL,$5C71        ; point to system variable FLAGX
        RES     6,(HL)          ; signal string result.
        SET     5,(HL)          ; signal in Input Mode for editor.
        LD      BC,$0001        ; initialize space required to one for
                                ; the carriage return.
        BIT     7,(HL)          ; test FLAGX - INPUT LINE in use ?
        JR      NZ,o211C        ; forward to IN-PR-2 if so as that is
                                ; all the space that is required.

        LD      A,($5C3B)       ; load accumulator from FLAGS
        AND     $40             ; mask to test BIT 6 of FLAGS and clear
                                ; the other bits in A.
                                ; numeric result expected ?
        JR      NZ,o211A        ; forward to IN-PR-1 if so

        LD      C,$03           ; increase space to three bytes for the
                                ; pair of surrounding quotes.

;; IN-PR-1
o211A:  OR      (HL)            ; if numeric result, set bit 6 of FLAGX.
        LD      (HL),A          ; and update system variable

;; IN-PR-2
o211C:  RST     30H             ; BC-SPACES opens 1 or 3 bytes in workspace
        LD      (HL),$0D        ; insert carriage return at last new location.
        LD      A,C             ; fetch the length, one or three.
        RRCA                    ; lose bit 0.
        RRCA                    ; test if quotes required.
        JR      NC,o2129        ; forward to IN-PR-3 if not.

        LD      A,$22           ; load the '"' character
        LD      (DE),A          ; place quote in first new location at DE.
        DEC     HL              ; decrease HL - from carriage return.
        LD      (HL),A          ; and place a quote in second location.

;; IN-PR-3
o2129:  LD      ($5C5B),HL      ; set keyboard cursor K_CUR to HL
        BIT     7,(IY+$37)      ; test FLAGX  - is this INPUT LINE ??
        JR      NZ,o215E        ; forward to IN-VAR-3 if so as input will
                                ; be accepted without checking its syntax.

        LD      HL,(CH_ADD)     ; fetch CH_ADD
        PUSH    HL              ; and save on stack.
        LD      HL,(ERR_SP)     ; fetch ERR_SP
        PUSH    HL              ; and save on stack

;; IN-VAR-1
o213A:  LD      HL,o213A        ; address: IN-VAR-1 - this address
        PUSH    HL              ; is saved on stack to handle errors.
        BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
        JR      Z,o2148         ; forward to IN-VAR-2 if not using the
                                ; keyboard for input. (??)

        LD      (ERR_SP),SP     ; set ERR_SP to point to IN-VAR-1 on stack.

;; IN-VAR-2
o2148:  LD      HL,($5C61)      ; set HL to WORKSP - start of workspace.
        CALL    o11A7           ; routine REMOVE-FP removes floating point
                                ; forms when looping in error condition.
        LD      (IY+$00),$FF    ; set ERR_NR to 'OK' cancelling the error.
                                ; but X_PTR causes flashing error marker
                                ; to be displayed at each call to the editor.
        CALL    o0F2C           ; routine EDITOR allows input to be entered
                                ; or corrected if this is second time around.

; if we pass to next then there are no system errors

        RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax
        CALL    o21B9           ; routine IN-ASSIGN checks syntax using
                                ; the VAL-FET-2 and powerful SCANNING routines.
                                ; any syntax error and its back to IN-VAR-1.
                                ; but with the flashing error marker showing
                                ; where the error is.
                                ; Note. the syntax of string input has to be
                                ; checked as the user may have removed the
                                ; bounding quotes or escaped them as with
                                ; "hat" + "stand" for example.
; proceed if syntax passed.

        JR      o2161           ; jump forward to IN-VAR-4

; ---

; the jump was to here when using INPUT LINE.

;; IN-VAR-3
o215E:  CALL    o0F2C           ; routine EDITOR is called for input

; when ENTER received rejoin other route but with no syntax check.

; INPUT and INPUT LINE converge here.

;; IN-VAR-4
o2161:  LD      (IY+$22),$00    ; set K_CUR_hi to a low value so that the cursor
                                ; no longer appears in the input line.

        CALL    o21D6           ; routine IN-CHAN-K tests if the keyboard
                                ; is being used for input.
        JR      NZ,o2174        ; forward to IN-VAR-5 if using another input
                                ; channel.

; continue here if using the keyboard.

        CALL    o111D           ; routine ED-COPY overprints the edit line
                                ; to the lower screen. The only visible
                                ; affect is that the cursor disappears.
                                ; if you're inputting more than one item in
                                ; a statement then that becomes apparent.

        LD      BC,($5C82)      ; fetch line and column from ECHO_E
        CALL    o0DD9           ; routine CL-SET sets S-POSNL to those
                                ; values.

; if using another input channel rejoin here.

;; IN-VAR-5
o2174:  LD      HL,$5C71        ; point HL to FLAGX
        RES     5,(HL)          ; signal not in input mode
        BIT     7,(HL)          ; is this INPUT LINE ?
        RES     7,(HL)          ; cancel the bit anyway.
        JR      NZ,o219B        ; forward to IN-VAR-6 if INPUT LINE.

        POP     HL              ; drop the looping address
        POP     HL              ; drop the address of previous
                                ; error handler.
        LD      (ERR_SP),HL     ; set ERR_SP to point to it.
        POP     HL              ; drop original CH_ADD which points to
                                ; INPUT command in BASIC line.
        LD      (X_PTR),HL      ; save in X_PTR while input is assigned.
        SET     7,(IY+$01)      ; update FLAGS - Signal running program
        CALL    o21B9           ; routine IN-ASSIGN is called again
                                ; this time the variable will be assigned
                                ; the input value without error.
                                ; Note. the previous example now
                                ; becomes "hatstand"

        LD      HL,(X_PTR)      ; fetch stored CH_ADD value from X_PTR.
        LD      (IY+$26),$00    ; set X_PTR_hi so that iy is no longer relevant.
        LD      (CH_ADD),HL     ; put restored value back in CH_ADD
        JR      o21B2           ; forward to IN-NEXT-2 to see if anything
                                ; more in the INPUT list.

; ---

; the jump was to here with INPUT LINE only

;; IN-VAR-6
o219B:  LD      HL,($5C63)      ; STKBOT points to the end of the input.
        LD      DE,($5C61)      ; WORKSP points to the beginning.
        SCF                     ; prepare for true subtraction.
        SBC     HL,DE           ; subtract to get length
        LD      B,H             ; transfer it to
        LD      C,L             ; the BC register pair.
        CALL    o2AB2           ; routine STK-STO-$ stores parameters on
                                ; the calculator stack.
        CALL    o2AFF           ; routine LET assigns it to destination.
        JR      o21B2           ; forward to IN-NEXT-2 as print items
                                ; not allowed with INPUT LINE.
                                ; Note. that "hat" + "stand" will, for
                                ; example, be unchanged as also would
                                ; 'PRINT "Iris was here"'.

; ---

; the jump was to here when ALPHA found more items while looking for
; a variable name.

;; IN-NEXT-1
o21AF:  CALL    o1FFC           ; routine PR-ITEM-1 considers further items.

;; IN-NEXT-2
o21B2:  CALL    o204E           ; routine PR-POSN-1 handles a position item.
        JP      Z,o20C1         ; jump back to IN-ITEM-1 if the zero flag
                                ; indicates more items are present.

        RET                     ; return.

; ---------------------------
; INPUT ASSIGNMENT Subroutine
; ---------------------------
; This subroutine is called twice from the INPUT command when normal
; keyboard input is assigned. On the first occasion syntax is checked
; using SCANNING. The final call with the syntax flag reset is to make
; the assignment.

;; IN-ASSIGN
o21B9:  LD      HL,($5C61)      ; fetch WORKSP start of input
        LD      (CH_ADD),HL     ; set CH_ADD to first character

        RST     18H             ; GET-CHAR ignoring leading white-space.
        CP      $E2             ; is it 'STOP'
        JR      Z,o21D0         ; forward to IN-STOP if so.

        LD      A,($5C71)       ; load accumulator from FLAGX
        CALL    o1C59           ; routine VAL-FET-2 makes assignment
                                ; or goes through the motions if checking
                                ; syntax. SCANNING is used.

        RST     18H             ; GET-CHAR
        CP      $0D             ; is it carriage return ?
        RET     Z               ; return if so
                                ; either syntax is OK
                                ; or assignment has been made.

; if another character was found then raise an error.
; User doesn't see report but the flashing error marker
; appears in the lower screen.

;; REPORT-Cb
o21CE:  RST     08H             ; ERROR-1
        DEFB    $0B             ; Error Report: Nonsense in BASIC

;; IN-STOP
o21D0:  CALL    o2530           ; routine SYNTAX-Z (UNSTACK-Z?)
        RET     Z               ; return if checking syntax
                                ; as user wouldn't see error report.
                                ; but generate visible error report
                                ; on second invocation.

;; REPORT-H
o21D4:  RST     08H             ; ERROR-1
        DEFB    $10             ; Error Report: STOP in INPUT

; -----------------------------------
; THE 'TEST FOR CHANNEL K' SUBROUTINE
; -----------------------------------
;   This subroutine is called once from the keyboard INPUT command to check if
;   the input routine in use is the one for the keyboard.

;; IN-CHAN-K
o21D6:  LD      HL,(CURCHL)     ; fetch address of current channel CURCHL
        INC     HL              ;
        INC     HL              ; advance past
        INC     HL              ; input and
        INC     HL              ; output streams
        LD      A,(HL)          ; fetch the channel identifier.
        CP      $4B             ; test for 'K'
        RET                     ; return with zero set if keyboard is use.

; --------------------
; Colour Item Routines
; --------------------
;
; These routines have 3 entry points -
; 1) CO-TEMP-2 to handle a series of embedded Graphic colour items.
; 2) CO-TEMP-3 to handle a single embedded print colour item.
; 3) CO TEMP-4 to handle a colour command such as FLASH 1
;
; "Due to a bug, if you bring in a peripheral channel and later use a colour
;  statement, colour controls will be sent to it by mistake." - Steven Vickers
;  Pitman Pocket Guide, 1984.
;
; To be fair, this only applies if the last channel was other than 'K', 'S'
; or 'P', which are all that are supported by this ROM, but if that last
; channel was a microdrive file, network channel etc. then
; PAPER 6; CLS will not turn the screen yellow and
; CIRCLE INK 2; 128,88,50 will not draw a red circle.
;
; This bug does not apply to embedded PRINT items as it is quite permissible
; to mix stream altering commands and colour items.
; The fix therefore would be to ensure that CLASS-07 and CLASS-09 make
; channel 'S' the current channel when not checking syntax.
; -----------------------------------------------------------------

;; CO-TEMP-1
o21E1:  RST     20H             ; NEXT-CHAR

; -> Entry point from CLASS-09. Embedded Graphic colour items.
; e.g. PLOT INK 2; PAPER 8; 128,88
; Loops till all colour items output, finally addressing the coordinates.

;; CO-TEMP-2
o21E2:  CALL    o21F2           ; routine CO-TEMP-3 to output colour control.
        RET     C               ; return if nothing more to output. ->


        RST     18H             ; GET-CHAR
        CP      $2C             ; is it ',' separator ?
        JR      Z,o21E1         ; back if so to CO-TEMP-1

        CP      $3B             ; is it ';' separator ?
        JR      Z,o21E1         ; back to CO-TEMP-1 for more.

        JP      o1C8A           ; to REPORT-C (REPORT-Cb is within range)
                                ; 'Nonsense in BASIC'

; -------------------
; CO-TEMP-3
; -------------------
; -> this routine evaluates and outputs a colour control and parameter.
; It is called from above and also from PR-ITEM-3 to handle a single embedded
; print item e.g. PRINT PAPER 6; "Hi". In the latter case, the looping for
; multiple items is within the PR-ITEM routine.
; It is quite permissible to send these to any stream.

;; CO-TEMP-3
o21F2:  CP      $D9             ; is it 'INK' ?
        RET     C               ; return if less.

        CP      $DF             ; compare with 'OUT'
        CCF                     ; Complement Carry Flag
        RET     C               ; return if greater than 'OVER', $DE.

        PUSH    AF              ; save the colour token.

        RST     20H             ; address NEXT-CHAR
        POP     AF              ; restore token and continue.

; -> this entry point used by CLASS-07. e.g. the command PAPER 6.

;; CO-TEMP-4
o21FC:  SUB     $C9             ; reduce to control character $10 (INK)
                                ; thru $15 (OVER).
        PUSH    AF              ; save control.
        CALL    o1C82           ; routine EXPT-1NUM stacks addressed
                                ; parameter on calculator stack.
        POP     AF              ; restore control.
        AND     A               ; clear carry

        CALL    o1FC3           ; routine UNSTACK-Z returns if checking syntax.

        PUSH    AF              ; save again
        CALL    o1E94           ; routine FIND-INT1 fetches parameter to A.
        LD      D,A             ; transfer now to D
        POP     AF              ; restore control.

        RST     10H             ; PRINT-A outputs the control to current
                                ; channel.
        LD      A,D             ; transfer parameter to A.

        RST     10H             ; PRINT-A outputs parameter.
        RET                     ; return. ->

; -------------------------------------------------------------------------
;
;         {fl}{br}{   paper   }{  ink    }    The temporary colour attributes
;          ___ ___ ___ ___ ___ ___ ___ ___    system variable.
; ATTR_T  |   |   |   |   |   |   |   |   |
;         |   |   |   |   |   |   |   |   |
; 23695   |___|___|___|___|___|___|___|___|
;           7   6   5   4   3   2   1   0
;
;
;         {fl}{br}{   paper   }{  ink    }    The temporary mask used for
;          ___ ___ ___ ___ ___ ___ ___ ___    transparent colours. Any bit
; MASK_T  |   |   |   |   |   |   |   |   |   that is 1 shows that the
;         |   |   |   |   |   |   |   |   |   corresponding attribute is
; 23696   |___|___|___|___|___|___|___|___|   taken not from ATTR-T but from
;           7   6   5   4   3   2   1   0     what is already on the screen.
;
;
;         {paper9 }{ ink9 }{ inv1 }{ over1}   The print flags. Even bits are
;          ___ ___ ___ ___ ___ ___ ___ ___    temporary flags. The odd bits
; P_FLAG  |   |   |   |   |   |   |   |   |   are the permanent flags.
;         | p | t | p | t | p | t | p | t |
; 23697   |___|___|___|___|___|___|___|___|
;           7   6   5   4   3   2   1   0
;
; -----------------------------------------------------------------------

; ------------------------------------
;  The colour system variable handler.
; ------------------------------------
; This is an exit branch from PO-1-OPER, PO-2-OPER
; A holds control $10 (INK) to $15 (OVER)
; D holds parameter 0-9 for ink/paper 0,1 or 8 for bright/flash,
; 0 or 1 for over/inverse.

;; CO-TEMP-5
o2211:  SUB     $11             ; reduce range $FF-$04
        ADC     A,$00           ; add in carry if INK
        JR      Z,o2234         ; forward to CO-TEMP-7 with INK and PAPER.

        SUB     $02             ; reduce range $FF-$02
        ADC     A,$00           ; add carry if FLASH
        JR      Z,o2273         ; forward to CO-TEMP-C with FLASH and BRIGHT.

        CP      $01             ; is it 'INVERSE' ?
        LD      A,D             ; fetch parameter for INVERSE/OVER
        LD      B,$01           ; prepare OVER mask setting bit 0.
        JR      NZ,o2228        ; forward to CO-TEMP-6 if OVER

        RLCA                    ; shift bit 0
        RLCA                    ; to bit 2
        LD      B,$04           ; set bit 2 of mask for inverse.

;; CO-TEMP-6
o2228:  LD      C,A             ; save the A
        LD      A,D             ; re-fetch parameter
        CP      $02             ; is it less than 2
        JR      NC,o2244        ; to REPORT-K if not 0 or 1.
                                ; 'Invalid colour'.

        LD      A,C             ; restore A
        LD      HL,$5C91        ; address system variable P_FLAG
        JR      o226C           ; forward to exit via routine CO-CHANGE

; ---

; the branch was here with INK/PAPER and carry set for INK.

;; CO-TEMP-7
o2234:  LD      A,D             ; fetch parameter
        LD      B,$07           ; set ink mask 00000111
        JR      C,o223E         ; forward to CO-TEMP-8 with INK

        RLCA                    ; shift bits 0-2
        RLCA                    ; to
        RLCA                    ; bits 3-5
        LD      B,$38           ; set paper mask 00111000

; both paper and ink rejoin here

;; CO-TEMP-8
o223E:  LD      C,A             ; value to C
        LD      A,D             ; fetch parameter
        CP      $0A             ; is it less than 10d ?
        JR      C,o2246         ; forward to CO-TEMP-9 if so.

; ink 10 etc. is not allowed.

;; REPORT-K
o2244:  RST     08H             ; ERROR-1
        DEFB    $13             ; Error Report: Invalid colour

;; CO-TEMP-9
o2246:  LD      HL,ATTR_T       ; address system variable ATTR_T initially.
        CP      $08             ; compare with 8
        JR      C,o2258         ; forward to CO-TEMP-B with 0-7.

        LD      A,(HL)          ; fetch temporary attribute as no change.
        JR      Z,o2257         ; forward to CO-TEMP-A with INK/PAPER 8

; it is either ink 9 or paper 9 (contrasting)

        OR      B               ; or with mask to make white
        CPL                     ; make black and change other to dark
        AND     $24             ; 00100100
        JR      Z,o2257         ; forward to CO-TEMP-A if black and
                                ; originally light.

        LD      A,B             ; else just use the mask (white)

;; CO-TEMP-A
o2257:  LD      C,A             ; save A in C

;; CO-TEMP-B
o2258:  LD      A,C             ; load colour to A
        CALL    o226C           ; routine CO-CHANGE addressing ATTR-T

        LD      A,$07           ; put 7 in accumulator
        CP      D               ; compare with parameter
        SBC     A,A             ; $00 if 0-7, $FF if 8
        CALL    o226C           ; routine CO-CHANGE addressing MASK-T
                                ; mask returned in A.

; now consider P-FLAG.

        RLCA                    ; 01110000 or 00001110
        RLCA                    ; 11100000 or 00011100
        AND     $50             ; 01000000 or 00010000  (AND 01010000)
        LD      B,A             ; transfer to mask
        LD      A,$08           ; load A with 8
        CP      D               ; compare with parameter
        SBC     A,A             ; $FF if was 9,  $00 if 0-8
                                ; continue while addressing P-FLAG
                                ; setting bit 4 if ink 9
                                ; setting bit 6 if paper 9

; -----------------------
; Handle change of colour
; -----------------------
; This routine addresses a system variable ATTR_T, MASK_T or P-FLAG in HL.
; colour value in A, mask in B.

;; CO-CHANGE
o226C:  XOR     (HL)            ; impress bits specified
        AND     B               ; by mask
        XOR     (HL)            ; on system variable.
        LD      (HL),A          ; update system variable.
        INC     HL              ; address next location.
        LD      A,B             ; put current value of mask in A
        RET                     ; return.

; ---

; the branch was here with flash and bright

;; CO-TEMP-C
o2273:  SBC     A,A             ; set zero flag for bright.
        LD      A,D             ; fetch original parameter 0,1 or 8
        RRCA                    ; rotate bit 0 to bit 7
        LD      B,$80           ; mask for flash 10000000
        JR      NZ,o227D        ; forward to CO-TEMP-D if flash

        RRCA                    ; rotate bit 7 to bit 6
        LD      B,$40           ; mask for bright 01000000

;; CO-TEMP-D
o227D:  LD      C,A             ; store value in C
        LD      A,D             ; fetch parameter
        CP      $08             ; compare with 8
        JR      Z,o2287         ; forward to CO-TEMP-E if 8

        CP      $02             ; test if 0 or 1
        JR      NC,o2244        ; back to REPORT-K if not
                                ; 'Invalid colour'

;; CO-TEMP-E
o2287:  LD      A,C             ; value to A
        LD      HL,ATTR_T       ; address ATTR_T
        CALL    o226C           ; routine CO-CHANGE addressing ATTR_T
        LD      A,C             ; fetch value
        RRCA                    ; for flash8/bright8 complete
        RRCA                    ; rotations to put set bit in
        RRCA                    ; bit 7 (flash) bit 6 (bright)
        JR      o226C           ; back to CO-CHANGE addressing MASK_T
                                ; and indirect return.

; ---------------------
; Handle BORDER command
; ---------------------
; Command syntax example: BORDER 7
; This command routine sets the border to one of the eight colours.
; The colours used for the lower screen are based on this.

;; BORDER
o2294:  CALL    o1E94           ; routine FIND-INT1
        CP      $08             ; must be in range 0 (black) to 7 (white)
        JR      NC,o2244        ; back to REPORT-K if not
                                ; 'Invalid colour'.

        OUT     ($FE),A         ; outputting to port effects an immediate
                                ; change.
        RLCA                    ; shift the colour to
        RLCA                    ; the paper bits setting the
        RLCA                    ; ink colour black.
        BIT     5,A             ; is the number light coloured ?
                                ; i.e. in the range green to white.
        JR      NZ,o22A6        ; skip to BORDER-1 if so

        XOR     $07             ; make the ink white.

;; BORDER-1
o22A6:  LD      (BORDCR),A      ; update BORDCR with new paper/ink
        RET                     ; return.

; -----------------
; Get pixel address
; -----------------
;
;

;; PIXEL-ADD
o22AA:  LD      A,$AF           ; load with 175 decimal.
        SUB     B               ; subtract the y value.
        JP      C,o24F9         ; jump forward to REPORT-Bc if greater.
                                ; 'Integer out of range'

; the high byte is derived from Y only.
; the first 3 bits are always 010
; the next 2 bits denote in which third of the screen the byte is.
; the last 3 bits denote in which of the 8 scan lines within a third
; the byte is located. There are 24 discrete values.


        LD      B,A             ; the line number from top of screen to B.
        AND     A               ; clear carry (already clear)
        RRA                     ;                     0xxxxxxx
        SCF                     ; set carry flag
        RRA                     ;                     10xxxxxx
        AND     A               ; clear carry flag
        RRA                     ;                     010xxxxx

        XOR     B               ;
        AND     $F8             ; keep the top 5 bits 11111000
        XOR     B               ;                     010xxbbb
        LD      H,A             ; transfer high byte to H.

; the low byte is derived from both X and Y.

        LD      A,C             ; the x value 0-255.
        RLCA                    ;
        RLCA                    ;
        RLCA                    ;
        XOR     B               ; the y value
        AND     $C7             ; apply mask             11000111
        XOR     B               ; restore unmasked bits  xxyyyxxx
        RLCA                    ; rotate to              xyyyxxxx
        RLCA                    ; required position.     yyyxxxxx
        LD      L,A             ; low byte to L.

; finally form the pixel position in A.

        LD      A,C             ; x value to A
        AND     $07             ; mod 8
        RET                     ; return

; ----------------
; Point Subroutine
; ----------------
; The point subroutine is called from s-point via the scanning functions
; table.

;; POINT-SUB
o22CB:  CALL    o2307           ; routine STK-TO-BC
        CALL    o22AA           ; routine PIXEL-ADD finds address of pixel.
        LD      B,A             ; pixel position to B, 0-7.
        INC     B               ; increment to give rotation count 1-8.
        LD      A,(HL)          ; fetch byte from screen.

;; POINT-LP
o22D4:  RLCA                    ; rotate and loop back
        DJNZ    o22D4           ; to POINT-LP until pixel at right.

        AND      $01            ; test to give zero or one.
        JP      o2D28           ; jump forward to STACK-A to save result.

; -------------------
; Handle PLOT command
; -------------------
; Command Syntax example: PLOT 128,88
;

;; PLOT
o22DC:  CALL    o2307           ; routine STK-TO-BC
        CALL    o22E5           ; routine PLOT-SUB
        JP      o0D4D           ; to TEMPS

; -------------------
; The Plot subroutine
; -------------------
; A screen byte holds 8 pixels so it is necessary to rotate a mask
; into the correct position to leave the other 7 pixels unaffected.
; However all 64 pixels in the character cell take any embedded colour
; items.
; A pixel can be reset (inverse 1), toggled (over 1), or set ( with inverse
; and over switches off). With both switches on, the byte is simply put
; back on the screen though the colours may change.

;; PLOT-SUB
o22E5:  LD      ($5C7D),BC      ; store new x/y values in COORDS
o22E9:  CALL    o22AA           ; routine PIXEL-ADD gets address in HL,
                                ; count from left 0-7 in B.
        LD      B,A             ; transfer count to B.
        INC     B               ; increase 1-8.
        LD      A,$FE           ; 11111110 in A.

;; PLOT-LOOP
o22F0:  RRCA                    ; rotate mask.
        DJNZ    o22F0           ; to PLOT-LOOP until B circular rotations.

        LD      B,A             ; load mask to B
        LD      A,(HL)          ; fetch screen byte to A

        LD      C,(IY+$57)      ; P_FLAG to C
        BIT     0,C             ; is it to be OVER 1 ?
        JR      NZ,o22FD        ; forward to PL-TST-IN if so.

; was over 0

        AND     B               ; combine with mask to blank pixel.

;; PL-TST-IN
o22FD:  BIT     2,C             ; is it inverse 1 ?
        JR      NZ,o2303        ; to PLOT-END if so.

        XOR     B               ; switch the pixel
        CPL                     ; restore other 7 bits

;; PLOT-END
o2303:  LD      (HL),A          ; load byte to the screen.
        JP      o0BDB           ; exit to PO-ATTR to set colours for cell.

; ------------------------------
; Put two numbers in BC register
; ------------------------------
;
;

;; STK-TO-BC
o2307:  CALL    o2314           ; routine STK-TO-A
        LD      B,A             ;
        PUSH    BC              ;
        CALL    o2314           ; routine STK-TO-A
        LD      E,C             ;
        POP     BC              ;
        LD      D,C             ;
        LD      C,A             ;
        RET                     ;

; -----------------------
; Put stack in A register
; -----------------------
; This routine puts the last value on the calculator stack into the accumulator
; deleting the last value.

;; STK-TO-A
o2314:  CALL    o2DD5           ; routine FP-TO-A compresses last value into
                                ; accumulator. e.g. PI would become 3.
                                ; zero flag set if positive.
        JP      C,o24F9         ; jump forward to REPORT-Bc if >= 255.5.

        LD      C,$01           ; prepare a positive sign byte.
        RET     Z               ; return if FP-TO-BC indicated positive.

        LD      C,$FF           ; prepare negative sign byte and
        RET                     ; return.


; --------------------
; THE 'CIRCLE' COMMAND
; --------------------
;   "Goe not Thou about to Square eyther circle" -
;   - John Donne, Cambridge educated theologian, 1624
;
;   The CIRCLE command draws a circle as a series of straight lines.
;   In some ways it can be regarded as a polygon, but the first line is drawn
;   as a tangent, taking the radius as its distance from the centre.
;
;   Both the CIRCLE algorithm and the ARC drawing algorithm make use of the
;   'ROTATION FORMULA' (see later).  It is only necessary to work out where
;   the first line will be drawn and how long it is and then the rotation
;   formula takes over and calculates all other rotated points.
;
;   All Spectrum circles consist of two vertical lines at each side and two
;   horizontal lines at the top and bottom. The number of lines is calculated
;   from the radius of the circle and is always divisible by 4. For complete
;   circles it will range from 4 for a square circle to 32 for a circle of
;   radius 87. The Spectrum can attempt larger circles e.g. CIRCLE 0,14,255
;   but these will error as they go off-screen after four lines are drawn.
;   At the opposite end, CIRCLE 128,88,1.23 will draw a circle as a perfect 3x3
;   square using 4 straight lines although very small circles are just drawn as
;   a dot on the screen.
;
;   The first chord drawn is the vertical chord on the right of the circle.
;   The starting point is at the base of this chord which is drawn upwards and
;   the circle continues in an anti-clockwise direction. As noted earlier the
;   x-coordinate of this point measured from the centre of the circle is the
;   radius.
;
;   The CIRCLE command makes extensive use of the calculator and as part of
;   process of drawing a large circle, free memory is checked 1315 times.
;   When drawing a large arc, free memory is checked 928 times.
;   A single call to 'sin' involves 63 memory checks and so values of sine
;   and cosine are pre-calculated and held in the mem locations. As a
;   clever trick 'cos' is derived from 'sin' using simple arithmetic operations
;   instead of the more expensive 'cos' function.
;
;   Initially, the syntax has been partly checked using the class for the DRAW
;   command which stacks the origin of the circle (X,Y).

;; CIRCLE
o2320:  RST     18H             ; GET-CHAR              x, y.
        CP      $2C             ; Is character the required comma ?
        JP      NZ,o1C8A        ; Jump, if not, to REPORT-C
                                ; 'Nonsense in basic'

        RST     20H             ; NEXT-CHAR advances the parsed character address.
        CALL    o1C82           ; routine EXPT-1NUM stacks radius in runtime.
        CALL    o1BEE           ; routine CHECK-END will return here in runtime
                                ; if nothing follows the command.

;   Now make the radius positive and ensure that it is in floating point form
;   so that the exponent byte can be accessed for quick testing.

o232D:  RST     28H             ;; FP-CALC              x, y, r.
        DEFB    $2A             ;;abs                   x, y, r.
        DEFB    $3D             ;;re-stack              x, y, r.
        DEFB    $38             ;;end-calc              x, y, r.

        LD      A,(HL)          ; Fetch first, floating-point, exponent byte.
        CP      $81             ; Compare to one.
        JR      NC,o233B        ; Forward to C-R-GRE-1
                                ; if circle radius is greater than one.

;    The circle is no larger than a single pixel so delete the radius from the
;    calculator stack and plot a point at the centre.

        RST     28H             ;; FP-CALC              x, y, r.
        DEFB    $02             ;;delete                x, y.
        DEFB    $38             ;;end-calc              x, y.

        JR      o22DC           ; back to PLOT routine to just plot x,y.

; ---

;   Continue when the circle's radius measures greater than one by forming
;   the angle 2 * PI radians which is 360 degrees.

;; C-R-GRE-1
o233B:  RST     28H             ;; FP-CALC      x, y, r
        DEFB    $A3             ;;stk-pi/2      x, y, r, pi/2.
        DEFB    $38             ;;end-calc      x, y, r, pi/2.

;   Change the exponent of pi/2 from $81 to $83 giving 2*PI the central angle.
;   This is quicker than multiplying by four.

        LD      (HL),$83        ;               x, y, r, 2*PI.

;   Now store this important constant in mem-5 and delete so that other
;   parameters can be derived from it, by a routine shared with DRAW.

        RST     28H             ;; FP-CALC      x, y, r, 2*PI.
        DEFB    $C5             ;;st-mem-5      store 2*PI in mem-5
        DEFB    $02             ;;delete        x, y, r.
        DEFB    $38             ;;end-calc      x, y, r.

;   The parameters derived from mem-5 (A) and from the radius are set up in
;   four of the other mem locations by the CIRCLE DRAW PARAMETERS routine which
;   also returns the number of straight lines in the B register.

        CALL    o247D           ; routine CD-PRMS1

                                ; mem-0 ; A/No of lines (=a)            unused
                                ; mem-1 ; sin(a/2)  will be moving x    var
                                ; mem-2 ; -         will be moving y    var
                                ; mem-3 ; cos(a)                        const
                                ; mem-4 ; sin(a)                        const
                                ; mem-5 ; Angle of rotation (A) (2*PI)  const
                                ; B     ; Number of straight lines.

        PUSH    BC              ; Preserve the number of lines in B.

;   Next calculate the length of half a chord by multiplying the sine of half
;   the central angle by the radius of the circle.

        RST     28H             ;; FP-CALC      x, y, r.
        DEFB    $31             ;;duplicate     x, y, r, r.
        DEFB    $E1             ;;get-mem-1     x, y, r, r, sin(a/2).
        DEFB    $04             ;;multiply      x, y, r, half-chord.
        DEFB    $38             ;;end-calc      x, y, r, half-chord.

        LD      A,(HL)          ; fetch exponent  of the half arc to A.
        CP      $80             ; compare to a half pixel
        JR      NC,o235A        ; forward, if greater than .5, to C-ARC-GE1

;   If the first line is less than .5 then 4 'lines' would be drawn on the same
;   spot so tidy the calculator stack and machine stack and plot the centre.

        RST     28H             ;; FP-CALC      x, y, r, hc.
        DEFB    $02             ;;delete        x, y, r.
        DEFB    $02             ;;delete        x, y.
        DEFB    $38             ;;end-calc      x, y.

        POP     BC              ; Balance machine stack by taking chord-count.

        JP      o22DC           ; JUMP to PLOT

; ---

;   The arc is greater than 0.5 so the circle can be drawn.

;; C-ARC-GE1
o235A:  RST     28H             ;; FP-CALC      x, y, r, hc.
        DEFB    $C2             ;;st-mem-2      x, y, r, half chord to mem-2.
        DEFB    $01             ;;exchange      x, y, hc, r.
        DEFB    $C0             ;;st-mem-0      x, y, hc, r.
        DEFB    $02             ;;delete        x, y, hc.

;   Subtract the length of the half-chord from the absolute y coordinate to
;   give the starting y coordinate sy.
;   Note that for a circle this is also the end coordinate.

        DEFB    $03             ;;subtract      x, y-hc.  (The start y-coord)
        DEFB    $01             ;;exchange      sy, x.

;   Next simply add the radius to the x coordinate to give a fuzzy x-coordinate.
;   Strictly speaking, the radius should be multiplied by cos(a/2) first but
;   doing it this way makes the circle slightly larger.

        DEFB    $E0             ;;get-mem-0     sy, x, r.
        DEFB    $0F             ;;addition      sy, x+r.  (The start x-coord)

;   We now want three copies of this pair of values on the calculator stack.
;   The first pair remain on the stack throughout the circle routine and are
;   the end points. The next pair will be the moving absolute values of x and y
;   that are updated after each line is drawn. The final pair will be loaded
;   into the COORDS system variable so that the first vertical line starts at
;   the right place.

        DEFB    $C0             ;;st-mem-0      sy, sx.
        DEFB    $01             ;;exchange      sx, sy.
        DEFB    $31             ;;duplicate     sx, sy, sy.
        DEFB    $E0             ;;get-mem-0     sx, sy, sy, sx.
        DEFB    $01             ;;exchange      sx, sy, sx, sy.
        DEFB    $31             ;;duplicate     sx, sy, sx, sy, sy.
        DEFB    $E0             ;;get-mem-0     sx, sy, sx, sy, sy, sx.

;   Locations mem-1 and mem-2 are the relative x and y values which are updated
;   after each line is drawn. Since we are drawing a vertical line then the rx
;   value in mem-1 is zero and the ry value in mem-2 is the full chord.

        DEFB    $A0             ;;stk-zero      sx, sy, sx, sy, sy, sx, 0.
        DEFB    $C1             ;;st-mem-1      sx, sy, sx, sy, sy, sx, 0.
        DEFB    $02             ;;delete        sx, sy, sx, sy, sy, sx.

;   Although the three pairs of x/y values are the same for a circle, they
;   will be labelled terminating, absolute and start coordinates.

        DEFB    $38             ;;end-calc      tx, ty, ax, ay, sy, sx.

;   Use the exponent manipulating trick again to double the value of mem-2.

        INC     (IY+$62)        ; Increment MEM-2-1st doubling half chord.

;   Note. this first vertical chord is drawn at the radius so circles are
;   slightly dispoaced to the right.
;   It is only necessary to place the values (sx) and (sy) in the system
;   variable COORDS to ensure that drawing commences at the correct pixel.
;   Note. a couple of LD (COORDS),A instructions would have been quicker, and
;   simpler, than using LD (COORDS),HL.

        CALL    o1E94           ; routine FIND-INT1 fetches sx from stack to A.

        LD      L,A             ; place X value in L.
        PUSH    HL              ; save the holding register.

        CALL    o1E94           ; routine FIND-INT1 fetches sy to A

        POP     HL              ; restore the holding register.
        LD      H,A             ; and place y value in high byte.

        LD      ($5C7D),HL      ; Update the COORDS system variable.
                                ;
                                ;               tx, ty, ax, ay.

        POP     BC              ; restore the chord count
                                ; values 4,8,12,16,20,24,28 or 32.

        JP      o2420           ; forward to DRW-STEPS
                                ;               tx, ty, ax, ay.

;   Note. the jump to DRW-STEPS is just to decrement B and jump into the
;   middle of the arc-drawing loop. The arc count which includes the first
;   vertical arc draws one less than the perceived number of arcs.
;   The final arc offsets are obtained by subtracting the final COORDS value
;   from the initial sx and sy values which are kept at the base of the
;   calculator stack throughout the arc loop.
;   This ensures that the final line finishes exactly at the starting pixel
;   removing the possibility of any inaccuracy.
;   Since the initial sx and sy values are not required until the final arc
;   is drawn, they are not shown until then.
;   As the calculator stack is quite busy, only the active parts are shown in
;   each section.


; ------------------
; THE 'DRAW' COMMAND
; ------------------
;   The Spectrum's DRAW command is overloaded and can take two parameters sets.
;
;   With two parameters, it simply draws an approximation to a straight line
;   at offset x,y using the LINE-DRAW routine.
;
;   With three parameters, an arc is drawn to the point at offset x,y turning
;   through an angle, in radians, supplied by the third parameter.
;   The arc will consist of 4 to 252 straight lines each one of which is drawn
;   by calls to the DRAW-LINE routine.

;; DRAW
o2382:  RST     18H             ; GET-CHAR
        CP      $2C             ; is it the comma character ?
        JR      Z,o238D         ; forward, if so, to DR-3-PRMS

;   There are two parameters e.g. DRAW 255,175

        CALL    o1BEE           ; routine CHECK-END

        JP      o2477           ; jump forward to LINE-DRAW

; ---

;    There are three parameters e.g. DRAW 255, 175, .5
;    The first two are relative coordinates and the third is the angle of
;    rotation in radians (A).

;; DR-3-PRMS
o238D:  RST     20H             ; NEXT-CHAR skips over the 'comma'.

        CALL    o1C82           ; routine EXPT-1NUM stacks the rotation angle.

        CALL    o1BEE           ; routine CHECK-END

;   Now enter the calculator and store the complete rotation angle in mem-5

o2394:  RST     28H             ;; FP-CALC      x, y, A.
        DEFB    $C5             ;;st-mem-5      x, y, A.

;   Test the angle for the special case of 360 degrees.

        DEFB    $A2             ;;stk-half      x, y, A, 1/2.
        DEFB    $04             ;;multiply      x, y, A/2.
        DEFB    $1F             ;;sin           x, y, sin(A/2).
        DEFB    $31             ;;duplicate     x, y, sin(A/2),sin(A/2)
        DEFB    $30             ;;not           x, y, sin(A/2), (0/1).
        DEFB    $30             ;;not           x, y, sin(A/2), (1/0).
        DEFB    $00             ;;jump-true     x, y, sin(A/2).

        DEFB    $06             ;;forward to o23A3, DR-SIN-NZ
                                ; if sin(r/2) is not zero.

;   The third parameter is 2*PI (or a multiple of 2*PI) so a 360 degrees turn
;   would just be a straight line.  Eliminating this case here prevents
;   division by zero at later stage.

        DEFB    $02             ;;delete        x, y.
        DEFB    $38             ;;end-calc      x, y.

        JP      o2477           ; forward to LINE-DRAW

; ---

;   An arc can be drawn.

;; DR-SIN-NZ
o23A3:  DEFB    $C0             ;;st-mem-0      x, y, sin(A/2).   store mem-0
        DEFB    $02             ;;delete        x, y.

;   The next step calculates (roughly) the diameter of the circle of which the
;   arc will form part.  This value does not have to be too accurate as it is
;   only used to evaluate the number of straight lines and then discarded.
;   After all for a circle, the radius is used. Consequently, a circle of
;   radius 50 will have 24 straight lines but an arc of radius 50 will have 20
;   straight lines - when drawn in any direction.
;   So that simple arithmetic can be used, the length of the chord can be
;   calculated as X+Y rather than by Pythagoras Theorem and the sine of the
;   nearest angle within reach is used.

        DEFB    $C1             ;;st-mem-1      x, y.             store mem-1
        DEFB    $02             ;;delete        x.

        DEFB    $31             ;;duplicate     x, x.
        DEFB    $2A             ;;abs           x, x (+ve).
        DEFB    $E1             ;;get-mem-1     x, X, y.
        DEFB    $01             ;;exchange      x, y, X.
        DEFB    $E1             ;;get-mem-1     x, y, X, y.
        DEFB    $2A             ;;abs           x, y, X, Y (+ve).
        DEFB    $0F             ;;addition      x, y, X+Y.
        DEFB    $E0             ;;get-mem-0     x, y, X+Y, sin(A/2).
        DEFB    $05             ;;division      x, y, X+Y/sin(A/2).
        DEFB    $2A             ;;abs           x, y, X+Y/sin(A/2) = D.

;    Bring back sin(A/2) from mem-0 which will shortly get trashed.
;    Then bring D to the top of the stack again.

        DEFB    $E0             ;;get-mem-0     x, y, D, sin(A/2).
        DEFB    $01             ;;exchange      x, y, sin(A/2), D.

;   Note. that since the value at the top of the stack has arisen as a result
;   of division then it can no longer be in integer form and the next re-stack
;   is unnecessary. Only the Sinclair ZX80 had integer division.

        DEFB    $3D             ;;re-stack      (unnecessary)

        DEFB    $38             ;;end-calc      x, y, sin(A/2), D.

;   The next test avoids drawing 4 straight lines when the start and end pixels
;   are adjacent (or the same) but is probably best dispensed with.

        LD      A,(HL)          ; fetch exponent byte of D.
        CP      $81             ; compare to 1
        JR      NC,o23C1        ; forward, if > 1,  to DR-PRMS

;   else delete the top two stack values and draw a simple straight line.

        RST     28H             ;; FP-CALC
        DEFB    $02             ;;delete
        DEFB    $02             ;;delete
        DEFB    $38             ;;end-calc      x, y.

        JP      o2477           ; to LINE-DRAW

; ---

;   The ARC will consist of multiple straight lines so call the CIRCLE-DRAW
;   PARAMETERS ROUTINE to pre-calculate sine values from the angle (in mem-5)
;   and determine also the number of straight lines from that value and the
;   'diameter' which is at the top of the calculator stack.

;; DR-PRMS
o23C1:  CALL    o247D           ; routine CD-PRMS1

                                ; mem-0 ; (A)/No. of lines (=a) (step angle)
                                ; mem-1 ; sin(a/2)
                                ; mem-2 ; -
                                ; mem-3 ; cos(a)                        const
                                ; mem-4 ; sin(a)                        const
                                ; mem-5 ; Angle of rotation (A)         in
                                ; B     ; Count of straight lines - max 252.

        PUSH    BC              ; Save the line count on the machine stack.

;   Remove the now redundant diameter value D.

        RST     28H             ;; FP-CALC      x, y, sin(A/2), D.
        DEFB    $02             ;;delete        x, y, sin(A/2).

;   Dividing the sine of the step angle by the sine of the total angle gives
;   the length of the initial chord on a unary circle. This factor f is used
;   to scale the coordinates of the first line which still points in the
;   direction of the end point and may be larger.

        DEFB    $E1             ;;get-mem-1     x, y, sin(A/2), sin(a/2)
        DEFB    $01             ;;exchange      x, y, sin(a/2), sin(A/2)
        DEFB    $05             ;;division      x, y, sin(a/2)/sin(A/2)
        DEFB    $C1             ;;st-mem-1      x, y. f.
        DEFB    $02             ;;delete        x, y.

;   With the factor stored, scale the x coordinate first.

        DEFB    $01             ;;exchange      y, x.
        DEFB    $31             ;;duplicate     y, x, x.
        DEFB    $E1             ;;get-mem-1     y, x, x, f.
        DEFB    $04             ;;multiply      y, x, x*f    (=xx)
        DEFB    $C2             ;;st-mem-2      y, x, xx.
        DEFB    $02             ;;delete        y. x.

;   Now scale the y coordinate.

        DEFB    $01             ;;exchange      x, y.
        DEFB    $31             ;;duplicate     x, y, y.
        DEFB    $E1             ;;get-mem-1     x, y, y, f
        DEFB    $04             ;;multiply      x, y, y*f    (=yy)

;   Note. 'sin' and 'cos' trash locations mem-0 to mem-2 so fetch mem-2 to the
;   calculator stack for safe keeping.

        DEFB    $E2             ;;get-mem-2     x, y, yy, xx.

;   Once we get the coordinates of the first straight line then the 'ROTATION
;   FORMULA' used in the arc loop will take care of all other points, but we
;   now use a variation of that formula to rotate the first arc through (A-a)/2
;   radians.
;
;       xRotated = y * sin(angle) + x * cos(angle)
;       yRotated = y * cos(angle) - x * sin(angle)
;

        DEFB    $E5             ;;get-mem-5     x, y, yy, xx, A.
        DEFB    $E0             ;;get-mem-0     x, y, yy, xx, A, a.
        DEFB    $03             ;;subtract      x, y, yy, xx, A-a.
        DEFB    $A2             ;;stk-half      x, y, yy, xx, A-a, 1/2.
        DEFB    $04             ;;multiply      x, y, yy, xx, (A-a)/2. (=angle)
        DEFB    $31             ;;duplicate     x, y, yy, xx, angle, angle.
        DEFB    $1F             ;;sin           x, y, yy, xx, angle, sin(angle)
        DEFB    $C5             ;;st-mem-5      x, y, yy, xx, angle, sin(angle)
        DEFB    $02             ;;delete        x, y, yy, xx, angle

        DEFB    $20             ;;cos           x, y, yy, xx, cos(angle).

;   Note. mem-0, mem-1 and mem-2 can be used again now...

        DEFB    $C0             ;;st-mem-0      x, y, yy, xx, cos(angle).
        DEFB    $02             ;;delete        x, y, yy, xx.

        DEFB    $C2             ;;st-mem-2      x, y, yy, xx.
        DEFB    $02             ;;delete        x, y, yy.

        DEFB    $C1             ;;st-mem-1      x, y, yy.
        DEFB    $E5             ;;get-mem-5     x, y, yy, sin(angle)
        DEFB    $04             ;;multiply      x, y, yy*sin(angle).
        DEFB    $E0             ;;get-mem-0     x, y, yy*sin(angle), cos(angle)
        DEFB    $E2             ;;get-mem-2     x, y, yy*sin(angle), cos(angle), xx.
        DEFB    $04             ;;multiply      x, y, yy*sin(angle), xx*cos(angle).
        DEFB    $0F             ;;addition      x, y, xRotated.
        DEFB    $E1             ;;get-mem-1     x, y, xRotated, yy.
        DEFB    $01             ;;exchange      x, y, yy, xRotated.
        DEFB    $C1             ;;st-mem-1      x, y, yy, xRotated.
        DEFB    $02             ;;delete        x, y, yy.

        DEFB    $E0             ;;get-mem-0     x, y, yy, cos(angle).
        DEFB    $04             ;;multiply      x, y, yy*cos(angle).
        DEFB    $E2             ;;get-mem-2     x, y, yy*cos(angle), xx.
        DEFB    $E5             ;;get-mem-5     x, y, yy*cos(angle), xx, sin(angle).
        DEFB    $04             ;;multiply      x, y, yy*cos(angle), xx*sin(angle).
        DEFB    $03             ;;subtract      x, y, yRotated.
        DEFB    $C2             ;;st-mem-2      x, y, yRotated.

;   Now the initial x and y coordinates are made positive and summed to see
;   if they measure up to anything significant.

        DEFB    $2A             ;;abs           x, y, yRotated'.
        DEFB    $E1             ;;get-mem-1     x, y, yRotated', xRotated.
        DEFB    $2A             ;;abs           x, y, yRotated', xRotated'.
        DEFB    $0F             ;;addition      x, y, yRotated+xRotated.
        DEFB    $02             ;;delete        x, y.

        DEFB    $38             ;;end-calc      x, y.

;   Although the test value has been deleted it is still above the calculator
;   stack in memory and conveniently DE which points to the first free byte
;   addresses the exponent of the test value.

        LD      A,(DE)          ; Fetch exponent of the length indicator.
        CP      $81             ; Compare to that for 1

        POP     BC              ; Balance the machine stack

        JP      C,o2477         ; forward, if the coordinates of first line
                                ; don't add up to more than 1, to LINE-DRAW

;   Continue when the arc will have a discernable shape.

        PUSH    BC              ; Restore line counter to the machine stack.

;   The parameters of the DRAW command were relative and they are now converted
;   to absolute coordinates by adding to the coordinates of the last point
;   plotted. The first two values on the stack are the terminal tx and ty
;   coordinates.  The x-coordinate is converted first but first the last point
;   plotted is saved as it will initialize the moving ax, value.

        RST     28H             ;; FP-CALC      x, y.
        DEFB    $01             ;;exchange      y, x.
        DEFB    $38             ;;end-calc      y, x.

        LD      A,($5C7D)       ; Fetch System Variable COORDS-x
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      y, x, last-x.

;   Store the last point plotted to initialize the moving ax value.

        DEFB    $C0             ;;st-mem-0      y, x, last-x.
        DEFB    $0F             ;;addition      y, absolute x.
        DEFB    $01             ;;exchange      tx, y.
        DEFB    $38             ;;end-calc      tx, y.

        LD      A,($5C7E)       ; Fetch System Variable COORDS-y
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      tx, y, last-y.

;   Store the last point plotted to initialize the moving ay value.

        DEFB    $C5             ;;st-mem-5      tx, y, last-y.
        DEFB    $0F             ;;addition      tx, ty.

;   Fetch the moving ax and ay to the calculator stack.

        DEFB    $E0             ;;get-mem-0     tx, ty, ax.
        DEFB    $E5             ;;get-mem-5     tx, ty, ax, ay.
        DEFB    $38             ;;end-calc      tx, ty, ax, ay.

        POP     BC              ; Restore the straight line count.

; -----------------------------------
; THE 'CIRCLE/DRAW CONVERGENCE POINT'
; -----------------------------------
;   The CIRCLE and ARC-DRAW commands converge here.
;
;   Note. for both the CIRCLE and ARC commands the minimum initial line count
;   is 4 (as set up by the CD_PARAMS routine) and so the zero flag will never
;   be set and the loop is always entered.  The first test is superfluous and
;   the jump will always be made to ARC-START.

;; DRW-STEPS
o2420:  DEC     B               ; decrement the arc count (4,8,12,16...).

        JR      Z,o245F         ; forward, if zero (not possible), to ARC-END

        JR      o2439           ; forward to ARC-START

; --------------
; THE 'ARC LOOP'
; --------------
;
;   The arc drawing loop will draw up to 31 straight lines for a circle and up
;   251 straight lines for an arc between two points. In both cases the final
;   closing straight line is drawn at ARC_END, but it otherwise loops back to
;   here to calculate the next coordinate using the ROTATION FORMULA where (a)
;   is the previously calculated, constant CENTRAL ANGLE of the arcs.
;
;       Xrotated = x * cos(a) - y * sin(a)
;       Yrotated = x * sin(a) + y * cos(a)
;
;   The values cos(a) and sin(a) are pre-calculated and held in mem-3 and mem-4
;   for the duration of the routine.
;   Memory location mem-1 holds the last relative x value (rx) and mem-2 holds
;   the last relative y value (ry) used by DRAW.
;
;   Note. that this is a very clever twist on what is after all a very clever,
;   well-used formula.  Normally the rotation formula is used with the x and y
;   coordinates from the centre of the circle (or arc) and a supplied angle to
;   produce two new x and y coordinates in an anticlockwise direction on the
;   circumference of the circle.
;   What is being used here, instead, is the relative X and Y parameters from
;   the last point plotted that are required to get to the current point and
;   the formula returns the next relative coordinates to use.

;; ARC-LOOP
o2425:  RST     28H             ;; FP-CALC
        DEFB    $E1             ;;get-mem-1     rx.
        DEFB    $31             ;;duplicate     rx, rx.
        DEFB    $E3             ;;get-mem-3     cos(a)
        DEFB    $04             ;;multiply      rx, rx*cos(a).
        DEFB    $E2             ;;get-mem-2     rx, rx*cos(a), ry.
        DEFB    $E4             ;;get-mem-4     rx, rx*cos(a), ry, sin(a).
        DEFB    $04             ;;multiply      rx, rx*cos(a), ry*sin(a).
        DEFB    $03             ;;subtract      rx, rx*cos(a) - ry*sin(a)
        DEFB    $C1             ;;st-mem-1      rx, new relative x rotated.
        DEFB    $02             ;;delete        rx.

        DEFB    $E4             ;;get-mem-4     rx, sin(a).
        DEFB    $04             ;;multiply      rx*sin(a)
        DEFB    $E2             ;;get-mem-2     rx*sin(a), ry.
        DEFB    $E3             ;;get-mem-3     rx*sin(a), ry, cos(a).
        DEFB    $04             ;;multiply      rx*sin(a), ry*cos(a).
        DEFB    $0F             ;;addition      rx*sin(a) + ry*cos(a).
        DEFB    $C2             ;;st-mem-2      new relative y rotated.
        DEFB    $02             ;;delete        .
        DEFB    $38             ;;end-calc      .

;   Note. the calculator stack actually holds   tx, ty, ax, ay
;   and the last absolute values of x and y
;   are now brought into play.
;
;   Magically, the two new rotated coordinates rx and ry are all that we would
;   require to draw a circle or arc - on paper!
;   The Spectrum DRAW routine draws to the rounded x and y coordinate and so
;   repetitions of values like 3.49 would mean that the fractional parts
;   would be lost until eventually the draw coordinates might differ from the
;   floating point values used above by several pixels.
;   For this reason the accurate offsets calculated above are added to the
;   accurate, absolute coordinates maintained in ax and ay and these new
;   coordinates have the integer coordinates of the last plot position
;   ( from System Variable COORDS ) subtracted from them to give the relative
;   coordinates required by the DRAW routine.

;   The mid entry point.

;; ARC-START
o2439:  PUSH    BC              ; Preserve the arc counter on the machine stack.

;   Store the absolute ay in temporary variable mem-0 for the moment.

        RST     28H             ;; FP-CALC      ax, ay.
        DEFB    $C0             ;;st-mem-0      ax, ay.
        DEFB    $02             ;;delete        ax.

;   Now add the fractional relative x coordinate to the fractional absolute
;   x coordinate to obtain a new fractional x-coordinate.

        DEFB    $E1             ;;get-mem-1     ax, xr.
        DEFB    $0F             ;;addition      ax+xr (= new ax).
        DEFB    $31             ;;duplicate     ax, ax.
        DEFB    $38             ;;end-calc      ax, ax.

        LD      A,($5C7D)       ; COORDS-x      last x    (integer ix 0-255)
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      ax, ax, ix.
        DEFB    $03             ;;subtract      ax, ax-ix  = relative DRAW Dx.

;   Having calculated the x value for DRAW do the same for the y value.

        DEFB    $E0             ;;get-mem-0     ax, Dx, ay.
        DEFB    $E2             ;;get-mem-2     ax, Dx, ay, ry.
        DEFB    $0F             ;;addition      ax, Dx, ay+ry (= new ay).
        DEFB    $C0             ;;st-mem-0      ax, Dx, ay.
        DEFB    $01             ;;exchange      ax, ay, Dx,
        DEFB    $E0             ;;get-mem-0     ax, ay, Dx, ay.
        DEFB    $38             ;;end-calc      ax, ay, Dx, ay.

        LD      A,($5C7E)       ; COORDS-y      last y (integer iy 0-175)
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      ax, ay, Dx, ay, iy.
        DEFB    $03             ;;subtract      ax, ay, Dx, ay-iy ( = Dy).
        DEFB    $38             ;;end-calc      ax, ay, Dx, Dy.

        CALL    o24B7           ; Routine DRAW-LINE draws (Dx,Dy) relative to
                                ; the last pixel plotted leaving absolute x
                                ; and y on the calculator stack.
                                ;               ax, ay.

        POP     BC              ; Restore the arc counter from the machine stack.

        DJNZ    o2425           ; Decrement and loop while > 0 to ARC-LOOP

; -------------
; THE 'ARC END'
; -------------

;   To recap the full calculator stack is       tx, ty, ax, ay.

;   Just as one would do if drawing the curve on paper, the final line would
;   be drawn by joining the last point plotted to the initial start point
;   in the case of a CIRCLE or to the calculated end point in the case of
;   an ARC.
;   The moving absolute values of x and y are no longer required and they
;   can be deleted to expose the closing coordinates.

;; ARC-END
o245F:  RST     28H             ;; FP-CALC      tx, ty, ax, ay.
        DEFB    $02             ;;delete        tx, ty, ax.
        DEFB    $02             ;;delete        tx, ty.
        DEFB    $01             ;;exchange      ty, tx.
        DEFB    $38             ;;end-calc      ty, tx.

;   First calculate the relative x coordinate to the end-point.

        LD      A,($5C7D)       ; COORDS-x
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      ty, tx, coords_x.
        DEFB    $03             ;;subtract      ty, rx.

;   Next calculate the relative y coordinate to the end-point.

        DEFB    $01             ;;exchange      rx, ty.
        DEFB    $38             ;;end-calc      rx, ty.

        LD      A,($5C7E)       ; COORDS-y
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC      rx, ty, coords_y
        DEFB    $03             ;;subtract      rx, ry.
        DEFB    $38             ;;end-calc      rx, ry.

;   Finally draw the last straight line.

;; LINE-DRAW
o2477:  CALL    o24B7           ; routine DRAW-LINE draws to the relative
                                ; coordinates (rx, ry).

        JP      o0D4D           ; jump back and exit via TEMPS          >>>


; --------------------------------------------
; THE 'INITIAL CIRCLE/DRAW PARAMETERS' ROUTINE
; --------------------------------------------
;   Begin by calculating the number of chords which will be returned in B.
;   A rule of thumb is employed that uses a value z which for a circle is the
;   radius and for an arc is the diameter with, as it happens, a pinch more if
;   the arc is on a slope.
;
;   NUMBER OF STRAIGHT LINES = ANGLE OF ROTATION * SQUARE ROOT ( Z ) / 2

;; CD-PRMS1
o247D:  RST     28H             ;; FP-CALC      z.
        DEFB    $31             ;;duplicate     z, z.
        DEFB    $28             ;;sqr           z, sqr(z).
        DEFB    $34             ;;stk-data      z, sqr(z), 2.
        DEFB    $32             ;;Exponent: $82, Bytes: 1
        DEFB    $00             ;;(+00,+00,+00)
        DEFB    $01             ;;exchange      z, 2, sqr(z).
        DEFB    $05             ;;division      z, 2/sqr(z).
        DEFB    $E5             ;;get-mem-5     z, 2/sqr(z), ANGLE.
        DEFB    $01             ;;exchange      z, ANGLE, 2/sqr (z)
        DEFB    $05             ;;division      z, ANGLE*sqr(z)/2 (= No. of lines)
        DEFB    $2A             ;;abs           (for arc only)
        DEFB    $38             ;;end-calc      z, number of lines.

;    As an example for a circle of radius 87 the number of lines will be 29.

        CALL    o2DD5           ; routine FP-TO-A

;    The value is compressed into A register, no carry with valid circle.

        JR      C,o2495         ; forward, if over 256, to USE-252

;    now make a multiple of 4 e.g. 29 becomes 28

        AND     $FC             ; AND 252

;    Adding 4 could set carry for arc, for the circle example, 28 becomes 32.

        ADD     A,$04           ; adding 4 could set carry if result is 256.

        JR      NC,o2497        ; forward if less than 256 to DRAW-SAVE

;    For an arc, a limit of 252 is imposed.

;; USE-252
o2495:  LD      A,$FC           ; Use a value of 252 (for arc).


;   For both arcs and circles, constants derived from the central angle are
;   stored in the 'mem' locations.  Some are not relevant for the circle.

;; DRAW-SAVE
o2497:  PUSH    AF              ; Save the line count (A) on the machine stack.

        CALL    o2D28           ; Routine STACK-A stacks the modified count(A).

        RST     28H             ;; FP-CALC      z, A.
        DEFB    $E5             ;;get-mem-5     z, A, ANGLE.
        DEFB    $01             ;;exchange      z, ANGLE, A.
        DEFB    $05             ;;division      z, ANGLE/A. (Angle/count = a)
        DEFB    $31             ;;duplicate     z, a, a.

;  Note. that cos (a) could be formed here directly using 'cos' and stored in
;  mem-3 but that would spoil a good story and be slightly slower, as also
;  would using square roots to form cos (a) from sin (a).

        DEFB    $1F             ;;sin           z, a, sin(a)
        DEFB    $C4             ;;st-mem-4      z, a, sin(a)
        DEFB    $02             ;;delete        z, a.
        DEFB    $31             ;;duplicate     z, a, a.
        DEFB    $A2             ;;stk-half      z, a, a, 1/2.
        DEFB    $04             ;;multiply      z, a, a/2.
        DEFB    $1F             ;;sin           z, a, sin(a/2).

;   Note. after second sin, mem-0 and mem-1 become free.

        DEFB    $C1             ;;st-mem-1      z, a, sin(a/2).
        DEFB    $01             ;;exchange      z, sin(a/2), a.
        DEFB    $C0             ;;st-mem-0      z, sin(a/2), a.  (for arc only)

;   Now form cos(a) from sin(a/2) using the 'DOUBLE ANGLE FORMULA'.

        DEFB    $02             ;;delete        z, sin(a/2).
        DEFB    $31             ;;duplicate     z, sin(a/2), sin(a/2).
        DEFB    $04             ;;multiply      z, sin(a/2)*sin(a/2).
        DEFB    $31             ;;duplicate     z, sin(a/2)*sin(a/2),
                                ;;                           sin(a/2)*sin(a/2).
        DEFB    $0F             ;;addition      z, 2*sin(a/2)*sin(a/2).
        DEFB    $A1             ;;stk-one       z, 2*sin(a/2)*sin(a/2), 1.
        DEFB    $03             ;;subtract      z, 2*sin(a/2)*sin(a/2)-1.

        DEFB    $1B             ;;negate        z, 1-2*sin(a/2)*sin(a/2).

        DEFB    $C3             ;;st-mem-3      z, cos(a).
        DEFB    $02             ;;delete        z.
        DEFB    $38             ;;end-calc      z.

;   The radius/diameter is left on the calculator stack.

        POP     BC              ; Restore the line count to the B register.

        RET                     ; Return.

; --------------------------
; THE 'DOUBLE ANGLE FORMULA'
; --------------------------
;   This formula forms cos(a) from sin(a/2) using simple arithmetic.
;
;   THE GEOMETRIC PROOF OF FORMULA   cos (a) = 1 - 2 * sin(a/2) * sin(a/2)
;
;
;                                            A
;
;                                         . /|\
;                                     .    / | \
;                                  .      /  |  \
;                               .        /   |a/2\
;                            .          /    |    \
;                         .          1 /     |     \
;                      .              /      |      \
;                   .                /       |       \
;                .                  /        |        \
;             .  a/2             D / a      E|-+       \
;          B ---------------------/----------+-+--------\ C
;            <-         1       -><-       1           ->
;
;   cos a = 1 - 2 * sin(a/2) * sin(a/2)
;
;   The figure shows a right triangle that inscribes a circle of radius 1 with
;   centre, or origin, D.  Line BC is the diameter of length 2 and A is a point
;   on the circle. The periphery angle BAC is therefore a right angle by the
;   Rule of Thales.
;   Line AC is a chord touching two points on the circle and the angle at the
;   centre is (a).
;   Since the vertex of the largest triangle B touches the circle, the
;   inscribed angle (a/2) is half the central angle (a).
;   The cosine of (a) is the length DE as the hypotenuse is of length 1.
;   This can also be expressed as 1-length CE.  Examining the triangle at the
;   right, the top angle is also (a/2) as angle BAE and EBA add to give a right
;   angle as do BAE and EAC.
;   So cos (a) = 1 - AC * sin(a/2)
;   Looking at the largest triangle, side AC can be expressed as
;   AC = 2 * sin(a/2)   and so combining these we get
;   cos (a) = 1 - 2 * sin(a/2) * sin(a/2).
;
;   "I will be sufficiently rewarded if when telling it to others, you will
;    not claim the discovery as your own, but will say it is mine."
;   - Thales, 640 - 546 B.C.
;
; --------------------------
; THE 'LINE DRAWING' ROUTINE
; --------------------------
;
;

;; DRAW-LINE
o24B7:  CALL    o2307           ; routine STK-TO-BC
        LD      A,C             ;
        CP      B               ;
        JR      NC,o24C4        ; to DL-X-GE-Y

        LD      L,C             ;
        PUSH    DE              ;
        XOR     A               ;
        LD      E,A             ;
        JR      o24CB           ; to DL-LARGER

; ---

;; DL-X-GE-Y
o24C4:  OR      C               ;
        RET     Z               ;

        LD      L,B             ;
        LD      B,C             ;
        PUSH    DE              ;
        LD      D,$00           ;

;; DL-LARGER
o24CB:  LD      H,B             ;
        LD      A,B             ;
        RRA                     ;

;; D-L-LOOP
o24CE:  ADD     A,L             ;
        JR      C,o24D4         ; to D-L-DIAG

        CP      H               ;
        JR      C,o24DB         ; to D-L-HR-VT

;; D-L-DIAG
o24D4:  SUB     H               ;
        LD      C,A             ;
        EXX                     ;
        POP     BC              ;
        PUSH    BC              ;
        JR      o24DF           ; to D-L-STEP

; ---

;; D-L-HR-VT
o24DB:  LD      C,A             ;
        PUSH    DE              ;
        EXX                     ;
        POP     BC              ;

;; D-L-STEP
o24DF:  LD      HL,($5C7D)      ; COORDS
        LD      A,B             ;
        ADD     A,H             ;
        LD      B,A             ;
        LD      A,C             ;
        INC     A               ;
        ADD     A,L             ;
        JR      C,o24F7         ; to D-L-RANGE

        JR      Z,o24F9         ; to REPORT-Bc

;; D-L-PLOT
o24EC:  DEC     A               ;
        LD      C,A             ;
        CALL    o22E5           ; routine PLOT-SUB
        EXX                     ;
        LD      A,C             ;
        DJNZ    o24CE           ; to D-L-LOOP

        POP     DE              ;
        RET                     ;

; ---

;; D-L-RANGE
o24F7:  JR      Z,o24EC         ; to D-L-PLOT


;; REPORT-Bc
o24F9:  RST     08H             ; ERROR-1
        DEFB    $0A             ; Error Report: Integer out of range



;***********************************
;** Part 8. EXPRESSION EVALUATION **
;***********************************
;
; It is a this stage of the ROM that the Spectrum ceases altogether to be
; just a colourful novelty. One remarkable feature is that in all previous
; commands when the Spectrum is expecting a number or a string then an
; expression of the same type can be substituted ad infinitum.
; This is the routine that evaluates that expression.
; This is what causes 2 + 2 to give the answer 4.
; That is quite easy to understand. However you don't have to make it much
; more complex to start a remarkable juggling act.
; e.g. PRINT 2 * (VAL "2+2" + TAN 3)
; In fact, provided there is enough free RAM, the Spectrum can evaluate
; an expression of unlimited complexity.
; Apart from a couple of minor glitches, which you can now correct, the
; system is remarkably robust.


; ---------------------------------
; Scan expression or sub-expression
; ---------------------------------
;
;

;; SCANNING
o24FB:  RST     18H             ; GET-CHAR
        LD      B,$00           ; priority marker zero is pushed on stack
                                ; to signify end of expression when it is
                                ; popped off again.
        PUSH    BC              ; put in on stack.
                                ; and proceed to consider the first character
                                ; of the expression.

;; S-LOOP-1
o24FF:  LD      C,A             ; store the character while a look up is done.
        LD      HL,o2596        ; Address: scan-func
        CALL    o16DC           ; routine INDEXER is called to see if it is
                                ; part of a limited range '+', '(', 'ATTR' etc.

        LD      A,C             ; fetch the character back
        JP      NC,o2684        ; jump forward to S-ALPHNUM if not in primary
                                ; operators and functions to consider in the
                                ; first instance a digit or a variable and
                                ; then anything else.                >>>

        LD      B,$00           ; but here if it was found in table so
        LD      C,(HL)          ; fetch offset from table and make B zero.
        ADD     HL,BC           ; add the offset to position found
o250E:  JP      (HL)            ; and jump to the routine e.g. S-BIN
                                ; making an indirect exit from there.

; -------------------------------------------------------------------------
; The four service subroutines for routines in the scanning function table
; -------------------------------------------------------------------------

; PRINT """Hooray!"" he cried."

;; S-QUOTE-S
o250F:  CALL    o0074           ; routine CH-ADD+1 points to next character
                                ; and fetches that character.
        INC     BC              ; increase length counter.
        CP      $0D             ; is it carriage return ?
                                ; inside a quote.
        JP      Z,o1C8A         ; jump back to REPORT-C if so.
                                ; 'Nonsense in BASIC'.

        CP      $22             ; is it a quote '"' ?
        JR      NZ,o250F        ; back to S-QUOTE-S if not for more.

        CALL    o0074           ; routine CH-ADD+1
        CP      $22             ; compare with possible adjacent quote
        RET                     ; return. with zero set if two together.

; ---

; This subroutine is used to get two coordinate expressions for the three
; functions SCREEN$, ATTR and POINT that have two fixed parameters and
; therefore require surrounding braces.

;; S-2-COORD
o2522:  RST     20H             ; NEXT-CHAR
        CP      $28             ; is it the opening '(' ?
        JR      NZ,o252D        ; forward to S-RPORT-C if not
                                ; 'Nonsense in BASIC'.

        CALL    o1C79           ; routine NEXT-2NUM gets two comma-separated
                                ; numeric expressions. Note. this could cause
                                ; many more recursive calls to SCANNING but
                                ; the parent function will be evaluated fully
                                ; before rejoining the main juggling act.

        RST     18H             ; GET-CHAR
        CP      $29             ; is it the closing ')' ?

;; S-RPORT-C
o252D:  JP      NZ,o1C8A        ; jump back to REPORT-C if not.
                                ; 'Nonsense in BASIC'.

; ------------
; Check syntax
; ------------
; This routine is called on a number of occasions to check if syntax is being
; checked or if the program is being run. To test the flag inline would use
; four bytes of code, but a call instruction only uses 3 bytes of code.

;; SYNTAX-Z
o2530:  BIT     7,(IY+$01)      ; test FLAGS  - checking syntax only ?
        RET                     ; return.

; ----------------
; Scanning SCREEN$
; ----------------
; This function returns the code of a bit-mapped character at screen
; position at line C, column B. It is unable to detect the mosaic characters
; which are not bit-mapped but detects the ASCII 32 - 127 range.
; The bit-mapped UDGs are ignored which is curious as it requires only a
; few extra bytes of code. As usual, anything to do with CHARS is weird.
; If no match is found a null string is returned.
; No actual check on ranges is performed - that's up to the BASIC programmer.
; No real harm can come from SCREEN$(255,255) although the BASIC manual
; says that invalid values will be trapped.
; Interestingly, in the Pitman pocket guide, 1984, Vickers says that the
; range checking will be performed.

;; S-SCRN$-S
o2535:  CALL    o2307           ; routine STK-TO-BC.
        LD      HL,($5C36)      ; fetch address of CHARS.
        LD      DE,$0100        ; fetch offset to chr$ 32
        ADD     HL,DE           ; and find start of bitmaps.
                                ; Note. not inc h. ??
        LD      A,C             ; transfer line to A.
        RRCA                    ; multiply
        RRCA                    ; by
        RRCA                    ; thirty-two.
        AND     $E0             ; and with 11100000
        XOR     B               ; combine with column $00 - $1F
        LD      E,A             ; to give the low byte of top line
        LD      A,C             ; column to A range 00000000 to 00011111
        AND     $18             ; and with 00011000
        XOR     $40             ; xor with 01000000 (high byte screen start)
        LD      D,A             ; register DE now holds start address of cell.
        LD      B,$60           ; there are 96 characters in ASCII set.

;; S-SCRN-LP
o254F:  PUSH    BC              ; save count
        PUSH    DE              ; save screen start address
        PUSH    HL              ; save bitmap start
        LD      A,(DE)          ; first byte of screen to A
        XOR     (HL)            ; xor with corresponding character byte
        JR      Z,o255A         ; forward to S-SC-MTCH if they match
                                ; if inverse result would be $FF
                                ; if any other then mismatch

        INC     A               ; set to $00 if inverse
        JR      NZ,o2573        ; forward to S-SCR-NXT if a mismatch

        DEC     A               ; restore $FF

; a match has been found so seven more to test.

;; S-SC-MTCH
o255A:  LD      C,A             ; load C with inverse mask $00 or $FF
        LD      B,$07           ; count seven more bytes

;; S-SC-ROWS
o255D:  INC     D               ; increment screen address.
        INC     HL              ; increment bitmap address.
        LD      A,(DE)          ; byte to A
        XOR     (HL)            ; will give $00 or $FF (inverse)
        XOR     C               ; xor with inverse mask
        JR      NZ,o2573        ; forward to S-SCR-NXT if no match.

        DJNZ    o255D           ; back to S-SC-ROWS until all eight matched.

; continue if a match of all eight bytes was found

        POP     BC              ; discard the
        POP     BC              ; saved
        POP     BC              ; pointers
        LD      A,$80           ; the endpoint of character set
        SUB     B               ; subtract the counter
                                ; to give the code 32-127
        LD      BC,$0001        ; make one space in workspace.

        RST     30H             ; BC-SPACES creates the space sliding
                                ; the calculator stack upwards.
        LD      (DE),A          ; start is addressed by DE, so insert code
        JR      o257D           ; forward to S-SCR-STO

; ---

; the jump was here if no match and more bitmaps to test.

;; S-SCR-NXT
o2573:  POP     HL              ; restore the last bitmap start
        LD      DE,$0008        ; and prepare to add 8.
        ADD     HL,DE           ; now addresses next character bitmap.
        POP     DE              ; restore screen address
        POP     BC              ; and character counter in B
        DJNZ    o254F           ; back to S-SCRN-LP if more characters.

        LD      C,B             ; B is now zero, so BC now zero.

;; S-SCR-STO
o257D:  JP      o2AB2           ; to STK-STO-$ to store the string in
                                ; workspace or a string with zero length.
                                ; (value of DE doesn't matter in last case)

; Note. this exit seems correct but the general-purpose routine S-STRING
; that calls this one will also stack any of its string results so this
; leads to a double storing of the result in this case.
; The instruction at o257D should just be a RET.
; credit Stephen Kelly and others, 1982.

; -------------
; Scanning ATTR
; -------------
; This function subroutine returns the attributes of a screen location -
; a numeric result.
; Again it's up to the BASIC programmer to supply valid values of line/column.

;; S-ATTR-S
o2580:  CALL    o2307           ; routine STK-TO-BC fetches line to C,
                                ; and column to B.
        LD      A,C             ; line to A $00 - $17   (max 00010111)
        RRCA                    ; rotate
        RRCA                    ; bits
        RRCA                    ; left.
        LD      C,A             ; store in C as an intermediate value.

        AND     $E0             ; pick up bits 11100000 ( was 00011100 )
        XOR     B               ; combine with column $00 - $1F
        LD      L,A             ; low byte now correct.

        LD      A,C             ; bring back intermediate result from C
        AND     $03             ; mask to give correct third of
                                ; screen $00 - $02
        XOR     $58             ; combine with base address.
        LD      H,A             ; high byte correct.
        LD      A,(HL)          ; pick up the colour attribute.
        JP      o2D28           ; forward to STACK-A to store result
                                ; and make an indirect exit.

; -----------------------
; Scanning function table
; -----------------------
; This table is used by INDEXER routine to find the offsets to
; four operators and eight functions. e.g. $A8 is the token 'FN'.
; This table is used in the first instance for the first character of an
; expression or by a recursive call to SCANNING for the first character of
; any sub-expression. It eliminates functions that have no argument or
; functions that can have more than one argument and therefore require
; braces. By eliminating and dealing with these now it can later take a
; simplistic approach to all other functions and assume that they have
; one argument.
; Similarly by eliminating BIN and '.' now it is later able to assume that
; all numbers begin with a digit and that the presence of a number or
; variable can be detected by a call to ALPHANUM.
; By default all expressions are positive and the spurious '+' is eliminated
; now as in print +2. This should not be confused with the operator '+'.
; Note. this does allow a degree of nonsense to be accepted as in
; PRINT +"3 is the greatest.".
; An acquired programming skill is the ability to include brackets where
; they are not necessary.
; A bracket at the start of a sub-expression may be spurious or necessary
; to denote that the contained expression is to be evaluated as an entity.
; In either case this is dealt with by recursive calls to SCANNING.
; An expression that begins with a quote requires special treatment.

;; scan-func
o2596:  DEFB    $22, o25B3-$-1  ; $1C offset to S-QUOTE
        DEFB    '(', o25E8-$-1  ; $4F offset to S-BRACKET
        DEFB    '.', o268D-$-1  ; $F2 offset to S-DECIMAL
        DEFB    '+', o25AF-$-1  ; $12 offset to S-U-PLUS

        DEFB    $A8, o25F5-$-1  ; $56 offset to S-FN
        DEFB    $A5, o25F8-$-1  ; $57 offset to S-RND
        DEFB    $A7, o2627-$-1  ; $84 offset to S-PI
        DEFB    $A6, o2634-$-1  ; $8F offset to S-INKEY$
        DEFB    $C4, o268D-$-1  ; $E6 offset to S-BIN
        DEFB    $AA, o2668-$-1  ; $BF offset to S-SCREEN$
        DEFB    $AB, o2672-$-1  ; $C7 offset to S-ATTR
        DEFB    $A9, o267B-$-1  ; $CE offset to S-POINT

        DEFB    $00             ; zero end marker

; --------------------------
; Scanning function routines
; --------------------------
; These are the 11 subroutines accessed by the above table.
; S-BIN and S-DECIMAL are the same
; The 1-byte offset limits their location to within 255 bytes of their
; entry in the table.

; ->
;; S-U-PLUS
o25AF:  RST     20H             ; NEXT-CHAR just ignore
        JP      o24FF           ; to S-LOOP-1

; ---

; ->
;; S-QUOTE
o25B3:  RST     18H             ; GET-CHAR
        INC     HL              ; address next character (first in quotes)
        PUSH    HL              ; save start of quoted text.
        LD      BC,$0000        ; initialize length of string to zero.
        CALL    o250F           ; routine S-QUOTE-S
        JR      NZ,o25D9        ; forward to S-Q-PRMS if

;; S-Q-AGAIN
o25BE:  CALL    o250F           ; routine S-QUOTE-S copies string until a
                                ; quote is encountered
        JR      Z,o25BE         ; back to S-Q-AGAIN if two quotes WERE
                                ; together.

; but if just an isolated quote then that terminates the string.

        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o25D9         ; forward to S-Q-PRMS if checking syntax.


        RST     30H             ; BC-SPACES creates the space for true
                                ; copy of string in workspace.
        POP     HL              ; re-fetch start of quoted text.
        PUSH    DE              ; save start in workspace.

;; S-Q-COPY
o25CB:  LD      A,(HL)          ; fetch a character from source.
        INC     HL              ; advance source address.
        LD      (DE),A          ; place in destination.
        INC     DE              ; advance destination address.
        CP      $22             ; was it a '"' just copied ?
        JR      NZ,o25CB        ; back to S-Q-COPY to copy more if not

        LD      A,(HL)          ; fetch adjacent character from source.
        INC     HL              ; advance source address.
        CP      $22             ; is this '"' ? - i.e. two quotes together ?
        JR      Z,o25CB         ; to S-Q-COPY if so including just one of the
                                ; pair of quotes.

; proceed when terminating quote encountered.

;; S-Q-PRMS
o25D9:  DEC     BC              ; decrease count by 1.
        POP     DE              ; restore start of string in workspace.

;; S-STRING
o25DB:  LD      HL,$5C3B        ; Address FLAGS system variable.
        RES     6,(HL)          ; signal string result.
        BIT     7,(HL)          ; is syntax being checked.
        CALL    NZ,o2AB2        ; routine STK-STO-$ is called in runtime.
        JP      o2712           ; jump forward to S-CONT-2          ===>

; ---

; ->
;; S-BRACKET
o25E8:  RST     20H             ; NEXT-CHAR
        CALL    o24FB           ; routine SCANNING is called recursively.
        CP      $29             ; is it the closing ')' ?
        JP      NZ,o1C8A        ; jump back to REPORT-C if not
                                ; 'Nonsense in BASIC'

        RST     20H             ; NEXT-CHAR
        JP      o2712           ; jump forward to S-CONT-2          ===>

; ---

; ->
;; S-FN
o25F5:  JP      o27BD           ; jump forward to S-FN-SBRN.

; --------------------------------------------------------------------
;
;   RANDOM THEORY from the ZX81 manual by Steven Vickers
;
;   (same algorithm as the ZX Spectrum).
;
;   Chapter 5. Exercise 6. (For mathematicians only.)
;
;   Let p be a [large] prime, & let a be a primitive root modulo p.
;   Then if b_i is the residue of a^i modulo p (1<=b_i<p-1), the
;   sequence
;
;                           (b_i-1)/(p-1)
;
;   is a cyclical sequence of p-1 distinct numbers in the range 0 to 1
;   (excluding 1). By choosing a suitably, these can be made to look
;   fairly random.
;
;     65537 is a Mersenne prime 2^16-1. Note.
;
;   Use this, & Gauss' law of quadratic reciprocity, to show that 75
;   is a primitive root modulo 65537.
;
;     The ZX81 uses p=65537 & a=75, & stores some b_i-1 in memory.
;   The function RND involves replacing b_i-1 in memory by b_(i+1)-1,
;   & yielding the result (b_(i+1)-1)/(p-1). RAND n (with 1<=n<=65535)
;   makes b_i equal to n+1.
;
; --------------------------------------------------------------------
;
; Steven Vickers writing in comp.sys.sinclair on 20-DEC-1993
;
;   Note. (Of course, 65537 is 2^16 + 1, not -1.)
;
;   Consider arithmetic modulo a prime p. There are p residue classes, and the
;   non-zero ones are all invertible. Hence under multiplication they form a
;   group (Fp*, say) of order p-1; moreover (and not so obvious) Fp* is cyclic.
;   Its generators are the "primitive roots". The "quadratic residues modulo p"
;   are the squares in Fp*, and the "Legendre symbol" (d/p) is defined (when p
;   does not divide d) as +1 or -1, according as d is or is not a quadratic
;   residue mod p.
;
;   In the case when p = 65537, we can show that d is a primitive root if and
;   only if it's not a quadratic residue. For let w be a primitive root, d
;   congruent to w^r (mod p). If d is not primitive, then its order is a proper
;   factor of 65536: hence w^{32768*r} = 1 (mod p), so 65536 divides 32768*r,
;   and hence r is even and d is a square (mod p). Conversely, the squares in
;   Fp* form a subgroup of (Fp*)^2 of index 2, and so cannot be generators.
;
;   Hence to check whether 75 is primitive mod 65537, we want to calculate that
;   (75/65537) = -1. There is a multiplicative formula (ab/p) = (a/p)(b/p) (mod
;   p), so (75/65537) = (5/65537)^2 * (3/65537) = (3/65537). Now the law of
;   quadratic reciprocity says that if p and q are distinct odd primes, then
;
;    (p/q)(q/p) = (-1)^{(p-1)(q-1)/4}
;
;   Hence (3/65537) = (65537/3) * (-1)^{65536*2/4} = (65537/3)
;            = (2/3)  (because 65537 = 2 mod 3)
;            = -1
;
;   (I referred to Pierre Samuel's "Algebraic Theory of Numbers".)
;
; ->

;; S-RND
o25F8:  CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o2625         ; forward to S-RND-END if checking syntax.

        LD      BC,($5C76)      ; fetch system variable SEED
        CALL    o2D2B           ; routine STACK-BC places on calculator stack

        RST     28H             ;; FP-CALC           ;s.
        DEFB    $A1             ;;stk-one            ;s,1.
        DEFB    $0F             ;;addition           ;s+1.
        DEFB    $34             ;;stk-data           ;
        DEFB    $37             ;;Exponent: $87,
                                ;;Bytes: 1
        DEFB    $16             ;;(+00,+00,+00)      ;s+1,75.
        DEFB    $04             ;;multiply           ;(s+1)*75 = v
        DEFB    $34             ;;stk-data           ;v.
        DEFB    $80             ;;Bytes: 3
        DEFB    $41             ;;Exponent $91
        DEFB    $00,$00,$80     ;;(+00)              ;v,65537.
        DEFB    $32             ;;n-mod-m            ;remainder, result.
        DEFB    $02             ;;delete             ;remainder.
        DEFB    $A1             ;;stk-one            ;remainder, 1.
        DEFB    $03             ;;subtract           ;remainder - 1. = rnd
        DEFB    $31             ;;duplicate          ;rnd,rnd.
        DEFB    $38             ;;end-calc

        CALL    o2DA2           ; routine FP-TO-BC
        LD      ($5C76),BC      ; store in SEED for next starting point.
        LD      A,(HL)          ; fetch exponent
        AND     A               ; is it zero ?
        JR      Z,o2625         ; forward if so to S-RND-END

        SUB     $10             ; reduce exponent by 2^16
        LD      (HL),A          ; place back

;; S-RND-END
o2625:  JR      o2630           ; forward to S-PI-END

; ---

; the number PI 3.14159...

; ->
;; S-PI
o2627:  CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o2630         ; to S-PI-END if checking syntax.

        RST     28H             ;; FP-CALC
        DEFB    $A3             ;;stk-pi/2                          pi/2.
        DEFB    $38             ;;end-calc

        INC     (HL)            ; increment the exponent leaving pi
                                ; on the calculator stack.

;; S-PI-END
o2630:  RST     20H             ; NEXT-CHAR
        JP      o26C3           ; jump forward to S-NUMERIC

; ---

; ->
;; S-INKEY$
o2634:  LD      BC,$105A        ; priority $10, operation code $1A ('read-in')
                                ; +$40 for string result, numeric operand.
                                ; set this up now in case we need to use the
                                ; calculator.
        RST     20H             ; NEXT-CHAR
        CP      $23             ; '#' ?
        JP      Z,o270D         ; to S-PUSH-PO if so to use the calculator
                                ; single operation
                                ; to read from network/RS232 etc. .

; else read a key from the keyboard.

        LD      HL,$5C3B        ; fetch FLAGS
        RES     6,(HL)          ; signal string result.
        BIT     7,(HL)          ; checking syntax ?
        JR      Z,o2665         ; forward to S-INK$-EN if so

        JP      o3A5A
        LD      C,$00           ; the length of an empty string
        JR      NZ,o2660        ; to S-IK$-STK to store empty string if
                                ; no key returned.

        CALL    o031E           ; routine K-TEST get main code in A
        JR      NC,o2660        ; to S-IK$-STK to stack null string if
                                ; invalid

        DEC     D               ; D is expected to be FLAGS so set bit 3 $FF
                                ; 'L' Mode so no keywords.
        LD      E,A             ; main key to A
                                ; C is MODE 0 'KLC' from above still.
        CALL    o0333           ; routine K-DECODE
o2657:  PUSH    AF              ; save the code
        LD      BC,$0001        ; make room for one character

        RST     30H             ; BC-SPACES
        POP     AF              ; bring the code back
        LD      (DE),A          ; put the key in workspace
        LD      C,$01           ; set C length to one

;; S-IK$-STK
o2660:  LD      B,$00           ; set high byte of length to zero
        CALL    o2AB2           ; routine STK-STO-$

;; S-INK$-EN
o2665:  JP      o2712           ; to S-CONT-2            ===>

; ---

; ->
;; S-SCREEN$
o2668:  CALL    o2522           ; routine S-2-COORD
        CALL    NZ,o2535        ; routine S-SCRN$-S

        RST     20H             ; NEXT-CHAR
        JP      o25DB           ; forward to S-STRING to stack result

; ---

; ->
;; S-ATTR
o2672:  CALL    o2522           ; routine S-2-COORD
        CALL    NZ,o2580        ; routine S-ATTR-S

        RST     20H             ; NEXT-CHAR
        JR      o26C3           ; forward to S-NUMERIC

; ---

; ->
;; S-POINT
o267B:  CALL    o2522           ; routine S-2-COORD
        CALL    NZ,o22CB        ; routine POINT-SUB

        RST     20H             ; NEXT-CHAR
        JR      o26C3           ; forward to S-NUMERIC

; -----------------------------

; ==> The branch was here if not in table.

;; S-ALPHNUM
o2684:  CALL    o2C88           ; routine ALPHANUM checks if variable or
                                ; a digit.
        JR      NC,o26DF        ; forward to S-NEGATE if not to consider
                                ; a '-' character then functions.

        CP      $41             ; compare 'A'
        JR      NC,o26C9        ; forward to S-LETTER if alpha       ->
                                ; else must have been numeric so continue
                                ; into that routine.

; This important routine is called during runtime and from LINE-SCAN
; when a BASIC line is checked for syntax. It is this routine that
; inserts, during syntax checking, the invisible floating point numbers
; after the numeric expression. During runtime it just picks these
; numbers up. It also handles BIN format numbers.

; ->
;; S-BIN
;; S-DECIMAL
o268D:  CALL    o2530           ; routine SYNTAX-Z
        JR      NZ,o26B5        ; to S-STK-DEC in runtime

; this route is taken when checking syntax.

        CALL    o2C9B           ; routine DEC-TO-FP to evaluate number

        RST     18H             ; GET-CHAR to fetch HL
        LD      BC,$0006        ; six locations required
        CALL    o1655           ; routine MAKE-ROOM
        INC     HL              ; to first new location
        LD      (HL),$0E        ; insert number marker
        INC     HL              ; address next
        EX      DE,HL           ; make DE destination.
        LD      HL,(STKEND)     ; STKEND points to end of stack.
        LD      C,$05           ; result is five locations lower
        AND     A               ; prepare for true subtraction
        SBC     HL,BC           ; point to start of value.
        LD      (STKEND),HL     ; update STKEND as we are taking number.
        LDIR                    ; Copy five bytes to program location
        EX      DE,HL           ; transfer pointer to HL
        DEC     HL              ; adjust
        CALL    o0077           ; routine TEMP-PTR1 sets CH-ADD
        JR      o26C3           ; to S-NUMERIC to record nature of result

; ---

; branch here in runtime.

;; S-STK-DEC
o26B5:  RST     18H             ; GET-CHAR positions HL at digit.

;; S-SD-SKIP
o26B6:  INC     HL              ; advance pointer
        LD      A,(HL)          ; until we find
        CP      $0E             ; chr 14d - the number indicator
        JR      NZ,o26B6        ; to S-SD-SKIP until a match
                                ; it has to be here.

        INC     HL              ; point to first byte of number
        CALL    o33B4           ; routine STACK-NUM stacks it
        LD      (CH_ADD),HL     ; update system variable CH_ADD

;; S-NUMERIC
o26C3:  SET     6,(IY+$01)      ; update FLAGS  - Signal numeric result
        JR      o26DD           ; forward to S-CONT-1               ===>
                                ; actually S-CONT-2 is destination but why
                                ; waste a byte on a jump when a JR will do.
                                ; Actually a JR o2712 can be used. Rats.

; end of functions accessed from scanning functions table.

; --------------------------
; Scanning variable routines
; --------------------------
;
;

;; S-LETTER
o26C9:  CALL    o28B2           ; routine LOOK-VARS

        JP      C,o1C2E         ; jump back to REPORT-2 if variable not found
                                ; 'Variable not found'
                                ; but a variable is always 'found' if syntax
                                ; is being checked.

        CALL    Z,o2996         ; routine STK-VAR considers a subscript/slice
        LD      A,($5C3B)       ; fetch FLAGS value
        CP      $C0             ; compare 11000000
        JR      C,o26DD         ; step forward to S-CONT-1 if string  ===>

        INC     HL              ; advance pointer
        CALL    o33B4           ; routine STACK-NUM

;; S-CONT-1
o26DD:  JR      o2712           ; forward to S-CONT-2                 ===>

; ----------------------------------------
; -> the scanning branch was here if not alphanumeric.
; All the remaining functions will be evaluated by a single call to the
; calculator. The correct priority for the operation has to be poaced in
; the B register and the operation code, calculator literal in the C register.
; the operation code has bit 7 set if result is numeric and bit 6 is
; set if operand is numeric. so
; $C0 = numeric result, numeric operand.            e.g. 'sin'
; $80 = numeric result, string operand.             e.g. 'code'
; $40 = string result, numeric operand.             e.g. 'str$'
; $00 = string result, string operand.              e.g. 'val$'

;; S-NEGATE
o26DF:  LD      BC,$09DB        ; prepare priority 09, operation code $C0 +
                                ; 'negate' ($1B) - bits 6 and 7 set for numeric
                                ; result and numeric operand.

        CP      $2D             ; is it '-' ?
        JR      Z,o270D         ; forward if so to S-PUSH-PO

        LD      BC,$1018        ; prepare priority $10, operation code 'val$' -
                                ; bits 6 and 7 reset for string result and
                                ; string operand.

        CP      $AE             ; is it 'VAL$' ?
        JR      Z,o270D         ; forward if so to S-PUSH-PO

        SUB     $AF             ; subtract token 'CODE' value to reduce
                                ; functions 'CODE' to 'NOT' although the
                                ; upper range is, as yet, unchecked.
                                ; valid range would be $00 - $14.

        JP      C,o1C8A         ; jump back to REPORT-C with anything else
                                ; 'Nonsense in BASIC'

        LD      BC,$04F0        ; prepare priority $04, operation $C0 +
                                ; 'not' ($30)

        CP      $14             ; is it 'NOT'
        JR      Z,o270D         ; forward to S-PUSH-PO if so

        JP      NC,o1C8A        ; to REPORT-C if higher
                                ; 'Nonsense in BASIC'

        LD      B,$10           ; priority $10 for all the rest
        ADD     A,$DC           ; make range $DC - $EF
                                ; $C0 + 'code'($1C) thru 'chr$' ($2F)

        LD      C,A             ; transfer 'function' to C
        CP      $DF             ; is it 'sin' ?
        JR      NC,o2707        ; forward to S-NO-TO-$  with 'sin' through
                                ; 'chr$' as operand is numeric.

; all the rest 'cos' through 'chr$' give a numeric result except 'str$'
; and 'chr$'.

        RES     6,C             ; signal string operand for 'code', 'val' and
                                ; 'len'.

;; S-NO-TO-$
o2707:  CP      $EE             ; compare 'str$'
        JR      C,o270D         ; forward to S-PUSH-PO if lower as result
                                ; is numeric.

        RES     7,C             ; reset bit 7 of op code for 'str$', 'chr$'
                                ; as result is string.

; >> This is where they were all headed for.

;; S-PUSH-PO
o270D:  PUSH    BC              ; push the priority and calculator operation
                                ; code.

        RST     20H             ; NEXT-CHAR
        JP      o24FF           ; jump back to S-LOOP-1 to go round the loop
                                ; again with the next character.

; --------------------------------

; ===>  there were many branches forward to here

;   An important step after the evaluation of an expression is to test for
;   a string expression and allow it to be sliced.  If a numeric expression is
;   followed by a '(' then the numeric expression is complete.
;   Since a string slice can itself be sliced then loop repeatedly
;   e.g. (STR$ PI) (3 TO) (TO 2)    or "nonsense" (4 TO )

;; S-CONT-2
o2712:  RST     18H             ; GET-CHAR

;; S-CONT-3
o2713:  CP      $28             ; is it '(' ?
        JR      NZ,o2723        ; forward, if not, to S-OPERTR

        BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
        JR      NZ,o2734        ; forward, if numeric, to S-LOOP

;   if a string expression preceded the '(' then slice it.

        CALL    o2A52           ; routine SLICING

        RST     20H             ; NEXT-CHAR
        JR      o2713           ; loop back to S-CONT-3

; ---------------------------

;   the branch was here when possibility of a '(' has been excluded.

;; S-OPERTR
o2723:  LD      B,$00           ; prepare to add
        LD      C,A             ; possible operator to C
        LD      HL,o2795        ; Address: $2795 - tbl-of-ops
        CALL    o16DC           ; routine INDEXER
        JR      NC,o2734        ; forward to S-LOOP if not in table

;   but if found in table the priority has to be looked up.

        LD      C,(HL)          ; operation code to C ( B is still zero )
        LD      HL,o27B0 - $C3  ; $26ED is base of table
        ADD     HL,BC           ; index into table.
        LD      B,(HL)          ; priority to B.

; ------------------
; Scanning main loop
; ------------------
; the juggling act

;; S-LOOP
o2734:  POP     DE              ; fetch last priority and operation
        LD      A,D             ; priority to A
        CP      B               ; compare with this one
        JR      C,o2773         ; forward to S-TIGHTER to execute the
                                ; last operation before this one as it has
                                ; higher priority.

; the last priority was greater or equal this one.

        AND     A               ; if it is zero then so is this
        JP      Z,o0018         ; jump to exit via get-char pointing at
                                ; next character.
                                ; This may be the character after the
                                ; expression or, if exiting a recursive call,
                                ; the next part of the expression to be
                                ; evaluated.

        PUSH    BC              ; save current priority/operation
                                ; as it has lower precedence than the one
                                ; now in DE.

; the 'USR' function is special in that it is overloaded to give two types
; of result.

        LD      HL,$5C3B        ; address FLAGS
        LD      A,E             ; new operation to A register
        CP      $ED             ; is it $C0 + 'usr-no' ($2D)  ?
        JR      NZ,o274C        ; forward to S-STK-LST if not

        BIT     6,(HL)          ; string result expected ?
                                ; (from the lower priority operand we've
                                ; just pushed on stack )
        JR      NZ,o274C        ; forward to S-STK-LST if numeric
                                ; as operand bits match.

        LD      E,$99           ; reset bit 6 and substitute $19 'usr-$'
                                ; for string operand.

;; S-STK-LST
o274C:  PUSH    DE              ; now stack this priority/operation
        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o275B         ; forward to S-SYNTEST if checking syntax.

        LD      A,E             ; fetch the operation code
        AND     $3F             ; mask off the result/operand bits to leave
                                ; a calculator literal.
        LD      B,A             ; transfer to B register

; now use the calculator to perform the single operation - operand is on
; the calculator stack.
; Note. although the calculator is performing a single operation most
; functions e.g. TAN are written using other functions and literals and
; these in turn are written using further strings of calculator literals so
; another level of magical recursion joins the juggling act for a while
; as the calculator too is calling itself.

        RST     28H             ;; FP-CALC
        DEFB    $3B             ;;fp-calc-2
o2758:  DEFB    $38             ;;end-calc

        JR      o2764           ; forward to S-RUNTEST

; ---

; the branch was here if checking syntax only.

;; S-SYNTEST
o275B:  LD      A,E             ; fetch the operation code to accumulator
        XOR     (IY+$01)        ; compare with bits of FLAGS
        AND     $40             ; bit 6 will be zero now if operand
                                ; matched expected result.

;; S-RPORT-C2
o2761:  JP      NZ,o1C8A        ; to REPORT-C if mismatch
                                ; 'Nonsense in BASIC'
                                ; else continue to set flags for next

; the branch is to here in runtime after a successful operation.

;; S-RUNTEST
o2764:  POP     DE              ; fetch the last operation from stack
        LD      HL,$5C3B        ; address FLAGS
        SET     6,(HL)          ; set default to numeric result in FLAGS
        BIT     7,E             ; test the operational result
        JR      NZ,o2770        ; forward to S-LOOPEND if numeric

        RES     6,(HL)          ; reset bit 6 of FLAGS to show string result.

;; S-LOOPEND
o2770:  POP     BC              ; fetch the previous priority/operation
        JR      o2734           ; back to S-LOOP to perform these

; ---

; the branch was here when a stacked priority/operator had higher priority
; than the current one.

;; S-TIGHTER
o2773:  PUSH    DE              ; save high priority op on stack again
        LD      A,C             ; fetch lower priority operation code
        BIT     6,(IY+$01)      ; test FLAGS - Numeric or string result ?
        JR      NZ,o2790        ; forward to S-NEXT if numeric result

; if this is lower priority yet has string then must be a comparison.
; Since these can only be evaluated in context and were defaulted to
; numeric in operator look up they must be changed to string equivalents.

        AND     $3F             ; mask to give true calculator literal
        ADD     A,$08           ; augment numeric literals to string
                                ; equivalents.
                                ; 'no-&-no'  => 'str-&-no'
                                ; 'no-l-eql' => 'str-l-eql'
                                ; 'no-gr-eq' => 'str-gr-eq'
                                ; 'nos-neql' => 'strs-neql'
                                ; 'no-grtr'  => 'str-grtr'
                                ; 'no-less'  => 'str-less'
                                ; 'nos-eql'  => 'strs-eql'
                                ; 'addition' => 'strs-add'
        LD      C,A             ; put modified comparison operator back
        CP      $10             ; is it now 'str-&-no' ?
        JR      NZ,o2788        ; forward to S-NOT-AND  if not.

        SET     6,C             ; set numeric operand bit
        JR      o2790           ; forward to S-NEXT

; ---

;; S-NOT-AND
o2788:  JR      C,o2761         ; back to S-RPORT-C2 if less
                                ; 'Nonsense in BASIC'.
                                ; e.g. a$ * b$

        CP      $17             ; is it 'strs-add' ?
        JR      Z,o2790         ; forward to S-NEXT if so
                                ; (bit 6 and 7 are reset)

        SET     7,C             ; set numeric (Boolean) result for all others

;; S-NEXT
o2790:  PUSH    BC              ; now save this priority/operation on stack

        RST     20H             ; NEXT-CHAR
        JP      o24FF           ; jump back to S-LOOP-1

; ------------------
; Table of operators
; ------------------
; This table is used to look up the calculator literals associated with
; the operator character. The thirteen calculator operations $03 - $0F
; have bits 6 and 7 set to signify a numeric result.
; Some of these codes and bits may be altered later if the context suggests
; a string comparison or operation.
; that is '+', '=', '>', '<', '<=', '>=' or '<>'.

;; tbl-of-ops
o2795:  DEFB    '+', $CF        ;        $C0 + 'addition'
        DEFB    '-', $C3        ;        $C0 + 'subtract'
        DEFB    '*', $C4        ;        $C0 + 'multiply'
        DEFB    '/', $C5        ;        $C0 + 'division'
        DEFB    '^', $C6        ;        $C0 + 'to-power'
        DEFB    '=', $CE        ;        $C0 + 'nos-eql'
        DEFB    '>', $CC        ;        $C0 + 'no-grtr'
        DEFB    '<', $CD        ;        $C0 + 'no-less'

        DEFB    $C7, $C9        ; '<='   $C0 + 'no-l-eql'
        DEFB    $C8, $CA        ; '>='   $C0 + 'no-gr-eql'
        DEFB    $C9, $CB        ; '<>'   $C0 + 'nos-neql'
        DEFB    $C5, $C7        ; 'OR'   $C0 + 'or'
        DEFB    $C6, $C8        ; 'AND'  $C0 + 'no-&-no'

        DEFB    $00             ; zero end-marker.


; -------------------
; Table of priorities
; -------------------
; This table is indexed with the operation code obtained from the above
; table $C3 - $CF to obtain the priority for the respective operation.

;; tbl-priors
o27B0:  DEFB    $06             ; '-'   opcode $C3
        DEFB    $08             ; '*'   opcode $C4
        DEFB    $08             ; '/'   opcode $C5
        DEFB    $0A             ; '^'   opcode $C6
        DEFB    $02             ; 'OR'  opcode $C7
        DEFB    $03             ; 'AND' opcode $C8
        DEFB    $05             ; '<='  opcode $C9
        DEFB    $05             ; '>='  opcode $CA
        DEFB    $05             ; '<>'  opcode $CB
        DEFB    $05             ; '>'   opcode $CC
        DEFB    $05             ; '<'   opcode $CD
        DEFB    $05             ; '='   opcode $CE
        DEFB    $06             ; '+'   opcode $CF

; ----------------------
; Scanning function (FN)
; ----------------------
; This routine deals with user-defined functions.
; The definition can be anywhere in the program area but these are best
; poaced near the start of the program as we shall see.
; The evaluation process is quite complex as the Spectrum has to parse two
; statements at the same time. Syntax of both has been checked previously
; and hidden locations have been created immediately after each argument
; of the DEF FN statement. Each of the arguments of the FN function is
; evaluated by SCANNING and poaced in the hidden locations. Then the
; expression to the right of the DEF FN '=' is evaluated by SCANNING and for
; any variables encountered, a search is made in the DEF FN variable list
; in the program area before searching in the normal variables area.
;
; Recursion is not allowed: i.e. the definition of a function should not use
; the same function, either directly or indirectly ( through another function).
; You'll normally get error 4, ('Out of memory'), although sometimes the system
; will crash. - Vickers, Pitman 1984.
;
; As the definition is just an expression, there would seem to be no means
; of breaking out of such recursion.
; However, by the clever use of string expressions and VAL, such recursion is
; possible.
; e.g. DEF FN a(n) = VAL "n+FN a(n-1)+0" ((n<1) * 10 + 1 TO )
; will evaluate the full 11-character expression for all values where n is
; greater than zero but just the 11th character, "0", when n drops to zero
; thereby ending the recursion producing the correct result.
; Recursive string functions are possible using VAL$ instead of VAL and the
; null string as the final addend.
; - from a turn of the century newsgroup discussion initiated by Mike Wynne.

;; S-FN-SBRN
o27BD:  CALL    o2530           ; routine SYNTAX-Z
        JR      NZ,o27F7        ; forward to SF-RUN in runtime


        RST     20H             ; NEXT-CHAR
        CALL    o2C8D           ; routine ALPHA check for letters A-Z a-z
        JP      NC,o1C8A        ; jump back to REPORT-C if not
                                ; 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR
        CP      $24             ; is it '$' ?
        PUSH    AF              ; save character and flags
        JR      NZ,o27D0        ; forward to SF-BRKT-1 with numeric function


        RST     20H             ; NEXT-CHAR

;; SF-BRKT-1
o27D0:  CP      $28             ; is '(' ?
        JR      NZ,o27E6        ; forward to SF-RPRT-C if not
                                ; 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR
        CP      $29             ; is it ')' ?
        JR      Z,o27E9         ; forward to SF-FLAG-6 if no arguments.

;; SF-ARGMTS
o27D9:  CALL    o24FB           ; routine SCANNING checks each argument
                                ; which may be an expression.

        RST     18H             ; GET-CHAR
        CP      $2C             ; is it a ',' ?
        JR      NZ,o27E4        ; forward if not to SF-BRKT-2 to test bracket


        RST     20H             ; NEXT-CHAR if a comma was found
        JR      o27D9           ; back to SF-ARGMTS to parse all arguments.

; ---

;; SF-BRKT-2
o27E4:  CP      $29             ; is character the closing ')' ?

;; SF-RPRT-C
o27E6:  JP      NZ,o1C8A        ; jump to REPORT-C
                                ; 'Nonsense in BASIC'

; at this point any optional arguments have had their syntax checked.

;; SF-FLAG-6
o27E9:  RST     20H             ; NEXT-CHAR
        LD      HL,$5C3B        ; address system variable FLAGS
        RES     6,(HL)          ; signal string result
        POP     AF              ; restore test against '$'.
        JR      Z,o27F4         ; forward to SF-SYN-EN if string function.

        SET     6,(HL)          ; signal numeric result

;; SF-SYN-EN
o27F4:  JP      o2712           ; jump back to S-CONT-2 to continue scanning.

; ---

; the branch was here in runtime.

;; SF-RUN
o27F7:  RST     20H             ; NEXT-CHAR fetches name
        AND     $DF             ; AND 11101111 - reset bit 5 - upper-case.
        LD      B,A             ; save in B

        RST     20H             ; NEXT-CHAR
        SUB     $24             ; subtract '$'
        LD      C,A             ; save result in C
        JR      NZ,o2802        ; forward if not '$' to SF-ARGMT1

        RST     20H             ; NEXT-CHAR advances to bracket

;; SF-ARGMT1
o2802:  RST     20H             ; NEXT-CHAR advances to start of argument
        PUSH    HL              ; save address
        LD      HL,(PROG)       ; fetch start of program area from PROG
        DEC     HL              ; the search starting point is the previous
                                ; location.

;; SF-FND-DF
o2808:  LD      DE,$00CE        ; search is for token 'DEF FN' in E,
                                ; statement count in D.
        PUSH    BC              ; save C the string test, and B the letter.
        CALL    o1D86           ; routine LOOK-PROG will search for token.
        POP     BC              ; restore BC.
        JR      NC,o2814        ; forward to SF-CP-DEF if a match was found.


;; REPORT-P
o2812:  RST     08H             ; ERROR-1
        DEFB    $18             ; Error Report: FN without DEF

;; SF-CP-DEF
o2814:  PUSH    HL              ; save address of DEF FN
        CALL    o28AB           ; routine FN-SKPOVR skips over white-space etc.
                                ; without disturbing CH-ADD.
        AND     $DF             ; make fetched character upper-case.
        CP      B               ; compare with FN name
        JR      NZ,o2825        ; forward to SF-NOT-FD if no match.

; the letters match so test the type.

        CALL    o28AB           ; routine FN-SKPOVR skips white-space
        SUB     $24             ; subtract '$' from fetched character
        CP      C               ; compare with saved result of same operation
                                ; on FN name.
        JR      Z,o2831         ; forward to SF-VALUES with a match.

; the letters matched but one was string and the other numeric.

;; SF-NOT-FD
o2825:  POP     HL              ; restore search point.
        DEC     HL              ; make location before
        LD      DE,$0200        ; the search is to be for the end of the
                                ; current definition - 2 statements forward.
        PUSH    BC              ; save the letter/type
        CALL    o198B           ; routine EACH-STMT steps past rejected
                                ; definition.
        POP     BC              ; restore letter/type
        JR      o2808           ; back to SF-FND-DF to continue search

; ---

; Success!
; the branch was here with matching letter and numeric/string type.

;; SF-VALUES
o2831:  AND     A               ; test A ( will be zero if string '$' - '$' )

        CALL    Z,o28AB         ; routine FN-SKPOVR advances HL past '$'.

        POP     DE              ; discard pointer to 'DEF FN'.
        POP     DE              ; restore pointer to first FN argument.
        LD      (CH_ADD),DE     ; save in CH_ADD

        CALL    o28AB           ; routine FN-SKPOVR advances HL past '('
        PUSH    HL              ; save start address in DEF FN  ***
        CP      $29             ; is character a ')' ?
        JR      Z,o2885         ; forward to SF-R-BR-2 if no arguments.

;; SF-ARG-LP
o2843:  INC     HL              ; point to next character.
        LD      A,(HL)          ; fetch it.
        CP      $0E             ; is it the number marker
        LD      D,$40           ; signal numeric in D.
        JR      Z,o2852         ; forward to SF-ARG-VL if numeric.

        DEC     HL              ; back to letter
        CALL    o28AB           ; routine FN-SKPOVR skips any white-space
        INC     HL              ; advance past the expected '$' to
                                ; the 'hidden' marker.
        LD      D,$00           ; signal string.

;; SF-ARG-VL
o2852:  INC     HL              ; now address first of 5-byte location.
        PUSH    HL              ; save address in DEF FN statement
        PUSH    DE              ; save D - result type

        CALL    o24FB           ; routine SCANNING evaluates expression in
                                ; the FN statement setting FLAGS and leaving
                                ; result as last value on calculator stack.

        POP     AF              ; restore saved result type to A

        XOR     (IY+$01)        ; xor with FLAGS
        AND     $40             ; and with 01000000 to test bit 6
        JR      NZ,o288B        ; forward to REPORT-Q if type mismatch.
                                ; 'Parameter error'

        POP     HL              ; pop the start address in DEF FN statement
        EX      DE,HL           ; transfer to DE ?? pop straight into de ?

        LD      HL,(STKEND)     ; set HL to STKEND location after value
        LD      BC,$0005        ; five bytes to move
        SBC     HL,BC           ; decrease HL by 5 to point to start.
        LD      (STKEND),HL     ; set STKEND 'removing' value from stack.

        LDIR                    ; copy value into DEF FN statement
        EX      DE,HL           ; set HL to location after value in DEF FN
        DEC     HL              ; step back one
        CALL    o28AB           ; routine FN-SKPOVR gets next valid character
        CP      $29             ; is it ')' end of arguments ?
        JR      Z,o2885         ; forward to SF-R-BR-2 if so.

; a comma separator has been encountered in the DEF FN argument list.

        PUSH    HL              ; save position in DEF FN statement

        RST     18H             ; GET-CHAR from FN statement
        CP      $2C             ; is it ',' ?
        JR      NZ,o288B        ; forward to REPORT-Q if not
                                ; 'Parameter error'

        RST     20H             ; NEXT-CHAR in FN statement advances to next
                                ; argument.

        POP     HL              ; restore DEF FN pointer
        CALL    o28AB           ; routine FN-SKPOVR advances to corresponding
                                ; argument.

        JR      o2843           ; back to SF-ARG-LP looping until all
                                ; arguments are passed into the DEF FN
                                ; hidden locations.

; ---

; the branch was here when all arguments passed.

;; SF-R-BR-2
o2885:  PUSH    HL              ; save location of ')' in DEF FN

        RST     18H             ; GET-CHAR gets next character in FN
        CP      $29             ; is it a ')' also ?
        JR      Z,o288D         ; forward to SF-VALUE if so.


;; REPORT-Q
o288B:  RST     08H             ; ERROR-1
        DEFB    $19             ; Error Report: Parameter error

;; SF-VALUE
o288D:  POP     DE              ; location of ')' in DEF FN to DE.
        EX      DE,HL           ; now to HL, FN ')' pointer to DE.
        LD      (CH_ADD),HL     ; initialize CH_ADD to this value.

; At this point the start of the DEF FN argument list is on the machine stack.
; We also have to consider that this defined function may form part of the
; definition of another defined function (though not itself).
; As this defined function may be part of a hierarchy of defined functions
; currently being evaluated by recursive calls to SCANNING, then we have to
; preserve the original value of DEFADD and not assume that it is zero.

        LD      HL,($5C0B)      ; get original DEFADD address
        EX      (SP),HL         ; swap with DEF FN address on stack ***
        LD      ($5C0B),HL      ; set DEFADD to point to this argument list
                                ; during scanning.

        PUSH    DE              ; save FN ')' pointer.

        RST     20H             ; NEXT-CHAR advances past ')' in define

        RST     20H             ; NEXT-CHAR advances past '=' to expression

        CALL    o24FB           ; routine SCANNING evaluates but searches
                                ; initially for variables at DEFADD

        POP     HL              ; pop the FN ')' pointer
        LD      (CH_ADD),HL     ; set CH_ADD to this
        POP     HL              ; pop the original DEFADD value
        LD      ($5C0B),HL      ; and re-insert into DEFADD system variable.

        RST     20H             ; NEXT-CHAR advances to character after ')'
        JP      o2712           ; to S-CONT-2 - to continue current
                                ; invocation of scanning

; --------------------
; Used to parse DEF FN
; --------------------
; e.g. DEF FN     s $ ( x )     =  b     $ (  TO  x  ) : REM exaggerated
;
; This routine is used 10 times to advance along a DEF FN statement
; skipping spaces and colour control codes. It is similar to NEXT-CHAR
; which is, at the same time, used to skip along the corresponding FN function
; except the latter has to deal with AT and TAB characters in string
; expressions. These cannot occur in a program area so this routine is
; simpler as both colour controls and their parameters are less than space.

;; FN-SKPOVR
o28AB:  INC     HL              ; increase pointer
        LD      A,(HL)          ; fetch addressed character
        CP      $21             ; compare with space + 1
        JR      C,o28AB         ; back to FN-SKPOVR if less

        RET                     ; return pointing to a valid character.

; ---------
; LOOK-VARS
; ---------
;
;

;; LOOK-VARS
o28B2:  SET     6,(IY+$01)      ; update FLAGS - presume numeric result

        RST     18H             ; GET-CHAR
        CALL    o2C8D           ; routine ALPHA tests for A-Za-z
        JP      NC,o1C8A        ; jump to REPORT-C if not.
                                ; 'Nonsense in BASIC'

        PUSH    HL              ; save pointer to first letter       ^1
        AND     $1F             ; mask lower bits, 1 - 26 decimal     000xxxxx
        LD      C,A             ; store in C.

        RST     20H             ; NEXT-CHAR
        PUSH    HL              ; save pointer to second character   ^2
        CP      $28             ; is it '(' - an array ?
        JR      Z,o28EF         ; forward to V-RUN/SYN if so.

        SET     6,C             ; set 6 signaling string if solitary  010
        CP      $24             ; is character a '$' ?
        JR      Z,o28DE         ; forward to V-STR-VAR

        SET     5,C             ; signal numeric                       011
        CALL    o2C88           ; routine ALPHANUM sets carry if second
                                ; character is alphanumeric.
        JR      NC,o28E3        ; forward to V-TEST-FN if just one character

; It is more than one character but re-test current character so that 6 reset
; This loop renders the similar loop at V-PASS redundant.

;; V-CHAR
o28D4:  CALL    o2C88           ; routine ALPHANUM
        JR      NC,o28EF        ; to V-RUN/SYN when no more

        RES     6,C             ; make long named type                 001

        RST     20H             ; NEXT-CHAR
        JR      o28D4           ; loop back to V-CHAR

; ---


;; V-STR-VAR
o28DE:  RST     20H             ; NEXT-CHAR advances past '$'
        RES     6,(IY+$01)      ; update FLAGS - signal string result.

;; V-TEST-FN
o28E3:  LD      A,($5C0C)       ; load A with DEFADD_hi
        AND     A               ; and test for zero.
        JR      Z,o28EF         ; forward to V-RUN/SYN if a defined function
                                ; is not being evaluated.

; Note.

        CALL    o2530           ; routine SYNTAX-Z
        JP      NZ,o2951        ; JUMP to STK-F-ARG in runtime and then
                                ; back to this point if no variable found.

;; V-RUN/SYN
o28EF:  LD      B,C             ; save flags in B
        CALL    o2530           ; routine SYNTAX-Z
        JR      NZ,o28FD        ; to V-RUN to look for the variable in runtime

; if checking syntax the letter is not returned

        LD      A,C             ; copy letter/flags to A
        AND     $E0             ; and with 11100000 to get rid of the letter
        SET     7,A             ; use spare bit to signal checking syntax.
        LD      C,A             ; and transfer to C.
        JR      o2934           ; forward to V-SYNTAX

; ---

; but in runtime search for the variable.

;; V-RUN
o28FD:  LD      HL,(VARS)       ; set HL to start of variables from VARS

;; V-EACH
o2900:  LD      A,(HL)          ; get first character
        AND     $7F             ; and with 01111111
                                ; ignoring bit 7 which distinguishes
                                ; arrays or for/next variables.

        JR      Z,o2932         ; to V-80-BYTE if zero as must be 10000000
                                ; the variables end-marker.

        CP      C               ; compare with supplied value.
        JR      NZ,o292A        ; forward to V-NEXT if no match.

        RLA                     ; destructively test
        ADD     A,A             ; bits 5 and 6 of A
                                ; jumping if bit 5 reset or 6 set

        JP      P,o293F         ; to V-FOUND-2  strings and arrays

        JR      C,o293F         ; to V-FOUND-2  simple and for next

; leaving long name variables.

        POP     DE              ; pop pointer to 2nd. char
        PUSH    DE              ; save it again
        PUSH    HL              ; save variable first character pointer

;; V-MATCHES
o2912:  INC     HL              ; address next character in vars area

;; V-SPACES
o2913:  LD      A,(DE)          ; pick up letter from prog area
        INC     DE              ; and advance address
        CP      $20             ; is it a space
        JR      Z,o2913         ; back to V-SPACES until non-space

        OR      $20             ; convert to range 1 - 26.
        CP      (HL)            ; compare with addressed variables character
        JR      Z,o2912         ; loop back to V-MATCHES if a match on an
                                ; intermediate letter.

        OR      $80             ; now set bit 7 as last character of long
                                ; names are inverted.
        CP      (HL)            ; compare again
        JR      NZ,o2929        ; forward to V-GET-PTR if no match

; but if they match check that this is also last letter in prog area

        LD      A,(DE)          ; fetch next character
        CALL    o2C88           ; routine ALPHANUM sets carry if not alphanum
        JR      NC,o293E        ; forward to V-FOUND-1 with a full match.

;; V-GET-PTR
o2929:  POP     HL              ; pop saved pointer to char 1

;; V-NEXT
o292A:  PUSH    BC              ; save flags
        CALL    o19B8           ; routine NEXT-ONE gets next variable in DE
        EX      DE,HL           ; transfer to HL.
        POP     BC              ; restore the flags
        JR      o2900           ; loop back to V-EACH
                                ; to compare each variable

; ---

;; V-80-BYTE
o2932:  SET     7,B             ; will signal not found

; the branch was here when checking syntax

;; V-SYNTAX
o2934:  POP     DE              ; discard the pointer to 2nd. character  v2
                                ; in BASIC line/workspace.

        RST     18H             ; GET-CHAR gets character after variable name.
        CP      $28             ; is it '(' ?
        JR      Z,o2943         ; forward to V-PASS
                                ; Note. could go straight to V-END ?

        SET     5,B             ; signal not an array
        JR      o294B           ; forward to V-END

; ---------------------------

; the jump was here when a long name matched and HL pointing to last character
; in variables area.

;; V-FOUND-1
o293E:  POP     DE              ; discard pointer to first var letter

; the jump was here with all other matches HL points to first var char.

;; V-FOUND-2
o293F:  POP     DE              ; discard pointer to 2nd prog char       v2
        POP     DE              ; drop pointer to 1st prog char          v1
        PUSH    HL              ; save pointer to last char in vars

        RST     18H             ; GET-CHAR

;; V-PASS
o2943:  CALL    o2C88           ; routine ALPHANUM
        JR      NC,o294B        ; forward to V-END if not

; but it never will be as we advanced past long-named variables earlier.

        RST     20H             ; NEXT-CHAR
        JR      o2943           ; back to V-PASS

; ---

;; V-END
o294B:  POP     HL              ; pop the pointer to first character in
                                ; BASIC line/workspace.
        RL      B               ; rotate the B register left
                                ; bit 7 to carry
        BIT     6,B             ; test the array indicator bit.
        RET                     ; return

; -----------------------
; Stack function argument
; -----------------------
; This branch is taken from LOOK-VARS when a defined function is currently
; being evaluated.
; Scanning is evaluating the expression after the '=' and the variable
; found could be in the argument list to the left of the '=' or in the
; normal place after the program. Preference will be given to the former.
; The variable name to be matched is in C.

;; STK-F-ARG
o2951:  LD      HL,($5C0B)      ; set HL to DEFADD
        LD      A,(HL)          ; load the first character
        CP      $29             ; is it ')' ?
        JP      Z,o28EF         ; JUMP back to V-RUN/SYN, if so, as there are
                                ; no arguments.

; but proceed to search argument list of defined function first if not empty.

;; SFA-LOOP
o295A:  LD      A,(HL)          ; fetch character again.
        OR      $60             ; or with 01100000 presume a simple variable.
        LD      B,A             ; save result in B.
        INC     HL              ; address next location.
        LD      A,(HL)          ; pick up byte.
        CP      $0E             ; is it the number marker ?
        JR      Z,o296B         ; forward to SFA-CP-VR if so.

; it was a string. White-space may be present but syntax has been checked.

        DEC     HL              ; point back to letter.
        CALL    o28AB           ; routine FN-SKPOVR skips to the '$'
        INC     HL              ; now address the hidden marker.
        RES     5,B             ; signal a string variable.

;; SFA-CP-VR
o296B:  LD      A,B             ; transfer found variable letter to A.
        CP      C               ; compare with expected.
        JR      Z,o2981         ; forward to SFA-MATCH with a match.

        INC     HL              ; step
        INC     HL              ; past
        INC     HL              ; the
        INC     HL              ; five
        INC     HL              ; bytes.

        CALL    o28AB           ; routine FN-SKPOVR skips to next character
        CP      $29             ; is it ')' ?
        JP      Z,o28EF         ; jump back if so to V-RUN/SYN to look in
                                ; normal variables area.

        CALL    o28AB           ; routine FN-SKPOVR skips past the ','
                                ; all syntax has been checked and these
                                ; things can be taken as read.
        JR      o295A           ; back to SFA-LOOP while there are more
                                ; arguments.

; ---

;; SFA-MATCH
o2981:  BIT     5,C             ; test if numeric
        JR      NZ,o2991        ; to SFA-END if so as will be stacked
                                ; by scanning

        INC     HL              ; point to start of string descriptor
        LD      DE,(STKEND)     ; set DE to STKEND
        CALL    o33C0           ; routine MOVE-FP puts parameters on stack.
        EX      DE,HL           ; new free location to HL.
        LD      (STKEND),HL     ; use it to set STKEND system variable.

;; SFA-END
o2991:  POP     DE              ; discard
        POP     DE              ; pointers.
        XOR     A               ; clear carry flag.
        INC     A               ; and zero flag.
        RET                     ; return.

; ------------------------
; Stack variable component
; ------------------------
; This is called to evaluate a complex structure that has been found, in
; runtime, by LOOK-VARS in the variables area.
; In this case HL points to the initial letter, bits 7-5
; of which indicate the type of variable.
; 010 - simple string, 110 - string array, 100 - array of numbers.
;
; It is called from CLASS-01 when assigning to a string or array including
; a slice.
; It is called from SCANNING to isolate the required part of the structure.
;
; An important part of the runtime process is to check that the number of
; dimensions of the variable match the number of subscripts supplied in the
; BASIC line.
;
; If checking syntax,
; the B register, which counts dimensions is set to zero (256) to allow
; the loop to continue till all subscripts are checked. While doing this it
; is reading dimension sizes from some arbitrary area of memory. Although
; these are meaningless it is of no concern as the limit is never checked by
; int-exp during syntax checking.
;
; The routine is also called from the syntax path of DIM command to check the
; syntax of both string and numeric arrays definitions except that bit 6 of C
; is reset so both are checked as numeric arrays. This ruse avoids a terminal
; slice being accepted as part of the DIM command.
; All that is being checked is that there are a valid set of comma-separated
; expressions before a terminal ')', although, as above, it will still go
; through the motions of checking dummy dimension sizes.

;; STK-VAR
o2996:  XOR     A               ; clear A
        LD      B,A             ; and B, the syntax dimension counter (256)
        BIT     7,C             ; checking syntax ?
        JR      NZ,o29E7        ; forward to SV-COUNT if so.

; runtime evaluation.

        BIT     7,(HL)          ; will be reset if a simple string.
        JR      NZ,o29AE        ; forward to SV-ARRAYS otherwise

        INC     A               ; set A to 1, simple string.

;; SV-SIMPLE$
o29A1:  INC     HL              ; address length low
        LD      C,(HL)          ; place in C
        INC     HL              ; address length high
        LD      B,(HL)          ; place in B
        INC     HL              ; address start of string
        EX      DE,HL           ; DE = start now.
        CALL    o2AB2           ; routine STK-STO-$ stacks string parameters
                                ; DE start in variables area,
                                ; BC length, A=1 simple string

; the only thing now is to consider if a slice is required.

        RST     18H             ; GET-CHAR puts character at CH_ADD in A
        JP      o2A49           ; jump forward to SV-SLICE? to test for '('

; --------------------------------------------------------

; the branch was here with string and numeric arrays in runtime.

;; SV-ARRAYS
o29AE:  INC     HL              ; step past
        INC     HL              ; the total length
        INC     HL              ; to address Number of dimensions.
        LD      B,(HL)          ; transfer to B overwriting zero.
        BIT     6,C             ; a numeric array ?
        JR      Z,o29C0         ; forward to SV-PTR with numeric arrays

        DEC     B               ; ignore the final element of a string array
                                ; the fixed string size.

        JR      Z,o29A1         ; back to SV-SIMPLE$ if result is zero as has
                                ; been created with DIM a$(10) for instance
                                ; and can be treated as a simple string.

; proceed with multi-dimensioned string arrays in runtime.

        EX      DE,HL           ; save pointer to dimensions in DE

        RST     18H             ; GET-CHAR looks at the BASIC line
        CP      $28             ; is character '(' ?
        JR      NZ,o2A20        ; to REPORT-3 if not
                                ; 'Subscript wrong'

        EX      DE,HL           ; dimensions pointer to HL to synchronize
                                ; with next instruction.

; runtime numeric arrays path rejoins here.

;; SV-PTR
o29C0:  EX      DE,HL           ; save dimension pointer in DE
        JR      o29E7           ; forward to SV-COUNT with true no of dims
                                ; in B. As there is no initial comma the
                                ; loop is entered at the midpoint.

; ----------------------------------------------------------
; the dimension counting loop which is entered at mid-point.

;; SV-COMMA
o29C3:  PUSH    HL              ; save counter

        RST     18H             ; GET-CHAR

        POP     HL              ; pop counter
        CP      $2C             ; is character ',' ?
        JR      Z,o29EA         ; forward to SV-LOOP if so

; in runtime the variable definition indicates a comma should appear here

        BIT     7,C             ; checking syntax ?
        JR      Z,o2A20         ; forward to REPORT-3 if not
                                ; 'Subscript error'

; proceed if checking syntax of an array?

        BIT     6,C             ; array of strings
        JR      NZ,o29D8        ; forward to SV-CLOSE if so

; an array of numbers.

        CP      $29             ; is character ')' ?
        JR      NZ,o2A12        ; forward to SV-RPT-C if not
                                ; 'Nonsense in BASIC'

        RST     20H             ; NEXT-CHAR moves CH-ADD past the statement
        RET                     ; return ->

; ---

; the branch was here with an array of strings.

;; SV-CLOSE
o29D8:  CP      $29             ; as above ')' could follow the expression
        JR      Z,o2A48         ; forward to SV-DIM if so

        CP      $CC             ; is it 'TO' ?
        JR      NZ,o2A12        ; to SV-RPT-C with anything else
                                ; 'Nonsense in BASIC'

; now backtrack CH_ADD to set up for slicing routine.
; Note. in a BASIC line we can safely backtrack to a colour parameter.

;; SV-CH-ADD
o29E0:  RST     18H             ; GET-CHAR
        DEC     HL              ; backtrack HL
        LD      (CH_ADD),HL     ; to set CH_ADD up for slicing routine
        JR      o2A45           ; forward to SV-SLICE and make a return
                                ; when all slicing complete.

; ----------------------------------------
; -> the mid-point entry point of the loop

;; SV-COUNT
o29E7:  LD      HL,$0000        ; initialize data pointer to zero.

;; SV-LOOP
o29EA:  PUSH    HL              ; save the data pointer.

        RST     20H             ; NEXT-CHAR in BASIC area points to an
                                ; expression.

        POP     HL              ; restore the data pointer.
        LD      A,C             ; transfer name/type to A.
        CP      $C0             ; is it 11000000 ?
                                ; Note. the letter component is absent if
                                ; syntax checking.
        JR      NZ,o29FB        ; forward to SV-MULT if not an array of
                                ; strings.

; proceed to check string arrays during syntax.

        RST     18H             ; GET-CHAR
        CP      $29             ; ')'  end of subscripts ?
        JR      Z,o2A48         ; forward to SV-DIM to consider further slice

        CP      $CC             ; is it 'TO' ?
        JR      Z,o29E0         ; back to SV-CH-ADD to consider a slice.
                                ; (no need to repeat get-char at o29E0)

; if neither, then an expression is required so rejoin runtime loop ??
; registers HL and DE only point to somewhere meaningful in runtime so
; comments apply to that situation.

;; SV-MULT
o29FB:  PUSH    BC              ; save dimension number.
        PUSH    HL              ; push data pointer/rubbish.
                                ; DE points to current dimension.
        CALL    o2AEE           ; routine DE,(DE+1) gets next dimension in DE
                                ; and HL points to it.
        EX      (SP),HL         ; dim pointer to stack, data pointer to HL (*)
        EX      DE,HL           ; data pointer to DE, dim size to HL.

        CALL    o2ACC           ; routine INT-EXP1 checks integer expression
                                ; and gets result in BC in runtime.
        JR      C,o2A20         ; to REPORT-3 if > HL
                                ; 'Subscript out of range'

        DEC     BC              ; adjust returned result from 1-x to 0-x
        CALL    o2AF4           ; routine GET-HL*DE multiplies data pointer by
                                ; dimension size.
        ADD     HL,BC           ; add the integer returned by expression.
        POP     DE              ; pop the dimension pointer.                              ***
        POP     BC              ; pop dimension counter.
        DJNZ    o29C3           ; back to SV-COMMA if more dimensions
                                ; Note. during syntax checking, unless there
                                ; are more than 256 subscripts, the branch
                                ; back to SV-COMMA is always taken.

        BIT     7,C             ; are we checking syntax ?
                                ; then we've got a joker here.

;; SV-RPT-C
o2A12:  JR      NZ,o2A7A        ; forward to SL-RPT-C if so
                                ; 'Nonsense in BASIC'
                                ; more than 256 subscripts in BASIC line.

; but in runtime the number of subscripts are at least the same as dims

        PUSH    HL              ; save data pointer.
        BIT     6,C             ; is it a string array ?
        JR      NZ,o2A2C        ; forward to SV-ELEM$ if so.

; a runtime numeric array subscript.

        LD      B,D             ; register DE has advanced past all dimensions
        LD      C,E             ; and points to start of data in variable.
                                ; transfer it to BC.

        RST     18H             ; GET-CHAR checks BASIC line
        CP      $29             ; must be a ')' ?
        JR      Z,o2A22         ; skip to SV-NUMBER if so

; else more subscripts in BASIC line than the variable definition.

;; REPORT-3
o2A20:  RST     08H             ; ERROR-1
        DEFB    $02             ; Error Report: Subscript wrong

; continue if subscripts matched the numeric array.

;; SV-NUMBER
o2A22:  RST     20H             ; NEXT-CHAR moves CH_ADD to next statement
                                ; - finished parsing.

        POP     HL              ; pop the data pointer.
        LD      DE,$0005        ; each numeric element is 5 bytes.
        CALL    o2AF4           ; routine GET-HL*DE multiplies.
        ADD     HL,BC           ; now add to start of data in the variable.

        RET                     ; return with HL pointing at the numeric
                                ; array subscript.                       ->

; ---------------------------------------------------------------

; the branch was here for string subscripts when the number of subscripts
; in the BASIC line was one less than in variable definition.

;; SV-ELEM$
o2A2C:  CALL    o2AEE           ; routine DE,(DE+1) gets final dimension
                                ; the length of strings in this array.
        EX      (SP),HL         ; start pointer to stack, data pointer to HL.
        CALL    o2AF4           ; routine GET-HL*DE multiplies by element
                                ; size.
        POP     BC              ; the start of data pointer is added
        ADD     HL,BC           ; in - now points to location before.
        INC     HL              ; point to start of required string.
        LD      B,D             ; transfer the length (final dimension size)
        LD      C,E             ; from DE to BC.
        EX      DE,HL           ; put start in DE.
        CALL    o2AB1           ; routine STK-ST-0 stores the string parameters
                                ; with A=0 - a slice or subscript.

; now check that there were no more subscripts in the BASIC line.

        RST     18H             ; GET-CHAR
        CP      $29             ; is it ')' ?
        JR      Z,o2A48         ; forward to SV-DIM to consider a separate
                                ; subscript or/and a slice.

        CP      $2C             ; a comma is allowed if the final subscript
                                ; is to be sliced e.g. a$(2,3,4 TO 6).
        JR      NZ,o2A20        ; to REPORT-3 with anything else
                                ; 'Subscript error'

;; SV-SLICE
o2A45:  CALL    o2A52           ; routine SLICING slices the string.

; but a slice of a simple string can itself be sliced.

;; SV-DIM
o2A48:  RST     20H             ; NEXT-CHAR

;; SV-SLICE?
o2A49:  CP      $28             ; is character '(' ?
        JR      Z,o2A45         ; loop back if so to SV-SLICE

        RES     6,(IY+$01)      ; update FLAGS  - Signal string result
        RET                     ; and return.

; ---

; The above section deals with the flexible syntax allowed.
; DIM a$(3,3,10) can be considered as two dimensional array of ten-character
; strings or a 3-dimensional array of characters.
; a$(1,1) will return a 10-character string as will a$(1,1,1 TO 10)
; a$(1,1,1) will return a single character.
; a$(1,1) (1 TO 6) is the same as a$(1,1,1 TO 6)
; A slice can itself be sliced ad infinitum
; b$ () () () () () () (2 TO 10) (2 TO 9) (3) is the same as b$(5)



; -------------------------
; Handle slicing of strings
; -------------------------
; The syntax of string slicing is very natural and it is as well to reflect
; on the permutations possible.
; a$() and a$( TO ) indicate the entire string although just a$ would do
; and would avoid coming here.
; h$(16) indicates the single character at position 16.
; a$( TO 32) indicates the first 32 characters.
; a$(257 TO) indicates all except the first 256 characters.
; a$(19000 TO 19999) indicates the thousand characters at position 19000.
; Also a$(9 TO 5) returns a null string not an error.
; This enables a$(2 TO) to return a null string if the passed string is
; of length zero or 1.
; A string expression in brackets can be sliced. e.g. (STR$ PI) (3 TO )
; We arrived here from SCANNING with CH-ADD pointing to the initial '('
; or from above.

;; SLICING
o2A52:  CALL    o2530           ; routine SYNTAX-Z
        CALL    NZ,o2BF1        ; routine STK-FETCH fetches parameters of
                                ; string at runtime, start in DE, length
                                ; in BC. This could be an array subscript.

        RST     20H             ; NEXT-CHAR
        CP      $29             ; is it ')' ?     e.g. a$()
        JR      Z,o2AAD         ; forward to SL-STORE to store entire string.

        PUSH    DE              ; else save start address of string

        XOR     A               ; clear accumulator to use as a running flag.
        PUSH    AF              ; and save on stack before any branching.

        PUSH    BC              ; save length of string to be sliced.
        LD      DE,$0001        ; default the start point to position 1.

        RST     18H             ; GET-CHAR

        POP     HL              ; pop length to HL as default end point
                                ; and limit.

        CP      $CC             ; is it 'TO' ?    e.g. a$( TO 10000)
        JR      Z,o2A81         ; to SL-SECOND to evaluate second parameter.

        POP     AF              ; pop the running flag.

        CALL    o2ACD           ; routine INT-EXP2 fetches first parameter.

        PUSH    AF              ; save flag (will be $FF if parameter>limit)

        LD      D,B             ; transfer the start
        LD      E,C             ; to DE overwriting 0001.
        PUSH    HL              ; save original length.

        RST     18H             ; GET-CHAR
        POP     HL              ; pop the limit length.
        CP      $CC             ; is it 'TO' after a start ?
        JR      Z,o2A81         ; to SL-SECOND to evaluate second parameter

        CP      $29             ; is it ')' ?       e.g. a$(365)

;; SL-RPT-C
o2A7A:  JP      NZ,o1C8A        ; jump to REPORT-C with anything else
                                ; 'Nonsense in BASIC'

        LD      H,D             ; copy start
        LD      L,E             ; to end - just a one character slice.
        JR      o2A94           ; forward to SL-DEFINE.

; ---------------------

;; SL-SECOND
o2A81:  PUSH    HL              ; save limit length.

        RST     20H             ; NEXT-CHAR

        POP     HL              ; pop the length.

        CP      $29             ; is character ')' ?        e.g. a$(7 TO )
        JR      Z,o2A94         ; to SL-DEFINE using length as end point.

        POP     AF              ; else restore flag.
        CALL    o2ACD           ; routine INT-EXP2 gets second expression.

        PUSH    AF              ; save the running flag.

        RST     18H             ; GET-CHAR

        LD      H,B             ; transfer second parameter
        LD      L,C             ; to HL.              e.g. a$(42 to 99)
        CP      $29             ; is character a ')' ?
        JR      NZ,o2A7A        ; to SL-RPT-C if not
                                ; 'Nonsense in BASIC'

; we now have start in DE and an end in HL.

;; SL-DEFINE
o2A94:  POP     AF              ; pop the running flag.
        EX      (SP),HL         ; put end point on stack, start address to HL
        ADD     HL,DE           ; add address of string to the start point.
        DEC     HL              ; point to first character of slice.
        EX      (SP),HL         ; start address to stack, end point to HL (*)
        AND     A               ; prepare to subtract.
        SBC     HL,DE           ; subtract start point from end point.
        LD      BC,$0000        ; default the length result to zero.
        JR      C,o2AA8         ; forward to SL-OVER if start > end.

        INC     HL              ; increment the length for inclusive byte.

        AND     A               ; now test the running flag.
        JP      M,o2A20         ; jump back to REPORT-3 if $FF.
                                ; 'Subscript out of range'

        LD      B,H             ; transfer the length
        LD      C,L             ; to BC.

;; SL-OVER
o2AA8:  POP     DE              ; restore start address from machine stack ***
        RES     6,(IY+$01)      ; update FLAGS - signal string result for
                                ; syntax.

;; SL-STORE
o2AAD:  CALL    o2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
        RET     Z               ; return if checking syntax.
                                ; but continue to store the string in runtime.

; ------------------------------------
; other than from above, this routine is called from STK-VAR to stack
; a known string array element.
; ------------------------------------

;; STK-ST-0
o2AB1:  XOR     A               ; clear to signal a sliced string or element.

; -------------------------
; this routine is called from chr$, scrn$ etc. to store a simple string result.
; --------------------------

;; STK-STO-$
o2AB2:  RES     6,(IY+$01)      ; update FLAGS - signal string result.
                                ; and continue to store parameters of string.

; ---------------------------------------
; Pass five registers to calculator stack
; ---------------------------------------
; This subroutine puts five registers on the calculator stack.

;; STK-STORE
o2AB6:  PUSH    BC              ; save two registers
        CALL    o33A9           ; routine TEST-5-SP checks room and puts 5
                                ; in BC.
        POP     BC              ; fetch the saved registers.
        LD      HL,(STKEND)     ; make HL point to first empty location STKEND
        LD      (HL),A          ; place the 5 registers.
        INC     HL              ;
        LD      (HL),E          ;
        INC     HL              ;
        LD      (HL),D          ;
        INC     HL              ;
        LD      (HL),C          ;
        INC     HL              ;
        LD      (HL),B          ;
        INC     HL              ;
        LD      (STKEND),HL     ; update system variable STKEND.
        RET                     ; and return.

; -------------------------------------------
; Return result of evaluating next expression
; -------------------------------------------
; This clever routine is used to check and evaluate an integer expression
; which is returned in BC, setting A to $FF, if greater than a limit supplied
; in HL. It is used to check array subscripts, parameters of a string slice
; and the arguments of the DIM command. In the latter case, the limit check
; is not required and H is set to $FF. When checking optional string slice
; parameters, it is entered at the second entry point so as not to disturb
; the running flag A, which may be $00 or $FF from a previous invocation.

;; INT-EXP1
o2ACC:  XOR     A               ; set result flag to zero.

; -> The entry point is here if A is used as a running flag.

;; INT-EXP2
o2ACD:  PUSH    DE              ; preserve DE register throughout.
        PUSH    HL              ; save the supplied limit.
        PUSH    AF              ; save the flag.

        CALL    o1C82           ; routine EXPT-1NUM evaluates expression
                                ; at CH_ADD returning if numeric result,
                                ; with value on calculator stack.

        POP     AF              ; pop the flag.
        CALL    o2530           ; routine SYNTAX-Z
        JR      Z,o2AEB         ; forward to I-RESTORE if checking syntax so
                                ; avoiding a comparison with supplied limit.

        PUSH    AF              ; save the flag.

        CALL    o1E99           ; routine FIND-INT2 fetches value from
                                ; calculator stack to BC producing an error
                                ; if too high.

        POP     DE              ; pop the flag to D.
        LD      A,B             ; test value for zero and reject
        OR      C               ; as arrays and strings begin at 1.
        SCF                     ; set carry flag.
        JR      Z,o2AE8         ; forward to I-CARRY if zero.

        POP     HL              ; restore the limit.
        PUSH    HL              ; and save.
        AND     A               ; prepare to subtract.
        SBC     HL,BC           ; subtract value from limit.

;; I-CARRY
o2AE8:  LD      A,D             ; move flag to accumulator $00 or $FF.
        SBC     A,$00           ; will set to $FF if carry set.

;; I-RESTORE
o2AEB:  POP     HL              ; restore the limit.
        POP     DE              ; and DE register.
        RET                     ; return.


; -----------------------
; LD DE,(DE+1) Subroutine
; -----------------------
; This routine just loads the DE register with the contents of the two
; locations following the location addressed by DE.
; It is used to step along the 16-bit dimension sizes in array definitions.
; Note. Such code is made into subroutines to make programs easier to
; write and it would use less space to include the five instructions in-line.
; However, there are so many exchanges going on at the places this is invoked
; that to implement it in-line would make the code hard to follow.
; It probably had a zippier label though as the intention is to simplify the
; program.

;; DE,(DE+1)
o2AEE:  EX      DE,HL           ;
        INC     HL              ;
        LD      E,(HL)          ;
        INC     HL              ;
        LD      D,(HL)          ;
        RET                     ;

; -------------------
; HL=HL*DE Subroutine
; -------------------
; This routine calls the mathematical routine to multiply HL by DE in runtime.
; It is called from STK-VAR and from DIM. In the latter case syntax is not
; being checked so the entry point could have been at the second CALL
; instruction to save a few clock-cycles.

;; GET-HL*DE
o2AF4:  CALL    o2530           ; routine SYNTAX-Z.
        RET     Z               ; return if checking syntax.

        CALL    o30A9           ; routine HL-HL*DE.
        JP      C,o1F15         ; jump back to REPORT-4 if over 65535.

        RET                     ; else return with 16-bit result in HL.

; -----------------
; THE 'LET' COMMAND
; -----------------
; Sinclair BASIC adheres to the ANSI-78 standard and a LET is required in
; assignments e.g. LET a = 1  :   LET h$ = "hat".
;
; Long names may contain spaces but not colour controls (when assigned).
; a substring can appear to the left of the equals sign.

; An earlier mathematician Lewis Carroll may have been pleased that
; 10 LET Babies cannot manage crocodiles = Babies are illogical AND
;    Nobody is despised who can manage a crocodile AND Illogical persons
;    are despised
; does not give the 'Nonsense..' error if the three variables exist.
; I digress.

;; LET
o2AFF:  LD      HL,($5C4D)      ; fetch system variable DEST to HL.
        BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
        JR      Z,o2B66         ; forward to L-EXISTS if not.

; continue for a new variable. DEST points to start in BASIC line.
; from the CLASS routines.

        LD      BC,$0005        ; assume numeric and assign an initial 5 bytes

;; L-EACH-CH
o2B0B:  INC     BC              ; increase byte count for each relevant
                                ; character

;; L-NO-SP
o2B0C:  INC     HL              ; increase pointer.
        LD      A,(HL)          ; fetch character.
        CP      $20             ; is it a space ?
        JR      Z,o2B0C         ; back to L-NO-SP is so.

        JR      NC,o2B1F        ; forward to L-TEST-CH if higher.

        CP      $10             ; is it $00 - $0F ?
        JR      C,o2B29         ; forward to L-SPACES if so.

        CP      $16             ; is it $16 - $1F ?
        JR      NC,o2B29        ; forward to L-SPACES if so.

; it was $10 - $15  so step over a colour code.

        INC     HL              ; increase pointer.
        JR      o2B0C           ; loop back to L-NO-SP.

; ---

; the branch was to here if higher than space.

;; L-TEST-CH
o2B1F:  CALL    o2C88           ; routine ALPHANUM sets carry if alphanumeric
        JR      C,o2B0B         ; loop back to L-EACH-CH for more if so.

        CP      $24             ; is it '$' ?
        JP      Z,o2BC0         ; jump forward if so, to L-NEW$
                                ; with a new string.

;; L-SPACES
o2B29:  LD      A,C             ; save length lo in A.
        LD      HL,($5C59)      ; fetch E_LINE to HL.
        DEC     HL              ; point to location before, the variables
                                ; end-marker.
        CALL    o1655           ; routine MAKE-ROOM creates BC spaces
                                ; for name and numeric value.
        INC     HL              ; advance to first new location.
        INC     HL              ; then to second.
        EX      DE,HL           ; set DE to second location.
        PUSH    DE              ; save this pointer.
        LD      HL,($5C4D)      ; reload HL with DEST.
        DEC     DE              ; point to first.
        SUB     $06             ; subtract six from length_lo.
        LD      B,A             ; save count in B.
        JR      Z,o2B4F         ; forward to L-SINGLE if it was just
                                ; one character.

; HL points to start of variable name after 'LET' in BASIC line.

;; L-CHAR
o2B3E:  INC     HL              ; increase pointer.
        LD      A,(HL)          ; pick up character.
        CP      $21             ; is it space or higher ?
        JR      C,o2B3E         ; back to L-CHAR with space and less.

        OR      $20             ; make variable lower-case.
        INC     DE              ; increase destination pointer.
        LD      (DE),A          ; and load to edit line.
        DJNZ    o2B3E           ; loop back to L-CHAR until B is zero.

        OR      $80             ; invert the last character.
        LD      (DE),A          ; and overwrite that in edit line.

; now consider first character which has bit 6 set

        LD      A,$C0           ; set A 11000000 is xor mask for a long name.
                                ; %101      is xor/or  result

; single character numerics rejoin here with %00000000 in mask.
;                                            %011      will be xor/or result

;; L-SINGLE
o2B4F:  LD      HL,($5C4D)      ; fetch DEST - HL addresses first character.
        XOR     (HL)            ; apply variable type indicator mask (above).
        OR      $20             ; make lowercase - set bit 5.
        POP     HL              ; restore pointer to 2nd character.
        CALL    o2BEA           ; routine L-FIRST puts A in first character.
                                ; and returns with HL holding
                                ; new E_LINE-1  the $80 vars end-marker.

;; L-NUMERIC
o2B59:  PUSH    HL              ; save the pointer.

; the value of variable is deleted but remains after calculator stack.

        RST     28H             ;; FP-CALC
        DEFB    $02             ;;delete      ; delete variable value
        DEFB    $38             ;;end-calc

; DE (STKEND) points to start of value.

        POP     HL              ; restore the pointer.
        LD      BC,$0005        ; start of number is five bytes before.
        AND     A               ; prepare for true subtraction.
        SBC     HL,BC           ; HL points to start of value.
        JR      o2BA6           ; forward to L-ENTER  ==>

; ---


; the jump was to here if the variable already existed.

;; L-EXISTS
o2B66:  BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
        JR      Z,o2B72         ; skip forward to L-DELETE$   -*->
                                ; if string result.

; A numeric variable could be simple or an array element.
; They are treated the same and the old value is overwritten.

        LD      DE,$0006        ; six bytes forward points to loc past value.
        ADD     HL,DE           ; add to start of number.
        JR      o2B59           ; back to L-NUMERIC to overwrite value.

; ---

; -*-> the branch was here if a string existed.

;; L-DELETE$
o2B72:  LD      HL,($5C4D)      ; fetch DEST to HL.
                                ; (still set from first instruction)
        LD      BC,($5C72)      ; fetch STRLEN to BC.
        BIT     0,(IY+$37)      ; test FLAGX - handling a complete simple
                                ; string ?
        JR      NZ,o2BAF        ; forward to L-ADD$ if so.

; must be a string array or a slice in workspace.
; Note. LET a$(3 TO 6) = h$   will assign "hat " if h$ = "hat"
;                                  and    "hats" if h$ = "hatstand".
;
; This is known as Procrustean lengthening and shortening after a
; character Procrustes in Greek legend who made travellers sleep in his bed,
; cutting off their feet or stretching them so they fitted the bed perfectly.
; The bloke was hatstand and slain by Theseus.

        LD      A,B             ; test if length
        OR      C               ; is zero and
        RET     Z               ; return if so.

        PUSH    HL              ; save pointer to start.

        RST     30H             ; BC-SPACES creates room.
        PUSH    DE              ; save pointer to first new location.
        PUSH    BC              ; and length            (*)
        LD      D,H             ; set DE to point to last location.
        LD      E,L             ;
        INC     HL              ; set HL to next location.
        LD      (HL),$20        ; place a space there.
        LDDR                    ; copy bytes filling with spaces.

        PUSH    HL              ; save pointer to start.
        CALL    o2BF1           ; routine STK-FETCH start to DE,
                                ; length to BC.
        POP     HL              ; restore the pointer.
        EX      (SP),HL         ; (*) length to HL, pointer to stack.
        AND     A               ; prepare for true subtraction.
        SBC     HL,BC           ; subtract old length from new.
        ADD     HL,BC           ; and add back.
        JR      NC,o2B9B        ; forward if it fits to L-LENGTH.

        LD      B,H             ; otherwise set
        LD      C,L             ; length to old length.
                                ; "hatstand" becomes "hats"

;; L-LENGTH
o2B9B:  EX      (SP),HL         ; (*) length to stack, pointer to HL.
        EX      DE,HL           ; pointer to DE, start of string to HL.
        LD      A,B             ; is the length zero ?
        OR      C               ;
        JR      Z,o2BA3         ; forward to L-IN-W/S if so
                                ; leaving prepared spaces.

        LDIR                    ; else copy bytes overwriting some spaces.

;; L-IN-W/S
o2BA3:  POP     BC              ; pop the new length.  (*)
        POP     DE              ; pop pointer to new area.
        POP     HL              ; pop pointer to variable in assignment.
                                ; and continue copying from workspace
                                ; to variables area.

; ==> branch here from  L-NUMERIC

;; L-ENTER
o2BA6:  EX      DE,HL           ; exchange pointers HL=STKEND DE=end of vars.
        LD      A,B             ; test the length
        OR      C               ; and make a
        RET     Z               ; return if zero (strings only).

        PUSH    DE              ; save start of destination.
        LDIR                    ; copy bytes.
        POP     HL              ; address the start.
        RET                     ; and return.

; ---

; the branch was here from L-DELETE$ if an existing simple string.
; register HL addresses start of string in variables area.

;; L-ADD$
o2BAF:  DEC     HL              ; point to high byte of length.
        DEC     HL              ; to low byte.
        DEC     HL              ; to letter.
        LD      A,(HL)          ; fetch masked letter to A.
        PUSH    HL              ; save the pointer on stack.
        PUSH    BC              ; save new length.
        CALL    o2BC6           ; routine L-STRING adds new string at end
                                ; of variables area.
                                ; if no room we still have old one.
        POP     BC              ; restore length.
        POP     HL              ; restore start.
        INC     BC              ; increase
        INC     BC              ; length by three
        INC     BC              ; to include character and length bytes.
        JP      o19E8           ; jump to indirect exit via RECLAIM-2
                                ; deleting old version and adjusting pointers.

; ---

; the jump was here with a new string variable.

;; L-NEW$
o2BC0:  LD      A,$DF           ; indicator mask %11011111 for
                                ;                %010xxxxx will be result
        LD      HL,($5C4D)      ; address DEST first character.
        AND     (HL)            ; combine mask with character.

;; L-STRING
o2BC6:  PUSH    AF              ; save first character and mask.
        CALL    o2BF1           ; routine STK-FETCH fetches parameters of
                                ; the string.
        EX      DE,HL           ; transfer start to HL.
        ADD     HL,BC           ; add to length.
        PUSH    BC              ; save the length.
        DEC     HL              ; point to end of string.
        LD      ($5C4D),HL      ; save pointer in DEST.
                                ; (updated by POINTERS if in workspace)
        INC     BC              ; extra byte for letter.
        INC     BC              ; two bytes
        INC     BC              ; for the length of string.
        LD      HL,($5C59)      ; address E_LINE.
        DEC     HL              ; now end of VARS area.
        CALL    o1655           ; routine MAKE-ROOM makes room for string.
                                ; updating pointers including DEST.
        LD      HL,($5C4D)      ; pick up pointer to end of string from DEST.
        POP     BC              ; restore length from stack.
        PUSH    BC              ; and save again on stack.
        INC     BC              ; add a byte.
        LDDR                    ; copy bytes from end to start.
        EX      DE,HL           ; HL addresses length low
        INC     HL              ; increase to address high byte
        POP     BC              ; restore length to BC
        LD      (HL),B          ; insert high byte
        DEC     HL              ; address low byte location
        LD      (HL),C          ; insert that byte
        POP     AF              ; restore character and mask

;; L-FIRST
o2BEA:  DEC     HL              ; address variable name
        LD      (HL),A          ; and insert character.
        LD      HL,($5C59)      ; load HL with E_LINE.
        DEC     HL              ; now end of VARS area.
        RET                     ; return

; ------------------------------------
; Get last value from calculator stack
; ------------------------------------
;
;

;; STK-FETCH
o2BF1:  LD      HL,(STKEND)     ; STKEND
        DEC     HL              ;
        LD      B,(HL)          ;
        DEC     HL              ;
        LD      C,(HL)          ;
        DEC     HL              ;
        LD      D,(HL)          ;
        DEC     HL              ;
        LD      E,(HL)          ;
        DEC     HL              ;
        LD      A,(HL)          ;
        LD      (STKEND),HL     ; STKEND
        RET                     ;

; ------------------
; Handle DIM command
; ------------------
; e.g. DIM a(2,3,4,7): DIM a$(32) : DIM b$(20,2,768) : DIM c$(20000)
; the only limit to dimensions is memory so, for example,
; DIM a(2,2,2,2,2,2,2,2,2,2,2,2,2) is possible and creates a multi-
; dimensional array of zeros. String arrays are initialized to spaces.
; It is not possible to erase an array, but it can be re-dimensioned to
; a minimal size of 1, after use, to free up memory.

;; DIM
o2C02:  CALL    o28B2           ; routine LOOK-VARS

;; D-RPORT-C
o2C05:  JP      NZ,o1C8A        ; jump to REPORT-C if a long-name variable.
                                ; DIM lottery numbers(49) doesn't work.

        CALL    o2530           ; routine SYNTAX-Z
        JR      NZ,o2C15        ; forward to D-RUN in runtime.

        RES     6,C             ; signal 'numeric' array even if string as
                                ; this simplifies the syntax checking.

        CALL    o2996           ; routine STK-VAR checks syntax.
        CALL    o1BEE           ; routine CHECK-END performs early exit ->

; the branch was here in runtime.

;; D-RUN
o2C15:  JR      C,o2C1F         ; skip to D-LETTER if variable did not exist.
                                ; else reclaim the old one.

        PUSH    BC              ; save type in C.
        CALL    o19B8           ; routine NEXT-ONE find following variable
                                ; or position of $80 end-marker.
        CALL    o19E8           ; routine RECLAIM-2 reclaims the
                                ; space between.
        POP     BC              ; pop the type.

;; D-LETTER
o2C1F:  SET     7,C             ; signal array.
        LD      B,$00           ; initialize dimensions to zero and
        PUSH    BC              ; save with the type.
        LD      HL,$0001        ; make elements one character presuming string
        BIT     6,C             ; is it a string ?
        JR      NZ,o2C2D        ; forward to D-SIZE if so.

        LD      L,$05           ; make elements 5 bytes as is numeric.

;; D-SIZE
o2C2D:  EX      DE,HL           ; save the element size in DE.

; now enter a loop to parse each of the integers in the list.

;; D-NO-LOOP
o2C2E:  RST     20H             ; NEXT-CHAR
        LD      H,$FF           ; disable limit check by setting HL high
        CALL    o2ACC           ; routine INT-EXP1
        JP      C,o2A20         ; to REPORT-3 if > 65280 and then some
                                ; 'Subscript out of range'

        POP     HL              ; pop dimension counter, array type
        PUSH    BC              ; save dimension size                     ***
        INC     H               ; increment the dimension counter
        PUSH    HL              ; save the dimension counter
        LD      H,B             ; transfer size
        LD      L,C             ; to HL
        CALL    o2AF4           ; routine GET-HL*DE multiplies dimension by
                                ; running total of size required initially
                                ; 1 or 5.
        EX      DE,HL           ; save running total in DE

        RST     18H             ; GET-CHAR
        CP      $2C             ; is it ',' ?
        JR      Z,o2C2E         ; loop back to D-NO-LOOP until all dimensions
                                ; have been considered

; when loop complete continue.

        CP      $29             ; is it ')' ?
        JR      NZ,o2C05        ; to D-RPORT-C with anything else
                                ; 'Nonsense in BASIC'


        RST     20H             ; NEXT-CHAR advances to next statement/CR

        POP     BC              ; pop dimension counter/type
        LD      A,C             ; type to A

; now calculate space required for array variable

        LD      L,B             ; dimensions to L since these require 16 bits
                                ; then this value will be doubled
        LD      H,$00           ; set high byte to zero

; another four bytes are required for letter(1), total length(2), number of
; dimensions(1) but since we have yet to double allow for two

        INC     HL              ; increment
        INC     HL              ; increment

        ADD     HL,HL           ; now double giving 4 + dimensions * 2

        ADD     HL,DE           ; add to space required for array contents

        JP      C,o1F15         ; to REPORT-4 if > 65535
                                ; 'Out of memory'

        PUSH    DE              ; save data space
        PUSH    BC              ; save dimensions/type
        PUSH    HL              ; save total space
        LD      B,H             ; total space
        LD      C,L             ; to BC
        LD      HL,($5C59)      ; address E_LINE - first location after
                                ; variables area
        DEC     HL              ; point to location before - the $80 end-marker
        CALL    o1655           ; routine MAKE-ROOM creates the space if
                                ; memory is available.

        INC     HL              ; point to first new location and
        LD      (HL),A          ; store letter/type

        POP     BC              ; pop total space
        DEC     BC              ; exclude name
        DEC     BC              ; exclude the 16-bit
        DEC     BC              ; counter itself
        INC     HL              ; point to next location the 16-bit counter
        LD      (HL),C          ; insert low byte
        INC     HL              ; address next
        LD      (HL),B          ; insert high byte

        POP     BC              ; pop the number of dimensions.
        LD      A,B             ; dimensions to A
        INC     HL              ; address next
        LD      (HL),A          ; and insert "No. of dims"

        LD      H,D             ; transfer DE space + 1 from make-room
        LD      L,E             ; to HL
        DEC     DE              ; set DE to next location down.
        LD      (HL),$00        ; presume numeric and insert a zero
        BIT     6,C             ; test bit 6 of C. numeric or string ?
        JR      Z,o2C7C         ; skip to DIM-CLEAR if numeric

        LD      (HL),$20        ; place a space character in HL

;; DIM-CLEAR
o2C7C:  POP     BC              ; pop the data length

        LDDR                    ; LDDR sets to zeros or spaces

; The number of dimensions is still in A.
; A loop is now entered to insert the size of each dimension that was pushed
; during the D-NO-LOOP working downwards from position before start of data.

;; DIM-SIZES
o2C7F:  POP     BC              ; pop a dimension size                    ***
        LD      (HL),B          ; insert high byte at position
        DEC     HL              ; next location down
        LD      (HL),C          ; insert low byte
        DEC     HL              ; next location down
        DEC     A               ; decrement dimension counter
        JR      NZ,o2C7F        ; back to DIM-SIZES until all done.

        RET                     ; return.

; -----------------------------
; Check whether digit or letter
; -----------------------------
; This routine checks that the character in A is alphanumeric
; returning with carry set if so.

;; ALPHANUM
o2C88:  CALL    o2D1B           ; routine NUMERIC will reset carry if so.
        CCF                     ; Complement Carry Flag
        RET     C               ; Return if numeric else continue into
                                ; next routine.

; This routine checks that the character in A is alphabetic

;; ALPHA
o2C8D:  CP      $41             ; less than 'A' ?
        CCF                     ; Complement Carry Flag
        RET     NC              ; return if so

        CP      $5B             ; less than 'Z'+1 ?
        RET     C               ; is within first range

        CP      $61             ; less than 'a' ?
        CCF                     ; Complement Carry Flag
        RET     NC              ; return if so.

        CP      $7B             ; less than 'z'+1 ?
        RET                     ; carry set if within a-z.

; -------------------------
; Decimal to floating point
; -------------------------
; This routine finds the floating point number represented by an expression
; beginning with BIN, '.' or a digit.
; Note that BIN need not have any '0's or '1's after it.
; BIN is really just a notational symbol and not a function.

;; DEC-TO-FP
o2C9B:  CP      $C4             ; 'BIN' token ?
        JR      NZ,o2CB8        ; to NOT-BIN if not

        LD      DE,$0000        ; initialize 16 bit buffer register.

;; BIN-DIGIT
o2CA2:  RST     20H             ; NEXT-CHAR
        SUB     $31             ; '1'
        ADC     A,$00           ; will be zero if '1' or '0'
                                ; carry will be set if was '0'
        JR      NZ,o2CB3        ; forward to BIN-END if result not zero

        EX      DE,HL           ; buffer to HL
        CCF                     ; Carry now set if originally '1'
        ADC     HL,HL           ; shift the carry into HL
        JP      C,o31AD         ; to REPORT-6 if overflow - too many digits
                                ; after first '1'. There can be an unlimited
                                ; number of leading zeros.
                                ; 'Number too big' - raise an error

        EX      DE,HL           ; save the buffer
        JR      o2CA2           ; back to BIN-DIGIT for more digits

; ---

;; BIN-END
o2CB3:  LD      B,D             ; transfer 16 bit buffer
        LD      C,E             ; to BC register pair.
        JP      o2D2B           ; JUMP to STACK-BC to put on calculator stack

; ---

; continue here with .1,  42, 3.14, 5., 2.3 E -4

;; NOT-BIN
o2CB8:  CP      $2E             ; '.' - leading decimal point ?
        JR      Z,o2CCB         ; skip to DECIMAL if so.

        CALL    o2D3B           ; routine INT-TO-FP to evaluate all digits
                                ; This number 'x' is poaced on stack.
        CP      $2E             ; '.' - mid decimal point ?

        JR      NZ,o2CEB        ; to E-FORMAT if not to consider that format

        RST     20H             ; NEXT-CHAR
        CALL    o2D1B           ; routine NUMERIC returns carry reset if 0-9

        JR      C,o2CEB         ; to E-FORMAT if not a digit e.g. '1.'

        JR      o2CD5           ; to DEC-STO-1 to add the decimal part to 'x'

; ---

; a leading decimal point has been found in a number.

;; DECIMAL
o2CCB:  RST     20H             ; NEXT-CHAR
        CALL    o2D1B           ; routine NUMERIC will reset carry if digit

;; DEC-RPT-C
o2CCF:  JP      C,o1C8A         ; to REPORT-C if just a '.'
                                ; raise 'Nonsense in BASIC'

; since there is no leading zero put one on the calculator stack.

        RST     28H             ;; FP-CALC
        DEFB    $A0             ;;stk-zero  ; 0.
        DEFB    $38             ;;end-calc

; If rejoining from earlier there will be a value 'x' on stack.
; If continuing from above the value zero.
; Now store 1 in mem-0.
; Note. At each pass of the digit loop this will be divided by ten.

;; DEC-STO-1
o2CD5:  RST     28H             ;; FP-CALC
        DEFB    $A1             ;;stk-one   ;x or 0,1.
        DEFB    $C0             ;;st-mem-0  ;x or 0,1.
        DEFB    $02             ;;delete    ;x or 0.
        DEFB    $38             ;;end-calc


;; NXT-DGT-1
o2CDA:  RST     18H             ; GET-CHAR
        CALL    o2D22           ; routine STK-DIGIT stacks single digit 'd'
        JR      C,o2CEB         ; exit to E-FORMAT when digits exhausted  >


        RST     28H             ;; FP-CALC   ;x or 0,d.           first pass.
        DEFB    $E0             ;;get-mem-0  ;x or 0,d,1.
        DEFB    $A4             ;;stk-ten    ;x or 0,d,1,10.
        DEFB    $05             ;;division   ;x or 0,d,1/10.
        DEFB    $C0             ;;st-mem-0   ;x or 0,d,1/10.
        DEFB    $04             ;;multiply   ;x or 0,d/10.
        DEFB    $0F             ;;addition   ;x or 0 + d/10.
        DEFB    $38             ;;end-calc   last value.

        RST     20H             ; NEXT-CHAR  moves to next character
        JR      o2CDA           ; back to NXT-DGT-1

; ---

; although only the first pass is shown it can be seen that at each pass
; the new less significant digit is multiplied by an increasingly smaller
; factor (1/100, 1/1000, 1/10000 ... ) before being added to the previous
; last value to form a new last value.

; Finally see if an exponent has been input.

;; E-FORMAT
o2CEB:  CP      $45             ; is character 'E' ?
        JR      Z,o2CF2         ; to SIGN-FLAG if so

        CP      $65             ; 'e' is acceptable as well.
        RET     NZ              ; return as no exponent.

;; SIGN-FLAG
o2CF2:  LD      B,$FF           ; initialize temporary sign byte to $FF

        RST     20H             ; NEXT-CHAR
        CP      $2B             ; is character '+' ?
        JR      Z,o2CFE         ; to SIGN-DONE

        CP      $2D             ; is character '-' ?
        JR      NZ,o2CFF        ; to ST-E-PART as no sign

        INC     B               ; set sign to zero

; now consider digits of exponent.
; Note. incidentally this is the only occasion in Spectrum BASIC when an
; expression may not be used when a number is expected.

;; SIGN-DONE
o2CFE:  RST     20H             ; NEXT-CHAR

;; ST-E-PART
o2CFF:  CALL    o2D1B           ; routine NUMERIC
        JR      C,o2CCF         ; to DEC-RPT-C if not
                                ; raise 'Nonsense in BASIC'.

        PUSH    BC              ; save sign (in B)
        CALL    o2D3B           ; routine INT-TO-FP places exponent on stack
        CALL    o2DD5           ; routine FP-TO-A  transfers it to A
        POP     BC              ; restore sign
        JP      C,o31AD         ; to REPORT-6 if overflow (over 255)
                                ; raise 'Number too big'.

        AND     A               ; set flags
        JP      M,o31AD         ; to REPORT-6 if over '127'.
                                ; raise 'Number too big'.
                                ; 127 is still way too high and it is
                                ; impossible to enter an exponent greater
                                ; than 39 from the keyboard. The error gets
                                ; raised later in E-TO-FP so two different
                                ; error messages depending how high A is.

        INC     B               ; $FF to $00 or $00 to $01 - expendable now.
        JR      Z,o2D18         ; forward to E-FP-JUMP if exponent positive

        NEG                     ; Negate the exponent.

;; E-FP-JUMP
o2D18:  JP      o2D4F           ; JUMP forward to E-TO-FP to assign to
                                ; last value x on stack x * 10 to power A
                                ; a relative jump would have done.

; ---------------------
; Check for valid digit
; ---------------------
; This routine checks that the ASCII character in A is numeric
; returning with carry reset if so.

;; NUMERIC
o2D1B:  CP      $30             ; '0'
        RET     C               ; return if less than zero character.

        CP      $3A             ; The upper test is '9'
        CCF                     ; Complement Carry Flag
        RET                     ; Return - carry clear if character '0' - '9'

; -----------
; Stack Digit
; -----------
; This subroutine is called from INT-TO-FP and DEC-TO-FP to stack a digit
; on the calculator stack.

;; STK-DIGIT
o2D22:  CALL    o2D1B           ; routine NUMERIC
        RET     C               ; return if not numeric character

        SUB     $30             ; convert from ASCII to digit

; -----------------
; Stack accumulator
; -----------------
;
;

;; STACK-A
o2D28:  LD      C,A             ; transfer to C
        LD      B,$00           ; and make B zero

; ----------------------
; Stack BC register pair
; ----------------------
;

;; STACK-BC
o2D2B:  LD      IY,$5C3A        ; re-initialize ERR_NR

        XOR     A               ; clear to signal small integer
        LD      E,A             ; place in E for sign
        LD      D,C             ; LSB to D
        LD      C,B             ; MSB to C
        LD      B,A             ; last byte not used
        CALL    o2AB6           ; routine STK-STORE

        RST     28H             ;; FP-CALC
        DEFB    $38             ;;end-calc  make HL = STKEND-5

        AND     A               ; clear carry
        RET                     ; before returning

; -------------------------
; Integer to floating point
; -------------------------
; This routine places one or more digits found in a BASIC line
; on the calculator stack multiplying the previous value by ten each time
; before adding in the new digit to form a last value on calculator stack.

;; INT-TO-FP
o2D3B:  PUSH    AF              ; save first character

        RST     28H             ;; FP-CALC
        DEFB    $A0             ;;stk-zero    ; v=0. initial value
        DEFB    $38             ;;end-calc

        POP     AF              ; fetch first character back.

;; NXT-DGT-2
o2D40:  CALL    o2D22           ; routine STK-DIGIT puts 0-9 on stack
        RET     C               ; will return when character is not numeric >

        RST     28H             ;; FP-CALC    ; v, d.
        DEFB    $01             ;;exchange    ; d, v.
        DEFB    $A4             ;;stk-ten     ; d, v, 10.
        DEFB    $04             ;;multiply    ; d, v*10.
        DEFB    $0F             ;;addition    ; d + v*10 = newvalue
        DEFB    $38             ;;end-calc    ; v.

        CALL    o0074           ; routine CH-ADD+1 get next character
        JR      o2D40           ; back to NXT-DGT-2 to process as a digit


;*********************************
;** Part 9. ARITHMETIC ROUTINES **
;*********************************

; --------------------------
; E-format to floating point
; --------------------------
; This subroutine is used by the PRINT-FP routine and the decimal to FP
; routines to stack a number expressed in exponent format.
; Note. Though not used by the ROM as such, it has also been set up as
; a unary calculator literal but this will not work as the accumulator
; is not available from within the calculator.

; on entry there is a value x on the calculator stack and an exponent of ten
; in A.    The required value is x + 10 ^ A

;; e-to-fp
;; E-TO-FP
o2D4F:  RLCA                    ; this will set the          x.
        RRCA                    ; carry if bit 7 is set

        JR      NC,o2D55        ; to E-SAVE  if positive.

        CPL                     ; make negative positive
        INC     A               ; without altering carry.

;; E-SAVE
o2D55:  PUSH    AF              ; save positive exp and sign in carry

        LD      HL,$5C92        ; address MEM-0

        CALL    o350B           ; routine FP-0/1
                                ; places an integer zero, if no carry,
                                ; else a one in mem-0 as a sign flag

        RST     28H             ;; FP-CALC
        DEFB    $A4             ;;stk-ten                    x, 10.
        DEFB    $38             ;;end-calc

        POP     AF              ; pop the exponent.

; now enter a loop

;; E-LOOP
o2D60:  SRL     A               ; 0>76543210>C

        JR      NC,o2D71        ; forward to E-TST-END if no bit

        PUSH    AF              ; save shifted exponent.

        RST     28H             ;; FP-CALC
        DEFB    $C1             ;;st-mem-1                   x, 10.
        DEFB    $E0             ;;get-mem-0                  x, 10, (0/1).
        DEFB    $00             ;;jump-true

        DEFB    $04             ;;to o2D6D, E-DIVSN

        DEFB    $04             ;;multiply                   x*10.
        DEFB    $33             ;;jump

        DEFB    $02             ;;to o2D6E, E-FETCH

;; E-DIVSN
o2D6D:  DEFB    $05             ;;division                   x/10.

;; E-FETCH
o2D6E:  DEFB    $E1             ;;get-mem-1                  x/10 or x*10, 10.
        DEFB    $38             ;;end-calc                   new x, 10.

        POP     AF              ; restore shifted exponent

; the loop branched to here with no carry

;; E-TST-END
o2D71:  JR      Z,o2D7B         ; forward to E-END  if A emptied of bits

        PUSH    AF              ; re-save shifted exponent

        RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate                  new x, 10, 10.
        DEFB    $04             ;;multiply                   new x, 100.
        DEFB    $38             ;;end-calc

        POP     AF              ; restore shifted exponent
        JR      o2D60           ; back to E-LOOP  until all bits done.

; ---

; although only the first pass is shown it can be seen that for each set bit
; representing a power of two, x is multiplied or divided by the
; corresponding power of ten.

;; E-END
o2D7B:  RST     28H             ;; FP-CALC                   final x, factor.
        DEFB    $02             ;;delete                     final x.
        DEFB    $38             ;;end-calc                   x.

        RET                     ; return




; -------------
; Fetch integer
; -------------
; This routine is called by the mathematical routines - FP-TO-BC, PRINT-FP,
; mult, re-stack and negate to fetch an integer from address HL.
; HL points to the stack or a location in MEM and no deletion occurs.
; If the number is negative then a similar process to that used in INT-STORE
; is used to restore the twos complement number to normal in DE and a sign
; in C.

;; INT-FETCH
o2D7F:  INC     HL              ; skip zero indicator.
        LD      C,(HL)          ; fetch sign to C
        INC     HL              ; address low byte
        LD      A,(HL)          ; fetch to A
        XOR     C               ; two's complement
        SUB     C               ;
        LD      E,A             ; place in E
        INC     HL              ; address high byte
        LD      A,(HL)          ; fetch to A
        ADC     A,C             ; two's complement
        XOR     C               ;
        LD      D,A             ; place in D
        RET                     ; return

; ------------------------
; Store a positive integer
; ------------------------
; This entry point is not used in this ROM but would
; store any integer as positive.

;; p-int-sto
o2D8C:  LD      C,$00           ; make sign byte positive and continue

; -------------
; Store integer
; -------------
; this routine stores an integer in DE at address HL.
; It is called from mult, truncate, negate and sgn.
; The sign byte $00 +ve or $FF -ve is in C.
; If negative, the number is stored in 2's complement form so that it is
; ready to be added.

;; INT-STORE
o2D8E:  PUSH    HL              ; preserve HL

        LD      (HL),$00        ; first byte zero shows integer not exponent
        INC     HL              ;
        LD      (HL),C          ; then store the sign byte
        INC     HL              ;
                                ; e.g.             +1             -1
        LD      A,E             ; fetch low byte   00000001       00000001
        XOR     C               ; xor sign         00000000   or  11111111
                                ; gives            00000001   or  11111110
        SUB     C               ; sub sign         00000000   or  11111111
                                ; gives            00000001>0 or  11111111>C
        LD      (HL),A          ; store 2's complement.
        INC     HL              ;
        LD      A,D             ; high byte        00000000       00000000
        ADC     A,C             ; sign             00000000<0     11111111<C
                                ; gives            00000000   or  00000000
        XOR     C               ; xor sign         00000000       11111111
        LD      (HL),A          ; store 2's complement.
        INC     HL              ;
        LD      (HL),$00        ; last byte always zero for integers.
                                ; is not used and need not be looked at when
                                ; testing for zero but comes into play should
                                ; an integer be converted to fp.
        POP     HL              ; restore HL
        RET                     ; return.


; -----------------------------
; Floating point to BC register
; -----------------------------
; This routine gets a floating point number e.g. 127.4 from the calculator
; stack to the BC register.

;; FP-TO-BC
o2DA2:  RST     28H             ;; FP-CALC            set HL to
        DEFB    $38             ;;end-calc            point to last value.

        LD      A,(HL)          ; get first of 5 bytes
        AND     A               ; and test
        JR      Z,o2DAD         ; forward to FP-DELETE if an integer

; The value is first rounded up and then converted to integer.

        RST     28H             ;; FP-CALC           x.
        DEFB    $A2             ;;stk-half           x. 1/2.
        DEFB    $0F             ;;addition           x + 1/2.
        DEFB    $27             ;;int                int(x + .5)
        DEFB    $38             ;;end-calc

; now delete but leave HL pointing at integer

;; FP-DELETE
o2DAD:  RST     28H             ;; FP-CALC
        DEFB    $02             ;;delete
        DEFB    $38             ;;end-calc

        PUSH    HL              ; save pointer.
        PUSH    DE              ; and STKEND.
        EX      DE,HL           ; make HL point to exponent/zero indicator
        LD      B,(HL)          ; indicator to B
        CALL    o2D7F           ; routine INT-FETCH
                                ; gets int in DE sign byte to C
                                ; but meaningless values if a large integer

        XOR     A               ; clear A
        SUB     B               ; subtract indicator byte setting carry
                                ; if not a small integer.

        BIT     7,C             ; test a bit of the sign byte setting zero
                                ; if positive.

        LD      B,D             ; transfer int
        LD      C,E             ; to BC
        LD      A,E             ; low byte to A as a useful return value.

        POP     DE              ; pop STKEND
        POP     HL              ; and pointer to last value
        RET                     ; return
                                ; if carry is set then the number was too big.

; ------------
; LOG(2^A)
; ------------
; This routine is used when printing floating point numbers to calculate
; the number of digits before the decimal point.

; first convert a one-byte signed integer to its five byte form.

;; LOG(2^A)
o2DC1:  LD      D,A             ; store a copy of A in D.
        RLA                     ; test sign bit of A.
        SBC     A,A             ; now $FF if negative or $00
        LD      E,A             ; sign byte to E.
        LD      C,A             ; and to C
        XOR     A               ; clear A
        LD      B,A             ; and B.
        CALL    o2AB6           ; routine STK-STORE stacks number AEDCB

;  so 00 00 XX 00 00 (positive) or 00 FF XX FF 00 (negative).
;  i.e. integer indicator, sign byte, low, high, unused.

; now multiply exponent by log to the base 10 of two.

        RST      28H            ;; FP-CALC

        DEFB    $34             ;;stk-data                      .30103 (log 2)
        DEFB    $EF             ;;Exponent: $7F, Bytes: 4
        DEFB    $1A,$20,$9A,$85 ;;
        DEFB    $04             ;;multiply

        DEFB    $27             ;;int

        DEFB    $38             ;;end-calc

; -------------------
; Floating point to A
; -------------------
; this routine collects a floating point number from the stack into the
; accumulator returning carry set if not in range 0 - 255.
; Not all the calling routines raise an error with overflow so no attempt
; is made to produce an error report here.

;; FP-TO-A
o2DD5:  CALL    o2DA2           ; routine FP-TO-BC returns with C in A also.
        RET     C               ; return with carry set if > 65535, overflow

        PUSH    AF              ; save the value and flags
        DEC     B               ; and test that
        INC     B               ; the high byte is zero.
        JR      Z,o2DE1         ; forward  FP-A-END if zero

; else there has been 8-bit overflow

        POP     AF              ; retrieve the value
        SCF                     ; set carry flag to show overflow
        RET                     ; and return.

; ---

;; FP-A-END
o2DE1:  POP     AF              ; restore value and success flag and
        RET                     ; return.


; -----------------------------
; Print a floating point number
; -----------------------------
; Not a trivial task.
; Begin by considering whether to print a leading sign for negative numbers.

;; PRINT-FP
o2DE3:  RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate
        DEFB    $36             ;;less-0
        DEFB    $00             ;;jump-true

        DEFB    $0B             ;;to o2DF2, PF-NEGTVE

        DEFB    $31             ;;duplicate
        DEFB    $37             ;;greater-0
        DEFB    $00             ;;jump-true

        DEFB    $0D             ;;to o2DF8, PF-POSTVE

; must be zero itself

        DEFB    $02             ;;delete
        DEFB    $38             ;;end-calc

        LD      A,$30           ; prepare the character '0'

        RST     10H             ; PRINT-A
        RET                     ; return.                 ->
; ---

;; PF-NEGTVE
o2DF2:  DEFB    $2A             ;;abs
        DEFB    $38             ;;end-calc

        LD      A,$2D           ; the character '-'

        RST     10H             ; PRINT-A

; and continue to print the now positive number.

        RST     28H             ;; FP-CALC

;; PF-POSTVE
o2DF8:  DEFB    $A0             ;;stk-zero     x,0.     begin by
        DEFB    $C3             ;;st-mem-3     x,0.     clearing a temporary
        DEFB    $C4             ;;st-mem-4     x,0.     output buffer to
        DEFB    $C5             ;;st-mem-5     x,0.     fifteen zeros.
        DEFB    $02             ;;delete       x.
        DEFB    $38             ;;end-calc     x.

        EXX                     ; in case called from 'str$' then save the
        PUSH    HL              ; pointer to whatever comes after
        EXX                     ; str$ as H'L' will be used.

; now enter a loop?

;; PF-LOOP
o2E01:  RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate    x,x.
        DEFB    $27             ;;int          x,int x.
        DEFB    $C2             ;;st-mem-2     x,int x.
        DEFB    $03             ;;subtract     x-int x.     fractional part.
        DEFB    $E2             ;;get-mem-2    x-int x, int x.
        DEFB    $01             ;;exchange     int x, x-int x.
        DEFB    $C2             ;;st-mem-2     int x, x-int x.
        DEFB    $02             ;;delete       int x.
        DEFB    $38             ;;end-calc     int x.
                                ;
                                ; mem-2 holds the fractional part.

; HL points to last value int x

        LD      A,(HL)          ; fetch exponent of int x.
        AND     A               ; test
        JR      NZ,o2E56        ; forward to PF-LARGE if a large integer
                                ; > 65535

; continue with small positive integer components in range 0 - 65535
; if original number was say .999 then this integer component is zero.

        CALL    o2D7F           ; routine INT-FETCH gets x in DE
                                ; (but x is not deleted)

        LD      B,$10           ; set B, bit counter, to 16d

        LD      A,D             ; test if
        AND     A               ; high byte is zero
        JR      NZ,o2E1E        ; forward to PF-SAVE if 16-bit integer.

; and continue with integer in range 0 - 255.

        OR      E               ; test the low byte for zero
                                ; i.e. originally just point something or other.
        JR      Z,o2E24         ; forward if so to PF-SMALL

;

        LD      D,E             ; transfer E to D
        LD      B,$08           ; and reduce the bit counter to 8.

;; PF-SAVE
o2E1E:  PUSH    DE              ; save the part before decimal point.
        EXX                     ;
        POP     DE              ; and pop in into D'E'
        EXX                     ;
        JR      o2E7B           ; forward to PF-BITS

; ---------------------

; the branch was here when 'int x' was found to be zero as in say 0.5.
; The zero has been fetched from the calculator stack but not deleted and
; this should occur now. This omission leaves the stack unbalanced and while
; that causes no problems with a simple PRINT statement, it will if str$ is
; being used in an expression e.g. "2" + STR$ 0.5 gives the result "0.5"
; instead of the expected result "20.5".
; credit Tony Stratton, 1982.
; A DEFB 02 delete is required immediately on using the calculator.

;; PF-SMALL
o2E24:  RST     28H             ;; FP-CALC       int x = 0.
o2E25:  DEFB    $E2             ;;get-mem-2      int x = 0, x-int x.
        DEFB    $38             ;;end-calc

        LD      A,(HL)          ; fetch exponent of positive fractional number
        SUB     $7E             ; subtract

        CALL    o2DC1           ; routine LOG(2^A) calculates leading digits.

        LD      D,A             ; transfer count to D
        LD      A,($5CAC)       ; fetch total MEM-5-1
        SUB     D               ;
        LD      ($5CAC),A       ; MEM-5-1
        LD      A,D             ;
        CALL    o2D4F           ; routine E-TO-FP

        RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate
        DEFB    $27             ;;int
        DEFB    $C1             ;;st-mem-1
        DEFB    $03             ;;subtract
        DEFB    $E1             ;;get-mem-1
        DEFB    $38             ;;end-calc

        CALL    o2DD5           ; routine FP-TO-A

        PUSH    HL              ; save HL
        LD      ($5CA1),A       ; MEM-3-1
        DEC     A               ;
        RLA                     ;
        SBC     A,A             ;
        INC     A               ;

        LD      HL,$5CAB        ; address MEM-5-1 leading digit counter
        LD      (HL),A          ; store counter
        INC     HL              ; address MEM-5-2 total digits
        ADD     A,(HL)          ; add counter to contents
        LD      (HL),A          ; and store updated value
        POP     HL              ; restore HL

        JP      o2ECF           ; JUMP forward to PF-FRACTN

; ---

; Note. while it would be pedantic to comment on every occasion a JP
; instruction could be repoaced with a JR instruction, this applies to the
; above, which is useful if you wish to correct the unbalanced stack error
; by inserting a 'DEFB 02 delete' at o2E25, and maintain main addresses.

; the branch was here with a large positive integer > 65535 e.g. 123456789
; the accumulator holds the exponent.

;; PF-LARGE
o2E56:  SUB     $80             ; make exponent positive
        CP      $1C             ; compare to 28
        JR      C,o2E6F         ; to PF-MEDIUM if integer <= 2^27

        CALL    o2DC1           ; routine LOG(2^A)
        SUB     $07             ;
        LD      B,A             ;
        LD      HL,$5CAC        ; address MEM-5-1 the leading digits counter.
        ADD     A,(HL)          ; add A to contents
        LD      (HL),A          ; store updated value.
        LD      A,B             ;
        NEG                     ; negate
        CALL    o2D4F           ; routine E-TO-FP
        JR      o2E01           ; back to PF-LOOP

; ----------------------------

;; PF-MEDIUM
o2E6F:  EX      DE,HL           ;
        CALL    o2FBA           ; routine FETCH-TWO
        EXX                     ;
        SET     7,D             ;
        LD      A,L             ;
        EXX                     ;
        SUB     $80             ;
        LD      B,A             ;

; the branch was here to handle bits in DE with 8 or 16 in B  if small int
; and integer in D'E', 6 nibbles will accommodate 065535 but routine does
; 32-bit numbers as well from above

;; PF-BITS
o2E7B:  SLA     E               ;  C<xxxxxxxx<0
        RL      D               ;  C<xxxxxxxx<C
        EXX                     ;
        RL      E               ;  C<xxxxxxxx<C
        RL      D               ;  C<xxxxxxxx<C
        EXX                     ;

        LD      HL,$5CAA        ; set HL to mem-4-5th last byte of buffer
        LD      C,$05           ; set byte count to 5 -  10 nibbles

;; PF-BYTES
o2E8A:  LD      A,(HL)          ; fetch 0 or prev value
        ADC     A,A             ; shift left add in carry    C<xxxxxxxx<C

        DAA                     ; Decimal Adjust Accumulator.
                                ; if greater than 9 then the left hand
                                ; nibble is incremented. If greater than
                                ; 99 then adjusted and carry set.
                                ; so if we'd built up 7 and a carry came in
                                ;      0000 0111 < C
                                ;      0000 1111
                                ; daa     1 0101  which is 15 in BCD

        LD      (HL),A          ; put back
        DEC     HL              ; work down thru mem 4
        DEC     C               ; decrease the 5 counter.
        JR      NZ,o2E8A        ; back to PF-BYTES until the ten nibbles rolled

        DJNZ    o2E7B           ; back to PF-BITS until 8 or 16 (or 32) done

; at most 9 digits for 32-bit number will have been loaded with digits
; each of the 9 nibbles in mem 4 is poaced into ten bytes in mem-3 and mem 4
; unless the nibble is zero as the buffer is already zero.
; ( or in the case of mem-5 will become zero as a result of RLD instruction )

        XOR     A               ; clear to accept
        LD      HL,$5CA6        ; address MEM-4-0 byte destination.
        LD      DE,$5CA1        ; address MEM-3-0 nibble source.
        LD      B,$09           ; the count is 9 (not ten) as the first
                                ; nibble is known to be blank.

        RLD                     ; shift RH nibble to left in (HL)
                                ;    A           (HL)
                                ; 0000 0000 < 0000 3210
                                ; 0000 0000   3210 0000
                                ; A picks up the blank nibble


        LD      C,$FF           ; set a flag to indicate when a significant
                                ; digit has been encountered.

;; PF-DIGITS
o2EA1:  RLD                     ; pick up leftmost nibble from (HL)
                                ;    A           (HL)
                                ; 0000 0000 < 7654 3210
                                ; 0000 7654   3210 0000


        JR      NZ,o2EA9        ; to PF-INSERT if non-zero value picked up.

        DEC     C               ; test
        INC     C               ; flag
        JR      NZ,o2EB3        ; skip forward to PF-TEST-2 if flag still $FF
                                ; indicating this is a leading zero.

; but if the zero is a significant digit e.g. 10 then include in digit totals.
; the path for non-zero digits rejoins here.

;; PF-INSERT
o2EA9:  LD      (DE),A          ; insert digit at destination
        INC     DE              ; increase the destination pointer
        INC     (IY+$71)        ; increment MEM-5-1st  digit counter
        INC     (IY+$72)        ; increment MEM-5-2nd  leading digit counter
        LD      C,$00           ; set flag to zero indicating that any
                                ; subsequent zeros are significant and not
                                ; leading.

;; PF-TEST-2
o2EB3:  BIT     0,B             ; test if the nibble count is even
        JR      Z,o2EB8         ; skip to PF-ALL-9 if so to deal with the
                                ; other nibble in the same byte

        INC     HL              ; point to next source byte if not

;; PF-ALL-9
o2EB8:  DJNZ    o2EA1           ; decrement the nibble count, back to PF-DIGITS
                                ; if all nine not done.

; For 8-bit integers there will be at most 3 digits.
; For 16-bit integers there will be at most 5 digits.
; but for larger integers there could be nine leading digits.
; if nine digits complete then the last one is rounded up as the number will
; be printed using E-format notation

        LD      A,($5CAB)       ; fetch digit count from MEM-5-1st
        SUB     $09             ; subtract 9 - max possible
        JR      C,o2ECB         ; forward if less to PF-MORE

        DEC     (IY+$71)        ; decrement digit counter MEM-5-1st to 8
        LD      A,$04           ; load A with the value 4.
        CP      (IY+$6F)        ; compare with MEM-4-4th - the ninth digit
        JR      o2F0C           ; forward to PF-ROUND
                                ; to consider rounding.

; ---------------------------------------

; now delete int x from calculator stack and fetch fractional part.

;; PF-MORE
o2ECB:  RST     28H             ;; FP-CALC        int x.
        DEFB    $02             ;;delete          .
        DEFB    $E2             ;;get-mem-2       x - int x = f.
        DEFB    $38             ;;end-calc        f.

;; PF-FRACTN
o2ECF:  EX      DE,HL           ;
        CALL    o2FBA           ; routine FETCH-TWO
        EXX                     ;
        LD      A,$80           ;
        SUB     L               ;
        LD      L,$00           ;
        SET     7,D             ;
        EXX                     ;
        CALL    o2FDD           ; routine SHIFT-FP

;; PF-FRN-LP
o2EDF:  LD      A,(IY+$71)      ; MEM-5-1st
        CP      $08             ;
        JR      C,o2EEC         ; to PF-FR-DGT

        EXX                     ;
        RL      D               ;
        EXX                     ;
        JR      o2F0C           ; to PF-ROUND

; ---

;; PF-FR-DGT
o2EEC:  LD      BC,$0200        ;

;; PF-FR-EXX
o2EEF:  LD      A,E             ;
        CALL    o2F8B           ; routine CA-10*A+C
        LD      E,A             ;
        LD      A,D             ;
        CALL    o2F8B           ; routine CA-10*A+C
        LD      D,A             ;
        PUSH    BC              ;
        EXX                     ;
        POP     BC              ;
        DJNZ    o2EEF           ; to PF-FR-EXX

        LD      HL,$5CA1        ; MEM-3
        LD      A,C             ;
        LD      C,(IY+$71)      ; MEM-5-1st
        ADD     HL,BC           ;
        LD      (HL),A          ;
        INC     (IY+$71)        ; MEM-5-1st
        JR      o2EDF           ; to PF-FRN-LP

; ----------------

; 1) with 9 digits but 8 in mem-5-1 and A holding 4, carry set if rounding up.
; e.g.
;      999999999 is printed as 1E+9
;      100000001 is printed as 1E+8
;      100000009 is printed as 1.0000001E+8

;; PF-ROUND
o2F0C:  PUSH    AF              ; save A and flags
        LD      HL,$5CA1        ; address MEM-3 start of digits
        LD      C,(IY+$71)      ; MEM-5-1st No. of digits to C
        LD      B,$00           ; prepare to add
        ADD     HL,BC           ; address last digit + 1
        LD      B,C             ; No. of digits to B counter
        POP     AF              ; restore A and carry flag from comparison.

;; PF-RND-LP
o2F18:  DEC     HL              ; address digit at rounding position.
        LD      A,(HL)          ; fetch it
        ADC     A,$00           ; add carry from the comparison
        LD      (HL),A          ; put back result even if $0A.
        AND     A               ; test A
        JR      Z,o2F25         ; skip to PF-R-BACK if ZERO?

        CP      $0A             ; compare to 'ten' - overflow
        CCF                     ; complement carry flag so that set if ten.
        JR      NC,o2F2D        ; forward to PF-COUNT with 1 - 9.

;; PF-R-BACK
o2F25:  DJNZ    o2F18           ; loop back to PF-RND-LP

; if B counts down to zero then we've rounded right back as in 999999995.
; and the first 8 locations all hold $0A.


        LD      (HL),$01        ; load first location with digit 1.
        INC     B               ; make B hold 1 also.
                                ; could save an instruction byte here.
        INC     (IY+$72)        ; make MEM-5-2nd hold 1.
                                ; and proceed to initialize total digits to 1.

;; PF-COUNT
o2F2D:  LD      (IY+$71),B      ; MEM-5-1st

; now balance the calculator stack by deleting  it

        RST     28H             ;; FP-CALC
        DEFB    $02             ;;delete
        DEFB    $38             ;;end-calc

; note if used from str$ then other values may be on the calculator stack.
; we can also restore the next literal pointer from its position on the
; machine stack.

        EXX                     ;
        POP     HL              ; restore next literal pointer.
        EXX                     ;

        LD      BC,($5CAB)      ; set C to MEM-5-1st digit counter.
                                ; set B to MEM-5-2nd leading digit counter.
        LD      HL,$5CA1        ; set HL to start of digits at MEM-3-1
        LD      A,B             ;
        CP      $09             ;
        JR      C,o2F46         ; to PF-NOT-E

        CP      $FC             ;
        JR      C,o2F6C         ; to PF-E-FRMT

;; PF-NOT-E
o2F46:  AND     A               ; test for zero leading digits as in .123

        CALL    Z,o15EF         ; routine OUT-CODE prints a zero e.g. 0.123

;; PF-E-SBRN
o2F4A:  XOR     A               ;
        SUB     B               ;
        JP      M,o2F52         ; skip forward to PF-OUT-LP if originally +ve

        LD      B,A             ; else negative count now +ve
        JR      o2F5E           ; forward to PF-DC-OUT       ->

; ---

;; PF-OUT-LP
o2F52:  LD      A,C             ; fetch total digit count
        AND     A               ; test for zero
        JR      Z,o2F59         ; forward to PF-OUT-DT if so

        LD      A,(HL)          ; fetch digit
        INC     HL              ; address next digit
        DEC     C               ; decrease total digit counter

;; PF-OUT-DT
o2F59:  CALL    o15EF           ; routine OUT-CODE outputs it.
        DJNZ    o2F52           ; loop back to PF-OUT-LP until B leading
                                ; digits output.

;; PF-DC-OUT
o2F5E:  LD      A,C             ; fetch total digits and
        AND     A               ; test if also zero
        RET     Z               ; return if so              -->

;

        INC     B               ; increment B
        LD      A,$2E           ; prepare the character '.'

;; PF-DEC-0S
o2F64:  RST     10H             ; PRINT-A outputs the character '.' or '0'

        LD      A,$30           ; prepare the character '0'
                                ; (for cases like .000012345678)
        DJNZ    o2F64           ; loop back to PF-DEC-0S for B times.

        LD      B,C             ; load B with now trailing digit counter.
        JR      o2F52           ; back to PF-OUT-LP

; ---------------------------------

; the branch was here for E-format printing e.g. 123456789 => 1.2345679e+8

;; PF-E-FRMT
o2F6C:  LD      D,B             ; counter to D
        DEC     D               ; decrement
        LD      B,$01           ; load B with 1.

        CALL    o2F4A           ; routine PF-E-SBRN above

        LD      A,$45           ; prepare character 'e'
        RST     10H             ; PRINT-A

        LD      C,D             ; exponent to C
        LD      A,C             ; and to A
        AND     A               ; test exponent
        JP      P,o2F83         ; to PF-E-POS if positive

        NEG                     ; negate
        LD      C,A             ; positive exponent to C
        LD      A,$2D           ; prepare character '-'
        JR      o2F85           ; skip to PF-E-SIGN

; ---

;; PF-E-POS
o2F83:  LD      A,$2B           ; prepare character '+'

;; PF-E-SIGN
o2F85:  RST     10H             ; PRINT-A outputs the sign

        LD      B,$00           ; make the high byte zero.
        JP      o1A1B           ; exit via OUT-NUM-1 to print exponent in BC

; ------------------------------
; Handle printing floating point
; ------------------------------
; This subroutine is called twice from above when printing floating-point
; numbers. It returns 10*A +C in registers C and A

;; CA-10*A+C
o2F8B:  PUSH    DE              ; preserve DE.
        LD      L,A             ; transfer A to L
        LD      H,$00           ; zero high byte.
        LD      E,L             ; copy HL
        LD      D,H             ; to DE.
        ADD     HL,HL           ; double (*2)
        ADD     HL,HL           ; double (*4)
        ADD     HL,DE           ; add DE (*5)
        ADD     HL,HL           ; double (*10)
        LD      E,C             ; copy C to E    (D is 0)
        ADD     HL,DE           ; and add to give required result.
        LD      C,H             ; transfer to
        LD      A,L             ; destination registers.
        POP     DE              ; restore DE
        RET                     ; return with result.

; --------------
; Prepare to add
; --------------
; This routine is called twice by addition to prepare the two numbers. The
; exponent is picked up in A and the location made zero. Then the sign bit
; is tested before being set to the implied state. Negative numbers are twos
; complemented.

;; PREP-ADD
o2F9B:  LD      A,(HL)          ; pick up exponent
        LD      (HL),$00        ; make location zero
        AND     A               ; test if number is zero
        RET     Z               ; return if so

        INC     HL              ; address mantissa
        BIT     7,(HL)          ; test the sign bit
        SET     7,(HL)          ; set it to implied state
        DEC     HL              ; point to exponent
        RET     Z               ; return if positive number.

        PUSH    BC              ; preserve BC
        LD      BC,$0005        ; length of number
        ADD     HL,BC           ; point HL past end
        LD      B,C             ; set B to 5 counter
        LD      C,A             ; store exponent in C
        SCF                     ; set carry flag

;; NEG-BYTE
o2FAF:  DEC     HL              ; work from LSB to MSB
        LD      A,(HL)          ; fetch byte
        CPL                     ; complement
        ADC     A,$00           ; add in initial carry or from prev operation
        LD      (HL),A          ; put back
        DJNZ    o2FAF           ; loop to NEG-BYTE till all 5 done

        LD      A,C             ; stored exponent to A
        POP     BC              ; restore original BC
        RET                     ; return

; -----------------
; Fetch two numbers
; -----------------
; This routine is called twice when printing floating point numbers and also
; to fetch two numbers by the addition, multiply and division routines.
; HL addresses the first number, DE addresses the second number.
; For arithmetic only, A holds the sign of the result which is stored in
; the second location.

;; FETCH-TWO
o2FBA:  PUSH    HL              ; save pointer to first number, result if math.
        PUSH    AF              ; save result sign.

        LD      C,(HL)          ;
        INC     HL              ;

        LD      B,(HL)          ;
        LD      (HL),A          ; store the sign at correct location in
                                ; destination 5 bytes for arithmetic only.
        INC     HL              ;

        LD      A,C             ;
        LD      C,(HL)          ;
        PUSH    BC              ;
        INC     HL              ;
        LD      C,(HL)          ;
        INC     HL              ;
        LD      B,(HL)          ;
        EX      DE,HL           ;
        LD      D,A             ;
        LD      E,(HL)          ;
        PUSH    DE              ;
        INC     HL              ;
        LD      D,(HL)          ;
        INC     HL              ;
        LD      E,(HL)          ;
        PUSH    DE              ;
        EXX                     ;
        POP     DE              ;
        POP     HL              ;
        POP     BC              ;
        EXX                     ;
        INC     HL              ;
        LD      D,(HL)          ;
        INC     HL              ;
        LD      E,(HL)          ;

        POP     AF              ; restore possible result sign.
        POP     HL              ; and pointer to possible result.
        RET                     ; return.

; ---------------------------------
; Shift floating point number right
; ---------------------------------
;
;

;; SHIFT-FP
o2FDD:  AND     A               ;
        RET     Z               ;

        CP      $21             ;
        JR      NC,o2FF9        ; to ADDEND-0

        PUSH    BC              ;
        LD      B,A             ;

;; ONE-SHIFT
o2FE5:  EXX                     ;
        SRA     L               ;
        RR      D               ;
        RR      E               ;
        EXX                     ;
        RR      D               ;
        RR      E               ;
        DJNZ    o2FE5           ; to ONE-SHIFT

        POP     BC              ;
        RET     NC              ;

        CALL    o3004           ; routine ADD-BACK
        RET     NZ              ;

;; ADDEND-0
o2FF9:  EXX                     ;
        XOR     A               ;

;; ZEROS-4/5
o2FFB:  LD      L,$00           ;
        LD      D,A             ;
        LD      E,L             ;
        EXX                     ;
        LD      DE,$0000        ;
        RET                     ;

; ------------------
; Add back any carry
; ------------------
;
;

;; ADD-BACK
o3004:  INC     E               ;
        RET     NZ              ;

        INC      D              ;
        RET     NZ              ;

        EXX                     ;
        INC     E               ;
        JR      NZ,o300D        ; to ALL-ADDED

        INC     D               ;

;; ALL-ADDED
o300D:  EXX                     ;
        RET                     ;

; -----------------------
; Handle subtraction (03)
; -----------------------
; Subtraction is done by switching the sign byte/bit of the second number
; which may be integer of floating point and continuing into addition.

;; subtract
o300F:  EX      DE,HL           ; address second number with HL

        CALL    o346E           ; routine NEGATE switches sign

        EX      DE,HL           ; address first number again
                                ; and continue.

; --------------------
; Handle addition (0F)
; --------------------
; HL points to first number, DE to second.
; If they are both integers, then go for the easy route.

;; addition
o3014:  LD      A,(DE)          ; fetch first byte of second
        OR      (HL)            ; combine with first byte of first
        JR      NZ,o303E        ; forward to FULL-ADDN if at least one was
                                ; in floating point form.

; continue if both were small integers.

        PUSH    DE              ; save pointer to lowest number for result.

        INC     HL              ; address sign byte and
        PUSH    HL              ; push the pointer.

        INC     HL              ; address low byte
        LD      E,(HL)          ; to E
        INC     HL              ; address high byte
        LD      D,(HL)          ; to D
        INC     HL              ; address unused byte

        INC     HL              ; address known zero indicator of 1st number
        INC     HL              ; address sign byte

        LD      A,(HL)          ; sign to A, $00 or $FF

        INC     HL              ; address low byte
        LD      C,(HL)          ; to C
        INC     HL              ; address high byte
        LD      B,(HL)          ; to B

        POP     HL              ; pop result sign pointer
        EX      DE,HL           ; integer to HL

        ADD     HL,BC           ; add to the other one in BC
                                ; setting carry if overflow.

        EX      DE,HL           ; save result in DE bringing back sign pointer

        ADC     A,(HL)          ; if pos/pos A=01 with overflow else 00
                                ; if neg/neg A=FF with overflow else FE
                                ; if mixture A=00 with overflow else FF

        RRCA                    ; bit 0 to (C)

        ADC     A,$00           ; both acceptable signs now zero

        JR      NZ,o303C        ; forward to ADDN-OFLW if not

        SBC     A,A             ; restore a negative result sign

        LD      (HL),A          ;
        INC     HL              ;
        LD      (HL),E          ;
        INC     HL              ;
        LD      (HL),D          ;
        DEC     HL              ;
        DEC     HL              ;
        DEC     HL              ;

        POP     DE              ; STKEND
        RET                     ;

; ---

;; ADDN-OFLW
o303C:  DEC     HL              ;
        POP     DE              ;

;; FULL-ADDN
o303E:  CALL    o3293           ; routine RE-ST-TWO
        EXX                     ;
        PUSH    HL              ;
        EXX                     ;
        PUSH    DE              ;
        PUSH    HL              ;
        CALL    o2F9B           ; routine PREP-ADD
        LD      B,A             ;
        EX      DE,HL           ;
        CALL    o2F9B           ; routine PREP-ADD
        LD       C,A            ;
        CP      B               ;
        JR      NC,o3055        ; to SHIFT-LEN

        LD      A,B             ;
        LD      B,C             ;
        EX      DE,HL           ;

;; SHIFT-LEN
o3055:  PUSH    AF              ;
        SUB     B               ;
        CALL    o2FBA           ; routine FETCH-TWO
        CALL    o2FDD           ; routine SHIFT-FP
        POP     AF              ;
        POP     HL              ;
        LD      (HL),A          ;
        PUSH    HL              ;
        LD      L,B             ;
        LD      H,C             ;
        ADD     HL,DE           ;
        EXX                     ;
        EX      DE,HL           ;
        ADC     HL,BC           ;
        EX      DE,HL           ;
        LD      A,H             ;
        ADC     A,L             ;
        LD      L,A             ;
        RRA                     ;
        XOR     L               ;
        EXX                     ;
        EX      DE,HL           ;
        POP     HL              ;
        RRA                     ;
        JR      NC,o307C        ; to TEST-NEG

        LD      A,$01           ;
        CALL    o2FDD           ; routine SHIFT-FP
        INC     (HL)            ;
        JR      Z,o309F         ; to ADD-REP-6

;; TEST-NEG
o307C:  EXX                     ;
        LD      A,L             ;
        AND     $80             ;
        EXX                     ;
        INC     HL              ;
        LD      (HL),A          ;
        DEC     HL              ;
        JR      Z,o30A5         ; to GO-NC-MLT

        LD      A,E             ;
        NEG                     ; Negate
        CCF                     ; Complement Carry Flag
        LD      E,A             ;
        LD      A,D             ;
        CPL                     ;
        ADC     A,$00           ;
        LD      D,A             ;
        EXX                     ;
        LD      A,E             ;
        CPL                     ;
        ADC     A,$00           ;
        LD      E,A             ;
        LD      A,D             ;
        CPL                     ;
        ADC     A,$00           ;
        JR      NC,o30A3        ; to END-COMPL

        RRA                     ;
        EXX                     ;
        INC     (HL)            ;

;; ADD-REP-6
o309F:  JP      Z,o31AD         ; to REPORT-6

        EXX                     ;

;; END-COMPL
o30A3:  LD      D,A             ;
        EXX                     ;

;; GO-NC-MLT
o30A5:  XOR     A               ;
        JP      o3155           ; to TEST-NORM

; -----------------------------
; Used in 16 bit multiplication
; -----------------------------
; This routine is used, in the first instance, by the multiply calculator
; literal to perform an integer multiplication in preference to
; 32-bit multiplication to which it will resort if this overflows.
;
; It is also used by STK-VAR to calculate array subscripts and by DIM to
; calculate the space required for multi-dimensional arrays.

;; HL-HL*DE
o30A9:  PUSH    BC              ; preserve BC throughout
        LD      B,$10           ; set B to 16
        LD      A,H             ; save H in A high byte
        LD      C,L             ; save L in C low byte
        LD      HL,$0000        ; initialize result to zero

; now enter a loop.

;; HL-LOOP
o30B1:  ADD     HL,HL           ; double result
        JR      C,o30BE         ; to HL-END if overflow

        RL      C               ; shift AC left into carry
        RLA                     ;
        JR      NC,o30BC        ; to HL-AGAIN to skip addition if no carry

        ADD     HL,DE           ; add in DE
        JR      C,o30BE         ; to HL-END if overflow

;; HL-AGAIN
o30BC:  DJNZ    o30B1           ; back to HL-LOOP for all 16 bits

;; HL-END
o30BE:  POP     BC              ; restore preserved BC
        RET                     ; return with carry reset if successful
                                ; and result in HL.

; ----------------------------------------------
; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
; ----------------------------------------------
;   This routine is called in succession from multiply and divide to prepare
;   two mantissas by setting the leftmost bit that is used for the sign.
;   On the first call A holds zero and picks up the sign bit. On the second
;   call the two bits are XORed to form the result sign - minus * minus giving
;   plus etc. If either number is zero then this is flagged.
;   HL addresses the exponent.

;; PREP-M/D
o30C0:  CALL    o34E9           ; routine TEST-ZERO  preserves accumulator.
        RET     C               ; return carry set if zero

        INC     HL              ; address first byte of mantissa
        XOR     (HL)            ; pick up the first or xor with first.
        SET     7,(HL)          ; now set to give true 32-bit mantissa
        DEC     HL              ; point to exponent
        RET                     ; return with carry reset

; ----------------------
; THE 'MULTIPLY' ROUTINE
; ----------------------
; (offset: $04 'multiply')
;
;
;   "He said go forth and something about mathematics, I wasn't really
;    listening" - overheard conversation between two unicorns.
;    [ The Odd Streak ].

;; multiply
o30CA:  LD      A,(DE)          ;
        OR      (HL)            ;
        JR      NZ,o30F0        ; to MULT-LONG

        PUSH    DE              ;
        PUSH    HL              ;
        PUSH    DE              ;
        CALL    o2D7F           ; routine INT-FETCH
        EX      DE,HL           ;
        EX      (SP),HL         ;
        LD      B,C             ;
        CALL    o2D7F           ; routine INT-FETCH
        LD      A,B             ;
        XOR     C               ;
        LD      C,A             ;
        POP     HL              ;
        CALL    o30A9           ; routine HL-HL*DE
        EX      DE,HL           ;
        POP     HL              ;
        JR      C,o30EF         ; to MULT-OFLW

        LD      A,D             ;
        OR      E               ;
        JR      NZ,o30EA        ; to MULT-RSLT

        LD      C,A             ;

;; MULT-RSLT
o30EA:  CALL    o2D8E           ; routine INT-STORE
        POP     DE              ;
        RET                     ;

; ---

;; MULT-OFLW
o30EF:  POP     DE              ;

;; MULT-LONG
o30F0:  CALL    o3293           ; routine RE-ST-TWO
        XOR     A               ;
        CALL    o30C0           ; routine PREP-M/D
        RET     C               ;

        EXX                     ;
        PUSH    HL              ;
        EXX                     ;
        PUSH    DE              ;
        EX      DE,HL           ;
        CALL    o30C0           ; routine PREP-M/D
        EX      DE,HL           ;
        JR      C,o315D         ; to ZERO-RSLT

        PUSH    HL              ;
        CALL    o2FBA           ; routine FETCH-TWO
        LD      A,B             ;
        AND     A               ;
        SBC     HL,HL           ;
        EXX                     ;
        PUSH    HL              ;
        SBC     HL,HL           ;
        EXX                     ;
        LD      B,$21           ;
        JR      o3125           ; to STRT-MLT

; ---

;; MLT-LOOP
o3114:  JR      NC,o311B        ; to NO-ADD

        ADD     HL,DE           ;
        EXX                     ;
        ADC     HL,DE           ;
        EXX                     ;

;; NO-ADD
o311B:  EXX                     ;
        RR      H               ;
        RR      L               ;
        EXX                     ;
        RR      H               ;
        RR      L               ;

;; STRT-MLT
o3125:  EXX                     ;
        RR      B               ;
        RR      C               ;
        EXX                     ;
        RR      C               ;
        RRA                     ;
        DJNZ    o3114           ; to MLT-LOOP

        EX      DE,HL           ;
        EXX                     ;
        EX      DE,HL           ;
        EXX                     ;
        POP     BC              ;
        POP     HL              ;
        LD      A,B             ;
        ADD     A,C             ;
        JR      NZ,o313B        ; to MAKE-EXPT

        AND     A               ;

;; MAKE-EXPT
o313B:  DEC     A               ;
        CCF                     ; Complement Carry Flag

;; DIVN-EXPT
o313D:  RLA                     ;
        CCF                     ; Complement Carry Flag
        RRA                     ;
        JP      P,o3146         ; to OFLW1-CLR

        JR      NC,o31AD        ; to REPORT-6

        AND     A               ;

;; OFLW1-CLR
o3146:  INC     A               ;
        JR      NZ,o3151        ; to OFLW2-CLR

        JR      C,o3151         ; to OFLW2-CLR

        EXX                     ;
        BIT     7,D             ;
        EXX                     ;
        JR      NZ,o31AD        ; to REPORT-6

;; OFLW2-CLR
o3151:  LD      (HL),A          ;
        EXX                     ;
        LD      A,B             ;
        EXX                     ;

;; TEST-NORM
o3155:  JR      NC,o316C        ; to NORMALISE

        LD      A,(HL)          ;
        AND     A               ;

;; NEAR-ZERO
o3159:  LD      A,$80           ;
        JR      Z,o315E         ; to SKIP-ZERO

;; ZERO-RSLT
o315D:  XOR     A               ;

;; SKIP-ZERO
o315E:  EXX                     ;
        AND     D               ;
        CALL    o2FFB           ; routine ZEROS-4/5
        RLCA                    ;
        LD      (HL),A          ;
        JR      C,o3195         ; to OFLOW-CLR

        INC     HL              ;
        LD      (HL),A          ;
        DEC     HL              ;
        JR      o3195           ; to OFLOW-CLR

; ---

;; NORMALISE
o316C:  LD      B,$20           ;

;; SHIFT-ONE
o316E:  EXX                     ;
        BIT     7,D             ;
        EXX                     ;
        JR      NZ,o3186        ; to NORML-NOW

        RLCA                    ;
        RL      E               ;
        RL      D               ;
        EXX                     ;
        RL      E               ;
        RL      D               ;
        EXX                     ;
        DEC     (HL)            ;
        JR      Z,o3159         ; to NEAR-ZERO

        DJNZ    o316E           ; to SHIFT-ONE

        JR      o315D           ; to ZERO-RSLT

; ---

;; NORML-NOW
o3186:  RLA                     ;
        JR      NC,o3195        ; to OFLOW-CLR

        CALL    o3004           ; routine ADD-BACK
        JR      NZ,o3195        ; to OFLOW-CLR

        EXX                     ;
        LD       D,$80          ;
        EXX                     ;
        INC     (HL)            ;
        JR      Z,o31AD         ; to REPORT-6

;; OFLOW-CLR
o3195:  PUSH    HL              ;
        INC     HL              ;
        EXX                     ;
        PUSH    DE              ;
        EXX                     ;
        POP     BC              ;
        LD      A,B             ;
        RLA                     ;
        RL      (HL)            ;
        RRA                     ;
        LD      (HL),A          ;
        INC     HL              ;
        LD      (HL),C          ;
        INC     HL              ;
        LD      (HL),D          ;
        INC     HL              ;
        LD      (HL),E          ;
        POP     HL              ;
        POP     DE              ;
        EXX                     ;
        POP     HL              ;
        EXX                     ;
        RET                     ;

; ---

;; REPORT-6
o31AD:  RST     08H             ; ERROR-1
        DEFB    $05             ; Error Report: Number too big

; ----------------------
; THE 'DIVISION' ROUTINE
; ----------------------
; (offset: $05 'division')
;
;   "He who can properly define and divide is to be considered a god"
;   - Plato,  429 - 347 B.C.

;; division
o31AF:  CALL    o3293           ; routine RE-ST-TWO
        EX      DE,HL           ;
        XOR     A               ;
        CALL    o30C0           ; routine PREP-M/D
        JR      C,o31AD         ; to REPORT-6

        EX      DE,HL           ;
        CALL    o30C0           ; routine PREP-M/D
        RET     C               ;

        EXX                     ;
        PUSH    HL              ;
        EXX                     ;
        PUSH    DE              ;
        PUSH    HL              ;
        CALL    o2FBA           ; routine FETCH-TWO
        EXX                     ;
        PUSH    HL              ;
        LD      H,B             ;
        LD      L,C             ;
        EXX                     ;
        LD      H,C             ;
        LD      L,B             ;
        XOR     A               ;
        LD      B,$DF           ;
        JR      o31E2           ; to DIV-START

; ---

;; DIV-LOOP
o31D2:  RLA                     ;
        RL      C               ;
        EXX                     ;
        RL      C               ;
        RL      B               ;
        EXX                     ;

;; div-34th
o31DB:  ADD     HL,HL           ;
        EXX                     ;
        ADC     HL,HL           ;
        EXX                     ;
        JR      C,o31F2         ; to SUBN-ONLY

;; DIV-START
o31E2:  SBC     HL,DE           ;
        EXX                     ;
        SBC     HL,DE           ;
        EXX                     ;
        JR      NC,o31F9        ; to NO-RSTORE

        ADD     HL,DE           ;
        EXX                     ;
        ADC     HL,DE           ;
        EXX                     ;
        AND     A               ;
        JR      o31FA           ; to COUNT-ONE

; ---

;; SUBN-ONLY
o31F2:  AND     A               ;
        SBC     HL,DE           ;
        EXX                     ;
        SBC     HL,DE           ;
        EXX                     ;

;; NO-RSTORE
o31F9:  SCF                     ; Set Carry Flag

;; COUNT-ONE
o31FA:  INC     B               ;
        JP      M,o31D2         ; to DIV-LOOP

        PUSH    AF              ;
        JR      Z,o31E2         ; to DIV-START

;
;
;
;

        LD      E,A             ;
        LD      D,C             ;
        EXX                     ;
        LD      E,C             ;
        LD      D,B             ;
        POP     AF              ;
        RR      B               ;
        POP     AF              ;
        RR      B               ;
        EXX                     ;
        POP     BC              ;
        POP     HL              ;
        LD      A,B             ;
        SUB     C               ;
        JP      o313D           ; jump back to DIVN-EXPT

; ------------------------------------
; Integer truncation towards zero ($3A)
; ------------------------------------
;
;

;; truncate
o3214:  LD      A,(HL)          ;
        AND     A               ;
        RET     Z               ;

        CP      $81             ;
        JR      NC,o3221        ; to T-GR-ZERO

        LD      (HL),$00        ;
        LD      A,$20           ;
        JR      o3272           ; to NIL-BYTES

; ---

;; T-GR-ZERO
o3221:  CP      $91             ;
        JR      NZ,o323F        ; to T-SMALL

        INC     HL              ;
        INC     HL              ;
        INC     HL              ;
        LD      A,$80           ;
        AND     (HL)            ;
        DEC     HL              ;
        OR      (HL)            ;
        DEC     HL              ;
        JR      NZ,o3233        ; to T-FIRST

        LD      A,$80           ;
        XOR     (HL)            ;

;; T-FIRST
o3233:  DEC     HL              ;
        JR      NZ,o326C        ; to T-EXPNENT

        LD      (HL),A          ;
        INC     HL              ;
        LD      (HL),$FF        ;
        DEC     HL              ;
        LD      A,$18           ;
        JR      o3272           ; to NIL-BYTES

; ---

;; T-SMALL
o323F:  JR      NC,o326D        ; to X-LARGE

        PUSH    DE              ;
        CPL                     ;
        ADD     A,$91           ;
        INC     HL              ;
        LD      D,(HL)          ;
        INC     HL              ;
        LD      E,(HL)          ;
        DEC     HL              ;
        DEC     HL              ;
        LD      C,$00           ;
        BIT     7,D             ;
        JR      Z,o3252         ; to T-NUMERIC

        DEC     C               ;

;; T-NUMERIC
o3252:  SET     7,D             ;
        LD      B,$08           ;
        SUB     B               ;
        ADD     A,B             ;
        JR      C,o325E         ; to T-TEST

        LD      E,D             ;
        LD      D,$00           ;
        SUB     B               ;

;; T-TEST
o325E:  JR      Z,o3267         ; to T-STORE

        LD      B,A             ;

;; T-SHIFT
o3261:  SRL     D               ;
        RR      E               ;
        DJNZ    o3261           ; to T-SHIFT

;; T-STORE
o3267:  CALL    o2D8E           ; routine INT-STORE
        POP     DE              ;
        RET                     ;

; ---

;; T-EXPNENT
o326C:  LD      A,(HL)          ;

;; X-LARGE
o326D:  SUB     $A0             ;
        RET     P               ;

        NEG                     ; Negate

;; NIL-BYTES
o3272:  PUSH    DE              ;
        EX      DE,HL           ;
        DEC     HL              ;
        LD      B,A             ;
        SRL     B               ;
        SRL     B               ;
        SRL     B               ;
        JR      Z,o3283         ; to BITS-ZERO

;; BYTE-ZERO
o327E:  LD      (HL),$00        ;
        DEC     HL              ;
        DJNZ    o327E           ; to BYTE-ZERO

;; BITS-ZERO
o3283:  AND     $07             ;
        JR      Z,o3290         ; to IX-END

        LD      B,A             ;
        LD      A,$FF           ;

;; LESS-MASK
o328A:  SLA     A               ;
        DJNZ    o328A           ; to LESS-MASK

        AND     (HL)            ;
        LD      (HL),A          ;

;; IX-END
o3290:  EX      DE,HL           ;
        POP     DE              ;
        RET                     ;

; ----------------------------------
; Storage of numbers in 5 byte form.
; ==================================
; Both integers and floating-point numbers can be stored in five bytes.
; Zero is a special case stored as 5 zeros.
; For integers the form is
; Byte 1 - zero,
; Byte 2 - sign byte, $00 +ve, $FF -ve.
; Byte 3 - Low byte of integer.
; Byte 4 - High byte
; Byte 5 - unused but always zero.
;
; it seems unusual to store the low byte first but it is just as easy either
; way. Statistically it just increases the chances of trailing zeros which
; is an advantage elsewhere in saving ROM code.
;
;             zero     sign     low      high    unused
; So +1 is  00000000 00000000 00000001 00000000 00000000
;
; and -1 is 00000000 11111111 11111111 11111111 00000000
;
; much of the arithmetic found in BASIC lines can be done using numbers
; in this form using the Z80's 16 bit register operation ADD.
; (multiplication is done by a sequence of additions).
;
; Storing -ve integers in two's complement form, means that they are ready for
; addition and you might like to add the numbers above to prove that the
; answer is zero. If, as in this case, the carry is set then that denotes that
; the result is positive. This only applies when the signs don't match.
; With positive numbers a carry denotes the result is out of integer range.
; With negative numbers a carry denotes the result is within range.
; The exception to the last rule is when the result is -65536
;
; Floating point form is an alternative method of storing numbers which can
; be used for integers and larger (or fractional) numbers.
;
; In this form 1 is stored as
;           10000001 00000000 00000000 00000000 00000000
;
; When a small integer is converted to a floating point number the last two
; bytes are always blank so they are omitted in the following steps
;
; first make exponent +1 +16d  (bit 7 of the exponent is set if positive)

; 10010001 00000000 00000001
; 10010000 00000000 00000010 <-  now shift left and decrement exponent
; ...
; 10000010 01000000 00000000 <-  until a 1 abuts the imaginary point
; 10000001 10000000 00000000     to the left of the mantissa.
;
; however since the leftmost bit of the mantissa is always set then it can
; be used to denote the sign of the mantissa and put back when needed by the
; PREP routines which gives
;
; 10000001 00000000 00000000

; ----------------------------------------------
; THE 'RE-STACK TWO "SMALL" INTEGERS' SUBROUTINE
; ----------------------------------------------
;   This routine is called to re-stack two numbers in full floating point form
;   e.g. from mult when integer multiplication has overflowed.

;; RE-ST-TWO
o3293:  CALL    o3296           ; routine RESTK-SUB  below and continue
                                ; into the routine to do the other one.

;; RESTK-SUB
o3296:  EX      DE,HL           ; swap pointers

; ---------------------------------------------
; THE 'RE-STACK ONE "SMALL" INTEGER' SUBROUTINE
; ---------------------------------------------
; (offset: $3D 're-stack')
;   This routine re-stacks an integer, usually on the calculator stack, in full
;   floating point form.  HL points to first byte.

;; re-stack
o3297:  LD      A,(HL)          ; Fetch Exponent byte to A
        AND     A               ; test it
        RET     NZ              ; return if not zero as already in full
                                ; floating-point form.

        PUSH    DE              ; preserve DE.
        CALL    o2D7F           ; routine INT-FETCH
                                ; integer to DE, sign to C.

; HL points to 4th byte.

        XOR     A               ; clear accumulator.
        INC     HL              ; point to 5th.
        LD      (HL),A          ; and blank.
        DEC     HL              ; point to 4th.
        LD      (HL),A          ; and blank.

        LD      B,$91           ; set exponent byte +ve $81
                                ; and imaginary dec point 16 bits to right
                                ; of first bit.

;   we could skip to normalize now but it's quicker to avoid normalizing
;   through an empty D.

        LD      A,D             ; fetch the high byte D
        AND     A               ; is it zero ?
        JR      NZ,o32B1        ; skip to RS-NRMLSE if not.

        OR      E               ; low byte E to A and test for zero
        LD      B,D             ; set B exponent to 0
        JR      Z,o32BD         ; forward to RS-STORE if value is zero.

        LD      D,E             ; transfer E to D
        LD      E,B             ; set E to 0
        LD      B,$89           ; reduce the initial exponent by eight.


;; RS-NRMLSE
o32B1:  EX      DE,HL           ; integer to HL, addr of 4th byte to DE.

;; RSTK-LOOP
o32B2:  DEC     B               ; decrease exponent
        ADD     HL,HL           ; shift DE left
        JR      NC,o32B2        ; loop back to RSTK-LOOP
                                ; until a set bit pops into carry

        RRC     C               ; now rotate the sign byte $00 or $FF
                                ; into carry to give a sign bit

        RR      H               ; rotate the sign bit to left of H
        RR      L               ; rotate any carry into L

        EX      DE,HL           ; address 4th byte, normalized int to DE

;; RS-STORE
o32BD:  DEC     HL              ; address 3rd byte
        LD      (HL),E          ; place E
        DEC     HL              ; address 2nd byte
        LD      (HL),D          ; place D
        DEC     HL              ; address 1st byte
        LD      (HL),B          ; store the exponent

        POP     DE              ; restore initial DE.
        RET                     ; return.

;****************************************
;** Part 10. FLOATING-POINT CALCULATOR **
;****************************************

; As a general rule the calculator avoids using the IY register.
; exceptions are val, val$ and str$.
; So an assembly language programmer who has disabled interrupts to use
; IY for other purposes can still use the calculator for mathematical
; purposes.


; ------------------------
; THE 'TABLE OF CONSTANTS'
; ------------------------
;
;

; used 11 times
;; stk-zero                                                 00 00 00 00 00
o32C5:  DEFB    $00             ;;Bytes: 1
        DEFB    $B0             ;;Exponent $00
        DEFB    $00             ;;(+00,+00,+00)

; used 19 times
;; stk-one                                                  00 00 01 00 00
o32C8:  DEFB    $40             ;;Bytes: 2
        DEFB    $B0             ;;Exponent $00
        DEFB    $00,$01         ;;(+00,+00)

; used 9 times
;; stk-half                                                 80 00 00 00 00
o32CC:  DEFB    $30             ;;Exponent: $80, Bytes: 1
        DEFB    $00             ;;(+00,+00,+00)

; used 4 times.
;; stk-pi/2                                                 81 49 0F DA A2
o32CE:  DEFB    $F1             ;;Exponent: $81, Bytes: 4
        DEFB    $49,$0F,$DA,$A2 ;;

; used 3 times.
;; stk-ten                                                  00 00 0A 00 00
o32D3:  DEFB    $40             ;;Bytes: 2
        DEFB    $B0             ;;Exponent $00
        DEFB    $00,$0A         ;;(+00,+00)


; ------------------------
; THE 'TABLE OF ADDRESSES'
; ------------------------
;  "Each problem that I solved became a rule which served afterwards to solve
;   other problems" - Rene Descartes 1596 - 1650.
;
;   Starts with binary operations which have two operands and one result.
;   Three pseudo binary operations first.

;; tbl-addrs
o32D7:  DEFW    o368F           ; $00 Address: $368F - jump-true
        DEFW    o343C           ; $01 Address: $343C - exchange
        DEFW    o33A1           ; $02 Address: $33A1 - delete

;   True binary operations.

        DEFW    o300F           ; $03 Address: $300F - subtract
        DEFW    o30CA           ; $04 Address: $30CA - multiply
        DEFW    o31AF           ; $05 Address: $31AF - division
        DEFW    o3851           ; $06 Address: $3851 - to-power
        DEFW    o351B           ; $07 Address: $351B - or

        DEFW    o3524           ; $08 Address: $3524 - no-&-no
        DEFW    o353B           ; $09 Address: $353B - no-l-eql
        DEFW    o353B           ; $0A Address: $353B - no-gr-eql
        DEFW    o353B           ; $0B Address: $353B - nos-neql
        DEFW    o353B           ; $0C Address: $353B - no-grtr
        DEFW    o353B           ; $0D Address: $353B - no-less
        DEFW    o353B           ; $0E Address: $353B - nos-eql
        DEFW    o3014           ; $0F Address: $3014 - addition

        DEFW    o352D           ; $10 Address: $352D - str-&-no
        DEFW    o353B           ; $11 Address: $353B - str-l-eql
        DEFW    o353B           ; $12 Address: $353B - str-gr-eql
        DEFW    o353B           ; $13 Address: $353B - strs-neql
        DEFW    o353B           ; $14 Address: $353B - str-grtr
        DEFW    o353B           ; $15 Address: $353B - str-less
        DEFW    o353B           ; $16 Address: $353B - strs-eql
        DEFW    o359C           ; $17 Address: $359C - strs-add

;   Unary follow.

        DEFW    o35DE           ; $18 Address: $35DE - val$
        DEFW    o34BC           ; $19 Address: $34BC - usr-$
        DEFW    o3645           ; $1A Address: $3645 - read-in
        DEFW    o346E           ; $1B Address: $346E - negate

        DEFW    o3669           ; $1C Address: $3669 - code
        DEFW    o35DE           ; $1D Address: $35DE - val
        DEFW    o3674           ; $1E Address: $3674 - len
        DEFW    o37B5           ; $1F Address: $37B5 - sin
        DEFW    o37AA           ; $20 Address: $37AA - cos
        DEFW    o37DA           ; $21 Address: $37DA - tan
        DEFW    o3833           ; $22 Address: $3833 - asn
        DEFW    o3843           ; $23 Address: $3843 - acs
        DEFW    o37E2           ; $24 Address: $37E2 - atn
        DEFW    o3713           ; $25 Address: $3713 - ln
        DEFW    o36C4           ; $26 Address: $36C4 - exp
        DEFW    o36AF           ; $27 Address: $36AF - int
        DEFW    o384A           ; $28 Address: $384A - sqr
        DEFW    o3492           ; $29 Address: $3492 - sgn
        DEFW    o346A           ; $2A Address: $346A - abs
        DEFW    o34AC           ; $2B Address: $34AC - peek
        DEFW    o34A5           ; $2C Address: $34A5 - in
        DEFW    o34B3           ; $2D Address: $34B3 - usr-no
        DEFW    o361F           ; $2E Address: $361F - str$
        DEFW    o35C9           ; $2F Address: $35C9 - chrs
        DEFW    o3501           ; $30 Address: $3501 - not

;   End of true unary.

        DEFW    o33C0           ; $31 Address: $33C0 - duplicate
        DEFW    o36A0           ; $32 Address: $36A0 - n-mod-m
        DEFW    o3686           ; $33 Address: $3686 - jump
        DEFW    o33C6           ; $34 Address: $33C6 - stk-data
        DEFW    o367A           ; $35 Address: $367A - dec-jr-nz
        DEFW    o3506           ; $36 Address: $3506 - less-0
        DEFW    o34F9           ; $37 Address: $34F9 - greater-0
        DEFW    o369B           ; $38 Address: $369B - end-calc
        DEFW    o3783           ; $39 Address: $3783 - get-argt
        DEFW    o3214           ; $3A Address: $3214 - truncate
        DEFW    o33A2           ; $3B Address: $33A2 - fp-calc-2
        DEFW    o2D4F           ; $3C Address: $2D4F - e-to-fp
        DEFW    o3297           ; $3D Address: $3297 - re-stack

;   The following are just the next available slots for the 128 compound
;   literals which are in range $80 - $FF.

        DEFW    o3449           ;     Address: $3449 - series-xx    $80 - $9F.
        DEFW    o341B           ;     Address: $341B - stk-const-xx $A0 - $BF.
        DEFW    o342D           ;     Address: $342D - st-mem-xx    $C0 - $DF.
        DEFW    o340F           ;     Address: $340F - get-mem-xx   $E0 - $FF.

;   Aside: 3E - 3F are therefore unused calculator literals.
;   If the literal has to be also usable as a function then bits 6 and 7 are
;   used to show type of arguments and result.

; --------------
; The Calculator
; --------------
;  "A good calculator does not need artificial aids"
;  Lao Tze 604 - 531 B.C.

;; CALCULATE
o335B:  CALL    o35BF           ; routine STK-PNTRS is called to set up the
                                ; calculator stack pointers for a default
                                ; unary operation. HL = last value on stack.
                                ; DE = STKEND first location after stack.

; the calculate routine is called at this point by the series generator...

;; GEN-ENT-1
o335E:  LD      A,B             ; fetch the Z80 B register to A
        LD      ($5C67),A       ; and store value in system variable BREG.
                                ; this will be the counter for dec-jr-nz
                                ; or if used from fp-calc2 the calculator
                                ; instruction.

; ... and again later at this point

;; GEN-ENT-2
o3362:  EXX                     ; switch sets
        EX      (SP),HL         ; and store the address of next instruction,
                                ; the return address, in H'L'.
                                ; If this is a recursive call the H'L'
                                ; of the previous invocation goes on stack.
                                ; c.f. end-calc.
        EXX                     ; switch back to main set

; this is the re-entry looping point when handling a string of literals.

;; RE-ENTRY
o3365:  LD      (STKEND),DE     ; save end of stack in system variable STKEND
        EXX                     ; switch to alt
        LD      A,(HL)          ; get next literal
        INC     HL              ; increase pointer'

; single operation jumps back to here

;; SCAN-ENT
o336C:  PUSH    HL              ; save pointer on stack
        AND     A               ; now test the literal
        JP      P,o3380         ; forward to FIRST-3D if in range $00 - $3D
                                ; anything with bit 7 set will be one of
                                ; 128 compound literals.

; compound literals have the following format.
; bit 7 set indicates compound.
; bits 6-5 the subgroup 0-3.
; bits 4-0 the embedded parameter $00 - $1F.
; The subgroup 0-3 needs to be manipulated to form the next available four
; address places after the simple literals in the address table.

        LD      D,A             ; save literal in D
        AND     $60             ; and with 01100000 to isolate subgroup
        RRCA                    ; rotate bits
        RRCA                    ; 4 places to right
        RRCA                    ; not five as we need offset * 2
        RRCA                    ; 00000xx0
        ADD     A,$7C           ; add ($3E * 2) to give correct offset.
                                ; alter above if you add more literals.
        LD      L,A             ; store in L for later indexing.
        LD      A,D             ; bring back compound literal
        AND     $1F             ; use mask to isolate parameter bits
        JR      o338E           ; forward to ENT-TABLE

; ---

; the branch was here with simple literals.

;; FIRST-3D
o3380:  CP      $18             ; compare with first unary operations.
        JR      NC,o338C        ; to DOUBLE-A with unary operations

; it is binary so adjust pointers.

        EXX                     ;
        LD      BC,$FFFB        ; the value -5
        LD      D,H             ; transfer HL, the last value, to DE.
        LD      E,L             ;
        ADD     HL,BC           ; subtract 5 making HL point to second
                                ; value.
        EXX                     ;

;; DOUBLE-A
o338C:  RLCA                    ; double the literal
        LD      L,A             ; and store in L for indexing

;; ENT-TABLE
o338E:  LD      DE,o32D7        ; Address: tbl-addrs
        LD      H,$00           ; prepare to index
        ADD     HL,DE           ; add to get address of routine
        LD      E,(HL)          ; low byte to E
        INC     HL              ;
        LD      D,(HL)          ; high byte to D
        LD      HL,o3365        ; Address: RE-ENTRY
        EX      (SP),HL         ; goes to stack
        PUSH    DE              ; now address of routine
        EXX                     ; main set
                                ; avoid using IY register.
        LD      BC,($5C66)      ; STKEND_hi
                                ; nothing much goes to C but BREG to B
                                ; and continue into next ret instruction
                                ; which has a dual identity


; ------------------
; Handle delete (02)
; ------------------
; A simple return but when used as a calculator literal this
; deletes the last value from the calculator stack.
; On entry, as always with binary operations,
; HL=first number, DE=second number
; On exit, HL=result, DE=stkend.
; So nothing to do

;; delete
o33A1:  RET                     ; return - indirect jump if from above.

; ---------------------
; Single operation (3B)
; ---------------------
;   This single operation is used, in the first instance, to evaluate most
;   of the mathematical and string functions found in BASIC expressions.

;; fp-calc-2
o33A2:  POP     AF              ; drop return address.
        LD      A,($5C67)       ; load accumulator from system variable BREG
                                ; value will be literal e.g. 'tan'
        EXX                     ; switch to alt
        JR      o336C           ; back to SCAN-ENT
                                ; next literal will be end-calc at o2758

; ---------------------------------
; THE 'TEST FIVE SPACES' SUBROUTINE
; ---------------------------------
;   This routine is called from MOVE-FP, STK-CONST and STK-STORE to test that
;   there is enough space between the calculator stack and the machine stack
;   for another five-byte value.  It returns with BC holding the value 5 ready
;   for any subsequent LDIR.

;; TEST-5-SP
o33A9:  PUSH    DE              ; save
        PUSH    HL              ; registers
        LD      BC,$0005        ; an overhead of five bytes
        CALL    o1F05           ; routine TEST-ROOM tests free RAM raising
                                ; an error if not.
        POP     HL              ; else restore
        POP     DE              ; registers.
        RET                     ; return with BC set at 5.

; -----------------------------
; THE 'STACK NUMBER' SUBROUTINE
; -----------------------------
;   This routine is called to stack a hidden floating point number found in
;   a BASIC line.  It is also called to stack a numeric variable value, and
;   from BEEP, to stack an entry in the semi-tone table.  It is not part of the
;   calculator suite of routines.  On entry, HL points to the number to be
;   stacked.

;; STACK-NUM
o33B4:  LD      DE,(STKEND)     ; Load destination from STKEND system variable.

        CALL    o33C0           ; Routine MOVE-FP puts on calculator stack
                                ; with a memory check.
        LD      (STKEND),DE     ; Set STKEND to next free location.

        RET                     ; Return.

; ---------------------------------
; Move a floating point number (31)
; ---------------------------------

; This simple routine is a 5-byte LDIR instruction
; that incorporates a memory check.
; When used as a calculator literal it duplicates the last value on the
; calculator stack.
; Unary so on entry HL points to last value, DE to stkend

;; duplicate
;; MOVE-FP
o33C0:  CALL    o33A9           ; routine TEST-5-SP test free memory
                                ; and sets BC to 5.
o33C3:  LDIR                    ; copy the five bytes.
        RET                     ; return with DE addressing new STKEND
                                ; and HL addressing new last value.

; -------------------
; Stack literals ($34)
; -------------------
; When a calculator subroutine needs to put a value on the calculator
; stack that is not a regular constant this routine is called with a
; variable number of following data bytes that convey to the routine
; the integer or floating point form as succinctly as is possible.

;; stk-data
o33C6:  LD      H,D             ; transfer STKEND
        LD      L,E             ; to HL for result.

;; STK-CONST
o33C8:  CALL    o33A9           ; routine TEST-5-SP tests that room exists
                                ; and sets BC to $05.

        EXX                     ; switch to alternate set
        PUSH    HL              ; save the pointer to next literal on stack
        EXX                     ; switch back to main set

        EX      (SP),HL         ; pointer to HL, destination to stack.

        PUSH    BC              ; save BC - value 5 from test room ??.

        LD      A,(HL)          ; fetch the byte following 'stk-data'
        AND     $C0             ; isolate bits 7 and 6
        RLCA                    ; rotate
        RLCA                    ; to bits 1 and 0  range $00 - $03.
        LD      C,A             ; transfer to C
        INC     C               ; and increment to give number of bytes
                                ; to read. $01 - $04
        LD      A,(HL)          ; reload the first byte
        AND     $3F             ; mask off to give possible exponent.
        JR      NZ,o33DE        ; forward to FORM-EXP if it was possible to
                                ; include the exponent.

; else byte is just a byte count and exponent comes next.

        INC     HL              ; address next byte and
        LD      A,(HL)          ; pick up the exponent ( - $50).

;; FORM-EXP
o33DE:  ADD     A,$50           ; now add $50 to form actual exponent
        LD      (DE),A          ; and load into first destination byte.
        LD      A,$05           ; load accumulator with $05 and
        SUB     C               ; subtract C to give count of trailing
                                ; zeros plus one.
        INC     HL              ; increment source
        INC     DE              ; increment destination
        LD      B,$00           ; prepare to copy
        LDIR                    ; copy C bytes

        POP     BC              ; restore 5 counter to BC ??.

        EX      (SP),HL         ; put HL on stack as next literal pointer
                                ; and the stack value - result pointer -
                                ; to HL.

        EXX                     ; switch to alternate set.
        POP     HL              ; restore next literal pointer from stack
                                ; to H'L'.
        EXX                     ; switch back to main set.

        LD      B,A             ; zero count to B
        XOR     A               ; clear accumulator

;; STK-ZEROS
o33F1:  DEC     B               ; decrement B counter
        RET     Z               ; return if zero.          >>
                                ; DE points to new STKEND
                                ; HL to new number.

        LD      (DE),A          ; else load zero to destination
        INC     DE              ; increase destination
        JR      o33F1           ; loop back to STK-ZEROS until done.

; -------------------------------
; THE 'SKIP CONSTANTS' SUBROUTINE
; -------------------------------
;   This routine traverses variable-length entries in the table of constants,
;   stacking intermediate, unwanted constants onto a dummy calculator stack,
;   in the first five bytes of ROM.  The destination DE normally points to the
;   end of the calculator stack which might be in the normal place or in the
;   system variables area during E-LINE-NO; INT-TO-FP; stk-ten.  In any case,
;   it would be simpler all round if the routine just shoved unwanted values
;   where it is going to stick the wanted value.  The instruction LD DE, $0000
;   can be removed.

;; SKIP-CONS
o33F7:  AND     A               ; test if initially zero.

;; SKIP-NEXT
o33F8:  RET     Z               ; return if zero.          >>

        PUSH    AF              ; save count.
        PUSH    DE              ; and normal STKEND

        LD      DE,$0000        ; dummy value for STKEND at start of ROM
                                ; Note. not a fault but this has to be
                                ; moved elsewhere when running in RAM.
                                ; e.g. with Expandor Systems 'Soft ROM'.
                                ; Better still, write to the normal place.
        CALL    o33C8           ; routine STK-CONST works through variable
                                ; length records.

        POP     DE              ; restore real STKEND
        POP     AF              ; restore count
        DEC     A               ; decrease
        JR      o33F8           ; loop back to SKIP-NEXT

; ------------------------------
; THE 'LOCATE MEMORY' SUBROUTINE
; ------------------------------
;   This routine, when supplied with a base address in HL and an index in A,
;   will calculate the address of the A'th entry, where each entry occupies
;   five bytes.  It is used for reading the semi-tone table and addressing
;   floating-point numbers in the calculator's memory area.
;   It is not possible to use this routine for the table of constants as these
;   six values are held in compressed format.

;; LOC-MEM
o3406:  LD      C,A             ; store the original number $00-$1F.
        RLCA                    ; X2 - double.
        RLCA                    ; X4 - quadruple.
        ADD     A,C             ; X5 - now add original to multiply by five.

        LD      C,A             ; place the result in the low byte.
        LD      B,$00           ; set high byte to zero.
        ADD     HL,BC           ; add to form address of start of number in HL.

        RET                     ; return.

; ------------------------------
; Get from memory area ($E0 etc.)
; ------------------------------
; Literals $E0 to $FF
; A holds $00-$1F offset.
; The calculator stack increases by 5 bytes.

;; get-mem-xx
o340F:  PUSH    DE              ; save STKEND
        LD      HL,($5C68)      ; MEM is base address of the memory cells.
        CALL    o3406           ; routine LOC-MEM so that HL = first byte
        CALL    o33C0           ; routine MOVE-FP moves 5 bytes with memory
                                ; check.
                                ; DE now points to new STKEND.
        POP     HL              ; original STKEND is now RESULT pointer.
        RET                     ; return.

; --------------------------
; Stack a constant (A0 etc.)
; --------------------------
; This routine allows a one-byte instruction to stack up to 32 constants
; held in short form in a table of constants. In fact only 5 constants are
; required. On entry the A register holds the literal ANDed with 1F.
; It isn't very efficient and it would have been better to hold the
; numbers in full, five byte form and stack them in a similar manner
; to that used for semi-tone table values.

;; stk-const-xx
o341B:  LD      H,D             ; save STKEND - required for result
        LD      L,E             ;
        EXX                     ; swap
        PUSH    HL              ; save pointer to next literal
        LD      HL,o32C5        ; Address: stk-zero - start of table of
                                ; constants
        EXX                     ;
        CALL    o33F7           ; routine SKIP-CONS
        CALL    o33C8           ; routine STK-CONST
        EXX                     ;
        POP     HL              ; restore pointer to next literal.
        EXX                     ;
        RET                     ; return.

; --------------------------------
; Store in a memory area ($C0 etc.)
; --------------------------------
; Offsets $C0 to $DF
; Although 32 memory storage locations can be addressed, only six
; $C0 to $C5 are required by the ROM and only the thirty bytes (6*5)
; required for these are allocated. Spectrum programmers who wish to
; use the floating point routines from assembly language may wish to
; alter the system variable MEM to point to 160 bytes of RAM to have
; use the full range available.
; A holds the derived offset $00-$1F.
; This is a unary operation, so on entry HL points to the last value and DE
; points to STKEND.

;; st-mem-xx
o342D:  PUSH    HL              ; save the result pointer.
        EX      DE,HL           ; transfer to DE.
        LD      HL,($5C68)      ; fetch MEM the base of memory area.
        CALL    o3406           ; routine LOC-MEM sets HL to the destination.
        EX      DE,HL           ; swap - HL is start, DE is destination.
        CALL    o33C0           ; routine MOVE-FP.
                                ; note. a short ld bc,5; ldir
                                ; the embedded memory check is not required
                                ; so these instructions would be faster.
        EX      DE,HL           ; DE = STKEND
        POP     HL              ; restore original result pointer
        RET                     ; return.

; -------------------------
; THE 'EXCHANGE' SUBROUTINE
; -------------------------
; (offset: $01 'exchange')
;   This routine swaps the last two values on the calculator stack.
;   On entry, as always with binary operations,
;   HL=first number, DE=second number
;   On exit, HL=result, DE=stkend.

;; exchange
o343C:  LD      B,$05           ; there are five bytes to be swapped

; start of loop.

;; SWAP-BYTE
o343E:  LD      A,(DE)          ; each byte of second
        LD      C,(HL)          ; each byte of first
        EX      DE,HL           ; swap pointers
        LD      (DE),A          ; store each byte of first
        LD      (HL),C          ; store each byte of second
        INC     HL              ; advance both
        INC     DE              ; pointers.
        DJNZ    o343E           ; loop back to SWAP-BYTE until all 5 done.

        EX      DE,HL           ; even up the exchanges so that DE addresses
                                ; STKEND.

        RET                     ; return.

; ------------------------------
; THE 'SERIES GENERATOR' ROUTINE
; ------------------------------
; (offset: $86 'series-06')
; (offset: $88 'series-08')
; (offset: $8C 'series-0C')
;   The Spectrum uses Chebyshev polynomials to generate approximations for
;   SIN, ATN, LN and EXP.  These are named after the Russian mathematician
;   Pafnuty Chebyshev, born in 1821, who did much pioneering work on numerical
;   series.  As far as calculators are concerned, Chebyshev polynomials have an
;   advantage over other series, for example the Taylor series, as they can
;   reach an approximation in just six iterations for SIN, eight for EXP and
;   twelve for LN and ATN.  The mechanics of the routine are interesting but
;   for full treatment of how these are generated with demonstrations in
;   Sinclair BASIC see "The Complete Spectrum ROM Disassembly" by Dr Ian Logan
;   and Dr Frank O'Hara, published 1983 by Melbourne House.

;; series-xx
o3449:  LD      B,A             ; parameter $00 - $1F to B counter
        CALL    o335E           ; routine GEN-ENT-1 is called.
                                ; A recursive call to a special entry point
                                ; in the calculator that puts the B register
                                ; in the system variable BREG. The return
                                ; address is the next location and where
                                ; the calculator will expect its first
                                ; instruction - now pointed to by HL'.
                                ; The previous pointer to the series of
                                ; five-byte numbers goes on the machine stack.

; The initialization phase.

        DEFB    $31             ;;duplicate       x,x
        DEFB    $0F             ;;addition        x+x
        DEFB    $C0             ;;st-mem-0        x+x
        DEFB    $02             ;;delete          .
        DEFB    $A0             ;;stk-zero        0
        DEFB    $C2             ;;st-mem-2        0

; a loop is now entered to perform the algebraic calculation for each of
; the numbers in the series

;; G-LOOP
o3453:  DEFB    $31             ;;duplicate       v,v.
        DEFB    $E0             ;;get-mem-0       v,v,x+2
        DEFB    $04             ;;multiply        v,v*x+2
        DEFB    $E2             ;;get-mem-2       v,v*x+2,v
        DEFB    $C1             ;;st-mem-1
        DEFB    $03             ;;subtract
        DEFB    $38             ;;end-calc

; the previous pointer is fetched from the machine stack to H'L' where it
; addresses one of the numbers of the series following the series literal.

        CALL    o33C6           ; routine STK-DATA is called directly to
                                ; push a value and advance H'L'.
        CALL    o3362           ; routine GEN-ENT-2 recursively re-enters
                                ; the calculator without disturbing
                                ; system variable BREG
                                ; H'L' value goes on the machine stack and is
                                ; then loaded as usual with the next address.

        DEFB    $0F             ;;addition
        DEFB    $01             ;;exchange
        DEFB    $C2             ;;st-mem-2
        DEFB    $02             ;;delete

        DEFB    $35             ;;dec-jr-nz
        DEFB    $EE             ;;back to o3453, G-LOOP

; when the counted loop is complete the final subtraction yields the result
; for example SIN X.

        DEFB    $E1             ;;get-mem-1
        DEFB    $03             ;;subtract
        DEFB    $38             ;;end-calc

        RET                     ; return with H'L' pointing to location
                                ; after last number in series.

; ---------------------------------
; THE 'ABSOLUTE MAGNITUDE' FUNCTION
; ---------------------------------
; (offset: $2A 'abs')
;   This calculator literal finds the absolute value of the last value,
;   integer or floating point, on calculator stack.

;; abs
o346A:  LD      B,$FF           ; signal abs
        JR      o3474           ; forward to NEG-TEST

; ---------------------------
; THE 'UNARY MINUS' OPERATION
; ---------------------------
; (offset: $1B 'negate')
;   Unary so on entry HL points to last value, DE to STKEND.

;; NEGATE
;; negate
o346E:  CALL    o34E9           ; call routine TEST-ZERO and
        RET     C               ; return if so leaving zero unchanged.

        LD      B,$00           ; signal negate required before joining
                                ; common code.

;; NEG-TEST
o3474:  LD      A,(HL)          ; load first byte and
        AND     A               ; test for zero
        JR      Z,o3483         ; forward to INT-CASE if a small integer

; for floating point numbers a single bit denotes the sign.

        INC     HL              ; address the first byte of mantissa.
        LD      A,B             ; action flag $FF=abs, $00=neg.
        AND     $80             ; now         $80      $00
        OR      (HL)            ; sets bit 7 for abs
        RLA                     ; sets carry for abs and if number negative
        CCF                     ; complement carry flag
        RRA                     ; and rotate back in altering sign
        LD      (HL),A          ; put the altered adjusted number back
        DEC     HL              ; HL points to result
        RET                     ; return with DE unchanged

; ---

; for integer numbers an entire byte denotes the sign.

;; INT-CASE
o3483:  PUSH    DE              ; save STKEND.

        PUSH    HL              ; save pointer to the last value/result.

        CALL    o2D7F           ; routine INT-FETCH puts integer in DE
                                ; and the sign in C.

        POP     HL              ; restore the result pointer.

        LD      A,B             ; $FF=abs, $00=neg
        OR      C               ; $FF for abs, no change neg
        CPL                     ; $00 for abs, switched for neg
        LD      C,A             ; transfer result to sign byte.

        CALL    o2D8E           ; routine INT-STORE to re-write the integer.

        POP     DE              ; restore STKEND.
        RET                     ; return.

; ---------------------
; THE 'SIGNUM' FUNCTION
; ---------------------
; (offset: $29 'sgn')
;   This routine replaces the last value on the calculator stack,
;   which may be in floating point or integer form, with the integer values
;   zero if zero, with one if positive and  with -minus one if negative.

;; sgn
o3492:  CALL    o34E9           ; call routine TEST-ZERO and
        RET     C               ; exit if so as no change is required.

        PUSH    DE              ; save pointer to STKEND.

        LD      DE,$0001        ; the result will be 1.
        INC     HL              ; skip over the exponent.
        RL      (HL)            ; rotate the sign bit into the carry flag.
        DEC     HL              ; step back to point to the result.
        SBC     A,A             ; byte will be $FF if negative, $00 if positive.
        LD      C,A             ; store the sign byte in the C register.
        CALL    o2D8E           ; routine INT-STORE to overwrite the last
                                ; value with 0001 and sign.

        POP     DE              ; restore STKEND.
        RET                     ; return.

; -----------------
; THE 'IN' FUNCTION
; -----------------
; (offset: $2C 'in')
;   This function reads a byte from an input port.

;; in
o34A5:  CALL    o1E99           ; Routine FIND-INT2 puts port address in BC.
                                ; All 16 bits are put on the address line.

        IN      A,(C)           ; Read the port.

        JR      o34B0           ; exit to STACK-A (via IN-PK-STK to save a byte
                                ; of instruction code).

; -------------------
; THE 'PEEK' FUNCTION
; -------------------
; (offset: $2B 'peek')
;   This function returns the contents of a memory address.
;   The entire address space can be peeked including the ROM.

;; peek
o34AC:  CALL    o1E99           ; routine FIND-INT2 puts address in BC.
        LD      A,(BC)          ; load contents into A register.

;; IN-PK-STK
o34B0:  JP      o2D28           ; exit via STACK-A to put the value on the
                                ; calculator stack.

; ------------------
; THE 'USR' FUNCTION
; ------------------
; (offset: $2d 'usr-no')
;   The USR function followed by a number 0-65535 is the method by which
;   the Spectrum invokes machine code programs. This function returns the
;   contents of the BC register pair.
;   Note. that STACK-BC re-initializes the IY register if a user-written
;   program has altered it.

;; usr-no
o34B3:  CALL    o1E99           ; routine FIND-INT2 to fetch the
                                ; supplied address into BC.

        LD      HL,o2D2B        ; address: STACK-BC is
        PUSH    HL              ; pushed onto the machine stack.
        PUSH    BC              ; then the address of the machine code
                                ; routine.

        RET                     ; make an indirect jump to the routine
                                ; and, hopefully, to STACK-BC also.

; -------------------------
; THE 'USR STRING' FUNCTION
; -------------------------
; (offset: $19 'usr-$')
;   The user function with a one-character string argument, calculates the
;   address of the User Defined Graphic character that is in the string.
;   As an alternative, the ASCII equivalent, upper or lower case,
;   may be supplied. This provides a user-friendly method of redefining
;   the 21 User Definable Graphics e.g.
;   POKE USR "a", BIN 10000000 will put a dot in the top left corner of the
;   character 144.
;   Note. the curious double check on the range. With 26 UDGs the first check
;   only is necessary. With anything less the second check only is required.
;   It is highly likely that the first check was written by Steven Vickers.

;; usr-$
o34BC:  CALL    o2BF1           ; routine STK-FETCH fetches the string
                                ; parameters.
        DEC     BC              ; decrease BC by
        LD      A,B             ; one to test
        OR      C               ; the length.
        JR      NZ,o34E7        ; to REPORT-A if not a single character.

        LD      A,(DE)          ; fetch the character
        CALL    o2C8D           ; routine ALPHA sets carry if 'A-Z' or 'a-z'.
        JR      C,o34D3         ; forward to USR-RANGE if ASCII.

        SUB     $90             ; make UDGs range 0-20d
        JR      C,o34E7         ; to REPORT-A if too low. e.g. usr " ".

        CP      $15             ; Note. this test is not necessary.
        JR      NC,o34E7        ; to REPORT-A if higher than 20.

        INC     A               ; make range 1-21d to match LSBs of ASCII

;; USR-RANGE
o34D3:  DEC     A               ; make range of bits 0-4 start at zero
        ADD     A,A             ; multiply by eight
        ADD     A,A             ; and lose any set bits
        ADD     A,A             ; range now 0 - 25*8
        CP      $A8             ; compare to 21*8
        JR      NC,o34E7        ; to REPORT-A if originally higher
                                ; than 'U','u' or graphics U.

        LD      BC,(UDG)        ; fetch the UDG system variable value.
        ADD     A,C             ; add the offset to character
        LD      C,A             ; and store back in register C.
        JR      NC,o34E4        ; forward to USR-STACK if no overflow.

        INC     B               ; increment high byte.

;; USR-STACK
o34E4:  JP      o2D2B           ; jump back and exit via STACK-BC to store

; ---

;; REPORT-A
o34E7:  RST     08H             ; ERROR-1
        DEFB    $09             ; Error Report: Invalid argument

; ------------------------------
; THE 'TEST FOR ZERO' SUBROUTINE
; ------------------------------
;   Test if top value on calculator stack is zero.  The carry flag is set if
;   the last value is zero but no registers are altered.
;   All five bytes will be zero but first four only need be tested.
;   On entry, HL points to the exponent the first byte of the value.

;; TEST-ZERO
o34E9:  PUSH    HL              ; preserve HL which is used to address.
        PUSH    BC              ; preserve BC which is used as a store.
        LD      B,A             ; preserve A in B.

        LD      A,(HL)          ; load first byte to accumulator
        INC     HL              ; advance.
        OR      (HL)            ; OR with second byte and clear carry.
        INC     HL              ; advance.
        OR      (HL)            ; OR with third byte.
        INC     HL              ; advance.
        OR      (HL)            ; OR with fourth byte.

        LD      A,B             ; restore A without affecting flags.
        POP     BC              ; restore the saved
        POP     HL              ; registers.

        RET     NZ              ; return if not zero and with carry reset.

        SCF                     ; set the carry flag.
        RET                     ; return with carry set if zero.

; --------------------------------
; THE 'GREATER THAN ZERO' OPERATOR
; --------------------------------
; (offset: $37 'greater-0' )
;   Test if the last value on the calculator stack is greater than zero.
;   This routine is also called directly from the end-tests of the comparison
;   routine.

;; GREATER-0
;; greater-0
o34F9:  CALL    o34E9           ; routine TEST-ZERO
        RET     C               ; return if was zero as this
                                ; is also the Boolean 'false' value.

        LD      A,$FF           ; prepare XOR mask for sign bit
        JR      o3507           ; forward to SIGN-TO-C
                                ; to put sign in carry
                                ; (carry will become set if sign is positive)
                                ; and then overwrite location with 1 or 0
                                ; as appropriate.

; ------------------
; THE 'NOT' FUNCTION
; ------------------
; (offset: $30 'not')
;   This overwrites the last value with 1 if it was zero else with zero
;   if it was any other value.
;
;   e.g. NOT 0 returns 1, NOT 1 returns 0, NOT -3 returns 0.
;
;   The subroutine is also called directly from the end-tests of the comparison
;   operator.

;; NOT
;; not
o3501:  CALL    o34E9           ; routine TEST-ZERO sets carry if zero

        JR      o350B           ; to FP-0/1 to overwrite operand with
                                ; 1 if carry is set else to overwrite with zero.

; ------------------------------
; THE 'LESS THAN ZERO' OPERATION
; ------------------------------
; (offset: $36 'less-0' )
;   Destructively test if last value on calculator stack is less than zero.
;   Bit 7 of second byte will be set if so.

;; less-0
o3506:  XOR     A               ; set XOR mask to zero
                                ; (carry will become set if sign is negative).

;   transfer sign of mantissa to Carry Flag.

;; SIGN-TO-C
o3507:  INC     HL              ; address 2nd byte.
        XOR     (HL)            ; bit 7 of HL will be set if number is negative.
        DEC     HL              ; address 1st byte again.
        RLCA                    ; rotate bit 7 of A to carry.

; ----------------------------
; THE 'ZERO OR ONE' SUBROUTINE
; ----------------------------
;   This routine places an integer value of zero or one at the addressed
;   location of the calculator stack or MEM area.  The value one is written if
;   carry is set on entry else zero.

;; FP-0/1
o350B:  PUSH    HL              ; save pointer to the first byte
        LD      A,$00           ; load accumulator with zero - without
                                ; disturbing flags.
        LD      (HL),A          ; zero to first byte
        INC     HL              ; address next
        LD      (HL),A          ; zero to 2nd byte
        INC     HL              ; address low byte of integer
        RLA                     ; carry to bit 0 of A
        LD      (HL),A          ; load one or zero to low byte.
        RRA                     ; restore zero to accumulator.
        INC     HL              ; address high byte of integer.
        LD      (HL),A          ; put a zero there.
        INC     HL              ; address fifth byte.
        LD      (HL),A          ; put a zero there.
        POP     HL              ; restore pointer to the first byte.
        RET                     ; return.

; -----------------
; THE 'OR' OPERATOR
; -----------------
; (offset: $07 'or' )
; The Boolean OR operator. e.g. X OR Y
; The result is zero if both values are zero else a non-zero value.
;
; e.g.    0 OR 0  returns 0.
;        -3 OR 0  returns -3.
;         0 OR -3 returns 1.
;        -3 OR 2  returns 1.
;
; A binary operation.
; On entry HL points to first operand (X) and DE to second operand (Y).

;; or
o351B:  EX      DE,HL           ; make HL point to second number
        CALL    o34E9           ; routine TEST-ZERO
        EX      DE,HL           ; restore pointers
        RET     C               ; return if result was zero - first operand,
                                ; now the last value, is the result.

        SCF                     ; set carry flag
        JR      o350B           ; back to FP-0/1 to overwrite the first operand
                                ; with the value 1.


; ---------------------------------
; THE 'NUMBER AND NUMBER' OPERATION
; ---------------------------------
; (offset: $08 'no-&-no')
;   The Boolean AND operator.
;
;   e.g.    -3 AND 2  returns -3.
;           -3 AND 0  returns 0.
;            0 and -2 returns 0.
;            0 and 0  returns 0.
;
;   Compare with OR routine above.

;; no-&-no
o3524:  EX      DE,HL           ; make HL address second operand.

        CALL    o34E9           ; routine TEST-ZERO sets carry if zero.

        EX      DE,HL           ; restore pointers.
        RET     NC              ; return if second non-zero, first is result.

;

        AND     A               ; else clear carry.
        JR      o350B           ; back to FP-0/1 to overwrite first operand
                                ; with zero for return value.

; ---------------------------------
; THE 'STRING AND NUMBER' OPERATION
; ---------------------------------
; (offset: $10 'str-&-no')
;   e.g. "You Win" AND score>99 will return the string if condition is true
;   or the null string if false.

;; str-&-no
o352D:  EX      DE,HL           ; make HL point to the number.
        CALL    o34E9           ; routine TEST-ZERO.
        EX      DE,HL           ; restore pointers.
        RET     NC              ; return if number was not zero - the string
                                ; is the result.

;   if the number was zero (false) then the null string must be returned by
;   altering the length of the string on the calculator stack to zero.

        PUSH    DE              ; save pointer to the now obsolete number
                                ; (which will become the new STKEND)

        DEC     DE              ; point to the 5th byte of string descriptor.
        XOR     A               ; clear the accumulator.
        LD      (DE),A          ; place zero in high byte of length.
        DEC     DE              ; address low byte of length.
        LD      (DE),A          ; place zero there - now the null string.

        POP     DE              ; restore pointer - new STKEND.
        RET                     ; return.

; ---------------------------
; THE 'COMPARISON' OPERATIONS
; ---------------------------
; (offset: $0A 'no-gr-eql')
; (offset: $0B 'nos-neql')
; (offset: $0C 'no-grtr')
; (offset: $0D 'no-less')
; (offset: $0E 'nos-eql')
; (offset: $11 'str-l-eql')
; (offset: $12 'str-gr-eql')
; (offset: $13 'strs-neql')
; (offset: $14 'str-grtr')
; (offset: $15 'str-less')
; (offset: $16 'strs-eql')

;   True binary operations.
;   A single entry point is used to evaluate six numeric and six string
;   comparisons. On entry, the calculator literal is in the B register and
;   the two numeric values, or the two string parameters, are on the
;   calculator stack.
;   The individual bits of the literal are manipulated to group similar
;   operations although the SUB 8 instruction does nothing useful and merely
;   alters the string test bit.
;   Numbers are compared by subtracting one from the other, strings are
;   compared by comparing every character until a mismatch, or the end of one
;   or both, is reached.
;
;   Numeric Comparisons.
;   --------------------
;   The 'x>y' example is the easiest as it employs straight-thru logic.
;   Number y is subtracted from x and the result tested for greater-0 yielding
;   a final value 1 (true) or 0 (false).
;   For 'x<y' the same logic is used but the two values are first swapped on the
;   calculator stack.
;   For 'x=y' NOT is applied to the subtraction result yielding true if the
;   difference was zero and false with anything else.
;   The first three numeric comparisons are just the opposite of the last three
;   so the same processing steps are used and then a final NOT is applied.
;
; literal    Test   No  sub 8       ExOrNot  1st RRCA  exch sub  ?   End-Tests
; =========  ====   == ======== === ======== ========  ==== ===  =  === === ===
; no-l-eql   x<=y   09 00000001 dec 00000000 00000000  ---- x-y  ?  --- >0? NOT
; no-gr-eql  x>=y   0A 00000010 dec 00000001 10000000c swap y-x  ?  --- >0? NOT
; nos-neql   x<>y   0B 00000011 dec 00000010 00000001  ---- x-y  ?  NOT --- NOT
; no-grtr    x>y    0C 00000100  -  00000100 00000010  ---- x-y  ?  --- >0? ---
; no-less    x<y    0D 00000101  -  00000101 10000010c swap y-x  ?  --- >0? ---
; nos-eql    x=y    0E 00000110  -  00000110 00000011  ---- x-y  ?  NOT --- ---
;
;                                                           comp -> C/F
;                                                           ====    ===
; str-l-eql  x$<=y$ 11 00001001 dec 00001000 00000100  ---- x$y$ 0  !or >0? NOT
; str-gr-eql x$>=y$ 12 00001010 dec 00001001 10000100c swap y$x$ 0  !or >0? NOT
; strs-neql  x$<>y$ 13 00001011 dec 00001010 00000101  ---- x$y$ 0  !or >0? NOT
; str-grtr   x$>y$  14 00001100  -  00001100 00000110  ---- x$y$ 0  !or >0? ---
; str-less   x$<y$  15 00001101  -  00001101 10000110c swap y$x$ 0  !or >0? ---
; strs-eql   x$=y$  16 00001110  -  00001110 00000111  ---- x$y$ 0  !or >0? ---
;
;   String comparisons are a little different in that the eql/neql carry flag
;   from the 2nd RRCA is, as before, fed into the first of the end tests but
;   along the way it gets modified by the comparison process. The result on the
;   stack always starts off as zero and the carry fed in determines if NOT is
;   applied to it. So the only time the greater-0 test is applied is if the
;   stack holds zero which is not very efficient as the test will always yield
;   zero. The most likely explanation is that there were once separate end tests
;   for numbers and strings.

;; no-l-eql,etc.
o353B:  LD      A,B             ; transfer literal to accumulator.
        SUB     $08             ; subtract eight - which is not useful.

        BIT     2,A             ; isolate '>', '<', '='.

        JR      NZ,o3543        ; skip to EX-OR-NOT with these.

        DEC     A               ; else make $00-$02, $08-$0A to match bits 0-2.

;; EX-OR-NOT
o3543:  RRCA                    ; the first RRCA sets carry for a swap.
        JR      NC,o354E        ; forward to NU-OR-STR with other 8 cases

; for the other 4 cases the two values on the calculator stack are exchanged.

        PUSH    AF              ; save A and carry.
        PUSH    HL              ; save HL - pointer to first operand.
                                ; (DE points to second operand).

        CALL    o343C           ; routine exchange swaps the two values.
                                ; (HL = second operand, DE = STKEND)

        POP     DE              ; DE = first operand
        EX      DE,HL           ; as we were.
        POP     AF              ; restore A and carry.

; Note. it would be better if the 2nd RRCA preceded the string test.
; It would save two duplicate bytes and if we also got rid of that sub 8
; at the beginning we wouldn't have to alter which bit we test.

;; NU-OR-STR
o354E:  BIT     2,A             ; test if a string comparison.
        JR      NZ,o3559        ; forward to STRINGS if so.

; continue with numeric comparisons.

        RRCA                    ; 2nd RRCA causes eql/neql to set carry.
        PUSH    AF              ; save A and carry

        CALL    o300F           ; routine subtract leaves result on stack.
        JR      o358C           ; forward to END-TESTS

; ---

;; STRINGS
o3559:  RRCA                    ; 2nd RRCA causes eql/neql to set carry.
        PUSH    AF              ; save A and carry.

        CALL    o2BF1           ; routine STK-FETCH gets 2nd string params
        PUSH    DE              ; save start2 *.
        PUSH    BC              ; and the length.

        CALL    o2BF1           ; routine STK-FETCH gets 1st string
                                ; parameters - start in DE, length in BC.
        POP     HL              ; restore length of second to HL.

; A loop is now entered to compare, by subtraction, each corresponding character
; of the strings. For each successful match, the pointers are incremented and
; the lengths decreased and the branch taken back to here. If both string
; remainders become null at the same time, then an exact match exists.

;; BYTE-COMP
o3564:  LD      A,H             ; test if the second string
        OR      L               ; is the null string and hold flags.

        EX      (SP),HL         ; put length2 on stack, bring start2 to HL *.
        LD      A,B             ; hi byte of length1 to A

        JR      NZ,o3575        ; forward to SEC-PLUS if second not null.

        OR      C               ; test length of first string.

;; SECND-LOW
o356B:  POP     BC              ; pop the second length off stack.
        JR      Z,o3572         ; forward to BOTH-NULL if first string is also
                                ; of zero length.

; the true condition - first is longer than second (SECND-LESS)

        POP     AF              ; restore carry (set if eql/neql)
        CCF                     ; complement carry flag.
                                ; Note. equality becomes false.
                                ; Inequality is true. By swapping or applying
                                ; a terminal 'not', all comparisons have been
                                ; manipulated so that this is success path.
        JR      o3588           ; forward to leave via STR-TEST

; ---
; the branch was here with a match

;; BOTH-NULL
o3572:  POP     AF              ; restore carry - set for eql/neql
        JR      o3588           ; forward to STR-TEST

; ---
; the branch was here when 2nd string not null and low byte of first is yet
; to be tested.


;; SEC-PLUS
o3575:  OR      C               ; test the length of first string.
        JR      Z,o3585         ; forward to FRST-LESS if length is zero.

; both strings have at least one character left.

        LD      A,(DE)          ; fetch character of first string.
        SUB     (HL)            ; subtract with that of 2nd string.
        JR      C,o3585         ; forward to FRST-LESS if carry set

        JR      NZ,o356B        ; back to SECND-LOW and then STR-TEST
                                ; if not exact match.

        DEC     BC              ; decrease length of 1st string.
        INC     DE              ; increment 1st string pointer.

        INC     HL              ; increment 2nd string pointer.
        EX      (SP),HL         ; swap with length on stack
        DEC     HL              ; decrement 2nd string length
        JR      o3564           ; back to BYTE-COMP

; ---
; the false condition.

;; FRST-LESS
o3585:  POP     BC              ; discard length
        POP     AF              ; pop A
        AND     A               ; clear the carry for false result.

; ---
; exact match and x$>y$ rejoin here

;; STR-TEST
o3588:  PUSH    AF              ; save A and carry

        RST     28H             ;; FP-CALC
        DEFB    $A0             ;;stk-zero      an initial false value.
        DEFB    $38             ;;end-calc

; both numeric and string paths converge here.

;; END-TESTS
o358C:  POP     AF              ; pop carry  - will be set if eql/neql
        PUSH    AF              ; save it again.

        CALL    C,o3501         ; routine NOT sets true(1) if equal(0)
                                ; or, for strings, applies true result.

        POP     AF              ; pop carry and
        PUSH    AF              ; save A

        CALL    NC,o34F9        ; routine GREATER-0 tests numeric subtraction
                                ; result but also needlessly tests the string
                                ; value for zero - it must be.

        POP     AF              ; pop A
        RRCA                    ; the third RRCA - test for '<=', '>=' or '<>'.
        CALL    NC,o3501        ; apply a terminal NOT if so.
        RET                     ; return.

; ------------------------------------
; THE 'STRING CONCATENATION' OPERATION
; ------------------------------------
; (offset: $17 'strs-add')
;   This literal combines two strings into one e.g. LET a$ = b$ + c$
;   The two parameters of the two strings to be combined are on the stack.

;; strs-add
o359C:  CALL    o2BF1           ; routine STK-FETCH fetches string parameters
                                ; and deletes calculator stack entry.
        PUSH    DE              ; save start address.
        PUSH    BC              ; and length.

        CALL    o2BF1           ; routine STK-FETCH for first string
        POP     HL              ; re-fetch first length
        PUSH    HL              ; and save again
        PUSH    DE              ; save start of second string
        PUSH    BC              ; and its length.

        ADD     HL,BC           ; add the two lengths.
        LD      B,H             ; transfer to BC
        LD      C,L             ; and create
        RST     30H             ; BC-SPACES in workspace.
                                ; DE points to start of space.

        CALL    o2AB2           ; routine STK-STO-$ stores parameters
                                ; of new string updating STKEND.

        POP     BC              ; length of first
        POP     HL              ; address of start
        LD      A,B             ; test for
        OR      C               ; zero length.
        JR      Z,o35B7         ; to OTHER-STR if null string

        LDIR                    ; copy string to workspace.

;; OTHER-STR
o35B7:  POP     BC              ; now second length
        POP     HL              ; and start of string
        LD      A,B             ; test this one
        OR      C               ; for zero length
        JR      Z,o35BF         ; skip forward to STK-PNTRS if so as complete.

        LDIR                    ; else copy the bytes.
                                ; and continue into next routine which
                                ; sets the calculator stack pointers.

; -----------------------------------
; THE 'SET STACK POINTERS' SUBROUTINE
; -----------------------------------
;   Register DE is set to STKEND and HL, the result pointer, is set to five
;   locations below this.
;   This routine is used when it is inconvenient to save these values at the
;   time the calculator stack is manipulated due to other activity on the
;   machine stack.
;   This routine is also used to terminate the VAL and READ-IN  routines for
;   the same reason and to initialize the calculator stack at the start of
;   the CALCULATE routine.

;; STK-PNTRS
o35BF:  LD      HL,(STKEND)     ; fetch STKEND value from system variable.
        LD      DE,$FFFB        ; the value -5
        PUSH    HL              ; push STKEND value.

        ADD     HL,DE           ; subtract 5 from HL.

        POP     DE              ; pop STKEND to DE.
        RET                     ; return.

; -------------------
; THE 'CHR$' FUNCTION
; -------------------
; (offset: $2f 'chr$')
;   This function returns a single character string that is a result of
;   converting a number in the range 0-255 to a string e.g. CHR$ 65 = "A".

;; chrs
o35C9:  CALL    o2DD5           ; routine FP-TO-A puts the number in A.

        JR      C,o35DC         ; forward to REPORT-Bd if overflow
        JR      NZ,o35DC        ; forward to REPORT-Bd if negative

        PUSH    AF              ; save the argument.

        LD      BC,$0001        ; one space required.
        RST     30H             ; BC-SPACES makes DE point to start

        POP     AF              ; restore the number.

        LD      (DE),A          ; and store in workspace

        CALL    o2AB2           ; routine STK-STO-$ stacks descriptor.

        EX      DE,HL           ; make HL point to result and DE to STKEND.
        RET                     ; return.

; ---

;; REPORT-Bd
o35DC:  RST     08H             ; ERROR-1
        DEFB    $0A             ; Error Report: Integer out of range

; ----------------------------
; THE 'VAL and VAL$' FUNCTIONS
; ----------------------------
; (offset: $1d 'val')
; (offset: $18 'val$')
;   VAL treats the characters in a string as a numeric expression.
;   e.g. VAL "2.3" = 2.3, VAL "2+4" = 6, VAL ("2" + "4") = 24.
;   VAL$ treats the characters in a string as a string expression.
;   e.g. VAL$ (z$+"(2)") = a$(2) if z$ happens to be "a$".

;; val
;; val$
o35DE:  LD      HL,(CH_ADD)     ; fetch value of system variable CH_ADD
        PUSH    HL              ; and save on the machine stack.
        LD      A,B             ; fetch the literal (either $1D or $18).
        ADD     A,$E3           ; add $E3 to form $00 (setting carry) or $FB.
        SBC     A,A             ; now form $FF bit 6 = numeric result
                                ; or $00 bit 6 = string result.
        PUSH    AF              ; save this mask on the stack

        CALL    o2BF1           ; routine STK-FETCH fetches the string operand
                                ; from calculator stack.

        PUSH    DE              ; save the address of the start of the string.
        INC     BC              ; increment the length for a carriage return.

        RST     30H             ; BC-SPACES creates the space in workspace.
        POP     HL              ; restore start of string to HL.
        LD      (CH_ADD),DE     ; load CH_ADD with start DE in workspace.

        PUSH    DE              ; save the start in workspace
        LDIR                    ; copy string from program or variables or
                                ; workspace to the workspace area.
        EX      DE,HL           ; end of string + 1 to HL
        DEC     HL              ; decrement HL to point to end of new area.
        LD      (HL),$0D        ; insert a carriage return at end.
        RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax.
        CALL    o24FB           ; routine SCANNING evaluates string
                                ; expression and result.

        RST     18H             ; GET-CHAR fetches next character.
        CP      $0D             ; is it the expected carriage return ?
        JR      NZ,o360C        ; forward to V-RPORT-C if not
                                ; 'Nonsense in BASIC'.

        POP     HL              ; restore start of string in workspace.
        POP     AF              ; restore expected result flag (bit 6).
        XOR     (IY+$01)        ; xor with FLAGS now updated by SCANNING.
        AND     $40             ; test bit 6 - should be zero if result types
                                ; match.

;; V-RPORT-C
o360C:  JP      NZ,o1C8A        ; jump back to REPORT-C with a result mismatch.

        LD      (CH_ADD),HL     ; set CH_ADD to the start of the string again.
        SET     7,(IY+$01)      ; update FLAGS  - signal running program.
        CALL    o24FB           ; routine SCANNING evaluates the string
                                ; in full leaving result on calculator stack.

        POP     HL              ; restore saved character address in program.
        LD      (CH_ADD),HL     ; and reset the system variable CH_ADD.

        JR      o35BF           ; back to exit via STK-PNTRS.
                                ; resetting the calculator stack pointers
                                ; HL and DE from STKEND as it wasn't possible
                                ; to preserve them during this routine.

; -------------------
; THE 'STR$' FUNCTION
; -------------------
; (offset: $2e 'str$')
;   This function produces a string comprising the characters that would appear
;   if the numeric argument were printed.
;   e.g. STR$ (1/10) produces "0.1".

;; str$
o361F:  LD      BC,$0001        ; create an initial byte in workspace
        RST     30H             ; using BC-SPACES restart.

        LD      ($5C5B),HL      ; set system variable K_CUR to new location.
        PUSH    HL              ; and save start on machine stack also.

        LD      HL,(CURCHL)     ; fetch value of system variable CURCHL
        PUSH    HL              ; and save that too.

        LD      A,$FF           ; select system channel 'R'.
        CALL    o1601           ; routine CHAN-OPEN opens it.
        CALL    o2DE3           ; routine PRINT-FP outputs the number to
                                ; workspace updating K-CUR.

        POP     HL              ; restore current channel.
        CALL    o1615           ; routine CHAN-FLAG resets flags.

        POP     DE              ; fetch saved start of string to DE.
        LD      HL,($5C5B)      ; load HL with end of string from K_CUR.

        AND     A               ; prepare for true subtraction.
        SBC     HL,DE           ; subtract start from end to give length.
        LD      B,H             ; transfer the length to
        LD      C,L             ; the BC register pair.

        CALL    o2AB2           ; routine STK-STO-$ stores string parameters
                                ; on the calculator stack.

        EX      DE,HL           ; HL = last value, DE = STKEND.
        RET                     ; return.

; ------------------------
; THE 'READ-IN' SUBROUTINE
; ------------------------
; (offset: $1a 'read-in')
;   This is the calculator literal used by the INKEY$ function when a '#'
;   is encountered after the keyword.
;   INKEY$ # does not interact correctly with the keyboard, #0 or #1, and
;   its uses are for other channels.

;; read-in
o3645:  CALL    o1E94           ; routine FIND-INT1 fetches stream to A
        CP      $10             ; compare with 16 decimal.
        JP      NC,o1E9F        ; JUMP to REPORT-Bb if not in range 0 - 15.
                                ; 'Integer out of range'
                                ; (REPORT-Bd is within range)

        LD      HL,(CURCHL)     ; fetch current channel CURCHL
        PUSH    HL              ; save it

        CALL    o1601           ; routine CHAN-OPEN opens channel

        CALL    o15E6           ; routine INPUT-AD - the channel must have an
                                ; input stream or else error here from stream
                                ; stub.
        LD      BC,$0000        ; initialize length of string to zero
        JR      NC,o365F        ; forward to R-I-STORE if no key detected.

        INC     C               ; increase length to one.

        RST     30H             ; BC-SPACES creates space for one character
                                ; in workspace.
        LD      (DE),A          ; the character is inserted.

;; R-I-STORE
o365F:  CALL    o2AB2           ; routine STK-STO-$ stacks the string
                                ; parameters.
        POP     HL              ; restore current channel address

        CALL    o1615           ; routine CHAN-FLAG resets current channel
                                ; system variable and flags.

        JP      o35BF           ; jump back to STK-PNTRS

; -------------------
; THE 'CODE' FUNCTION
; -------------------
; (offset: $1c 'code')
;   Returns the ASCII code of a character or first character of a string
;   e.g. CODE "Aardvark" = 65, CODE "" = 0.

;; code
o3669:  CALL    o2BF1           ; routine STK-FETCH to fetch and delete the
                                ; string parameters.
                                ; DE points to the start, BC holds the length.

        LD      A,B             ; test length
        OR      C               ; of the string.
        JR      Z,o3671         ; skip to STK-CODE with zero if the null string.

        LD      A,(DE)          ; else fetch the first character.

;; STK-CODE
o3671:  JP      o2D28           ; jump back to STACK-A (with memory check)

; ------------------
; THE 'LEN' FUNCTION
; ------------------
; (offset: $1e 'len')
;   Returns the length of a string.
;   In Sinclair BASIC strings can be more than twenty thousand characters long
;   so a sixteen-bit register is required to store the length

;; len
o3674:  CALL    o2BF1           ; Routine STK-FETCH to fetch and delete the
                                ; string parameters from the calculator stack.
                                ; Register BC now holds the length of string.

        JP      o2D2B           ; Jump back to STACK-BC to save result on the
                                ; calculator stack (with memory check).

; -------------------------------------
; THE 'DECREASE THE COUNTER' SUBROUTINE
; -------------------------------------
; (offset: $35 'dec-jr-nz')
;   The calculator has an instruction that decrements a single-byte
;   pseudo-register and makes consequential relative jumps just like
;   the Z80's DJNZ instruction.

;; dec-jr-nz
o367A:  EXX                     ; switch in set that addresses code

        PUSH    HL              ; save pointer to offset byte
        LD      HL,$5C67        ; address BREG in system variables
        DEC     (HL)            ; decrement it
        POP     HL              ; restore pointer

        JR      NZ,o3687        ; to JUMP-2 if not zero

        INC     HL              ; step past the jump length.
        EXX                     ; switch in the main set.
        RET                     ; return.

; Note. as a general rule the calculator avoids using the IY register
; otherwise the cumbersome 4 instructions in the middle could be repoaced by
; dec (iy+$2d) - three bytes instead of six.


; ---------------------
; THE 'JUMP' SUBROUTINE
; ---------------------
; (offset: $33 'jump')
;   This enables the calculator to perform relative jumps just like the Z80
;   chip's JR instruction.

;; jump
;; JUMP
o3686:  EXX                     ; switch in pointer set

;; JUMP-2
o3687:  LD      E,(HL)          ; the jump byte 0-127 forward, 128-255 back.
        LD      A,E             ; transfer to accumulator.
        RLA                     ; if backward jump, carry is set.
        SBC     A,A             ; will be $FF if backward or $00 if forward.
        LD      D,A             ; transfer to high byte.
        ADD     HL,DE           ; advance calculator pointer forward or back.

        EXX                     ; switch back.
        RET                     ; return.

; --------------------------
; THE 'JUMP-TRUE' SUBROUTINE
; --------------------------
; (offset: $00 'jump-true')
;   This enables the calculator to perform conditional relative jumps dependent
;   on whether the last test gave a true result.

;; jump-true
o368F:  INC     DE              ; Collect the
        INC     DE              ; third byte
        LD      A,(DE)          ; of the test
        DEC     DE              ; result and
        DEC     DE              ; backtrack.

        AND     A               ; Is result 0 or 1 ?
        JR      NZ,o3686        ; Back to JUMP if true (1).

        EXX                     ; Else switch in the pointer set.
        INC     HL              ; Step past the jump length.
        EXX                     ; Switch in the main set.
        RET                     ; Return.

; -------------------------
; THE 'END-CALC' SUBROUTINE
; -------------------------
; (offset: $38 'end-calc')
;   The end-calc literal terminates a mini-program written in the Spectrum's
;   internal language.

;; end-calc
o369B:  POP     AF              ; Drop the calculator return address RE-ENTRY
        EXX                     ; Switch to the other set.

        EX      (SP),HL         ; Transfer H'L' to machine stack for the
                                ; return address.
                                ; When exiting recursion, then the previous
                                ; pointer is transferred to H'L'.

        EXX                     ; Switch back to main set.
        RET                     ; Return.


; ------------------------
; THE 'MODULUS' SUBROUTINE
; ------------------------
; (offset: $32 'n-mod-m')
; (n1,n2 -- r,q)
;   Similar to FORTH's 'divide mod' /MOD
;   On the Spectrum, this is only used internally by the RND function and could
;   have been implemented inline.  On the ZX81, this calculator routine was also
;   used by PRINT-FP.

;; n-mod-m
o36A0:  RST     28H             ;; FP-CALC          17, 3.
        DEFB    $C0             ;;st-mem-0          17, 3.
        DEFB    $02             ;;delete            17.
        DEFB    $31             ;;duplicate         17, 17.
        DEFB    $E0             ;;get-mem-0         17, 17, 3.
        DEFB    $05             ;;division          17, 17/3.
        DEFB    $27             ;;int               17, 5.
        DEFB    $E0             ;;get-mem-0         17, 5, 3.
        DEFB    $01             ;;exchange          17, 3, 5.
        DEFB    $C0             ;;st-mem-0          17, 3, 5.
        DEFB    $04             ;;multiply          17, 15.
        DEFB    $03             ;;subtract          2.
        DEFB    $E0             ;;get-mem-0         2, 5.
        DEFB    $38             ;;end-calc          2, 5.

        RET                     ; return.


; ------------------
; THE 'INT' FUNCTION
; ------------------
; (offset $27: 'int' )
; This function returns the integer of x, which is just the same as truncate
; for positive numbers. The truncate literal truncates negative numbers
; upwards so that -3.4 gives -3 whereas the BASIC INT function has to
; truncate negative numbers down so that INT -3.4 is -4.
; It is best to work through using, say, +-3.4 as examples.

;; int
o36AF:  RST     28H             ;; FP-CALC              x.    (= 3.4 or -3.4).
        DEFB    $31             ;;duplicate             x, x.
        DEFB    $36             ;;less-0                x, (1/0)
        DEFB    $00             ;;jump-true             x, (1/0)
        DEFB    $04             ;;to o36B7, X-NEG

        DEFB    $3A             ;;truncate              trunc 3.4 = 3.
        DEFB    $38             ;;end-calc              3.

        RET                     ; return with + int x on stack.

; ---


;; X-NEG
o36B7:  DEFB    $31             ;;duplicate             -3.4, -3.4.
        DEFB    $3A             ;;truncate              -3.4, -3.
        DEFB    $C0             ;;st-mem-0              -3.4, -3.
        DEFB    $03             ;;subtract              -.4
        DEFB    $E0             ;;get-mem-0             -.4, -3.
        DEFB    $01             ;;exchange              -3, -.4.
        DEFB    $30             ;;not                   -3, (0).
        DEFB    $00             ;;jump-true             -3.
        DEFB    $03             ;;to o36C2, EXIT        -3.

        DEFB    $A1             ;;stk-one               -3, 1.
        DEFB    $03             ;;subtract              -4.

;; EXIT
o36C2:  DEFB    $38             ;;end-calc              -4.

        RET                     ; return.


; ------------------
; THE 'EXP' FUNCTION
; ------------------
; (offset $26: 'exp')
;   The exponential function EXP x is equal to e^x, where e is the mathematical
;   name for a number approximated to 2.718281828.
;   ERROR 6 if argument is more than about 88.

;; EXP
;; exp
o36C4:  RST     28H             ;; FP-CALC
        DEFB    $3D             ;;re-stack      (not required - mult will do)
        DEFB    $34             ;;stk-data
        DEFB    $F1             ;;Exponent: $81, Bytes: 4
        DEFB    $38,$AA,$3B,$29 ;;
        DEFB    $04             ;;multiply
        DEFB    $31             ;;duplicate
        DEFB    $27             ;;int
        DEFB    $C3             ;;st-mem-3
        DEFB    $03             ;;subtract
        DEFB    $31             ;;duplicate
        DEFB    $0F             ;;addition
        DEFB    $A1             ;;stk-one
        DEFB    $03             ;;subtract
        DEFB    $88             ;;series-08
        DEFB    $13             ;;Exponent: $63, Bytes: 1
        DEFB    $36             ;;(+00,+00,+00)
        DEFB    $58             ;;Exponent: $68, Bytes: 2
        DEFB    $65,$66         ;;(+00,+00)
        DEFB    $9D             ;;Exponent: $6D, Bytes: 3
        DEFB    $78,$65,$40     ;;(+00)
        DEFB    $A2             ;;Exponent: $72, Bytes: 3
        DEFB    $60,$32,$C9     ;;(+00)
        DEFB    $E7             ;;Exponent: $77, Bytes: 4
        DEFB    $21,$F7,$AF,$24 ;;
        DEFB    $EB             ;;Exponent: $7B, Bytes: 4
        DEFB    $2F,$B0,$B0,$14 ;;
        DEFB    $EE             ;;Exponent: $7E, Bytes: 4
        DEFB    $7E,$BB,$94,$58 ;;
        DEFB    $F1             ;;Exponent: $81, Bytes: 4
        DEFB    $3A,$7E,$F8,$CF ;;
        DEFB    $E3             ;;get-mem-3
        DEFB    $38             ;;end-calc

        CALL    o2DD5           ; routine FP-TO-A
        JR      NZ,o3705        ; to N-NEGTV

        JR      C,o3703         ; to REPORT-6b
                                ; 'Number too big'

        ADD     A,(HL)          ;
        JR      NC,o370C        ; to RESULT-OK


;; REPORT-6b
o3703:  RST     08H             ; ERROR-1
        DEFB    $05             ; Error Report: Number too big

; ---

;; N-NEGTV
o3705:  JR      C,o370E         ; to RSLT-ZERO

        SUB     (HL)            ;
        JR      NC,o370E        ; to RSLT-ZERO

        NEG                     ; Negate

;; RESULT-OK
o370C:  LD      (HL),A          ;
        RET                     ; return.

; ---


;; RSLT-ZERO
o370E:  RST     28H             ;; FP-CALC
        DEFB    $02             ;;delete
        DEFB    $A0             ;;stk-zero
        DEFB    $38             ;;end-calc

        RET                     ; return.


; --------------------------------
; THE 'NATURAL LOGARITHM' FUNCTION
; --------------------------------
; (offset $25: 'ln')
;   Function to calculate the natural logarithm (to the base e ).
;   Natural logarithms were devised in 1614 by well-traveled Scotsman John
;   Napier who noted
;   "Nothing doth more molest and hinder calculators than the multiplications,
;    divisions, square and cubical extractions of great numbers".
;
;   Napier's logarithms enabled the above operations to be accomplished by
;   simple addition and subtraction simplifying the navigational and
;   astronomical calculations which beset his age.
;   Napier's logarithms were quickly overtaken by logarithms to the base 10
;   devised, in conjunction with Napier, by Henry Briggs a Cambridge-educated
;   professor of Geometry at Oxford University. These simplified the layout
;   of the tables enabling humans to easily scale calculations.
;
;   It is only recently with the introduction of pocket calculators and machines
;   like the ZX Spectrum that natural logarithms are once more at the fore,
;   although some computers retain logarithms to the base ten.
;
;   'Natural' logarithms are powers to the base 'e', which like 'pi' is a
;   naturally occurring number in branches of mathematics.
;   Like 'pi' also, 'e' is an irrational number and starts 2.718281828...
;
;   The tabular use of logarithms was that to multiply two numbers one looked
;   up their two logarithms in the tables, added them together and then looked
;   for the result in a table of antilogarithms to give the desired product.
;
;   The EXP function is the BASIC equivalent of a calculator's 'antiln' function
;   and by picking any two numbers, 1.72 and 6.89 say,
;     10 PRINT EXP ( LN 1.72 + LN 6.89 )
;   will give just the same result as
;     20 PRINT 1.72 * 6.89.
;   Division is accomplished by subtracting the two logs.
;
;   Napier also mentioned "square and cubicle extractions".
;   To raise a number to the power 3, find its 'ln', multiply by 3 and find the
;   'antiln'.  e.g. PRINT EXP( LN 4 * 3 )  gives 64.
;   Similarly to find the n'th root divide the logarithm by 'n'.
;   The ZX81 ROM used PRINT EXP ( LN 9 / 2 ) to find the square root of the
;   number 9. The Napieran square root function is just a special case of
;   the 'to_power' function. A cube root or indeed any root/power would be just
;   as simple.

;   First test that the argument to LN is a positive, non-zero number.
;   Error A if the argument is 0 or negative.

;; ln
o3713:  RST     28H             ;; FP-CALC
        DEFB    $3D             ;;re-stack
        DEFB    $31             ;;duplicate
        DEFB    $37             ;;greater-0
        DEFB    $00             ;;jump-true
        DEFB    $04             ;;to o371C, VALID

        DEFB    $38             ;;end-calc


;; REPORT-Ab
o371A:  RST     08H             ; ERROR-1
        DEFB    $09             ; Error Report: Invalid argument

;; VALID
o371C:  DEFB    $A0             ;;stk-zero              Note. not
        DEFB    $02             ;;delete                necessary.
        DEFB    $38             ;;end-calc
        LD      A,(HL)          ;

        LD      (HL),$80        ;
        CALL    o2D28           ; routine STACK-A

        RST     28H             ;; FP-CALC
        DEFB    $34             ;;stk-data
        DEFB    $38             ;;Exponent: $88, Bytes: 1
        DEFB    $00             ;;(+00,+00,+00)
        DEFB    $03             ;;subtract
        DEFB    $01             ;;exchange
        DEFB    $31             ;;duplicate
        DEFB    $34             ;;stk-data
        DEFB    $F0             ;;Exponent: $80, Bytes: 4
        DEFB    $4C,$CC,$CC,$CD ;;
        DEFB    $03             ;;subtract
        DEFB    $37             ;;greater-0
        DEFB    $00             ;;jump-true
        DEFB    $08             ;;to o373D, GRE.8

        DEFB    $01             ;;exchange
        DEFB    $A1             ;;stk-one
        DEFB    $03             ;;subtract
        DEFB    $01             ;;exchange
        DEFB    $38             ;;end-calc

        INC     (HL)            ;

        RST     28H             ;; FP-CALC

;; GRE.8
o373D:  DEFB    $01             ;;exchange
        DEFB    $34             ;;stk-data
        DEFB    $F0             ;;Exponent: $80, Bytes: 4
        DEFB    $31,$72,$17,$F8 ;;
        DEFB    $04             ;;multiply
        DEFB    $01             ;;exchange
        DEFB    $A2             ;;stk-half
        DEFB    $03             ;;subtract
        DEFB    $A2             ;;stk-half
        DEFB    $03             ;;subtract
        DEFB    $31             ;;duplicate
        DEFB    $34             ;;stk-data
        DEFB    $32             ;;Exponent: $82, Bytes: 1
        DEFB    $20             ;;(+00,+00,+00)
        DEFB    $04             ;;multiply
        DEFB    $A2             ;;stk-half
        DEFB    $03             ;;subtract
        DEFB    $8C             ;;series-0C
        DEFB    $11             ;;Exponent: $61, Bytes: 1
        DEFB    $AC             ;;(+00,+00,+00)
        DEFB    $14             ;;Exponent: $64, Bytes: 1
        DEFB    $09             ;;(+00,+00,+00)
        DEFB    $56             ;;Exponent: $66, Bytes: 2
        DEFB    $DA,$A5         ;;(+00,+00)
        DEFB    $59             ;;Exponent: $69, Bytes: 2
        DEFB    $30,$C5         ;;(+00,+00)
        DEFB    $5C             ;;Exponent: $6C, Bytes: 2
        DEFB    $90,$AA         ;;(+00,+00)
        DEFB    $9E             ;;Exponent: $6E, Bytes: 3
        DEFB    $70,$6F,$61     ;;(+00)
        DEFB    $A1             ;;Exponent: $71, Bytes: 3
        DEFB    $CB,$DA,$96     ;;(+00)
        DEFB    $A4             ;;Exponent: $74, Bytes: 3
        DEFB    $31,$9F,$B4     ;;(+00)
        DEFB    $E7             ;;Exponent: $77, Bytes: 4
        DEFB    $A0,$FE,$5C,$FC ;;
        DEFB    $EA             ;;Exponent: $7A, Bytes: 4
        DEFB    $1B,$43,$CA,$36 ;;
        DEFB    $ED             ;;Exponent: $7D, Bytes: 4
        DEFB    $A7,$9C,$7E,$5E ;;
        DEFB    $F0             ;;Exponent: $80, Bytes: 4
        DEFB    $6E,$23,$80,$93 ;;
        DEFB    $04             ;;multiply
        DEFB    $0F             ;;addition
        DEFB    $38             ;;end-calc

        RET                     ; return.


; -----------------------------
; THE 'TRIGONOMETRIC' FUNCTIONS
; -----------------------------
; Trigonometry is rocket science. It is also used by carpenters and pyramid
; builders.
; Some uses can be quite abstract but the principles can be seen in simple
; right-angled triangles. Triangles have some special properties -
;
; 1) The sum of the three angles is always PI radians (180 degrees).
;    Very helpful if you know two angles and wish to find the third.
; 2) In any right-angled triangle the sum of the squares of the two shorter
;    sides is equal to the square of the longest side opposite the right-angle.
;    Very useful if you know the length of two sides and wish to know the
;    length of the third side.
; 3) Functions sine, cosine and tangent enable one to calculate the length
;    of an unknown side when the length of one other side and an angle is
;    known.
; 4) Functions arcsin, arccosine and arctan enable one to calculate an unknown
;    angle when the length of two of the sides is known.

; --------------------------------
; THE 'REDUCE ARGUMENT' SUBROUTINE
; --------------------------------
; (offset $39: 'get-argt')
;
; This routine performs two functions on the angle, in radians, that forms
; the argument to the sine and cosine functions.
; First it ensures that the angle 'wraps round'. That if a ship turns through
; an angle of, say, 3*PI radians (540 degrees) then the net effect is to turn
; through an angle of PI radians (180 degrees).
; Secondly it converts the angle in radians to a fraction of a right angle,
; depending within which quadrant the angle lies, with the periodicity
; resembling that of the desired sine value.
; The result lies in the range -1 to +1.
;
;                     90 deg.
;
;                     (pi/2)
;              II       +1        I
;                       |
;        sin+      |\   |   /|    sin+
;        cos-      | \  |  / |    cos+
;        tan-      |  \ | /  |    tan+
;                  |   \|/)  |
; 180 deg. (pi) 0 -|----+----|-- 0  (0)   0 degrees
;                  |   /|\   |
;        sin-      |  / | \  |    sin-
;        cos-      | /  |  \ |    cos+
;        tan+      |/   |   \|    tan-
;                       |
;              III      -1       IV
;                     (3pi/2)
;
;                     270 deg.
;

;; get-argt
o3783:  RST     28H             ;; FP-CALC      X.
        DEFB    $3D             ;;re-stack      (not rquired done by mult)
        DEFB    $34             ;;stk-data
        DEFB    $EE             ;;Exponent: $7E,
                                ;;Bytes: 4
        DEFB    $22,$F9,$83,$6E ;;              X, 1/(2*PI)
        DEFB    $04             ;;multiply      X/(2*PI) = fraction
        DEFB    $31             ;;duplicate
        DEFB    $A2             ;;stk-half
        DEFB    $0F             ;;addition
        DEFB    $27             ;;int

        DEFB    $03             ;;subtract      now range -.5 to .5

        DEFB    $31             ;;duplicate
        DEFB    $0F             ;;addition      now range -1 to 1.
        DEFB    $31             ;;duplicate
        DEFB    $0F             ;;addition      now range -2 to +2.

; quadrant I (0 to +1) and quadrant IV (-1 to 0) are now correct.
; quadrant II ranges +1 to +2.
; quadrant III ranges -2 to -1.

        DEFB    $31             ;;duplicate     Y, Y.
        DEFB    $2A             ;;abs           Y, abs(Y).    range 1 to 2
        DEFB    $A1             ;;stk-one       Y, abs(Y), 1.
        DEFB    $03             ;;subtract      Y, abs(Y)-1.  range 0 to 1
        DEFB    $31             ;;duplicate     Y, Z, Z.
        DEFB    $37             ;;greater-0     Y, Z, (1/0).

        DEFB    $C0             ;;st-mem-0         store as possible sign
                                ;;                 for cosine function.

        DEFB    $00             ;;jump-true
        DEFB    $04             ;;to o37A1, ZPLUS  with quadrants II and III.

; else the angle lies in quadrant I or IV and value Y is already correct.

        DEFB    $02             ;;delete        Y.   delete the test value.
        DEFB    $38             ;;end-calc      Y.

        RET                     ; return.       with Q1 and Q4           >>>

; ---

; the branch was here with quadrants II (0 to 1) and III (1 to 0).
; Y will hold -2 to -1 if this is quadrant III.

;; ZPLUS
o37A1:  DEFB    $A1             ;;stk-one         Y, Z, 1.
        DEFB    $03             ;;subtract        Y, Z-1.       Q3 = 0 to -1
        DEFB    $01             ;;exchange        Z-1, Y.
        DEFB    $36             ;;less-0          Z-1, (1/0).
        DEFB    $00             ;;jump-true       Z-1.
        DEFB    $02             ;;to o37A8, YNEG
                                ;;if angle in quadrant III

; else angle is within quadrant II (-1 to 0)

        DEFB    $1B             ;;negate          range +1 to 0.

;; YNEG
o37A8:  DEFB    $38             ;;end-calc        quadrants II and III correct.

        RET                     ; return.


; ---------------------
; THE 'COSINE' FUNCTION
; ---------------------
; (offset $20: 'cos')
; Cosines are calculated as the sine of the opposite angle rectifying the
; sign depending on the quadrant rules.
;
;
;           /|
;        h /y|
;         /  |o
;        /x  |
;       /----|
;         a
;
; The cosine of angle x is the adjacent side (a) divided by the hypotenuse 1.
; However if we examine angle y then a/h is the sine of that angle.
; Since angle x plus angle y equals a right-angle, we can find angle y by
; subtracting angle x from pi/2.
; However it's just as easy to reduce the argument first and subtract the
; reduced argument from the value 1 (a reduced right-angle).
; It's even easier to subtract 1 from the angle and rectify the sign.
; In fact, after reducing the argument, the absolute value of the argument
; is used and rectified using the test result stored in mem-0 by 'get-argt'
; for that purpose.
;

;; cos
o37AA:  RST     28H             ;; FP-CALC              angle in radians.
        DEFB    $39             ;;get-argt              X     reduce -1 to +1

        DEFB    $2A             ;;abs                   ABS X.   0 to 1
        DEFB    $A1             ;;stk-one               ABS X, 1.
        DEFB    $03             ;;subtract              now opposite angle
                                ;;                      although sign is -ve.

        DEFB    $E0             ;;get-mem-0             fetch the sign indicator
        DEFB    $00             ;;jump-true
        DEFB    $06             ;;fwd to o37B7, C-ENT
                                ;;forward to common code if in QII or QIII.

        DEFB    $1B             ;;negate                else make sign +ve.
        DEFB    $33             ;;jump
        DEFB    $03             ;;fwd to o37B7, C-ENT
                                ;; with quadrants I and IV.

; -------------------
; THE 'SINE' FUNCTION
; -------------------
; (offset $1F: 'sin')
; This is a fundamental transcendental function from which others such as cos
; and tan are directly, or indirectly, derived.
; It uses the series generator to produce Chebyshev polynomials.
;
;
;           /|
;        1 / |
;         /  |x
;        /a  |
;       /----|
;         y
;
; The 'get-argt' function is designed to modify the angle and its sign
; in line with the desired sine value and afterwards it can launch straight
; into common code.

;; sin
o37B5:  RST     28H             ;; FP-CALC      angle in radians
        DEFB    $39             ;;get-argt      reduce - sign now correct.

;; C-ENT
o37B7:  DEFB    $31             ;;duplicate
        DEFB    $31             ;;duplicate
        DEFB    $04             ;;multiply
        DEFB    $31             ;;duplicate
        DEFB    $0F             ;;addition
        DEFB    $A1             ;;stk-one
        DEFB    $03             ;;subtract

        DEFB    $86             ;;series-06
        DEFB    $14             ;;Exponent: $64, Bytes: 1
        DEFB    $E6             ;;(+00,+00,+00)
        DEFB    $5C             ;;Exponent: $6C, Bytes: 2
        DEFB    $1F,$0B         ;;(+00,+00)
        DEFB    $A3             ;;Exponent: $73, Bytes: 3
        DEFB    $8F,$38,$EE     ;;(+00)
        DEFB    $E9             ;;Exponent: $79, Bytes: 4
        DEFB    $15,$63,$BB,$23 ;;
        DEFB    $EE             ;;Exponent: $7E, Bytes: 4
        DEFB    $92,$0D,$CD,$ED ;;
        DEFB    $F1             ;;Exponent: $81, Bytes: 4
        DEFB    $23,$5D,$1B,$EA ;;
        DEFB    $04             ;;multiply
        DEFB    $38             ;;end-calc

        RET                     ; return.

; ----------------------
; THE 'TANGENT' FUNCTION
; ----------------------
; (offset $21: 'tan')
;
; Evaluates tangent x as    sin(x) / cos(x).
;
;
;           /|
;        h / |
;         /  |o
;        /x  |
;       /----|
;         a
;
; the tangent of angle x is the ratio of the length of the opposite side
; divided by the length of the adjacent side. As the opposite length can
; be calculates using sin(x) and the adjacent length using cos(x) then
; the tangent can be defined in terms of the previous two functions.

; Error 6 if the argument, in radians, is too close to one like pi/2
; which has an infinite tangent. e.g. PRINT TAN (PI/2)  evaluates as 1/0.
; Similarly PRINT TAN (3*PI/2), TAN (5*PI/2) etc.

;; tan
o37DA:  RST     28H             ;; FP-CALC          x.
        DEFB    $31             ;;duplicate         x, x.
        DEFB    $1F             ;;sin               x, sin x.
        DEFB    $01             ;;exchange          sin x, x.
        DEFB    $20             ;;cos               sin x, cos x.
        DEFB    $05             ;;division          sin x/cos x (= tan x).
        DEFB    $38             ;;end-calc          tan x.

        RET                     ; return.

; ---------------------
; THE 'ARCTAN' FUNCTION
; ---------------------
; (Offset $24: 'atn')
; the inverse tangent function with the result in radians.
; This is a fundamental transcendental function from which others such as asn
; and acs are directly, or indirectly, derived.
; It uses the series generator to produce Chebyshev polynomials.

;; atn
o37E2:  CALL    o3297           ; routine re-stack
        LD      A,(HL)          ; fetch exponent byte.
        CP      $81             ; compare to that for 'one'
        JR      C,o37F8         ; forward, if less, to SMALL

        RST     28H             ;; FP-CALC
        DEFB    $A1             ;;stk-one
        DEFB    $1B             ;;negate
        DEFB    $01             ;;exchange
        DEFB    $05             ;;division
        DEFB    $31             ;;duplicate
        DEFB    $36             ;;less-0
        DEFB    $A3             ;;stk-pi/2
        DEFB    $01             ;;exchange
        DEFB    $00             ;;jump-true
        DEFB    $06             ;;to o37FA, CASES

        DEFB    $1B             ;;negate
        DEFB    $33             ;;jump
        DEFB    $03             ;;to o37FA, CASES

;; SMALL
o37F8:  RST     28H             ;; FP-CALC
        DEFB    $A0             ;;stk-zero

;; CASES
o37FA:  DEFB    $01             ;;exchange
        DEFB    $31             ;;duplicate
        DEFB    $31             ;;duplicate
        DEFB    $04             ;;multiply
        DEFB    $31             ;;duplicate
        DEFB    $0F             ;;addition
        DEFB    $A1             ;;stk-one
        DEFB    $03             ;;subtract
        DEFB    $8C             ;;series-0C
        DEFB    $10             ;;Exponent: $60, Bytes: 1
        DEFB    $B2             ;;(+00,+00,+00)
        DEFB    $13             ;;Exponent: $63, Bytes: 1
        DEFB    $0E             ;;(+00,+00,+00)
        DEFB    $55             ;;Exponent: $65, Bytes: 2
        DEFB    $E4,$8D         ;;(+00,+00)
        DEFB    $58             ;;Exponent: $68, Bytes: 2
        DEFB    $39,$BC         ;;(+00,+00)
        DEFB    $5B             ;;Exponent: $6B, Bytes: 2
        DEFB    $98,$FD         ;;(+00,+00)
        DEFB    $9E             ;;Exponent: $6E, Bytes: 3
        DEFB    $00,$36,$75     ;;(+00)
        DEFB    $A0             ;;Exponent: $70, Bytes: 3
        DEFB    $DB,$E8,$B4     ;;(+00)
        DEFB    $63             ;;Exponent: $73, Bytes: 2
        DEFB    $42,$C4         ;;(+00,+00)
        DEFB    $E6             ;;Exponent: $76, Bytes: 4
        DEFB    $B5,$09,$36,$BE ;;
        DEFB    $E9             ;;Exponent: $79, Bytes: 4
        DEFB    $36,$73,$1B,$5D ;;
        DEFB    $EC             ;;Exponent: $7C, Bytes: 4
        DEFB    $D8,$DE,$63,$BE ;;
        DEFB    $F0             ;;Exponent: $80, Bytes: 4
        DEFB    $61,$A1,$B3,$0C ;;
        DEFB    $04             ;;multiply
        DEFB    $0F             ;;addition
        DEFB    $38             ;;end-calc

        RET                     ; return.


; ---------------------
; THE 'ARCSIN' FUNCTION
; ---------------------
; (Offset $22: 'asn')
;   The inverse sine function with result in radians.
;   Derived from arctan function above.
;   Error A unless the argument is between -1 and +1 inclusive.
;   Uses an adaptation of the formula asn(x) = atn(x/sqr(1-x*x))
;
;
;                 /|
;                / |
;              1/  |x
;              /a  |
;             /----|
;               y
;
;   e.g. We know the opposite side (x) and hypotenuse (1)
;   and we wish to find angle a in radians.
;   We can derive length y by Pythagoras and then use ATN instead.
;   Since y*y + x*x = 1*1 (Pythagoras Theorem) then
;   y=sqr(1-x*x)                         - no need to multiply 1 by itself.
;   So, asn(a) = atn(x/y)
;   or more fully,
;   asn(a) = atn(x/sqr(1-x*x))

;   Close but no cigar.

;   While PRINT ATN (x/SQR (1-x*x)) gives the same results as PRINT ASN x,
;   it leads to division by zero when x is 1 or -1.
;   To overcome this, 1 is added to y giving half the required angle and the
;   result is then doubled.
;   That is, PRINT ATN (x/(SQR (1-x*x) +1)) *2
;
;   GEOMETRIC PROOF.
;
;
;               . /|
;            .  c/ |
;         .     /1 |x
;      . c   b /a  |
;    ---------/----|
;      1      y
;
;   By creating an isosceles triangle with two equal sides of 1, angles c and
;   c are also equal. If b+c+c = 180 degrees and b+a = 180 degrees then c=a/2.
;
;   A value higher than 1 gives the required error as attempting to find  the
;   square root of a negative number generates an error in Sinclair BASIC.

;; asn
o3833:  RST     28H             ;; FP-CALC      x.
        DEFB    $31             ;;duplicate     x, x.
        DEFB    $31             ;;duplicate     x, x, x.
        DEFB    $04             ;;multiply      x, x*x.
        DEFB    $A1             ;;stk-one       x, x*x, 1.
        DEFB    $03             ;;subtract      x, x*x-1.
        DEFB    $1B             ;;negate        x, 1-x*x.
        DEFB    $28             ;;sqr           x, sqr(1-x*x) = y
        DEFB    $A1             ;;stk-one       x, y, 1.
        DEFB    $0F             ;;addition      x, y+1.
        DEFB    $05             ;;division      x/y+1.
        DEFB    $24             ;;atn           a/2       (half the angle)
        DEFB    $31             ;;duplicate     a/2, a/2.
        DEFB    $0F             ;;addition      a.
        DEFB    $38             ;;end-calc      a.

        RET                     ; return.


; ---------------------
; THE 'ARCCOS' FUNCTION
; ---------------------
; (Offset $23: 'acs')
; the inverse cosine function with the result in radians.
; Error A unless the argument is between -1 and +1.
; Result in range 0 to pi.
; Derived from asn above which is in turn derived from the preceding atn.
; It could have been derived directly from atn using acs(x) = atn(sqr(1-x*x)/x).
; However, as sine and cosine are horizontal translations of each other,
; uses acs(x) = pi/2 - asn(x)

; e.g. the arccosine of a known x value will give the required angle b in
; radians.
; We know, from above, how to calculate the angle a using asn(x).
; Since the three angles of any triangle add up to 180 degrees, or pi radians,
; and the largest angle in this case is a right-angle (pi/2 radians), then
; we can calculate angle b as pi/2 (both angles) minus asn(x) (angle a).
;
;
;           /|
;        1 /b|
;         /  |x
;        /a  |
;       /----|
;         y
;

;; acs
o3843:  RST     28H             ;; FP-CALC      x.
        DEFB    $22             ;;asn           asn(x).
        DEFB    $A3             ;;stk-pi/2      asn(x), pi/2.
        DEFB    $03             ;;subtract      asn(x) - pi/2.
        DEFB    $1B             ;;negate        pi/2 -asn(x)  =  acs(x).
        DEFB    $38             ;;end-calc      acs(x).

        RET                     ; return.


; --------------------------
; THE 'SQUARE ROOT' FUNCTION
; --------------------------
; (Offset $28: 'sqr')
; This routine is remarkable for its brevity - 7 bytes.
; It wasn't written here but in the ZX81 where the programmers had to squeeze
; a bulky operating system into an 8K ROM. It simply calculates
; the square root by stacking the value .5 and continuing into the 'to-power'
; routine. With more space available the much faster Newton-Raphson method
; could have been used as on the Jupiter Ace.

;; sqr
o384A:  RST     28H             ;; FP-CALC
        DEFB    $31             ;;duplicate
        DEFB    $30             ;;not
        DEFB    $00             ;;jump-true
        DEFB    $1E             ;;to o386C, LAST

        DEFB    $A2             ;;stk-half
        DEFB    $38             ;;end-calc


; ------------------------------
; THE 'EXPONENTIATION' OPERATION
; ------------------------------
; (Offset $06: 'to-power')
; This raises the first number X to the power of the second number Y.
; As with the ZX80,
; 0 ^ 0 = 1.
; 0 ^ +n = 0.
; 0 ^ -n = arithmetic overflow.
;

;; to-power
o3851:  RST     28H             ;; FP-CALC              X, Y.
        DEFB    $01             ;;exchange              Y, X.
        DEFB    $31             ;;duplicate             Y, X, X.
        DEFB    $30             ;;not                   Y, X, (1/0).
        DEFB    $00             ;;jump-true
        DEFB    $07             ;;to o385D, XIS0   if X is zero.

;   else X is non-zero. Function 'ln' will catch a negative value of X.

        DEFB    $25             ;;ln                    Y, LN X.
        DEFB    $04             ;;multiply              Y * LN X.
        DEFB    $38             ;;end-calc

        JP      o36C4           ; jump back to EXP routine   ->

; ---

;   these routines form the three simple results when the number is zero.
;   begin by deleting the known zero to leave Y the power factor.

;; XIS0
o385D:  DEFB    $02             ;;delete                Y.
        DEFB    $31             ;;duplicate             Y, Y.
        DEFB    $30             ;;not                   Y, (1/0).
        DEFB    $00             ;;jump-true
        DEFB    $09             ;;to o386A, ONE         if Y is zero.

        DEFB    $A0             ;;stk-zero              Y, 0.
        DEFB    $01             ;;exchange              0, Y.
        DEFB    $37             ;;greater-0             0, (1/0).
        DEFB    $00             ;;jump-true             0.
        DEFB    $06             ;;to o386C, LAST        if Y was any positive
                                ;;                      number.

;   else force division by zero thereby raising an Arithmetic overflow error.
;   There are some one and two-byte alternatives but perhaps the most formal
;   might have been to use end-calc; rst 08; defb 05.

        DEFB    $A1             ;;stk-one               0, 1.
        DEFB    $01             ;;exchange              1, 0.
        DEFB    $05             ;;division              1/0        ouch!

; ---

;; ONE
o386A:  DEFB    $02             ;;delete                .
        DEFB    $A1             ;;stk-one               1.

;; LAST
o386C:  DEFB    $38             ;;end-calc              last value is 1 or 0.

        RET                     ; return.

;   "Everything should be made as simple as possible, but not simpler"
;   - Albert Einstein, 1879-1955.

; ---------------------
; THE 'SPARE' LOCATIONS
; ---------------------

;; spare
o386E   PUSH    IX              ; save IX (why?)
        CALL    o02BF           ; scan keyboard as with 48K ROM
        BIT     4,(IY+$01)
        JR      Z,o387C         ; check bit 4 of FLAGS
        CALL    o387F           ; check disk motor if true
o387C   POP     IX
        RET     

; Subroutine to check disk motor timeout

o387F   LD      BC,$7FFD
        LD      A,(BANKM)
        OR      $07
        OUT     (C),A           ; page in page 7
        LD      A,($E600)
        OR      A
        JR      Z,o38AC         ; move on if motor already off
        LD      A,(FRAMES)
        BIT     0,A
        JR      NZ,o38AC        ; only decrement timeout every other time
        LD      A,($E600)
        DEC     A               ; decrement timeout
        LD      ($E600),A
        JR      NZ,o38AC        ; move on if not yet zero
        LD      BC,$1FFD
        LD      A,(BANK678)
        AND     $F7
        LD      (BANK678),A
        OUT     (C),A           ; switch motor off
o38AC   LD      BC,$7FFD
        LD      A,(BANKM)
        OUT     (C),A           ; page back page 0
        RET

;###########################################    ZXTAP subroutine part 1    ############################################
      if zx_tap
    ;**** disponible ****
        /*
        1) averiguar cual pagina esta arriba
        2) averiguar si estoy en modo 128 o 48
        3) si estoy en 48 retornar
        4) si estoy en 128 preguntar si 
            (tapeloader_stat1)=1
            si es asi cargar desde disco
            y si no retornar 
        
        5) si cargo desde disco los registros
            deben tener los mismos valores
            que tendrian si hubiese cargado desde
            cinta, especialmente IX
        */
        
FREE_START1:    
NEW_LOAD:   
        EX  AF,AF'  
        PUSH    AF  ;GUARDA AF ALT
        EX  AF,AF'  
        PUSH    AF  ;GUARDA AF NORMAL (ESTO TIENE EL FLAG CARGAR/VERIFICAR)
        PUSH    DE
        PUSH    HL
        PUSH    IX
        
        ;ESTOY SEGURO QUE LAS INT. ESTAN deshabilitadas
        ;de lo contario el usuario tampoco podr?a cargar
        ;desde cinta
        
        ;puedo usar HL y BC con tranquilidad
        
        LD  HL, ($C000)  ;GUARDO LOS CONTENIDOS DE C000-C003
        PUSH    HL
        LD  HL, ($C002)
        PUSH    HL
        LD  HL, $5446    ;*INSERTO* A PARTIR DE $C000 LA CADENA "FTAP" (POR FIND TAP)
        LD  ($C000), HL
        LD  HL, $5041
        LD  ($C002), HL

              
        LD  A, $10       ; A PARTIR DE AQUI AVERIGUO QUE PAGINA TENGO ARRIBA
        LD  BC, $7FFD    ; BUSCANDO EN CADA UNA DE ELLAS LA CADENA "FTAP" EN C000-C003
LFIND_UPPERMEM: 
        OUT (C), A       ; Y ME DETENGO CUANDO LA ENCUENTRE
        LD  HL, ($C000)
        AND A
        LD  DE, $5446
        SBC HL ,DE
        JR  NZ, NOMEMORY
        LD  HL, ($C002)
        AND A
        LD  DE, $5041
        SBC HL, DE
        JR  Z, ENCONTRADA
NOMEMORY:   
        INC A
        CP  $18
        JR  NZ, LFIND_UPPERMEM

ENCONTRADA: 
        EX  AF,AF'      ; EN A ME QUEDA LA PAGINA QUE TENGO ARRIBA
                        ; USO AF' PARA NO PERDER AF DE MOMENTO
        
        POP HL          ; RECUPERO LOS BYTES DE C000-C003
        LD  ($C002), HL
        POP HL
        LD  ($C000), HL
        
        LD  HL, $C000
        LD  A, $10       ; AVERIGUO SI ESTAN ACCESIBLES LOS 128K
        OUT (C), A
        LD  D, (HL)
        LD  (HL), A

        INC A           ;LD A,$11
        OUT (C), A
        LD  E, (HL)
        LD  (HL), A
        
        DEC A           ;LD A,$10
        OUT (C), A
        CP  (HL)
        LD  (HL), D
        JR  Z, ES128K
        
        LD  (HL), E      ; RECUPERO EL BYTE NO ESTOY EN MODO 128 ASI QUE NO PUEDE HABER
RETLOAD2:   
        POP IX      ; CARGA DE TAPs DESDE +3DOS
        POP HL
        POP DE
        POP AF
        EX  AF, AF'
        POP AF
        EX  AF, AF'
RET_NEW_LOAD:   
        IN  A, ($FE)
        RRA
        RET
    
ES128K:     
        LD  A, $11       ; RECUPERO LOS BYTES (SOLO EL QUE CORRESPONDIA A PAG.1 EL DE PAG 0 YA FUE RECUPERADO)
        OUT (C), A
        LD  (HL), E
        
        LD  A, $17           ; AVERIGUO SI TENGO QUE CARGAR DESDE DISCO
        OUT (C), A           ; SI tapeloader_stat1==1 SIGNIFICA QUE HUBO
        LD  A, (tapeloader_stat1)    ; UN COMANDO PREVIO SPECTRUM "xxxxxxxx.TAP"
        LD  D, A         ; QUE PREPARO LAS COSAS
        
        EX  AF, AF'          ; PONER LA PAGINA DE RAM AVERIGUADA MAS ARRIBA
        LD  (conf_ram), A        ; LA GUARDO EN ESTA VAR DE PAGINA 7
        OUT (C), A
        LD  A, D
        CP  $01
        JR  NZ, RETLOAD2
        
SIMULAR_TAPE:   ;Lo primero que quiero saber es que modo de interrupciones tengo
        ;puesto que voy a poner IM2 cuando use rutinas de +3DOS asi el propio +3DOS
        ;no me despedaza la zona de variables - 5C78
        LD  A, $17
        OUT (C), A
        LD  HL, $5B00
        LD  DE, save_buffer
        LD  BC, 1024
        LDIR
        CALL SET_NORM_MEMORY   ; pongo los valores "estandar" en BANKM y BANK678
        LD  A, I     ; porque a lo mejor la INT llamada en el HALT siguiente
        LD  (save_REGI), A   ; se le arma lio
        LD  A, $FF
        LD  ($5B00), A
        LD  A, $5B
        LD  I, A
        LD  HL, DUMMY_IM2
        LD  ($5BFF), HL
        XOR A
        LD  (EXCEPCIONES), A
        LD  A, (conf_ram)
        LD  BC, $7FFD
        OUT (C), A
        EI
        HALT            ; despues de que se ejecute la interrupcion puede pasar 2 cosas
        DI          ; 1) que ($5B00)==0 lo que significaria que estaba IM2
                    ; 2) que ($5B00)==FF lo que significaria que estaba IM1


        LD  A, $17       ; por las dudas si alguna interrupcion cabrona me quito pag 7
        LD  BC, $7FFD
        OUT (C), A
        XOR A
        LD  (terminar_CARGA), A
        
        LD  A, (save_REGI)
        LD  I, A
        LD  A, ($5B00)
        LD  (save_INTERR), A ; ENTONCES esta VAR me indica si es $FF = IM1 y si es $00 = IM2
        
        LD  HL, save_buffer
        LD  DE, $5B00
        LD  BC, 1024
        LDIR
        
        LD  A, (conf_ram)
        LD  BC, $7FFD
        OUT (C), A
        
        CALL    SWAPEAR_RT_ALERT
    
        POP IX          ; CARGA DE TAPs DESDE +3DOS
        POP HL
        POP DE
        POP AF
        EX  AF, AF'
        POP AF
        EX  AF, AF'

        CALL    GET_BYTE_TAPE
        PUSH    AF
        CALL    GET_BYTE_TAPE
        LD  H, A
        POP AF
        LD  L, A     ; en HL tengo la cantidad de bytes a leer del bloque actual
                    ; ej: una cabecera son 19 bytes, (17+2)4

        CALL    SET_POS_SIG
        
        CALL    GET_BYTE_TAPE   ; CARGO EL FLAG
        LD  C, A
        EX  AF, AF'
        LD  B, A
        EX  AF, AF'
        
        LD  A, B
        CP  C
        JR  NZ, ERROR_LFLAG  ; SIMULO ERROR DE CARGA
        
                    ; (!! AVERIGUAR EL PUNTERO ACTUAL Y SUMARLE HL PARA SABER EN DONDE
                    ; COMIENZE EL SIGUIENTE BLOQUE DEL TAP PARA CUANDO NECESITES PASAR
                    ; AL SIGUIENTE BLOQUE)
                    
        
        DEC HL      ; ya cargu? el flag
        DEC HL
        AND A
        SBC HL, DE
        JR  NZ, BAD_SIZE

        LD  H, C     ; EL control de parity
                    ; "comienza" con el mismo
                    ; valor del flag
        
LOOP_LOAD_TAP:  
        CALL    GET_BYTE_TAPE
        JP  NC, END_LDTAPE

        LD  C,A
        INC A
        AND $07
        OUT ($FE), A
        LD  A, C

        EX  AF, AF'
        JR  C, SET_LOAD

VERIF:      
        EX  AF,AF'
        CP  (IX+0)
        JR  NZ, ERROR_VERIF
        JR  CONT_NEXT_BYTE
        
SET_LOAD:   
        EX  AF,AF'
        LD  (IX+0), A

CONT_NEXT_BYTE: 
        INC IX
        DEC DE

        LD  L, A     ; calc parity
        LD  A, H
        XOR L
        LD  H, A
        
        LD  A, D
        OR  E
        JR  NZ, LOOP_LOAD_TAP
        
        JP  CONTINUARA


ERROR_LFLAG:    ;JR  TAPE_ERROR  ; cuando implementes retornar NZ y quedate posicionado al comienzo
                    ; del siguiente bloque del TAP

ERROR_PARITY:   ;JR  TAPE_ERROR

ERROR_VERIF:    ;JR  TAPE_ERROR

BAD_SIZE:   ;JR  TAPE_ERROR  ; significa que no me coincide lo que mandaron en DE y lo que puedo
                    ; yo ofrecer desde el TAP, asi que lo considero de "antemano" error
                    ; de carga y muevo el puntero del TAP al siguiente bloque

TAPE_ERROR: 
        JP  MOVE_NEXT_BLQ

GET_BYTE_TAPE:  
        CALL    READ_BYTE
        RET NC
        CALL    CHECK_TERMINAR
        RET

SPARE1:     
;        display "Spare1 Quedan ", /d,331 - ($-FREE_START1)," Bytes libres"
;        DEFS 331 - ($-FREE_START1);
      else
;        DEFS    331
      endif
;#######################################################################################

    IF pokemon&&!zx_tap
tab01   defb    $ff, $00, $00, $00, $ff, $00, $00, $00, $00, $23, $05
tab02   defb    $00, $10, $01, 'snapshot'
        defb    $27, $00, $00, $00, $27, $00
    ENDIF

    ;display "After TAP1 and POKEMON, there are ", /d,(0x3A00-$), " bytes free"
    defs 0x0 + (0x3A00-$), $ff

; The printer input (o3a00) and output (o3a05) routines
; Channel information for "P" channel points here

o3A00   LD      HL,$3D03        ; input routine in ROM 1
        JR      o3A08
o3A05   LD      HL,$3D06        ; output routine in ROM 1
o3A08   EX      AF,AF'
        LD      BC,$1FFD
        LD      A,(BANK678)
        PUSH    AF
        AND     $FB             ; select ROM 1
        DI      
        LD      (BANK678),A
        OUT     (C),A           ; at this point, routine continues in ROM 1
        JP      o3D00
o3A1B   EX      AF,AF'
        POP     AF
        LD      BC,$1FFD
        DI      
        LD      (BANK678),A
        OUT     (C),A
        EI                      ; control returns to this ROM here
        EX      AF,AF'
        RET     

; Patch to print error message routine

o3A29   BIT     4,(IY+$01)      ; check bit 4 of FLAGS
      IF v41 || garry && spanish
        DEFB    $00, $00
      ELSE
        JR      NZ,o3A34        ; move on if in +3 BASIC
      ENDIF
        XOR     A
        LD      DE,$1536        ; else exit to do standard "comma" message
        RET     
o3A34   LD      HL,$010F
o3A37   EX      (SP),HL
        JP      SWAP            ; call routine in ROM 0
                                ; note that all these routines seem to enter
                                ; during the reset routine! Or am I missing
                                ; something...


; Patch to "STMT-RET" routine

o3A3B   BIT     4,(IY+$01)      ; check bit 4 of FLAGS
      IF v41 || garry && spanish
        DEFB    $00, $00
      ELSE
        JR      NZ,o3A46        ; move on if in +3 BASIC
      ENDIF
        BIT     7,(IY+$0A)      ; else exit with normal 48K ROM check done
        RET     
o3A46   LD      HL,$0112
        JR      o3A37           ; go to call routine in ROM 0


; Patch to "STMT-NEXT" routine

o3A4B   BIT     4,(IY+$01)      ; check bit 4 of FLAGS
      IF v41 || garry && spanish
        DEFB    $00, $00
      ELSE
        JR      NZ,o3A55        ; move on if in +3 BASIC
      ENDIF
        RST     $18
        CP      $0D             ; else exit with normal 48K ROM check done
        RET     
o3A55   LD      HL,$0115
        JR      o3A37           ; go to call routine in ROM 0


; Patch to INKEY$ function routine
; Presumably, in earlier 128K spectrums this was used to read the
; external keypad, but it effectively does nothing different to the
; usual routine on the +3.

o3A5A   CALL    o028E           ; do normal call to get key-value in DE
        LD      C,$00
        JR      NZ,o3A6E        ; move on if too many keys pressed
        CALL    o031E           ; test key value
        JR      NC,o3A6E        ; move on if unsatisfactory
        DEC     D               ; D=$ff (L-mode)
        LD      E,A             ; E=key value
        CALL    o0333           ; decode
        JP      o2657           ; jump back into INKEY$ routine with keycode
o3A6E   BIT     4,(IY+$01)      ; check bit 4 of FLAGS
        JP      Z,o2660         ; jump back into INKEY$ if in 48K BASIC
        DI
        EI      
        JR      o3A79
o3A79   LD      C,$00
        JP      o2660           ; jump back into INKEY$ routine


; Patch to "print a character" routine

o3A7E   CP      $A3
        JR      Z,o3A8E         ; move on for "SPECTRUM"
        CP      $A4
        JR      Z,o3A8E         ; move on for "PLAY"
o3A86   SUB     $A5
        JP      NC,o0B5F        ; else rejoin print character routine
        JP      o0B56           ; with normal test done
o3A8E   BIT     4,(IY+$01)      ; check bit 4 of FLAGS
        JR      Z,o3A86         ; move back if in 48K mode
        LD      DE,o3AA8
        PUSH    DE              ; stack address to return to in this routine
        SUB     $A3
        LD      DE,o3AB1        ; address of "SPECTRUM"
        JR      Z,o3AA2         ; move on if SPECTRUM
        LD      DE,o3AB9        ; address of "PLAY"
o3AA2   LD      A,$04
        PUSH    AF              ; stack $04 to get a trailing space
        JP      o0C17           ; output the token & return to next instruction
o3AA8   SCF                     
        BIT     1,(IY+$01)
        RET     NZ              ; exit if handling the printer
        JP      o0B03           ; else jump back into print routine

o3AB1   DEFM    "SPECTRU", 'M'+$80
o3AB9   DEFM    "PLA", 'Y'+$80
        
        JP      l3AC2           ; what's this for???

        RST     $38
        RST     $38

l3AC2   DEFM    $13, $00, "19", $13, $01, "87"  ; testcard message
                                                ; why is it here???

;###########################################     ZXTAP subroutine part 2    ###########################################
      if zx_tap
FREE_START2:    


CONTINUARA: 
        CALL    GET_BYTE_TAPE   ; cargo parity
        CP  H
        JP  NZ, ERROR_PARITY
RET_BASIC:  
        INC SP
        INC SP
        EX  AF,AF'
        RET

READ_BYTE:  
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    IX
        EX  AF, AF'
        PUSH    AF
        EX  AF, AF'

RETRY_RBYTE:    
        LD  A,$7F       ; retorno si encontre SPACE presionada
        IN  A,($FE)
        RRA
        JR  NC, RET_READ_BYTE

        LD  A, $17           ;PONGO PAGINA 7
        LD  BC, $7FFD
        OUT (C), A
        XOR A
        LD  (EXCEPCIONES), A
        LD  HL, (buffer_COUNT)
        LD  A, H
        OR  L
        JR  NZ, OK_HAY_UN_BYTE

        LD  A, (conf_ram)        ;REESTABLEZCO ROM/RAM
        OUT (C), A
        CALL    DO_FILL_BUFFER
        JR  RETRY_RBYTE
        
OK_HAY_UN_BYTE: 
        DEC HL
        LD  (buffer_COUNT), HL
        LD  HL, (buffer_ADDR)
        LD  D, (HL)
        INC HL
        LD  (buffer_ADDR), HL
        
        LD  A, (conf_ram)        ;REESTABLEZCO ROM/RAM
        LD  BC, $7FFD
        OUT (C), A
        
        LD  A, D
        SCF             ;retorno CY si se leyeron bytes

RET_READ_BYTE:  
        EX  AF, AF'
        POP AF
        EX  AF, AF'
        POP IX
        POP BC
        POP DE
        POP HL

        RET
    
DO_FILL_BUFFER: 
        LD  A, $07
        OUT ($FE), A
        LD  A, $17           ;PONGO PAGINA 7
        LD  BC, $7FFD
        OUT (C), A

ALT_ENTRY:  
        LD  HL, temp_working_mem ;GUARDO LO QUE ESTA EN $8000 + 1K
        LD  DE, save_buffer
        LD  BC, 1024
        LDIR

        LD  A, (BANKM)       ;GUARDO ESTAS VARS. XQ TENGO QUE ALTERARLAS
        LD  (tmp_BANKM), A       ;PA' QUE +3DOS NO SE PONGA TRISTE LA PUTA QUE LO PARIO
        LD  A ,(BANK678)
        LD  (tmp_BANK678), A
        LD  (save_STACK), SP     ;TAMBIEN GUARDO STACK EN PAGINA 7

        LD  HL, SWITCH_ROM2      ;copio a $8000 la rutina de lectura del buffer
        LD  DE, temp_working_mem+200
        LD  BC, 512
        LDIR
        
        JP  temp_working_mem+200

SWITCH_ROM2:    
        LD  SP, temp_working_mem+199 ;NUEVO STACK

        LD  A, $04
        LD  (BANK678), A
        LD  BC, $1FFD
        OUT (C), A
        
        LD  A, $07
        LD  (BANKM) ,A
        LD  BC, $7FFD
        OUT (C), A           ;AHORA ESTOY ARRIBA CON ROM2 PAGINADA
        
        LD  A, $82           ;establezco mis int. en MODO 2, que solo tiene un RETI
        LD  I, A         ;as? me evito que +3DOS me pisotee la zona de variables
        LD  HL, $8301        ;cosa que no pasar?a si la carga fuera desde cinta real
        LD  ($82FF), HL
        LD  (HL), $ED        ; ---> RETI - o sea que no hago nada
        INC HL
        LD  (HL), $4D
        IM  2

        LD  A, (EXCEPCIONES)
        CP  $01
        JR  Z, RESET_FILE
        CP  $02
        JR  Z, SET_POS_FILE
        
        LD  BC, $0607        ;ARCHIVO #6 ABIERTO EN ROM1 POR RUTINA MODIFICADA
                        ;QUE INTERPRETA EL COMANDO SPECTRUM "filename.tap"
        
        LD  DE, buffer_file_size
        LD  HL, temp_buffer_file

        CALL    DOS_READ        ;LEO UN "sector"
        DI              ;+3DOS *SIEMPRE* HABILITA LAS INT CUANDO TERMINA SU
                        ;SERVICIO
        LD  HL, buffer_file_size ; hago de cuenta que lei todos los bytes
        JR  C, SIN_ERROR

        CP  25          ; 25 = End of file
        JR  Z, EOF

        LD  B, $06           ; OTRO error que no sea EOF abandono el archivo y desactivo la carga
        CALL    DOS_ABANDON
        XOR A
        LD  (tapeloader_stat1), A
        INC A
        LD  (terminar_CARGA), A
        LD  HL, $0001        ; le hago creer que entro por lo menos un byte para que retorne bien
        JR  SIN_ERROR       ; y como desactive la carga desde "cinta" no volvermos aqui

SET_POS_FILE:   
        LD  B, $06
        LD  DE, buffer_file_size
        PUSH    DE
        LD  DE, (save_POS_FILE+0)
        LD  HL, (save_POS_FILE+2)
        JR  CONT_SET_POS

RESET_FILE: 
        LD  DE,buffer_file_size

EOF:        
        PUSH    DE          ; reestablezco el puntero de archivo a 0. es como si hubiese rebobinado
        LD  H, $00           ; la cinta y comienza de nuevo
        LD  L, H
        LD  D, H
        LD  E, H
        LD  (save_POS_FILE+0), HL
        LD  (save_POS_FILE+2), HL
CONT_SET_POS:   
        LD  B,$06           

        CALL    DOS_SET_POSITION
        POP DE
        AND A           ; segun el manual si hay un error en DE me queda la cantidad remante
        LD  HL, buffer_file_size ; por leer, entonces calculo cuantos bytes se leyeron
        SBC HL, DE
        
SIN_ERROR:  
        LD  BC, $7FFD
        LD  A, $17
        OUT (C), A
        LD  BC, $1ffd
        LD  A, $04
        OUT (C), A           ;PARO EL MOTOR
        JP  RETPAG7

RETPAG7:    
        LD  SP, (save_STACK)

        LD  DE, temp_buffer_file
        LD  (buffer_ADDR), DE
        LD  (buffer_COUNT), HL
        
RETPAG7_3:  
        LD  HL, save_buffer      ;RECUPERO LO QUE ESTABA EN $8000 + 1K
        LD  DE, temp_working_mem
        LD  BC, 1024
        LDIR

        CALL REST_INT_MEMORY
        RET             ; SE RETORNA EN HL LA CANTIDAD DE BYTES LEIDOS

SPARE2:     
;        display "Spare2 Quedan ", /d,319 - ($-FREE_START2)," Bytes libres"

FREE_START3:  

END_LDTAPE: 
        LD  A,$01       ; EN EL CASO DE APRETAR SPACE MIENTRAS SE CARGA
        CALL    CALL_OTRAS  ; no importa conservar el valor de 'A'
        INC SP
        INC SP
        EX  AF,AF'
        AND A
        RET
                
CALL_OTRAS: 
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    IX
        EX  AF,AF'
        PUSH    AF
        EX  AF,AF'
        LD  HL, RET_CALL2
        PUSH    HL
        LD  L,A

        LD  A,$17
        LD  BC,$7FFD
        OUT (C),A
        LD  A,L
        LD  (EXCEPCIONES),A
        
        JP  ALT_ENTRY

RET_CALL2:  
        EX  AF,AF'
        POP AF
        EX  AF,AF'
        POP IX
        POP BC
        POP DE
        POP HL
        RET


REST_INT_MEMORY:
        EX  (SP),HL
        IM  1
        LD  A,(save_INTERR)
        CP  $FF
        JR  Z,OK_IM1
        IM  2
OK_IM1:     
        LD  A,(save_REGI)
        LD  I,A
        LD  A,(tmp_BANKM)
        LD  (BANKM),A
        LD  A,(tmp_BANK678)
        LD  (BANK678),A
        LD  A,(conf_ram)        ;REESTABLEZCO ROM/RAM
        LD  BC,$7FFD
        OUT (C),A
        EX  (SP),HL
        RET

DUMMY_IM2:  
        XOR A
        LD  ($5B00),A
        RETI


SET_POS_SIG:    
        PUSH    DE
        PUSH    BC
        PUSH    HL          ;ESTA RUTINA SE LLAMA CADA vez
        LD  A,$17           ;que se empieza a cargar un bloque
        LD  BC,$7FFD        ;va guardando en (save_POS_FILE) la
        OUT (C),A           ;posicion de archivo en donde comienza
        PUSH    HL          ;el siguiente bloque. para ser
        POP DE          ;usado en el manejo de errores
        INC DE
        INC DE
        LD  HL, (save_POS_FILE+2)
        AND A
        ADD HL,DE
        LD  (save_POS_FILE+2),HL
        LD  HL, save_POS_FILE+0
        JR  NC, NODESB
        INC (HL)
NODESB:     
        LD  A, (conf_ram)        ;REESTABLEZCO ROM/RAM
        OUT (C),A
        POP HL
        POP BC
        POP DE
        RET

MOVE_NEXT_BLQ:  
        LD  A,$02       ; mover al bloque siguiente en caso de "error"
        CALL    CALL_OTRAS
        
ERROR_EN_CARGA: 
        CALL    SWAPEAR_RT_ALERT   ; retorno forzado por posible error +3dos
        INC SP
        INC SP
        EX  AF,AF'
        AND A
        RET

SWAPEAR_RT_ALERT:
        PUSH    DE
        PUSH    BC
        PUSH    HL
        LD  A, $17
        LD  BC, $7FFD
        OUT (C) ,A
        LD  HL, (rt_alert)
        LD  DE, (save_rt_alert)
        LD  (rt_alert), DE
        LD  (save_rt_alert), HL
        JR  NODESB

CHECK_TERMINAR: 
        PUSH    AF
        PUSH    BC
        LD  A, $17
        LD  BC, $7FFD
        OUT (C) ,A
        LD  A, (terminar_CARGA)
        CP  $01
        LD  A, (conf_ram)
        OUT (C), A
        POP BC
        JR  NZ, NO_ERROR_P3DOS
        POP AF
        INC SP
        INC SP
        INC SP
        INC SP
        
        JR  ERROR_EN_CARGA

NO_ERROR_P3DOS: 
        POP AF
        RET

SET_NORM_MEMORY  
        LD  A,$10
        LD  (BANKM), A
        LD  A,$04
        LD  (BANK678), A
        RET

SPARE3:     
;        display "Spare3 Quedan ", /d,247 - ($-FREE_START3)," Bytes libres"
      endif
;#############################################     FIN ZXTAP 2     ####################################################

;###############################################     POKEMON     ######################################################
      if pokemon&&!zx_tap
        DEFINE  caden   $5800-6
poke    ld      (caden-2), sp
        ld      sp, caden-15-1
        push    bc
        push    de
        ld      bc, 11
        push    hl
        push    iy
        ld      iy, $5c3a
        jr      pok01
        defb    $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
pok01   ld      hl, $5c78
        ex      af, af'
        push    af
        ld      sp, $5700
        ld      e, (hl)
        inc     l
        ld      d, (hl)
        ld      (hl), b
        push    de
        ld      l, $8f
        ld      e, (hl)
        ld      (hl), $39
        inc     l
        ld      d, (hl)
        ld      (hl), b
        push    de
        inc     l
        ld      a, i
        ld      e, a
        ld      a, $18
        jp      po, pok02
        ld      a, l
pok02   ld      r, a
        ld      i, a
        ld      d, (hl)
        ld      (hl), b
        push    de
        ld      l, $3b
        ld      e, (hl)
        ld      (hl), 8
        ld      l, $41
        ld      d, (hl)
        ld      (hl), b
        push    de
        ld      l, b
        ld      de, caden-15
        ldir
        ex      de, hl
        ld      hl, tab01+10
        ld      c, e
        dec     e
        lddr
        push    bc
        ld      hl, caden
        xor     a
pok03   ld      (hl), b
pok04   inc     l
        jr      nz, pok03
        or      a
        ld      l, caden & $ff
        ld      (hl), l
pok05   ld      de, caden+1
        jr      z, pok06
        ld      (de), a
        ld      (hl), 2
pok06   ld      hl, $4000
        ld      b, 5
pok07   push    de
        ex      de, hl
        ld      l, (hl)
        add     hl, hl
        ld      h, 15
        add     hl, hl
        add     hl, hl
        ex      de, hl
        call    0x0B99
        pop     de
        inc     de
        djnz    pok07
        ld      hl, $5c3b
        ei
pok08   bit     5, (hl)
        jr      z, pok08
        di
        res     5, (hl)
        ld      a, ($5c08)
        or      $20
        ld      hl, caden
        ld      c, (hl)
        cp      $2d
        jr      z, pok14
        jr      nc, pok09
        dec     (hl)
        jr      z, pok09
        xor     a
        dec     c
        dec     (hl)
pok09   inc     (hl)
        jp      m, pok03
        add     hl, bc
        ld      (hl), a
        xor     a
        jr      pok05
pok10   inc     l
pok11   add     a, -10
pok12   inc     (hl)
        jr      c, pok11
        jp      c, $ffff
        inc     l
pok13   add     a, 10+$30
        ld      (hl), a
        xor     a
        jr      pok04
pok14   dec     c
        jp      m, pok18
        ld      b, c
        ex      de, hl
        ld      h, l
pok15   inc     e
        ld      a, (de)
        and     $0f
        push    bc
        add     hl, hl
        ld      b, h
        ld      c, l
        add     hl, hl
        add     hl, hl
        add     hl, bc
        ld      b, 0
        ld      c, a
        add     hl, bc
        pop     bc
        djnz    pok15
        ld      a, (caden+1)
        sub     'r'
        ret     z
        dec     a
        jr      z, pok17
        bit     2, c
        pop     de
        jr      nz, pok16
        ex      de, hl
        ld      (hl), e
        inc     hl
pok16   push    hl
        ld      a, (hl)
        ld      hl, caden+2
        ld      (hl), $2f
        dec     l
        ld      (hl), $32
        sub     200
        jr      nc, pok10
        dec     (hl)
        sub     -100
        jr      nc, pok10
        dec     (hl)
        dec     (hl)
        add     a, 90
        jr      nc, pok13
        jr      pok12
pok17   ex      af, af'
pok18   ld      c, 11
        pop     hl
        ld      hl, caden-15
        ld      de, $5c00
        ldir
        ld      hl, $5805
        ld      a, (hl)
        rra
        rra
        rra
        xor     (hl)
        and     %00000111
        xor     (hl)
        dec     l
        ld      c, l
        ld      (hl), a
        ld      de, $5803
        lddr
        pop     de
        ld      hl, $5c41
        ld      (hl), d
        ld      l, $3b
        ld      (hl), e
        pop     de
        ld      l, $91
        ld      a, e
        ld      i, a
        ld      (hl), d
        pop     de
        dec     l
        ld      (hl), d
        dec     l
        ld      (hl), e
        pop     hl
        ld      ($5c78), hl
        ex      af, af'
        jp      z, save
pok19   ld      sp, $57e0
        pop     af
        ex      af, af'
        pop     iy
        pop     hl
        pop     de
        pop     bc
        ld      a, r
        jp      p, pok20
        ei
pok20   ld      sp, (caden-2)
        pop     af
        ret
;tab01   defb    $ff, $00, $00, $00, $ff, $00, $00, $00, $00, $23, $05
;tab02   defb    $00, $10, $01, 'snapshot'
;        defb    $27, $00, $00, $00, $27, $00

;56d9   $3e, 0                            i     ld  a, i
;56db   $ed, $47                                ld  i, a
;56dd   $de, $c0, $37, $0e, $8f, $39, $96       over usr 5ccb
;56e4   $01, 0,   0                       bc'   ld  bc, 0
;56e7   $11, 0,   0                       de'   ld  de, 0
;56ea   $21, 0,   0                       hl'   ld  hl, 0
;56ed   $d9                                     exx
;56ee   $ed, $56                          im    im  1
;56f0   $fd, $21, 0,   0                  iy    ld  iy, 0
;56f4   $11, $00, $c0                           ld  hl, $4000
;56f7   $21, $00, $40                           ld  de, $c000
;56fa   $31, $00, $58                           ld  sp, $5800
;56fd   $c3, $f4, $07                           jp  $07f4
tab03   defb    $3e, 0,   $ed, $47, $de, $c0, $37, $0e, $8f, $39
        defb    $96, $01, 0,   0,   $11, 0,   0,   $21, 0,   0
        defb    $d9, $ed, $56, $fd, $21, 0,   0,   $11, $00, lenp
        defb    $21, $00, $40, $31, $00, $58, $c3, $f4, $07

;56e3   $21, 0,   0,   $e5, $f1, $08      af'   ld  hl, 0 / push hl / pop af / ex af,af'
;56e9   $01, 0,   0                       bc    ld  bc, 0
;56ec   $11, 0,   0                       de    ld  de, 0
;56ef   $dd, $21, 0,   0                  ix    ld  ix, 0
;56f3   $21, 0,   0,   $e5, $f1           af    ld  hl, 0 / push hl / pop af
;56f8   $21, 0,   0                       hl    ld  hl, 0
;56fb   $31, 0,   0                       sp    ld  sp, 0
;56fe   $f3                               iff   di
;56ff   $c9                                     ret


tab04   defb    $21, 0,   0,   $e5, $f1, $08, $01, 0,   0,   $11
        defb    0,   0,   $dd, $21, 0,   0,   $21, 0,   0,   $e5
        defb    $f1, $21, 0,   0,   $31, 0,   0,   $f3, $c9

;57fb-57ff  string                        56e3  <-57fe
;57fa       string length                 05cd  <-57fc
;57f8       sp
;57ed-57f7  keyboard variables            5c00
;57ec       unused                        im
;57ea       unused
;57e8       bc
;57e6       de
;57e4       hl
;57e2       iy
;57e0       af'
;56fe       FRAMES1                       5c78
;56fc       ATTR_T MASK-T                 5c8f     
;56fa       I P_FLAG                      5c91
;56f8       FLAGS MODE                    5c3b 5c41
;56f6       poke addr
;56f4       push de
;56f2       call 0b99
;56f0       push bc
;56ee       push hl
;56ec       call 0bdb
;56ea       interrup addr
;56e8       push af
;56e6       push hl
;56e4       push bc
;56e2       push de
;56e0       call 02bf                   bloque2 <-56e3
;56de       call 028e                   bloque1 <-56d9

        defb    $ff, $ff, $ff

save    ld      sp, $5800
        push    ix
        ld      ix, tab02
        ld      de, $0011
        call    $04c6
        ld      hl, tab03
        ld      de, $56d9
        push    de
        ld      c, $27
        push    bc
        ldir
        ld      a, i
        ld      ($56da), a
        exx
        ld      ($56e5), bc
        ld      ($56e8), de
        ld      ($56eb), hl
        exx
        pop     de
        pop     ix
        ld      a, ($57ec)
        or      a
        jr      z, sav01
        set     3, (ix+$16)
sav01   ld      hl, ($57e2)
        ld      ($56f2), hl
        ld      a, $ff
        call    $04c6
        ld      d, $56
        ld      hl, tab04+$1c
        ld      c, $1d
        lddr
        pop     hl
        ld      ($56f1), hl
        inc     e
        push    de
        ld      hl, $05cd
        push    hl
        ld      sp, $57e0
        pop     hl
        ld      ($56e4), hl   ;af'
        pop     hl
        pop     hl
        ld      ($56f9), hl   ;hl
        pop     hl
        ld      ($56ed), hl   ;de
        pop     hl
        ld      ($56ea), hl   ;bc
        pop     hl
        ld      ($56f4), hl   ;af
        pop     hl
        ld      a, i
        jp      pe, sav02
        set     3, (ix-3)     ;iff
sav02   ld      hl, ($57f8)
        ld      ($56fc), hl   ;sp
        ld      ix, $4000
        ld      de, lenp*256
        sbc     a, a
        call    $04c6
        ld      ix, ($56f1)
        jp      pok19

        ; block   $3cde-$, $ff
        ld      ($57ec), a
        jp      $0038
      endif
;##############################     FIN POKEMON    #######################################

    ;display "After TAP2 and POKEMON, there are ", /d,(0x3D00-$), " bytes free"
    defs 0x0 + (0x3D00-$), $ff


;#########################################################################################
      IF mhfont&&spanish
; ----------------------------------
; '  THE MICROHOBBY CHARACTER SET  '
; ----------------------------------
; $20 - Character: ' '          CHR$(32)
o3D00:
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000

; $21 - Character: '!'          CHR$(33)
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00000000

; $22 - Character: '"'          CHR$(34)
 DEFB    %01101100
 DEFB    %01101100
 DEFB    %01101100
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000

; $23 - Character: '#'          CHR$(35)
 DEFB    %01101100
 DEFB    %01101100
 DEFB    %11111110
 DEFB    %01101100
 DEFB    %11111110
 DEFB    %01101100
 DEFB    %01101100
 DEFB    %00000000

; $24 - Character: '$'          CHR$(36)
 DEFB    %00011000
 DEFB    %00111110
 DEFB    %01011000
 DEFB    %00111100
 DEFB    %00011010
 DEFB    %01111100
 DEFB    %00011000
 DEFB    %00000000

; $25 - Character: '%'          CHR$(37)
 DEFB    %00000000
 DEFB    %11000110
 DEFB    %11001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01100110
 DEFB    %11000110
 DEFB    %00000000

; $26 - Character: '&'          CHR$(38)
 DEFB    %00111000
 DEFB    %01101100
 DEFB    %00111000
 DEFB    %01110110
 DEFB    %11011100
 DEFB    %11001100
 DEFB    %01110110
 DEFB    %00000000

; $27 - Character: '''          CHR$(39)
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000

; $28 - Character: '('          CHR$(40)
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %00110000
 DEFB    %00110000
 DEFB    %00011000
 DEFB    %00001100
 DEFB    %00000000

; $29 - Character: ')'          CHR$(41)
 DEFB    %00110000
 DEFB    %00011000
 DEFB    %00001100
 DEFB    %00001100
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %00000000

; $2A - Character: '*'          CHR$(42)
 DEFB    %00000000
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %11111111
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %00000000
 DEFB    %00000000

; $2B - Character: '+'          CHR$(43)
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %01111110
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00000000

; $2C - Character: ','          CHR$(44)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00110000

; $2D - Character: '-'          CHR$(45)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01111100
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000

; $2E - Character: '-'          CHR$(46)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000

; $2F - Character: '/'          CHR$(47)
 DEFB    %00000110
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01100000
 DEFB    %11000000
 DEFB    %10000000
 DEFB    %00000000

; $30 - Character: '0'          CHR$(48)
 DEFB    %01111100
 DEFB    %11000110
 DEFB    %11001110
 DEFB    %11010110
 DEFB    %11100110
 DEFB    %11000110
 DEFB    %01111100
 DEFB    %00000000

; $31 - Character: '1'          CHR$(49)
 DEFB    %00011000
 DEFB    %00111000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %01111110
 DEFB    %00000000

; $32 - Character: '2'          CHR$(50)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %00000110
 DEFB    %00111100
 DEFB    %01100000
 DEFB    %01100110
 DEFB    %01111110
 DEFB    %00000000

; $33 - Character: '3'          CHR$(51)
 DEFB    %00111100
 DEFB    %01000110
 DEFB    %00000110
 DEFB    %00011100
 DEFB    %00000110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000

; $34 - Character: '4'          CHR$(52)
 DEFB    %00011000
 DEFB    %00111000
 DEFB    %01011000
 DEFB    %10011000
 DEFB    %11111110
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %00000000

; $35 - Character: '5'          CHR$(53)
 DEFB    %01111110
 DEFB    %01100010
 DEFB    %01100000
 DEFB    %00111100
 DEFB    %00000110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000

; $36 - Character: '6'          CHR$(54)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100000
 DEFB    %01111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $37 - Character: '7'          CHR$(55)
 DEFB    %01111110
 DEFB    %01000110
 DEFB    %00000110
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000

; $38 - Character: '8'          CHR$(56)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000

; $39 - Character: '9'          CHR$(57)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111110
 DEFB    %00000110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000

; $3A - Character: ':'          CHR$(58)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000

; $3B - Character: ';'          CHR$(59)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00110000

; $3C - Character: '<'          CHR$(60)
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01100000
 DEFB    %00110000
 DEFB    %00011000
 DEFB    %00001100
 DEFB    %00000000

; $3D - Character: '='          CHR$(61)
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01111110
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01111110
 DEFB    %00000000
 DEFB    %00000000

; $3E - Character: '>'          CHR$(62)
 DEFB    %01100000
 DEFB    %00110000
 DEFB    %00011000
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01100000
 DEFB    %00000000


; $3F - Character: '?'          CHR$(63)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %00000110
 DEFB    %00001100
 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00000000

; $40 - Character: '@'          CHR$(64)
 DEFB    %01111100
 DEFB    %11000110
 DEFB    %11011110
 DEFB    %11011110
 DEFB    %11011110
 DEFB    %11000000
 DEFB    %01111100
 DEFB    %00000000

; $41 - Character: 'A'          CHR$(65)
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00000000

; $42 - Character: 'B'          CHR$(66)
 DEFB    %11111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %11111100
 DEFB    %00000000

; $43 - Character: 'C'          CHR$(67)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %11000000
 DEFB    %11000000
 DEFB    %11000000
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000

; $44 - Character: 'D'          CHR$(68)
 DEFB    %11111000
 DEFB    %01101100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01101100
 DEFB    %11111000
 DEFB    %00000000

; $45 - Character: 'E'          CHR$(69)
 DEFB    %11111110
 DEFB    %01100010
 DEFB    %01101000
 DEFB    %01111000
 DEFB    %01101000
 DEFB    %01100010
 DEFB    %11111110
 DEFB    %00000000

; $46 - Character: 'F'          CHR$(70)
 DEFB    %11111110
 DEFB    %01100010
 DEFB    %01101000
 DEFB    %01111000
 DEFB    %01101000
 DEFB    %01100000
 DEFB    %11110000
 DEFB    %00000000

; $47 - Character: 'G'          CHR$(71)
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %11000000
 DEFB    %11000000
 DEFB    %11001110
 DEFB    %11000110
 DEFB    %01111110
 DEFB    %00000000

; $48 - Character: 'H'          CHR$(72)
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00000000

; $49 - Character: 'I'          CHR$(73)
 DEFB    %01111110
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %01111110
 DEFB    %00000000

; $4A - Character: 'J'          CHR$(74)
 DEFB    %00011110
 DEFB    %00001100
 DEFB    %00001100
 DEFB    %00001100
 DEFB    %11001100
 DEFB    %11001100
 DEFB    %01111000
 DEFB    %00000000

; $4B - Character: 'K'          CHR$(75)
 DEFB    %11100110
 DEFB    %01100110
 DEFB    %01101100
 DEFB    %01111000
 DEFB    %01101100
 DEFB    %01100110
 DEFB    %11100110
 DEFB    %00000000

; $4C - Character: 'L'          CHR$(76)
 DEFB    %11110000
 DEFB    %01100000
 DEFB    %01100000
 DEFB    %01100000
 DEFB    %01100010
 DEFB    %01100110
 DEFB    %11111110
 DEFB    %00000000

; $4D - Character: 'M'          CHR$(77)
 DEFB    %11000110
 DEFB    %11101110
 DEFB    %11111110
 DEFB    %11111110
 DEFB    %11010110
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %00000000

; $4E - Character: 'N'          CHR$(78)
 DEFB    %11000110
 DEFB    %11100110
 DEFB    %11110110
 DEFB    %11011110
 DEFB    %11001110
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %00000000

; $4F - Character: 'O'          CHR$(79)
 DEFB    %00111000
 DEFB    %01101100
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %01101100
 DEFB    %00111000
 DEFB    %00000000


; $50 - Character: 'P'          CHR$(80)

 DEFB    %11111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111000
 DEFB    %01100000
 DEFB    %01100000
 DEFB    %11110000
 DEFB    %00000000


; $51 - Character: 'Q'          CHR$(81)

 DEFB    %00111000
 DEFB    %01101100
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %11011010
 DEFB    %11001100
 DEFB    %01110110
 DEFB    %00000000


; $52 - Character: 'R'          CHR$(82)

 DEFB    %11111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111100
 DEFB    %01101100
 DEFB    %01100110
 DEFB    %11100010
 DEFB    %00000000


; $53 - Character: 'S'          CHR$(83)

 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100000
 DEFB    %00111100
 DEFB    %00000110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $54 - Character: 'T'          CHR$(84)

 DEFB    %01111110
 DEFB    %01011010
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %00000000


; $55 - Character: 'U'          CHR$(85)

 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $56 - Character: 'V'          CHR$(86)

 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00011000
 DEFB    %00000000


; $57 - Character: 'W'          CHR$(87)

 DEFB    %11000110
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %11010110
 DEFB    %11111110
 DEFB    %11101110
 DEFB    %11000110
 DEFB    %00000000


; $58 - Character: 'X'          CHR$(88)

 DEFB    %11000110
 DEFB    %01101100
 DEFB    %00111000
 DEFB    %00111000
 DEFB    %01101100
 DEFB    %11000110
 DEFB    %11000110
 DEFB    %00000000


; $59 - Character: 'Y'          CHR$(89)

 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %00000000


; $5A - Character: 'Z'          CHR$(90)

 DEFB    %11111110
 DEFB    %11000110
 DEFB    %10001100
 DEFB    %00011000
 DEFB    %00110010
 DEFB    %01100110
 DEFB    %11111110
 DEFB    %00000000


; $5B - Character: '!inv'          CHR$(91)

 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000


; $5C - Character: 'ntilde'          CHR$(92)

 DEFB    %00110010
 DEFB    %01001100
 DEFB    %00000000
 DEFB    %01100110
 DEFB    %01110110
 DEFB    %01101110
 DEFB    %01100110
 DEFB    %00000000


; $5D - Character: '?inv'          CHR$(93)

 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01100000
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $5E - Character: '^'          CHR$(94)

 DEFB    %00011000
 DEFB    %00111100
 DEFB    %01111110
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00000000


; $5F - Character: '_'          CHR$(95)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11111111

  IF euro
; $60 - Character: 'â¬'          CHR$(96)
    DEFB    %00000000
    DEFB    %00000000
    DEFB    %00011110
    DEFB    %01100000
    DEFB    %11111100
    DEFB    %01100000
    DEFB    %00011110
    DEFB    %00000000
  ELSE
; $60 - Character: 'Pt'       CHR$(96)
    DEFB    %11100000
    DEFB    %10010000
    DEFB    %10010100
    DEFB    %11101110
    DEFB    %10000100
    DEFB    %10000100
    DEFB    %10000011
    DEFB    %00000000
  ENDIF

; $61 - Character: 'a'          CHR$(97)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01111000
 DEFB    %00001100
 DEFB    %01111100
 DEFB    %11001100
 DEFB    %01110110
 DEFB    %00000000


; $62 - Character: 'b'          CHR$(98)

 DEFB    %11100000
 DEFB    %11100000
 DEFB    %01111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %10111100
 DEFB    %00000000


; $63 - Character: 'c'          CHR$(99)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100000
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $64 - Character: 'd'          CHR$(100)

 DEFB    %00011100
 DEFB    %00001100
 DEFB    %01111100
 DEFB    %11001100
 DEFB    %11001100
 DEFB    %11001100
 DEFB    %01110110
 DEFB    %00000000


; $65 - Character: 'e'          CHR$(101)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01111110
 DEFB    %01100000
 DEFB    %00111100
 DEFB    %00000000


; $66 - Character: 'f'          CHR$(102)

 DEFB    %00011100
 DEFB    %00110110
 DEFB    %00110000
 DEFB    %01111000
 DEFB    %00110000
 DEFB    %00110000
 DEFB    %01111000
 DEFB    %00000000


; $67 - Character: 'g'          CHR$(103)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00111110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111110
 DEFB    %00000110
 DEFB    %01111100


; $68 - Character: 'h'          CHR$(104)

 DEFB    %11100000
 DEFB    %01100000
 DEFB    %01101100
 DEFB    %01110110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %11100110
 DEFB    %00000000


; $69 - Character: 'i'          CHR$(105)

 DEFB    %00011000
 DEFB    %00000000
 DEFB    %00111000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %00000000


; $6A - Character: 'j'          CHR$(106)

 DEFB    %00000010
 DEFB    %00000000
 DEFB    %00001110
 DEFB    %00000110
 DEFB    %00000110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100


; $6B - Character: 'k'          CHR$(107)

 DEFB    %11100000
 DEFB    %01100000
 DEFB    %01100110
 DEFB    %01101100
 DEFB    %01111000
 DEFB    %01101100
 DEFB    %11100110
 DEFB    %00000000


; $6C - Character: 'l'          CHR$(108)

 DEFB    %00111000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00111100
 DEFB    %00000000


; $6D - Character: 'm'          CHR$(109)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01101100
 DEFB    %11111110
 DEFB    %11010110
 DEFB    %11010110
 DEFB    %11000110
 DEFB    %00000000


; $6E - Character: 'n'          CHR$(110)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11011000
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00000000


; $6F - Character: 'o'          CHR$(111)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00111100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00000000


; $70 - Character: 'p'          CHR$(112)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11011100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01111100
 DEFB    %01100000
 DEFB    %11110000


; $71 - Character: 'q'          CHR$(113)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01110110
 DEFB    %11001100
 DEFB    %11001100
 DEFB    %01111100
 DEFB    %00001100
 DEFB    %00011110


; $72 - Character: 'r'          CHR$(114)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11011000
 DEFB    %01101100
 DEFB    %01100000
 DEFB    %01100000
 DEFB    %11110000
 DEFB    %00000000


; $73 - Character: 's'          CHR$(115)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00111100
 DEFB    %01100000
 DEFB    %00111100
 DEFB    %00000110
 DEFB    %01111100
 DEFB    %00000000


; $74 - Character: 't'          CHR$(116)

 DEFB    %00110000
 DEFB    %00110000
 DEFB    %01111100
 DEFB    %00110000
 DEFB    %00110000
 DEFB    %00110110
 DEFB    %00011100
 DEFB    %00000000


; $75 - Character: 'u'          CHR$(117)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111110
 DEFB    %00000000


; $76 - Character: 'v'          CHR$(118)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111100
 DEFB    %00011000
 DEFB    %00000000


; $77 - Character: 'w'          CHR$(119)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11000110
 DEFB    %11010110
 DEFB    %11010110
 DEFB    %11111110
 DEFB    %01101100
 DEFB    %00000000


; $78 - Character: 'x'          CHR$(120)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %11000110
 DEFB    %01101100
 DEFB    %00111000
 DEFB    %01101100
 DEFB    %11000110
 DEFB    %00000000


; $79 - Character: 'y'          CHR$(121)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00111110
 DEFB    %00000110
 DEFB    %01111100


; $7A - Character: 'z'          CHR$(122)

 DEFB    %00000000
 DEFB    %00000000
 DEFB    %01111110
 DEFB    %01001100
 DEFB    %00011000
 DEFB    %00110000
 DEFB    %01111110
 DEFB    %00000000


; $7B - Character: '{'          CHR$(123)

 DEFB    %00001110
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %01110000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00001110
 DEFB    %00000000


; $7C - Character: 'ntilde'          CHR$(124)

 DEFB    %00110000
 DEFB    %01001100
 DEFB    %00000000
 DEFB    %11011100
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %01100110
 DEFB    %00000000


; $7D - Character: '}'          CHR$(125)

 DEFB    %01110000
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %00001110
 DEFB    %00011000
 DEFB    %00011000
 DEFB    %01110000
 DEFB    %00000000


; $7E - Character: '~'          CHR$(126)

 DEFB    %01110110
 DEFB    %11011000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000
 DEFB    %00000000


; $7F - Character: ' '          CHR$(127)

 DEFB    %00111000
 DEFB    %01000100
 DEFB    %10111010
 DEFB    %10100010
 DEFB    %10111010
 DEFB    %01000100
 DEFB    %00111000
 DEFB    %00000000

      ELSE
; -------------------------------
; THE 'ZX SPECTRUM CHARACTER SET'
; -------------------------------

;; char-set

; $20 - Character: ' '          CHR$(32)

o3D00:  DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000

; $21 - Character: '!'          CHR$(33)

        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00000000

; $22 - Character: '"'          CHR$(34)

        DEFB    %00000000
        DEFB    %00100100
        DEFB    %00100100
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000

; $23 - Character: '#'          CHR$(35)

        DEFB    %00000000
        DEFB    %00100100
        DEFB    %01111110
        DEFB    %00100100
        DEFB    %00100100
        DEFB    %01111110
        DEFB    %00100100
        DEFB    %00000000

; $24 - Character: '$'          CHR$(36)

        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00111110
        DEFB    %00101000
        DEFB    %00111110
        DEFB    %00001010
        DEFB    %00111110
        DEFB    %00001000

; $25 - Character: '%'          CHR$(37)

        DEFB    %00000000
        DEFB    %01100010
        DEFB    %01100100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00100110
        DEFB    %01000110
        DEFB    %00000000

; $26 - Character: '&'          CHR$(38)

        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00101000
        DEFB    %00010000
        DEFB    %00101010
        DEFB    %01000100
        DEFB    %00111010
        DEFB    %00000000

; $27 - Character: '''          CHR$(39)

        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000

; $28 - Character: '('          CHR$(40)

        DEFB    %00000000
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00000100
        DEFB    %00000000

; $29 - Character: ')'          CHR$(41)

        DEFB    %00000000
        DEFB    %00100000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00100000
        DEFB    %00000000

; $2A - Character: '*'          CHR$(42)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010100
        DEFB    %00001000
        DEFB    %00111110
        DEFB    %00001000
        DEFB    %00010100
        DEFB    %00000000

; $2B - Character: '+'          CHR$(43)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00111110
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00000000

; $2C - Character: ','          CHR$(44)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00010000

; $2D - Character: '-'          CHR$(45)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111110
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000

; $2E - Character: '.'          CHR$(46)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00011000
        DEFB    %00011000
        DEFB    %00000000

; $2F - Character: '/'          CHR$(47)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000010
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00100000
        DEFB    %00000000

; $30 - Character: '0'          CHR$(48)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000110
        DEFB    %01001010
        DEFB    %01010010
        DEFB    %01100010
        DEFB    %00111100
        DEFB    %00000000

; $31 - Character: '1'          CHR$(49)

        DEFB    %00000000
        DEFB    %00011000
        DEFB    %00101000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00111110
        DEFB    %00000000

; $32 - Character: '2'          CHR$(50)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %00000010
        DEFB    %00111100
        DEFB    %01000000
        DEFB    %01111110
        DEFB    %00000000

; $33 - Character: '3'          CHR$(51)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %00001100
        DEFB    %00000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $34 - Character: '4'          CHR$(52)

        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00011000
        DEFB    %00101000
        DEFB    %01001000
        DEFB    %01111110
        DEFB    %00001000
        DEFB    %00000000

; $35 - Character: '5'          CHR$(53)

        DEFB    %00000000
        DEFB    %01111110
        DEFB    %01000000
        DEFB    %01111100
        DEFB    %00000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $36 - Character: '6'          CHR$(54)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000000
        DEFB    %01111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $37 - Character: '7'          CHR$(55)

        DEFB    %00000000
        DEFB    %01111110
        DEFB    %00000010
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000

; $38 - Character: '8'          CHR$(56)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $39 - Character: '9'          CHR$(57)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111110
        DEFB    %00000010
        DEFB    %00111100
        DEFB    %00000000

; $3A - Character: ':'          CHR$(58)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00000000

; $3B - Character: ';'          CHR$(59)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00100000

; $3C - Character: '<'          CHR$(60)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00001000
        DEFB    %00000100
        DEFB    %00000000

; $3D - Character: '='          CHR$(61)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111110
        DEFB    %00000000
        DEFB    %00111110
        DEFB    %00000000
        DEFB    %00000000

; $3E - Character: '>'          CHR$(62)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00001000
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00000000

; $3F - Character: '?'          CHR$(63)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00000000

; $40 - Character: '@'          CHR$(64)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01001010
        DEFB    %01010110
        DEFB    %01011110
        DEFB    %01000000
        DEFB    %00111100
        DEFB    %00000000

; $41 - Character: 'A'          CHR$(65)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01111110
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00000000

; $42 - Character: 'B'          CHR$(66)

        DEFB    %00000000
        DEFB    %01111100
        DEFB    %01000010
        DEFB    %01111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01111100
        DEFB    %00000000

; $43 - Character: 'C'          CHR$(67)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $44 - Character: 'D'          CHR$(68)

        DEFB    %00000000
        DEFB    %01111000
        DEFB    %01000100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000100
        DEFB    %01111000
        DEFB    %00000000

; $45 - Character: 'E'          CHR$(69)

        DEFB    %00000000
        DEFB    %01111110
        DEFB    %01000000
        DEFB    %01111100
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01111110
        DEFB    %00000000

; $46 - Character: 'F'          CHR$(70)

        DEFB    %00000000
        DEFB    %01111110
        DEFB    %01000000
        DEFB    %01111100
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %00000000

; $47 - Character: 'G'          CHR$(71)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000000
        DEFB    %01001110
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $48 - Character: 'H'          CHR$(72)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01111110
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00000000

; $49 - Character: 'I'          CHR$(73)

        DEFB    %00000000
        DEFB    %00111110
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00111110
        DEFB    %00000000

; $4A - Character: 'J'          CHR$(74)

        DEFB    %00000000
        DEFB    %00000010
        DEFB    %00000010
        DEFB    %00000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $4B - Character: 'K'          CHR$(75)

        DEFB    %00000000
        DEFB    %01000100
        DEFB    %01001000
        DEFB    %01110000
        DEFB    %01001000
        DEFB    %01000100
        DEFB    %01000010
        DEFB    %00000000

; $4C - Character: 'L'          CHR$(76)

        DEFB    %00000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01111110
        DEFB    %00000000

; $4D - Character: 'M'          CHR$(77)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01100110
        DEFB    %01011010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00000000

; $4E - Character: 'N'          CHR$(78)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01100010
        DEFB    %01010010
        DEFB    %01001010
        DEFB    %01000110
        DEFB    %01000010
        DEFB    %00000000

; $4F - Character: 'O'          CHR$(79)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $50 - Character: 'P'          CHR$(80)

        DEFB    %00000000
        DEFB    %01111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01111100
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %00000000

; $51 - Character: 'Q'          CHR$(81)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01010010
        DEFB    %01001010
        DEFB    %00111100
        DEFB    %00000000

; $52 - Character: 'R'          CHR$(82)

        DEFB    %00000000
        DEFB    %01111100
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01111100
        DEFB    %01000100
        DEFB    %01000010
        DEFB    %00000000

; $53 - Character: 'S'          CHR$(83)

        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000000
        DEFB    %00111100
        DEFB    %00000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $54 - Character: 'T'          CHR$(84)

        DEFB    %00000000
        DEFB    %11111110
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000

; $55 - Character: 'U'          CHR$(85)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000

; $56 - Character: 'V'          CHR$(86)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %00100100
        DEFB    %00011000
        DEFB    %00000000

; $57 - Character: 'W'          CHR$(87)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01000010
        DEFB    %01011010
        DEFB    %00100100
        DEFB    %00000000

; $58 - Character: 'X'          CHR$(88)

        DEFB    %00000000
        DEFB    %01000010
        DEFB    %00100100
        DEFB    %00011000
        DEFB    %00011000
        DEFB    %00100100
        DEFB    %01000010
        DEFB    %00000000

; $59 - Character: 'Y'          CHR$(89)

        DEFB    %00000000
        DEFB    %10000010
        DEFB    %01000100
        DEFB    %00101000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000

; $5A - Character: 'Z'          CHR$(90)

        DEFB    %00000000
        DEFB    %01111110
        DEFB    %00000100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00100000
        DEFB    %01111110
        DEFB    %00000000

      IF spanish
; $5B - Character: '!inv'       CHR$(91)
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00000000
; $5C - Character: 'ntilde'     CHR$(92)
        DEFB    %00111100
        DEFB    %00000000
        DEFB    %01100010
        DEFB    %01010010
        DEFB    %01001010
        DEFB    %01000110
        DEFB    %01000010
        DEFB    %00000000
; $5D - Character: '?inv'       CHR$(93)
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00100000
        DEFB    %01000000
        DEFB    %01000010
        DEFB    %00111100
        DEFB    %00000000
      ELSE
; $5B - Character: '['          CHR$(91)
        DEFB    %00000000
        DEFB    %00001110
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001110
        DEFB    %00000000
; $5C - Character: '\'          CHR$(92)
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000000
        DEFB    %00100000
        DEFB    %00010000
        DEFB    %00001000
        DEFB    %00000100
        DEFB    %00000000
; $5D - Character: ']'          CHR$(93)
        DEFB    %00000000
        DEFB    %01110000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %01110000
        DEFB    %00000000
      ENDIF

; $5E - Character: '^'          CHR$(94)
        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00111000
        DEFB    %01010100
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000

; $5F - Character: '_'          CHR$(95)
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %11111111

      IF spanish
; $60 - Character: 'â¬'       CHR$(96)
        IF euro
            DEFB    %00000000
            DEFB    %00000000
            DEFB    %00011110
            DEFB    %00100000
            DEFB    %01111100
            DEFB    %00100000
            DEFB    %00011110
            DEFB    %00000000
        ELSE
; $60 - Character: 'Pt'       CHR$(96)
            DEFB    %00000000
            DEFB    %11110000
            DEFB    %10001000
            DEFB    %10001010
            DEFB    %11110111
            DEFB    %10000010
            DEFB    %10000011
            DEFB    %00000000
        ENDIF
      ELSE
; $60 - Character: 'â¬'       CHR$(96)
        IF euro
            DEFB    %00000000
            DEFB    %00000000
            DEFB    %00011110
            DEFB    %00100000
            DEFB    %01111100
            DEFB    %00100000
            DEFB    %00011110
            DEFB    %00000000
        ELSE
; $60 - Character: 'Â£'        CHR$(96)
            DEFB    %00000000
            DEFB    %00011100
            DEFB    %00100010
            DEFB    %01111000
            DEFB    %00100000
            DEFB    %00100000
            DEFB    %01111110
            DEFB    %00000000
        ENDIF
      ENDIF

; $61 - Character: 'a'          CHR$(97)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111000
        DEFB    %00000100
        DEFB    %00111100
        DEFB    %01000100
        DEFB    %00111100
        DEFB    %00000000

; $62 - Character: 'b'          CHR$(98)

        DEFB    %00000000
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00111100
        DEFB    %00100010
        DEFB    %00100010
        DEFB    %00111100
        DEFB    %00000000

; $63 - Character: 'c'          CHR$(99)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00011100
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00011100
        DEFB    %00000000

; $64 - Character: 'd'          CHR$(100)

        DEFB    %00000000
        DEFB    %00000100
        DEFB    %00000100
        DEFB    %00111100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111100
        DEFB    %00000000

; $65 - Character: 'e'          CHR$(101)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111000
        DEFB    %01000100
        DEFB    %01111000
        DEFB    %01000000
        DEFB    %00111100
        DEFB    %00000000

; $66 - Character: 'f'          CHR$(102)

        DEFB    %00000000
        DEFB    %00001100
        DEFB    %00010000
        DEFB    %00011000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00000000

; $67 - Character: 'g'          CHR$(103)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111100
        DEFB    %00000100
        DEFB    %00111000

; $68 - Character: 'h'          CHR$(104)

        DEFB    %00000000
        DEFB    %01000000
        DEFB    %01000000
        DEFB    %01111000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00000000

; $69 - Character: 'i'          CHR$(105)

        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00000000
        DEFB    %00110000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00111000
        DEFB    %00000000

; $6A - Character: 'j'          CHR$(106)

        DEFB    %00000000
        DEFB    %00000100
        DEFB    %00000000
        DEFB    %00000100
        DEFB    %00000100
        DEFB    %00000100
        DEFB    %00100100
        DEFB    %00011000

; $6B - Character: 'k'          CHR$(107)

        DEFB    %00000000
        DEFB    %00100000
        DEFB    %00101000
        DEFB    %00110000
        DEFB    %00110000
        DEFB    %00101000
        DEFB    %00100100
        DEFB    %00000000

; $6C - Character: 'l'          CHR$(108)

        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00001100
        DEFB    %00000000

; $6D - Character: 'm'          CHR$(109)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01101000
        DEFB    %01010100
        DEFB    %01010100
        DEFB    %01010100
        DEFB    %01010100
        DEFB    %00000000

; $6E - Character: 'n'          CHR$(110)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01111000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00000000

; $6F - Character: 'o'          CHR$(111)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111000
        DEFB    %00000000

; $70 - Character: 'p'          CHR$(112)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01111000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01111000
        DEFB    %01000000
        DEFB    %01000000

; $71 - Character: 'q'          CHR$(113)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111100
        DEFB    %00000100
        DEFB    %00000110

; $72 - Character: 'r'          CHR$(114)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00011100
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00100000
        DEFB    %00000000

; $73 - Character: 's'          CHR$(115)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00111000
        DEFB    %01000000
        DEFB    %00111000
        DEFB    %00000100
        DEFB    %01111000
        DEFB    %00000000

; $74 - Character: 't'          CHR$(116)

        DEFB    %00000000
        DEFB    %00010000
        DEFB    %00111000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %00001100
        DEFB    %00000000

; $75 - Character: 'u'          CHR$(117)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111000
        DEFB    %00000000

; $76 - Character: 'v'          CHR$(118)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00101000
        DEFB    %00101000
        DEFB    %00010000
        DEFB    %00000000

; $77 - Character: 'w'          CHR$(119)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000100
        DEFB    %01010100
        DEFB    %01010100
        DEFB    %01010100
        DEFB    %00101000
        DEFB    %00000000

; $78 - Character: 'x'          CHR$(120)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000100
        DEFB    %00101000
        DEFB    %00010000
        DEFB    %00101000
        DEFB    %01000100
        DEFB    %00000000

; $79 - Character: 'y'          CHR$(121)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00111100
        DEFB    %00000100
        DEFB    %00111000

; $7A - Character: 'z'          CHR$(122)

        DEFB    %00000000
        DEFB    %00000000
        DEFB    %01111100
        DEFB    %00001000
        DEFB    %00010000
        DEFB    %00100000
        DEFB    %01111100
        DEFB    %00000000

; $7B - Character: '{'          CHR$(123)

        DEFB    %00000000
        DEFB    %00001110
        DEFB    %00001000
        DEFB    %00110000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001110
        DEFB    %00000000

      IF spanish
; $7C - Character: 'ntilde'     CHR$(124)
        DEFB    %00111000
        DEFB    %00000000
        DEFB    %01011000
        DEFB    %01100100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %01000100
        DEFB    %00000000
      ELSE
; $7C - Character: '|'          CHR$(124)
        DEFB    %00000000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00001000
        DEFB    %00000000
      ENDIF

; $7D - Character: '}'          CHR$(125)

        DEFB    %00000000
        DEFB    %01110000
        DEFB    %00010000
        DEFB    %00001100
        DEFB    %00010000
        DEFB    %00010000
        DEFB    %01110000
        DEFB    %00000000

; $7E - Character: '~'          CHR$(126)

        DEFB    %00000000
        DEFB    %00010100
        DEFB    %00101000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000
        DEFB    %00000000

; $7F - Character: ' Â© '        CHR$(127)

        DEFB    %00111100
        DEFB    %01000010
        DEFB    %10011001
        DEFB    %10100001
        DEFB    %10100001
        DEFB    %10011001
        DEFB    %01000010
        DEFB    %00111100
      ENDIF
.end                            ; generic cross-assembler directive

; Acknowledgements
; -----------------
; Sean Irvine               for default list of section headings
; Dr. Ian Logan             for labels and functional disassembly.
; Dr. Frank O'Hara          for labels and functional disassembly.
;
; Credits
; -------
; Alex Pallero Gonzales     for corrections.
; Mike Dailly               for comments.
; Alvin Albrecht            for comments.
; Andy Styles               for full relocatability implementation and testing.
; Andrew Owen               for ZASM compatibility and format improvements.
; Jose Angel Velasco        for carmel
; Alejandro Valero          for curkl
; Rafael Pardo              for mmcen and mmcdata
; djr                       for zx_tap and ide8
; Cristian Secara           for bluerom and floppy35
; Antonio Villena           for pokemon
; Javier Herrera            for mhfont, euro and integrations

;   For other assemblers you may have to add directives like these near the
;   beginning - see accompanying documentation.
;   ZASM (MacOs) cross-assembler directives. (uncomment by removing ';' )
;   #target rom           ; declare target file format as binary.
;   #code   0,$4000       ; declare code segment.
;   Also see notes at Address Labels 0609 and 1CA5 if your assembler has
;   trouble with expressions.
;
;   Note. The Sinclair Interface 1 ROM written by Dr. Ian Logan and Martin
;   Brennan calls numerous routines in this ROM.
;   Non-standard entry points have a label beginning with X.
